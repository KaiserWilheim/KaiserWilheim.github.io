<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>亚兰字母拼写英语</title>
    <url>/hebrew-english/</url>
    <content><![CDATA[<p>一种使用亚兰字母来拼写英语的方案。<br>（测试博客显示情况用）<br>𗼇𗟲</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<p>首先展示 Note 框，以便使用：</p>
<details class="note "><summary><p>Without Class</p>
</summary>

</details>

<details class="note default"><summary><p>Default</p>
</summary>

</details>

<details class="note primary"><summary><p>Primary</p>
</summary>

</details>

<details class="note info"><summary><p>Info</p>
</summary>

</details>

<details class="note success"><summary><p>Success</p>
</summary>

</details>

<details class="note warning"><summary><p>Warning</p>
</summary>

</details>

<details class="note danger"><summary><p>Danger</p>
</summary>

</details>

<p>然后是 Tabs：</p>
<div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><a href="#test-1"><i class="fa fa-heart"></i>第一页</a></li><li class="tab"><a href="#test-2">Page 2</a></li></ul><div class="tab-content"><div class="tab-pane active" id="test-1"><p>这是第一个 Tab 。</p></div><div class="tab-pane" id="test-2"><p>Tab 语法里面的 <code>&lt;!--</code> 之后和 <code>--&gt;</code> 之前好像可以有空格。</p></div></div></div>

<div class="tabs" id="tabs-套-note"><ul class="nav-tabs"><li class="tab active"><a href="#tabs-套-note-1">无 Class</a></li><li class="tab"><a href="#tabs-套-note-2">default</a></li><li class="tab"><a href="#tabs-套-note-3">primary</a></li><li class="tab"><a href="#tabs-套-note-4">info</a></li><li class="tab"><a href="#tabs-套-note-5">success</a></li><li class="tab"><a href="#tabs-套-note-6">warning</a></li><li class="tab"><a href="#tabs-套-note-7">danger</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tabs-套-note-1"><details class="note "><summary><p>Without Class</p>
</summary>

</details></div><div class="tab-pane" id="tabs-套-note-2"><details class="note default"><summary><p>Default</p>
</summary>

</details></div><div class="tab-pane" id="tabs-套-note-3"><details class="note primary"><summary><p>Primary</p>
</summary>

</details></div><div class="tab-pane" id="tabs-套-note-4"><details class="note info"><summary><p>Info</p>
</summary>

</details></div><div class="tab-pane" id="tabs-套-note-5"><details class="note success"><summary><p>Success</p>
</summary>

</details></div><div class="tab-pane" id="tabs-套-note-6"><details class="note warning"><summary><p>Warning</p>
</summary>

</details></div><div class="tab-pane" id="tabs-套-note-7"><details class="note danger"><summary><p>Danger</p>
</summary>

</details></div></div></div>

<hr>
<h1 id="亚兰字母"><a href="#亚兰字母" class="headerlink" title="亚兰字母"></a>亚兰字母</h1><p>首先是元音。</p>
<p>&#x2F;ʌ&#x2F;-&gt;אֲ  &#x2F;æ&#x2F;-&gt;אֵ  &#x2F;α:&#x2F;-&gt;אַ</p>
<p>&#x2F;i&#x2F;-&gt;י  &#x2F;i:&#x2F;-&gt;יִ</p>
<p>&#x2F;u&#x2F;-&gt;ו  &#x2F;u:&#x2F;-&gt;וִ</p>
<p>&#x2F;e&#x2F;-&gt;אֶ  &#x2F;ə&#x2F;-&gt;ע  &#x2F;ə:&#x2F;-&gt;עִ</p>
<p>&#x2F;ɔ&#x2F;-&gt;אֳ  &#x2F;ɔ:&#x2F;-&gt;אָ</p>
<p>双元音直接组合即可。</p>
<p>&#x2F;ei&#x2F;-&gt;עֹ  &#x2F;ai&#x2F;-&gt;אַֹ  &#x2F;au&#x2F;-&gt;אַו  &#x2F;əu&#x2F;-&gt;עו  &#x2F;uə&#x2F;-&gt;וֶ  &#x2F;iə&#x2F;-&gt;יֶ  &#x2F;eə&#x2F;-&gt;עֶ  &#x2F;ɔi&#x2F;-&gt;אָֹ</p>
<p>然后是辅音。</p>
<p>&#x2F;k&#x2F;-&gt;ק  &#x2F;t&#x2F;-&gt;ט  &#x2F;p&#x2F;-&gt;פּ</p>
<p>&#x2F;g&#x2F;-&gt;ג  &#x2F;d&#x2F;-&gt;ד  &#x2F;b&#x2F;-&gt;בּ</p>
<p>&#x2F;s&#x2F;-&gt;ס  &#x2F;θ&#x2F;-&gt;ת  &#x2F;f&#x2F;-&gt;פ  &#x2F;ʃ&#x2F;-&gt;ש</p>
<p>&#x2F;z&#x2F;-&gt;ז  &#x2F;ð&#x2F;-&gt;דּ  &#x2F;v&#x2F;-&gt;ב  &#x2F;ʒ&#x2F;-&gt;שׁ</p>
<p>&#x2F;tʃ&#x2F;-&gt;טש  &#x2F;tr&#x2F;-&gt;טר  &#x2F;ts&#x2F;-&gt;צ</p>
<p>&#x2F;dʒ&#x2F;-&gt;דשׁ  &#x2F;dr&#x2F;-&gt;דר  &#x2F;dz&#x2F;-&gt;צּ</p>
<p>&#x2F;m&#x2F;-&gt;מ  &#x2F;n&#x2F;-&gt;נ  &#x2F;ŋ&#x2F;-&gt;נּ</p>
<p>&#x2F;h&#x2F;-&gt;ה  &#x2F;l&#x2F;-&gt;ל  &#x2F;r&#x2F;-&gt;ר</p>
<p>最后是半元音。</p>
<p>&#x2F;w&#x2F;-&gt;וּ  &#x2F;j&#x2F;-&gt;יּ</p>
<p>辅音中的כ与ח和元音中的אֻ没有用到，但我准备了适配其他语言的音素：</p>
<p>&#x2F;ç&#x2F;-&gt;כ  &#x2F;x&#x2F;-&gt;כּ  &#x2F;ʀ&#x2F;-&gt;ח  &#x2F;y&#x2F;-&gt;אֻ</p>
<p>还有重音符号：<br>&#x2F;ˈ&#x2F;-&gt;א֫<br>&#x2F;ˌ&#x2F;-&gt;אֽ ?</p>
<p>备注：</p>
<p>没想到tsadee没有办法类似שׁ这样向右上方加点，所以采用了中间加点的方式来使其可以打到电脑上。</p>
<p>示例：</p>
<p>原文：</p>
<p>To be, or not to be- that is the question:<br>Whether ‘tis nobler in the mind to suffer<br>The slings and arrows of outrageous fortune<br>Or to take arms against a sea of troubles,<br>And by opposing end them. To die- to sleep-<br>No more; and by a sleep to say we end<br>The heartache, and the thousand natural shocks<br>That flesh is heir to. ‘Tis a consummation<br>Devoutly to be wish’d. To die- to sleep.</p>
<p>音标：</p>
<p>[tuː] [biː]<strong>,</strong> [ɔː] [nɔt] [tuː] [biː]<strong>-</strong> [ðæt] [ɪz] [ðə] [ˈkwesʧən]<strong>:</strong><br>[ˈweðə] [tɪz] [ˈnəublər] [ɪn] [ðə] [maɪnd] [tuː] [ˈsʌfə]<br>[ðə] [slɪŋz] [ænd] [ˈærəuz] [ɔv] [autˈreɪʤəs] [ˈfɔːʧən]<br>[ɔː] [tuː] [teɪk] [ɑːmz] [əˈgenst] [ə] [siː] [ɔv] [ˈtrʌblz]<strong>,</strong><br>[ænd] [baɪ] [əˈpəuzɪŋ] [end] [ðem]<strong>.</strong> [tuː] [daɪ]<strong>-</strong> [tuː] [sliːp]<strong>-</strong><br>[nəu] [mɔː]<strong>;</strong> [ænd] [baɪ] [ə] [sliːp] [tuː] [seɪ] [wiː] [end]<br>[ðə] [ˈhɑːteɪk]<strong>,</strong> [ænd] [ðə] [ˈθauzənd] [ˈnæʧrəl] [ʃɔks]<br>[ðæt] [fleʃ] [ɪz] [eə] [tuː]<strong>.</strong> [tɪz] [ə] [ˌkɔnsəˈmeɪʃən]<br>[dɪˈvautli] [tuː] [biː] [wɪʃt]<strong>.</strong> [tuː] [daɪ]<strong>-</strong> [tuː] [sliːp]<strong>.</strong></p>
<p>转写：</p>
<p dir="rtl">
טוִ בּיִ, אָ נֳט טוִ בּיִ- דֵּט יז דּע ק֫וֶּסטשען: <br>
וֶּ֫דּע טיז נ֫עובּלער ין דּע מַֹנד טוִ סֲ֫פע <br>
דּע סלינּז אֵנד אֵ֫רעֻז אֳב אַוטר֫עֹדצּעס פָ֫טשען <br>
אָ טוִ טעֹק אַמז ע֫גֶנסט אֶ סיִ אֳב ט֫רֲבּלז, <br>
אֵנּד בַֹּ עפּ֫עֻזיןּ אֶנד דֶּם. טוִ דַֹ- טוִ סליִףּ- <br>
נעו מָ; אֵנד בַֹּ ע סליִפּ טוִ סעֹ וּיִ אֶנד <br>
דּע הַ֫טעֹק, דּע תַ֫וזענד נֵ֫טשרעל שָקס <br>
דֵּט פלֶש יז עֶ טוִ. טיז ע קֳנסעמ֫עֹשען <br>
דיבַ֫וטלי טוִ בּיִ וּישט. טוִ דַֹ- טוִ סליִףּ.
</p>

<p><del>犹太史诗（确信）</del></p>
<h1 id="阿拉伯字母"><a href="#阿拉伯字母" class="headerlink" title="阿拉伯字母"></a>阿拉伯字母</h1><p>既然阿拉伯字母与希伯来字母同根同源，那么……</p>
<p>（tbc）</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>博客索引</title>
    <url>/suoyin/</url>
    <content><![CDATA[<p>文章的索引。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>$\rm{OI}$ 与 $\rm{Ch}$ 的交汇，能迸发出怎样的火花呢？</p>
<p>为了便于<del>我自己及时更新</del>读者们挑选合适的文章，下面有几个符号，可以帮助读者大人们挑选。<del>（我有读者吗？）</del></p>
<ul>
<li>$\color[rgb]{0,0.5,1}{\sharp}$ 代表已经写完了</li>
<li>$\color[rgb]{0.067,0.270588,0.078431}{\natural}$ 表示长期更新</li>
<li>$\color[rgb]{1,0,0}{\flat}$ 表示我这个蒟蒻还没写完</li>
<li><strong>止まれ</strong> 表示我因某种原因暂停更新<del>也就是咕咕咕了</del></li>
<li>$\color[rgb]{0.5,0.4,0.4}{φ}$ 表示我虽然写完了，但是某些地方还需要完善，完善完了会换成 $\color[rgb]{0,0.5,1}{\sharp}$ 标志。</li>
<li>$\color[rgb]{1,1,0.0625}{\aleph}$ 表示我这个蒟蒻觉得我自己写的很好。</li>
</ul>
<p>阅读博客的时候，我们经常会看到一些板子。</p>
<p>如果某一个板子是我自己写的，在它的附近会有一个 $\color[rgb]{1,1,0.0625}{φ}$ 的标志。这些板子保证运行的正确性。大胆褐，不会有事的（指运行结果）。<br>如果某一个板子不是我写的，在它的附近会有一个 $\blacktriangleright$ 指向它的出处。这些板子不保证运行的正确性。使用之前请斟酌。 </p>
<p>最后一次维护：20220527</p>
<h1 id="OI"><a href="#OI" class="headerlink" title="OI"></a>OI</h1><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><p>数学是算法的基石。</p>
<ul>
<li><p><a href="/maths/mathematics">杂项整理</a> $\color[rgb]{0.067,0.270588,0.078431}{\natural}$<br>写不成博客的东西都在这里。</p>
</li>
<li><p><a href="/maths/eular-and-m%C3%B6bius">欧拉与莫比乌斯</a> $\color[rgb]{0,0.5,1}{\sharp}$<br>包含欧拉函数、欧拉定理、莫比乌斯函数与莫比乌斯反演。</p>
</li>
<li><p><a href="/maths/special-numbers">特殊的数</a> $\color[rgb]{1,0,0}{\flat}$<br>包含斯特林数等。</p>
</li>
<li><p><a href="/maths/fourier-transform">傅里叶变换</a> $\color[rgb]{0.5,0.4,0.4}{φ}$<br>包含傅里叶变换和快速傅里叶变换，附带一些复数和单位根的知识。</p>
</li>
<li><p><a href="/maths/lagrange-interpolation">拉格朗日插值</a> $\color[rgb]{0.5,0.4,0.4}{φ}$<br>包括拉格朗日插值。</p>
</li>
<li><p><a href="/maths/matrix/">矩阵</a> $\color[rgb]{0,0.5,1}{\sharp}$<br>矩阵相关运算，以及矩阵在OI中的运用。</p>
</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法是程序的基础。</p>
<ul>
<li><p><a href="/OI/scanning-line">扫描线</a> $\color[rgb]{0,0.5,1}{\sharp}$<br>一种用来求矩形面积并的算法。</p>
</li>
<li><p><a href="/OI/heavy-path-decomposition">树链剖分</a> $\color[rgb]{0,0.5,1}{\sharp}$<br>树剖。</p>
</li>
<li><p><a href="/OI/difference-constraint/">差分约束</a> $\color[rgb]{0,0.5,1}{\sharp}$<br>一种用来解决不等式组求解的算法。</p>
</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>啊这……这里该怎么写……</p>
<ul>
<li><p><a href="/OI/tree-array">树状数组</a> $\color[rgb]{0,0.5,1}{\sharp}$<br>如题，树状数组。</p>
</li>
<li><p><a href="/OI/segment-tree">线段树</a> $\color[rgb]{0,0.5,1}{\sharp}$<br>线段树相关内容，包括动态开点线段树、可持久化权值线段树等。</p>
</li>
<li><p><a href="/OI/scapegoat-tree/">替罪羊树</a> $\color[rgb]{0,0.5,1}{\sharp}$<br>一种利用暴力重构维护平衡的平衡树。</p>
</li>
<li><p><a href="/OI/splay/">Splay</a> $\color[rgb]{0,0.5,1}{\sharp}$<br>一种基于旋转的平衡树。</p>
</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串的处理和询问一直是OI中比较重要的内容。</p>
<ul>
<li><p><a href="/OI/kmp/">KMP算法与前缀函数</a> $\color[rgb]{0,0.5,1}{\sharp}$<br>一种用来快速查询模式串在文本串中的出现次数的算法。</p>
</li>
<li><p><a href="/OI/trie-and-AK-avtomat">Trie与AC自动机</a> $\color[rgb]{0,0.5,1}{\sharp}$<br> Trie与AC自动机，同时包括可持久化Trie。</p>
</li>
<li><p><a href="/OI/suffix-avtomat">后缀自动机</a> $\color[rgb]{0,0.5,1}{\sharp}$<br>如题，后缀自动机。</p>
</li>
</ul>
<h2 id="图论相关"><a href="#图论相关" class="headerlink" title="图论相关"></a>图论相关</h2><p>是时候把图论的东西单独拿出来了。</p>
<ul>
<li><p><a href="/OI/flow">网络流</a> $\color[rgb]{0.5,0.4,0.4}{φ}$<br>如题，网络流相关内容。</p>
</li>
<li><p><a href="/OI/bipartie-graph">二分图</a><br>如题，二分图相关内容。</p>
</li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题解还会有没写完的吗？</p>
<p>给自己看的：<br>注意提交地址顺序：<br>Luogu LibreOJ AcWing UOJ BZOJ</p>
<ul>
<li><a href="/solutions/solution-p1117">Luogu P1117</a> [NOI2016] 优秀的拆分</li>
<li><a href="/solutions/solution-p1251">Luogu P1251</a> 餐巾计划问题</li>
<li><a href="/solutions/solution-p1486">Luogu P1486</a> [NOI2004] 郁闷的出纳员</li>
<li><a href="/solutions/solution-p1505">Luogu P1505</a> [国家集训队] 旅游</li>
<li><a href="/solutions/solution-p1712">Luogu P1712</a> [NOI2016] 区间</li>
<li><a href="/solutions/solution-p2042">Luogu P2042</a> [NOI2005] 维护数列</li>
<li><a href="/solutions/solution-p2146">Luogu P2146</a> 软件包管理器</li>
<li><a href="/solutions/solution-p2414">Luogu P2414</a> [NOI2011] 阿狸的打字机</li>
<li><a href="/solutions/solution-p2824">Luogu P2824</a> [HEOI2016&#x2F;TJOI2016] 排序</li>
<li><a href="/solutions/solution-p2860">Luogu P2860</a> [USACO06JAN] Redundant Paths G</li>
<li><a href="/solutions/solution-p2906">Luogu P2906</a> [USACO08OPEN] Cow Neighborhoods G</li>
<li><a href="/solutions/solution-p3574">Luogu P3574</a> [POI2014] FAR-FarmCraft</li>
<li><a href="/solutions/solution-p3586">Luogu P3586</a> [POI2015] Logistyka</li>
<li><a href="/solutions/solution-p3644">Luogu P3644</a> [APIO2015] 巴邻旁之桥</li>
<li><a href="/solutions/solution-p3645">Luogu P3645</a> [APIO2015] 雅加达的摩天楼</li>
<li><a href="/solutions/solution-p4643">Luogu P4643</a> [国家集训队] 阿狸和桃子的游戏</li>
<li><a href="/solutions/solution-p5290">Luogu P5290</a> [十二省联考 2019] 春节十二响</li>
</ul>
<ul>
<li><a href="/solutions/solution-l2759">LibreOJ #2759</a> 蜜袋鼯（フクロモモンガ）</li>
<li><a href="/solutions/solution-l2980">LibreOJ #2980</a> 「THUSCH 2017」 大魔法师</li>
</ul>
<ul>
<li><a href="/solutions/solution-sy549">SEZSY OJ #549</a> 农夫奶牛的约翰们</li>
</ul>
<h2 id="比赛记录"><a href="#比赛记录" class="headerlink" title="比赛记录"></a>比赛记录</h2><p>校内OJ的模拟赛记录。</p>
<ul>
<li><a href="/contestrecords/2022-wh-8">2022寒假模拟赛8</a> $\color[rgb]{0,0.5,1}{\sharp}$</li>
</ul>
<h1 id="其他学习笔记"><a href="#其他学习笔记" class="headerlink" title="其他学习笔记"></a>其他学习笔记</h1><p>其他东西的学习笔记。</p>
<ul>
<li><p><a href="/notes/game-strategy">博弈论学习笔记</a> <strong>止まれ</strong><br>如题，博弈论学习笔记。<br>咕了。</p>
</li>
<li><p><a href="/notes/linar-algebra">线性代数</a> <strong>止まれ</strong><br>包含行列式和矩阵的运算。<br>同样咕了。</p>
</li>
</ul>
<h1 id="化学"><a href="#化学" class="headerlink" title="化学"></a>化学</h1><h2 id="有机化学相关"><a href="#有机化学相关" class="headerlink" title="有机化学相关"></a>有机化学相关</h2><ul>
<li><p><a href="/chemistry/lewis-structure">Lewis结构式</a> $\color[rgb]{0,0.5,1}{\sharp}$<br>$Lewis$ 结构式， $Lewis$ 电子理论以及形式电荷。</p>
</li>
<li><p>tbc<br>tbc</p>
</li>
</ul>
<hr>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMTJrNHkxMTczaQ==">展开<i class="fa fa-external-link-alt"></i></span><br>再见。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>感谢</title>
    <url>/thanks/</url>
    <content><![CDATA[<div id="problem-card-vis">false</div>

<p>感谢 <strong>CloudySky</strong> 和 <strong>宝硕</strong> 的大力支持。</p>
<p>没有他们就没有这个博客。</p>
<p>十分感谢。</p>
<p><img src="https://img.shields.io/github/repo-size/kaiserwilheim/kaiserwilheim.github.io?style=for-the-badge" alt="GitHub repo size"></p>
]]></content>
  </entry>
  <entry>
    <title>二分图</title>
    <url>/OI/bipartite-graph/</url>
    <content><![CDATA[<p>二分图相关内容。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="什么是二分图"><a href="#什么是二分图" class="headerlink" title="什么是二分图"></a>什么是二分图</h1><p>二分图是一种特殊的图。</p>
<p>二分图的一个性质是，节点由两个集合组成，且两个集合的内部没有任何一条边。</p>
<p>换而言之，就是我们可以将二分图的两个集合中的所有节点分别染成两种不同的颜色（比如红色与蓝色），可以发现任意一条边都连接着两个不同颜色的点。</p>
<p>我们一般将二分图的两个集合分别放在我们的左边和右边，而边都是横向的。<del>（其实你分别叫这两个集合<font color="#ff0000">华约</font>和<font color="0000ff">北约</font>也没人抗议）</del></p>
<h2 id="我们如何判断一个图是二分图？"><a href="#我们如何判断一个图是二分图？" class="headerlink" title="我们如何判断一个图是二分图？"></a>我们如何判断一个图是二分图？</h2><p>根据二分图的定义，我们可以推断出来一个重要的定理：</p>
<p><strong>二分图没有奇数环。</strong></p>
<p>因为一个二分图的所有边都是横跨两个集合的，每次需要横跨偶数次才能回到起点所在的集合，故二分图没有奇数环。</p>
<p>我们可以利用这个性质对给定的图进行搜索，如果找到了奇数环，那么这个图就一定不是二分图，反之亦然。</p>
<hr>
<p>已知所有二分图相关的问题应该都可以通过转化成为网络流问题来求解，所以在这里我就不对传统的二分图相关算法进行讲解，如匈牙利算法。</p>
<p>二分图有关的问题见下面：</p>
<h1 id="二分图最大匹配"><a href="#二分图最大匹配" class="headerlink" title="二分图最大匹配"></a>二分图最大匹配</h1><h2 id="啥sha是最大匹配？"><a href="#啥sha是最大匹配？" class="headerlink" title="啥shà是最大匹配？"></a><ruby>啥<rt>shà</rt></ruby>是最大匹配？</h2><p>“任意两条边都没有公共端点”的边的集合被称为图的一组匹配。<br>在二分图中，包含变数最多的一组匹配被称为二分图的<strong>最大匹配</strong>。</p>
<p>对于任意一组匹配 $E$ ，属于 $E$ 的边被称为<strong>匹配边</strong>，不属于 $E$ 的边被称为<strong>非匹配边</strong>。匹配边的端点被称为<strong>匹配点</strong>，其他店被称为<strong>非匹配点</strong>。</p>
<h2 id="增广路"><a href="#增广路" class="headerlink" title="增广路"></a>增广路</h2><p>如果在二分图中存在一条连接两个非匹配点的路径 $path$，使得非匹配边与匹配边在 $path$ 上交替出现，那么我们称 $path$ 是 匹配 $E$ 的一条<strong>增广路</strong>，也称交错路。</p>
<p>增广路具有以下性质：</p>
<ol>
<li>长度为奇数。</li>
<li>路径上第奇数条边是非匹配边，第偶数条边是匹配边。</li>
</ol>
<p>利用以上性质，我们尝试将路径上所有边的状态取反，也就是原来的匹配边变成了非匹配边，原来的非匹配边变成了匹配边。<br>经过了这样的一个操作，我们新得到的边集 $E’$ 仍然是一组匹配，且匹配边的数量增加了1。</p>
<p>利用这样的一个操作，我们可以得到一个推论：</p>
<p><strong>二分图的一组匹配 $E$ 是最大匹配，当且仅当图中不存在 $E$ 的增广路。</strong></p>
<p><em>注意</em>：这里的增广路与网络流中的增广路概念不同。</p>
<h2 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h2><p>我们可以使用匈牙利算法，一种利用增广路来求解的算法。其时间复杂度为 $O(nm)$ 。</p>
<p>但是，我们可以使用Dinic来求解。Dinic比匈牙利算法要快（时间复杂度为 $O(m\sqrt{n})$），而且适用范围较匈牙利算法更广。</p>
<p>对于这样的一个问题，我们只需要将所有左边的点<del><font color="$ff0000">华约成员国</font></del>与源点<del><font color="#ff0000">苏联</font></del>连一条容量为1的边，再将所有右边的点<del><font color="#0000ff">北约成员国</font></del>与汇点<del><font color="#0000ff">美国</font></del>连一条容量为1的边。最后，把所有的原图中的边变为一条容量为1的边。</p>
<p>这张图的最大流就是原图的最大匹配数。</p>
<p>以<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzODY=">Luogu P3386 【模板】二分图最大匹配<i class="fa fa-external-link-alt"></i></span>为例。<br>示例代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3386/p3386.cpp"><code>Luogu P3386</code></a></p>
<h2 id="与二分图最大匹配相关的概念"><a href="#与二分图最大匹配相关的概念" class="headerlink" title="与二分图最大匹配相关的概念"></a>与二分图最大匹配相关的概念</h2><h3 id="二分图最大独立集"><a href="#二分图最大独立集" class="headerlink" title="二分图最大独立集"></a>二分图最大独立集</h3><p>从图中选择最多的点，满足两两之间没有边相连。</p>
<p>在二分图中，这个就是去掉最大匹配后的剩余部分。</p>
<h3 id="二分图最小点覆盖"><a href="#二分图最小点覆盖" class="headerlink" title="二分图最小点覆盖"></a>二分图最小点覆盖</h3><p>从图中选择最少的点，满足每条边至少有一个端点被选上。</p>
<p>我们不难发现，点覆盖的补集其实是独立集。</p>
<p>在二分图中，最小点覆盖就是去掉最大独立集后的剩余部分，与最大匹配重合。</p>
<h1 id="二分图最大权匹配"><a href="#二分图最大权匹配" class="headerlink" title="二分图最大权匹配"></a>二分图最大权匹配</h1><p>如果我们给二分图上的边加上边权的话，我们就可以求边权和最大的匹配了。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们可以将其转换为费用流模型，将其按照最大匹配的建图方式建图，并给其中跨集合的边加上一个费用，求这个图的最大费用最大流。</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>差分约束</title>
    <url>/OI/difference-constraint/</url>
    <content><![CDATA[<p>差分约束系统。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<p>2022-03-30发布，<br>2022-06-03再修。</p>
<p>我们经常会遇到一些问题，就是给出一堆未知量，再给出一堆类似“某一个未知量比另一个未知量最多（最少）大（小）多少”的问题，让我们从这一团繁杂的毛钱中拎出一根线头来，以求得这个毛线团的一组可行解。</p>
<p>比如说下面这个东西：</p>
<p>$$<br>\begin{cases}<br>x_1 \geq x_2 - 10 \\<br>x_1 \leq x_3 - 20 \\<br>x_3 \leq x_2 + 10 \\<br>x_4 \leq x_3 - 10 \\<br>x_2 \leq x_4 - 10<br>\end{cases}<br>$$</p>
<p>我们就基本上无从下手。</p>
<p>这时候，我们就需要引入一个新的算法——<strong>差分约束</strong>。</p>
<p>差分约束通过将不等式的问题转化为最短路（或最长路）问题来求解。</p>
<h1 id="最短路？为什么？"><a href="#最短路？为什么？" class="headerlink" title="最短路？为什么？"></a>最短路？为什么？</h1><p>回忆我们学习最短路的时候学到的知识。</p>
<p>假设对于两个点 $a$ 和 $b$，如果其间有一条边长为 $w$ 的有向边 $a \to b$，那么它们的 $dis$ 一定满足 $dis[b] \leq dis[a] + w$。</p>
<p>我们如果将每一个未知量 $x_k$ 与每一个点的 $dis[i]$ 联系起来的话，那么我们就可以得到形如 $x_b \leq x_a + w$ 的一堆不等式。</p>
<p>而我们刚好需要这些不等式。</p>
<p>于是我们就可以将我们手中的不等式组转化为一堆边，并将其放到图里面，建成一个有向图。</p>
<p>最后得出的每一组合法的最短距离，都对应了一组不等式组的解。</p>
<p>我们首先把所有的式子转化为 $x_u \leq x_v + w$ 的形式，再从每一个 $v$ 向 $u$ 建一条边权为 $w$ 的有向边。</p>
<p>这个有向图可以有环，毕竟环是不影响我们的求值环节的。<br>但是它不能有负环。</p>
<p>比如说下面这一组边：</p>
<p>$$<br>\begin{cases}<br>x_2 \leq x_1 + 10 \\<br>x_3 \leq x_2 + 10 \\<br>x_1 \leq x_3 - 30<br>\end{cases}<br>$$</p>
<p>建到图上就是这个样子：</p>
<p><img src="https://s2.loli.net/2022/03/30/d9ltROoBAY178Uy.png" alt="diffcon1.png"></p>
<p>根据原始的不等式组，最终我们会得到 $x_1 \leq x_1 - 10$ 这样一个奇怪的式子，从而导致不等式组无解。</p>
<p>从图上看，这三条边构成了一个负环。</p>
<p>所以说，一个负环最终会导致出现一些奇怪的不等式，最终导致不等式组无解。<br>（当然，如果使用的是最长路的话就是正环）</p>
<p>那我们怎么判负环？（或者说正环）</p>
<p>SPFA！<br>（SPFA信徒狂喜）</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>但是我们光靠这些边实际上是不能得出最终解的。<br>很多情况下，这张图根本不联通。<br>但是这样的图还是可以找到至少一组可行解的。</p>
<p>所以我们还需要建一个超级源点，向每一个点连一条长度为0的边。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>具体情况下，我们不仅有类似 $x_a \leq x_b + w$ 这样的式子，还有其他的一些奇奇怪怪的约束条件。</p>
<p>下面列出了一些常见的约束条件和解决办法：</p>
<table>
<thead>
<tr>
<th>约束条件</th>
<th>解决办法</th>
</tr>
</thead>
<tbody><tr>
<td>$x_a \leq w$</td>
<td>将源点到 $a$ 的边权从0改到 $w$。</td>
</tr>
<tr>
<td>$x_a \geq w$</td>
<td>从 $a$ 向源点连一条长为 $-w$ 的边。</td>
</tr>
<tr>
<td>$x_a &#x3D; x_b + w$</td>
<td>将其拆分为 $x_a \leq x_b + w$ 和 $x_b \leq x_a + (-w)$。</td>
</tr>
<tr>
<td>$x_a + x_b \leq w$</td>
<td>差分约束会寄。请注意一下题目中有没有可以利用的其他特殊性质。</td>
</tr>
</tbody></table>
<p>如果在一个不等式组的约束下（不等式组有解），想求出 $x_i − x_j$ 的最大值呢？<br>首先一定有 $x_i − x_j \leq j$ 到 $i$ 的”最短” 路 $\operatorname{dis}(j,i)$ 。因为我可以先走到 $j$ ，然后走“$j$ 到 $i$ 的”最短路””到 $i$ 。<br>然后我们证明 $x_i − x_j$ 可以取到这个值。<br>这相当于往不等式组中添加一个 $x_i − x_j \geq \operatorname{dis}(j,i)$ ，如果不等式组仍有解，$x_i − x_j$ 就能取到 $\operatorname{dis}(j,i)$ 。<br>这也相当于在图中添加一条边，从 $i$ 到 $j$ ，边权是 $−\operatorname{dis}(j,i)$ 。这样加边一定不会出现负环，因为 $\operatorname{dis}(j,i)$ 是 $j$ 到 $i$ 的最短路，要有负环的话就有别的路径长度 $&lt; \operatorname{dis}(j,i)$ 了。<br>如果要求 $x_i − x_j$ 的最小值，就是求 $x_j − x_i$ 的最大值的相反数，即 $−\operatorname{dis}(i,j)$。<br>“$x_i − x_j$ 的最小值”$\leq$“$x_i − x_j$ 的最大值”，对应了 $−\operatorname{dis}(i,j) \leq \operatorname{dis}(j,i)$ ，也就是 $\operatorname{dis}(i,j) + \operatorname{dis}(j,i) \geq 0$ ，也就对应了图中没有包含 $i,j$ 的负环。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>洛谷<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDU5NjA=">板子题<i class="fa fa-external-link-alt"></i></span></p>
<p>参考代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p5000-p5999/p5960/p5960.cpp"><code>Luogu P5960</code></a></p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>其实差分约束最难的地方不是跑最短路求解的过程，而是如何去建这个图。</p>
<p>这样子的话其实是与网络流有些类似的情况的，有时候我们没有很好的办法来把我们题目中给出的信息来转化成为我们的建图方式。</p>
<p>下面首先会放上两道比较简单的、朴素的题目，没有什么太难理解的地方；然后就会放一些转化题意的例子。</p>
<h2 id="Luogu-P1993-小-K-的农场"><a href="#Luogu-P1993-小-K-的农场" class="headerlink" title="Luogu P1993 小 K 的农场"></a>Luogu P1993 小 K 的农场</h2><p>题目链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDE5OTM=">Luogu<i class="fa fa-external-link-alt"></i></span></p>
<p>接近板子题。</p>
<p>我们可以使用我们刚刚学到的技巧来完成这道题目。</p>
<p>参考代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p1000-p1999/p1993/p1993.cpp"><code>Luogu P1993</code></a></p>
<h2 id="Luogu-P3275-SCOI2011-糖果"><a href="#Luogu-P3275-SCOI2011-糖果" class="headerlink" title="Luogu P3275 [SCOI2011] 糖果"></a>Luogu P3275 [SCOI2011] 糖果</h2><p>题目链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMyNzU=">Luogu<i class="fa fa-external-link-alt"></i></span> || <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE3MS8=">AcWing<i class="fa fa-external-link-alt"></i></span> || <span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yNDM2">LibreOJ<i class="fa fa-external-link-alt"></i></span></p>
<p>我们遇到了新的约束条件：不带取等的不等式。</p>
<p>我们看一下题目的条件：<strong>分糖果</strong>。</p>
<p>由于糖果是一块一块的，我们不能分给小朋友们半块糖果或 $\lim\limits_{m \to 0}$ 块糖果，所以我们可以尝试着更改一下约束条件。<br>我们可以将 $x_a &gt; x_b$ 改为 $x_a \geq x_b + 1$。</p>
<p>这样就可以建图了。</p>
<p>参考代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3275/p3275.cpp"><code>Luogu P3275</code></a></p>
<h2 id="AcWing-362-区间"><a href="#AcWing-362-区间" class="headerlink" title="AcWing 362. 区间"></a>AcWing 362. 区间</h2><p>题目链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzY0Lw==">AcWing<i class="fa fa-external-link-alt"></i></span> || <span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8xMDA4Nw==">LibreOJ<i class="fa fa-external-link-alt"></i></span></p>
<p>这一次题目没有直接给出类似于“A大于等于B+C”这样的条件，我们需要自己推出不等式组。</p>
<p>首先我们需要了解我们维护的是一个不可重的集合，那么集合内的每一个数最多只能出现一次。</p>
<p>然后我们需要满足的条件是区间内的数字的个数不小于 $c_i$ 个。</p>
<p>然后我们会发现，我们可以将上述两个条件转化为前缀和数组中的不等关系。</p>
<p>因为我们每一个数只能出现0次或1次，所以我们前缀和数组是严格非降的，且相邻两项之间最多差1。<br>我们如果称前缀和数组为 $s$ 的话，那么上述条件可以转化为 $s_{i-1} \leq s_i$ 和 $s_i \leq s_{i-1} + 1$ 两个不等式。</p>
<p>对于第二个条件，也可以转化成为前缀和数组上的不等关系。<br>如果我们有一个条件是“$[ a,b ]$ 这段区间内的数字不少于 $c$ 个”的话，我们可以将其转化为类似 $s_b \geq s_{a-1} + c$ 这样的不等式。</p>
<p>然后我们就可以愉快地跑SPFA了，最后需要输出的是前缀和数组的最后一位——$s_{50001}$。</p>
<p>参考代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/AcWing/362/ac362.cpp"><code>AcWing 362</code></a></p>
<h2 id="Luogu-P4878-USACO05DEC-Layout-G"><a href="#Luogu-P4878-USACO05DEC-Layout-G" class="headerlink" title="Luogu P4878 [USACO05DEC] Layout G"></a>Luogu P4878 [USACO05DEC] Layout G</h2><p>题目链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQ4Nzg=">Luogu<i class="fa fa-external-link-alt"></i></span> || <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE3Mi8=">AcWing<i class="fa fa-external-link-alt"></i></span> || <span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8xMDA5MA==">LibreOJ<i class="fa fa-external-link-alt"></i></span></p>
<p>题目保证了奶牛的编号与其在序列中的位置是相对应的，同时两个奶牛之间的距离可以是0，也就是说我们每一个奶牛的坐标一定大于等于其上一只的坐标。</p>
<p>然后还有两种其他的条件，一是两头奶牛之间的距离不大于某个数，二是两头奶牛之间的距离不小于某个数。假设我们这两头奶牛分别是a和b，这个给定的数是c，那么我们对于上面两个条件分别可以得出 $x_b \leq x_a + c$ 和 $x_b \geq x_a + c$ 这两个不等式。</p>
<p>然后就建图跑就可以了。</p>
<p>参考代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p4000-p4999/p4878/p4878.cpp"><code>Luogu P4878</code></a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速求popcount和</title>
    <url>/OI/fast-popcnt-sum/</url>
    <content><![CDATA[<p>一种以 $O(\log n)$ 的时间复杂度快速求 $\sum\limits_{i&#x3D;1}^n \operatorname{popcount}(i)$ 的方法。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h1><p>摆结论：</p>
<p>$$<br>\sum_{i&#x3D;1}^n \operatorname{popcount}(i) &#x3D; \sum_{i&#x3D;1}^{\lceil \log_2(n) \rceil - 1} [(n&gt;&gt;(i-1)) \&amp; 1&#x3D;&#x3D;1] \times (i \times 2^{i-1} + 2^i \times \operatorname{popcount}(n&gt;&gt;i))<br>$$</p>
<p>其中 $[(n&gt;&gt;(i-1)) \&amp; 1&#x3D;&#x3D;1]$ 代表 $n$ 的第 $i$ 位是否为零。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>首先，我们可以想到一种 $O(1)$ 的求 $\sum\limits_{i&#x3D;0}^{2^k-1} \operatorname{popcount}(i)$ 的方法。</p>
<p>这里以 $[0,2^5-1]$ 为例。</p>
<p>我们首先将所有数字列出来：</p>
<p><img src="https://s2.loli.net/2022/06/13/dKYtT86FQsXDpmO.png" alt="fastpopcnt1.png"></p>
<p>然后逐二进制位来看。</p>
<p>最低位的规律是01010101…：</p>
<p><img src="https://s2.loli.net/2022/06/13/vc4nVkg5jTDflNQ.png" alt="fastpopcnt2.png"></p>
<p>第二位的规律是00110011…：</p>
<p><img src="https://s2.loli.net/2022/06/13/ADK2TXtixpzWIUf.png" alt="fastpopcnt3.png"></p>
<p>第三位的规律是00001111…：</p>
<p><img src="https://s2.loli.net/2022/06/13/8ACtzm36Gnfhkde.png" alt="fastpopcnt4.png"></p>
<p>之后的规律也显然：</p>
<p><img src="https://s2.loli.net/2022/06/13/gW4j5p2yVKxAhbk.png" alt="fastpopcnt5.png"><br><img src="https://s2.loli.net/2022/06/13/lFOnc31pAR8aTeG.png" alt="fastpopcnt6.png"></p>
<p>我们可以得到，每一位中都有一半是0，另一半是1。</p>
<p>于是我们就可以得出公式：</p>
<p>$$<br>\sum\limits_{i&#x3D;0}^{2^k-1} \operatorname{popcount}(i) &#x3D; k \times 2^{k-1}<br>$$</p>
<p>然后我们将给定的 $n$ 按照二进制位拆分。</p>
<p>这里以 $(11010110)_2 &#x3D; (214)_{10}$ 为例。 </p>
<p>（下面指的第几位都是从高向低数的）</p>
<p>其第一位是 $1$，所以我们可以向结果累加 $(00000000)_2 \sim (01111111)_2$ 的popcount和，也就是 $0 \times 2^7 + 7 \times 2^6$。</p>
<p>其第二位是 $1$，所以我们可以向结果累加 $(10000000)_2 \sim (10111111)_2$ 的popcount和，也就是 $1 \times 2^6 + 6 \times 2^5$。</p>
<p>其第三位是 $0$，对结果没有贡献。</p>
<p>其第四位是 $1$，所以我们可以向结果累加 $(11000000)_2 \sim (11001111)_2$ 的popcount和，也就是 $2 \times 2^4 + 4 \times 2^3$。</p>
<p>其第五位是 $0$，对结果没有贡献。</p>
<p>其第六位是 $1$，所以我们可以向结果累加 $(11010000)_2 \sim (11010011)_2$ 的popcount和，也就是 $3 \times 2^2 + 2 \times 2^1$。</p>
<p>其第七位是 $1$，所以我们可以向结果累加 $(11010100)_2 \sim (11010101)_2$ 的popcount和，也就是 $4 \times 2^1 + 1 \times 2^0$。</p>
<p>其第八位是 $0$，对结果没有贡献。<br>但其实不管有没有贡献我们都不算他了，因为我们只需要将 $[0,n)$ 这个区间分段即可。</p>
<p>最后再加上 $\operatorname{popcount}((11010110)_2) &#x3D; 5$。</p>
<p>最终结果就是</p>
<p>$$<br>\begin{align}<br>&amp; 0 \times 2^7 + 7 \times 2^6 + 1 \times 2^6 + 6 \times 2^5 + 2 \times 2^4 + 4 \times 2^3 + 3 \times 2^2 + 2 \times 2^1 \\ \notag<br>&amp; + 4 \times 2^1 + 1 \times 2^0 + \operatorname{popcount}((11010110)_2) \\<br>&#x3D;{} &amp; 448 + 256 + 64 + 16 + 9 + 5 \\<br>&#x3D;{} &amp; 798<br>\end{align}<br>$$</p>
<p>因为 $\operatorname{popcount}(0) &#x3D; 0$，所以统计上 $0$ 与不统计上其实没有本质上的区别。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> x = n;</span><br><span class="line"><span class="keyword">while</span>(x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &amp; <span class="number">1</span>)</span><br><span class="line">        tot += (cnt * (<span class="number">1</span> &lt;&lt; (cnt - <span class="number">1</span>))) + (<span class="number">1</span> &lt;&lt; cnt) * __builtin_popcount(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line">tot += __builtin_popcount(n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, tot);</span><br></pre></td></tr></table></figure>












]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>树链剖分</title>
    <url>/OI/heavy-path-decomposition/</url>
    <content><![CDATA[<p>树链剖分。<br>Luogu P3384</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>树链剖分（简称“树剖”，又称“重链剖分”）是一种将一棵树转化为一段连续的区间的方法。<br>这种方法可以将一棵树根据子树大小，也就是所谓的“重儿子”和“轻儿子”，来将一棵树划分成若干条”重链“，并可以保证，在任意一条路径上的连续的链都不超过 $\log_2{n}$ 个。</p>
<p>树剖可以借助一些数据结构（如线段树）来以 $O(\log n)$ 的复杂度维护数上路径的信息，如“修改<strong>树上两点之间的路径上</strong>所有点的值”和“查询<strong>树上两点之间的路径上</strong>节点权值的<strong>和&#x2F;极值&#x2F;其他</strong>(在序列上可以用数据结构维护的、便于合并的信息)”等等。</p>
<p>当然，除了上面那样做，树剖还可以快速地求LCA。</p>
<p>树剖在洛谷上有一道模板题：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzODQ=">Luogu P3384<i class="fa fa-external-link-alt"></i></span><br>一道比较经典的例题：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDIxNDY=">Luogu P2146 [NOI2015] 软件包管理器<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><p>树剖的思想是，将一棵树按照“重边”来划分称为若干条“重链”。<br>当然，这里的“重链”只是指的一种常用的情况，其他的划分方法比如“长链剖分”等等就不在此赘述了。</p>
<h2 id="重链"><a href="#重链" class="headerlink" title="重链"></a>重链</h2><p>“重链”的定义是若干条首尾衔接的“重边”。<br>那么，如果想要了解“重链”，就需要先了解<strong>重边</strong>。</p>
<h3 id="重边"><a href="#重边" class="headerlink" title="重边"></a>重边</h3><p>“重边”的划分标准是它连接向一个重儿子。<br>这里需要注意的是，它只需要结束于一个重儿子，而无其他限制。<br>那么“重儿子”呢？</p>
<h3 id="重儿子"><a href="#重儿子" class="headerlink" title="重儿子"></a>重儿子</h3><p>“重儿子”是“重子节点”的别称。<br>我们判断一个子节点是否为重子节点的标准是它的子树大小。</p>
<p>对于一个节点的所有儿子，其中子树最大的那个儿子称为“重儿子”，其余的，则相对地称之为“轻儿子”。<br>连接某个节点和其重儿子的边叫做“重边”，而连接其与其轻儿子的边则相应地叫做“轻边”。</p>
<h2 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h2><p>我们首先看一下例子：</p>
<p><img src="https://s2.loli.net/2021/12/29/iVkNYOTprWKF2Lz.png" alt="树剖1.png"></p>
<p>这是一棵树。<br>对于上面的这一棵树，我们可以进行如下的一些标记：<br>我们首先按照深度进行分层：</p>
<p><img src="https://s2.loli.net/2021/12/29/Jgwz7DUojWMBms1.png" alt="树剖2.png"></p>
<p>然后标出子树的大小：</p>
<p><img src="https://s2.loli.net/2021/12/29/4Xcb2qKiFyD6IdM.png" alt="树剖3.png"></p>
<p>然后标出轻儿子、重儿子、轻边和重边：</p>
<p><img src="https://s2.loli.net/2021/12/29/ACztKMokjJgmYx7.png" alt="树剖4.png"></p>
<p>然后标出重链：</p>
<p><img src="https://s2.loli.net/2021/12/29/4nWDzp72RSkBE1l.png" alt="树剖5.png"></p>
<p>最后标出DFS序：</p>
<p><img src="https://s2.loli.net/2021/12/29/bS7Y1wiOglACmkt.png" alt="树剖6.png"></p>
<p>这样就大功告成了。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>树剖的实现是通过两个DFS进行的。</p>
<p>我们这次使用邻接表来存储树的边信息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> w[N], h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个DFS记录了每个节点的父节点(vater)、深度(depth)、子树大小(sz)和重儿子(son)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> vater, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[p] = depth, fa[p] = vater, sz[p] = <span class="number">1</span>;<span class="comment">//初始化节点状态，记录其深度和父节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])<span class="comment">//遍历其所有儿子</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == vater) <span class="keyword">continue</span>;<span class="comment">//防止遍历其父亲</span></span><br><span class="line">        <span class="built_in">dfs1</span>(j, p, depth + <span class="number">1</span>);<span class="comment">//搜索当前儿子</span></span><br><span class="line">        sz[p] += sz[j];<span class="comment">//更新子树大小</span></span><br><span class="line">        <span class="keyword">if</span>(sz[son[p]] &lt; sz[j]) son[p] = j;<span class="comment">//判断是否为重儿子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个DFS记录了每个节点所在重链的链顶节点(top)、dfs序(id)和重新定向的节点权值(nw)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id[p] = ++cnt, nw[cnt] = w[p], top[p] = t;<span class="comment">//初始化节点信息，记录其DFS序</span></span><br><span class="line">    <span class="keyword">if</span>(!son[p]) <span class="keyword">return</span>;<span class="comment">//是否为叶节点</span></span><br><span class="line">    <span class="built_in">dfs2</span>(son[p], t);<span class="comment">//优先搜索在同一条重链上的重儿子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == fa[p] || j == son[p]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(j, j);<span class="comment">//搜索轻儿子，开一条新的重链，链顶为当前轻儿子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>树剖可以在 $O(n) \sim O(\log n)$ 的时间复杂度内求出两个点的LCA。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="板子题"><a href="#板子题" class="headerlink" title="板子题"></a>板子题</h2><p>洛谷上面提供了板子题。<br>题面见<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzODQ=">这里<i class="fa fa-external-link-alt"></i></span>。<br>代码正确性见<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3JlY29yZC82NTkwNzI2Mg==">提交记录<i class="fa fa-external-link-alt"></i></span>。</p>
<p>我们首先照常打出线段树部分（<del>不会的可以看<a href="">这篇博客</a></del>各位读者们一定已经会线段树了罢）；<br>两个DFS也是已经有了的代码（见上面）；<br>然后就有了这篇代码的核心部分。</p>
<p>之后就是对题目要求功能的实现。</p>
<p>题目要求我们这样做：</p>
<blockquote>
<ol>
<li>将树从 x 到 y 结点最短路径上所有节点的值都加上 z。</li>
<li>求树从 x 到 y 结点最短路径上所有节点的值之和。</li>
<li>将以 x 为根节点的子树内所有节点值都加上 z。</li>
<li>求以 x 为根节点的子树内所有节点值之和。</li>
</ol>
</blockquote>
<p>我们分类型进行实现。</p>
<p>对于那些对某一棵子树进行的操作，我们直接调用线段树来进行操作，因为对于任意一棵子树，它里面的所有节点的DFS序就是连续的，也就意味着可以被当成一段区间来进行操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addtree</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">segadd</span>(<span class="number">1</span>, id[p], id[p] + sz[p] - <span class="number">1</span>, k);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sumtree</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">segsum</span>(<span class="number">1</span>, id[p], id[p] + sz[p] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对于路径的操作，我们使用这样一种策略：边走边计算。<br>首先，我们求出这一条最短路，也就是求出它们的最近公共祖先。<br>我们使用这样的思路来寻找他们的LCA：</p>
<p>我们从较深的那一个节点开始不断向上跳重链，直到跳到与较浅的节点同一条重链上为止。此时，深度较浅的那一个就是他们的LCA。</p>
<p>于是我们就可以写出路径加、路径求和的代码了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addpath</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[p] != top[q])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[p]] &lt; dep[top[q]]) <span class="built_in">swap</span>(p, q);</span><br><span class="line">        <span class="built_in">segadd</span>(<span class="number">1</span>, id[top[p]], id[p], k);</span><br><span class="line">        p = fa[top[p]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[p] &lt; dep[q]) <span class="built_in">swap</span>(p, q);</span><br><span class="line">    <span class="built_in">segadd</span>(<span class="number">1</span>, id[q], id[p], k);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sumpath</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[p] != top[q])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[p]] &lt; dep[top[q]]) <span class="built_in">swap</span>(p, q);</span><br><span class="line">        res += <span class="built_in">segsum</span>(<span class="number">1</span>, id[top[p]], id[p]);</span><br><span class="line">        p = fa[top[p]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[p] &lt; dep[q]) <span class="built_in">swap</span>(p, q);</span><br><span class="line">    res += <span class="built_in">segsum</span>(<span class="number">1</span>, id[q], id[p]);</span><br><span class="line">    <span class="keyword">return</span> res % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后放一遍完整代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3384/p3384.cpp"><code>Luogu P3384</code></a></p>
<h2 id="NOI2015-软件包管理器"><a href="#NOI2015-软件包管理器" class="headerlink" title="[NOI2015] 软件包管理器"></a>[NOI2015] 软件包管理器</h2><p>也是一道树剖的经典题目。</p>
<p>我们仔细想一下就可以知道，<code>install</code>操作可以将从当前节点到根节点的所有未安装的软件全部安装，而<code>uninstall</code>会将其子树内的所有软件一并卸载。</p>
<p>然后就是区间推平了。</p>
<p>详细的解释可以看我的<a href="/solutions/solution-p2146/">题解</a>。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP 算法与前缀函数</title>
    <url>/OI/kmp/</url>
    <content><![CDATA[<p>KMP算法与前缀函数。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>KMP算法，全称为 Knuth-Morris-Pratt 算法，是由 Knuth, Morris 和 Pratt 这三个人创造的算法，可以在 $O(n+m)$ 的时间内使用 $O(n)$ 的空间完成如下的任务：</p>
<blockquote>
<p>给定一个字符串 $S$ 和一个模式串 $T$，求出 $S$ 在 $T$ 中所有出现的位置。</p>
</blockquote>
<p>其中 $|S| &#x3D; n$，$|T| &#x3D; m$。</p>
<p>KMP算法主要依赖的是 “Next函数” 这个东西。</p>
<h1 id="Next函数"><a href="#Next函数" class="headerlink" title="Next函数"></a>Next函数</h1><p>Next函数，有时候也被称作 “前缀函数”，是KMP算法的核心部分。<br>我们以一个数组 $\pi$ 来表示它。</p>
<p>其旨在求得任意一个前缀的border长度。</p>
<h2 id="什么是border？"><a href="#什么是border？" class="headerlink" title="什么是border？"></a>什么是border？</h2><p>border指的是一个字符串内，真前缀和真后缀相等的那一部分。<br>这样的真前缀和真后缀可能有很多种，我们需要找的是最长的那一组。</p>
<p>真前缀和真后缀说的是前缀和后缀中除去字符串本身之后剩下的部分。</p>
<h2 id="如何求得border？"><a href="#如何求得border？" class="headerlink" title="如何求得border？"></a>如何求得border？</h2><h3 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h3><p>我们显然可以暴力扫，最终的复杂度是 $O(n^3)$ 的。</p>
<p>懒得写了，直接搬了OI-Wiki的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefix_function</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = ( <span class="type">int</span> )s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pi</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, j) == s.<span class="built_in">substr</span>(i - j + <span class="number">1</span>, j))</span><br><span class="line">            &#123;</span><br><span class="line">                pi[i] = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prefix_function</span>(<span class="params">s</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    pi = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[<span class="number">0</span> : j] == s[i - j + <span class="number">1</span> : i + <span class="number">1</span>]:</span><br><span class="line">                pi[i] = j</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> pi</span><br></pre></td></tr></table></figure>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>我们会发现，相邻的两个函数值最多会增加1。</p>
<p>也就是说，当我们移动到下一个位置时，Next函数的值要么增加一，要么维持不变，要么减少。</p>
<p>此时改进的算法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefix_function</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = ( <span class="type">int</span> )s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pi</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = pi[i - <span class="number">1</span>] + <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)  <span class="comment">// improved: j=i =&gt; j=pi[i-1]+1</span></span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, j) == s.<span class="built_in">substr</span>(i - j + <span class="number">1</span>, j))</span><br><span class="line">            &#123;</span><br><span class="line">                pi[i] = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prefix_function</span>(<span class="params">s</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    pi = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(pi[i - <span class="number">1</span>] + <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[<span class="number">0</span> : j] == s[i - j + <span class="number">1</span> : i + <span class="number">1</span>]:</span><br><span class="line">                pi[i] = j</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> pi</span><br></pre></td></tr></table></figure>

<p>此时，我们每一个前缀最多需要比对 $O(n)$ 级别的字符串，总复杂度降到了 $O(n^2)$。</p>
<h3 id="继续优化"><a href="#继续优化" class="headerlink" title="继续优化"></a>继续优化</h3><p>刚才我们只考虑到了 $s[i+1] &#x3D; s[\pi[i]]$ 的情况，即函数值增加1。<br>那么对于其他的情况呢？</p>
<p>我们考虑 $s[i+1] \neq s[\pi[i]]$。<br>在我们之前的想法里面，我们就需要枚举出来可能的border长度，并与实际情况进行比较。</p>
<p>我们尝试避免这些无谓的比较。</p>
<p>我们尝试找到一个前缀，在保证其与后缀相等的前提下，使得我们当前匹配的进度最大地保留下来。</p>
<p>观察一下我们想要找到的东西：</p>
<img src="/pics/kmp1.svg" alt="kmp1.svg" width="50%" />

<p>我们想要找到两个字符串 $s[0 \to j-1]$ 和 $s[i-j+1 \to i]$，他们完全相等，同时也分别是 $s[0 \to i]$ 的一个前缀和一个后缀。</p>
<p>我们发现，这两个字符串是完全包含在 $s[0 \to \pi[i]-1]$ 和 $s[i-\pi[i]+1 \to i]$ 这两个完全相等的字符串内的。</p>
<p>所以，我们就可以将其转化成为寻找字符串 $s[0 \to \pi[i]-1]$ 的border。</p>
<p>所以说，我们需要找的就是 $s[0 \to \pi[\pi[i]]-1]$ 和 $s[i-\pi[\pi[i]]+1 \to i]$。</p>
<p>然后我们尝试将 $s_{i+1}$ 纳入我们当前找到的border里面。</p>
<p>如果匹配，那就向前移动；<br>如果失配，那就继续寻找当前长度的border，直到最后到达0。</p>
<p>此时改进的算法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefix_function</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = ( <span class="type">int</span> )s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pi</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = pi[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) j = pi[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i] == s[j]) j++;</span><br><span class="line">        pi[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prefix_function</span>(<span class="params">s</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    pi = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        j = pi[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> s[i] != s[j]:</span><br><span class="line">            j = pi[j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        pi[i] = j</span><br><span class="line">    <span class="keyword">return</span> pi</span><br></pre></td></tr></table></figure>

<p>同时我们还可以发现，我们进行优化过的算法是一个在线算法。</p>
<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><p>现在终于来到了KMP算法的本体部分。</p>
<p>我们考虑根据题目给定的 $S$ 和 $T$ 两个字符串，拼接成一个新的字符串 $S+ \sharp +T$ ，其中 $\sharp$ 代表在 $S$ 和 $T$ 中都没有出现过的分隔符。</p>
<p>我们考虑计算新字符串 $T$ 部分的Next函数。</p>
<p>因为对于 $T$ 部分的每一个位置，其位置所对应的前缀绝对包含 $S$ 和分隔符的。<br>所以，其Next函数长度绝对不会超过 $n$。（即 $|S|$）</p>
<p>同时，我们保证了只会比对 $T$ 部分的字串，因为分隔符的出现使得包含其的后缀无法与同样长度的前缀匹配，因为这个字符不在 $S$ 或 $T$ 中出现过，而假如前缀中也包含了它，也会因为位置不一样而无法匹配。</p>
<p>所以说，如果在某一个位置 $i$ 有 $\pi[i] &#x3D; n$ 成立，那么 $S$ 就会在 $T$ 的 $i-2n$ 处出现。</p>
<p>洛谷例题：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzNzU=">https://www.luogu.com.cn/problem/P3375<i class="fa fa-external-link-alt"></i></span></p>
<p>示例代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3375/p3375.cpp"><code>Luogu P3375</code></a></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="求一个字符串的周期"><a href="#求一个字符串的周期" class="headerlink" title="求一个字符串的周期"></a>求一个字符串的周期</h2><p>我们考虑利用border的性质。</p>
<p>如果一个字符串 $s$ 有长度为 $r$ 的border，那么 $|s| - r$ 一定是 $s$ 的周期，其长度我们这里记作 $p$。</p>
<p>就像这样：</p>
<img src="/pics/kmp2.svg" alt="kmp2.svg" width="50%" />

<p>从这里我们可以得出 $s[0 \to 1]&#x3D;s[2 \to 3]&#x3D;s[4 \to 5]&#x3D;s[6 \to 7]$，从而得出 $r-|s|&#x3D;2$ 为 $s$ 的周期。</p>
<p>同时，如果这个周期的长度 $p$ 可以被 $|s|$ 整除的话，那么长度为 $p$ 的前缀就是 $s$ 的最小循环元。</p>
<p>AcWing例题：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTQzLw==">https://www.acwing.com/problem/content/143/<i class="fa fa-external-link-alt"></i></span></p>
<p>参考代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/AcWing/141/ac141.cpp"><code>AcWing 141</code></a></p>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>扫描线</title>
    <url>/OI/scanning-line/</url>
    <content><![CDATA[<p>一种便携的用来求矩形面积并的算法。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><p>顾名思义，扫描线就是要模拟一根线，扫过整个图形。至于方向什么的自己根据喜好，这里选用从左往右的方式。</p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="朴素做法"><a href="#朴素做法" class="headerlink" title="朴素做法"></a>朴素做法</h2><p>首先我们看一下这个例子：</p>
<img src="https://i.loli.net/2021/11/12/ykmlLC6RpHTZbUf.png" alt="扫描线1.png" width="60%" />

<p>我们有三个矩形，分别用红、蓝、绿三色标注了出来。<br>他们相交的面积用其他的颜色标了出来。</p>
<p>我们所得到的信息只有矩形的左下端点和右上端点的坐标。也就是我们标红的这几个点：</p>
<img src="https://i.loli.net/2021/11/12/Naw9ZzMXnA6Jt7d.png" alt="扫描线2.png" width="60%" />

<p>然后我们可以画出一根线来，扫过这个多边形的所有面积。<br>这根线从最左边的边开始，每遇到一条边，就停下来计算之前扫到的面积，即为距上一条边的距离与扫描线落在图形上的长度之积，再加到之前的和上面。<br>用动画来做就是这样的：</p>
<img src="https://s2.loli.net/2021/12/29/zsg32tJnWbykfBo.gif" alt="扫描线3.gif" width="60%" />

<p>但是这样做有一处需要注意的地方： <strong>我们怎么才能知道每一次遇到一条边之后扫描线落在图像上的长度是多少</strong> ？<br>如果我们每一次都去枚举、去找，我们程序的时间复杂度就达不到我们的要求了。<br>这就是扫描线算法的精髓之处。</p>
<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>我们把 $y$ 轴上的一段区间按照每一个存在的矩形的边的高度值分一下块：</p>
<img src="https://i.loli.net/2021/11/12/pkELge24OblfDxI.png" alt="扫描线4.png" width="60%" />

<p>我们只需要计算每一段所对应的在 $x$ 轴上的长度就行了。</p>
<p>我们可以使用线段树这一强大的数据结构来帮助我们更快地进行区间修改。</p>
<img src="https://i.loli.net/2021/11/12/W3OLxhVenapUIfH.png" alt="扫描线5.png" width="60%" />

<h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><p>我们在遇到某个矩形的一条边的时候，我们需要看一下这两个东西：</p>
<ol>
<li>它的长度；</li>
<li>他是起始边还是终止边。</li>
</ol>
<p>如果是起始边的话，我们把他这条边所包含的所有区块都打上一个标记；如果是终止边的话，我们就把之前起始边打上的标记去掉。这样，只要有标记就是存在，不管有多少个；没有标记就是没有被覆盖，忽略不计。<br>所以，我们的线段树节点需要存储这个区段被标记的次数。同时，我们还需要存储基本的线段树信息，还有它的长度。<br>同时，我们用来存储矩形边的位置我们也需要改一下，使之能够存储这条边的上端点和下端点，还要标记这条边是起始边还是终止边。<br>最终我们使用动画模拟一下就是这个样子的：</p>
<img src="https://s2.loli.net/2021/12/29/UEmq4XVFOWL56eo.gif" alt="扫描线6.gif" width="60%" />

<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>洛谷板子题：Luogu P5490 【模板】 扫描线：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDU0OTA=">https://www.luogu.com.cn/problem/P5490<i class="fa fa-external-link-alt"></i></span></p>
<p>示例代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p5000-p5999/p5490/p5490.cpp"><code>Luogu P5490</code></a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>替罪羊树</title>
    <url>/OI/scapegoat-tree/</url>
    <content><![CDATA[<p>替罪羊树。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<p>替罪羊树是一种平衡树。</p>
<h1 id="热身"><a href="#热身" class="headerlink" title="热身"></a>热身</h1><p>平衡树一般都是一个二叉搜索树，其满足中序遍历得到的序列就是我们需要维护的原序列。</p>
<p>当然，二叉搜索树可以不平衡，这样就可以构造一个特殊的数据使之退化成为一条链。</p>
<p>那我们怎么定义一棵二叉搜索树“不平衡”呢？</p>
<p>这里需要引入一个概念：平衡指数 $\alpha$。</p>
<p>一棵二叉搜索树的平衡常数等于其子节点大小与其大小的比值。<br>这里取的是最大值。</p>
<p>平衡常数 $\alpha$ 的取值是 $\alpha \in [ 0.5 , 1 ]$。<br>其两个边界代表了两个极端情况：</p>
<p>当 $\alpha &#x3D; 1$ 时，我们不管怎样建造搜索树都会被认为是平衡的，因为其子节点的子树大小永远不可能超过其本身的子树大小。</p>
<p>当 $\alpha &#x3D; 0.5$ 时，我们每一个节点的子节点的子树大小必须恰好是其本身的子树大小的一半。<br>AVL树就在尽力维持这样的平衡，这就导致其代码十分冗长，没有能在OI上有太多实际的应用。<br>在<span class="exturl" data-url="aHR0cHM6Ly93d3cuY3MudXNmY2EuZWR1L35nYWxsZXMvdmlzdWFsaXphdGlvbi9BVkx0cmVlLmh0bWw=">这里<i class="fa fa-external-link-alt"></i></span>有一个AVL树的可视化。</p>
<p>红黑树比较特殊，通过放宽一些过于严苛的要求，其追求的是 $\alpha &#x3D; \frac{2}{3}$，同时降低了常数和代码长度。<br>在<span class="exturl" data-url="aHR0cHM6Ly93d3cuY3MudXNmY2EuZWR1L35nYWxsZXMvdmlzdWFsaXphdGlvbi9SZWRCbGFjay5odG1s">这里<i class="fa fa-external-link-alt"></i></span>有一个红黑树的可视化。</p>
<p>其他的平衡树都是通过一些思想来维持 $\alpha$ 的尽量低。</p>
<p>基于<span class="exturl" data-url="aHR0cHM6Ly9yaXRlbWUuc2l0ZS9ibG9nLzIwMTYtNC02L3NjYXBlZ29hdC5odG1s">这里<i class="fa fa-external-link-alt"></i></span>的数据，我们可以大概得知不同平衡树的 $\alpha$ 大小：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">平均</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Splay</td>
<td align="center">0.758</td>
<td align="center">0.588</td>
<td align="center">0.582</td>
<td align="center">0.612</td>
<td align="center">0.759</td>
<td align="center">0.659</td>
</tr>
<tr>
<td align="center">Treap</td>
<td align="center">0.766</td>
<td align="center">0.578</td>
<td align="center">0.601</td>
<td align="center">0.587</td>
<td align="center">0.781</td>
<td align="center">0.662</td>
</tr>
<tr>
<td align="center">FHQ-Treap</td>
<td align="center">0.914</td>
<td align="center">0.860</td>
<td align="center">0.613</td>
<td align="center">0.678</td>
<td align="center">0.803</td>
<td align="center">0.773</td>
</tr>
</tbody></table>
<p>可见，一般的平衡树都能将 $\alpha$ 维持到 0.6 到 0.8 范围内。</p>
<h2 id="替罪羊树"><a href="#替罪羊树" class="headerlink" title="替罪羊树"></a>替罪羊树</h2><p>替罪羊树最大的特点就是暴力。</p>
<p>怎么暴力呢？</p>
<p>替罪羊树会将不平衡的子树进行重构来保证其平衡。<br>而其判断子树平衡与否就是根据刚才讲的平衡因数 $\alpha$，只不过这里是人为设定的，称之为平衡常数。</p>
<h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><h2 id="暴力重构"><a href="#暴力重构" class="headerlink" title="暴力重构"></a>暴力重构</h2><p>替罪羊树之所以能够平衡，是在于其重构时不是瞎重构，而是将被重构的子树重构为一棵<strong>完全二叉树</strong>。</p>
<p>当然我们都知道这样费时又费力，更何况还是暴力重构的。</p>
<p>所以我们认为设定的平衡常数 $\alpha$ 在此时就起到了决定性的作用。<br>当其值合适的时候，我们就可以将所有的时间复杂度均摊到一个 $O(\log n)$ 的水平。</p>
<p>具体如何暴力重构就不用太多赘述了，我们可以使用简单的方法来保证线性建树，然后将新建的树接过来即可。</p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>替罪羊树的查询与其他二叉搜索树一样，并且因为其没有对树进行修改，还不会导致产生重构操作，所以最终时间复杂度为 $O(\log n)$。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>替罪羊树的插入操作与其他的二叉搜索树差不多。只不过因为其导致了树形态的改变，我们在插入完回溯的过程中还需要判断一下是否需要重构。</p>
<p>当然，还会有一条链上多棵子树不平衡的情况。<br>我们可以将最大的子树重构，但是这样在实际写代码的时候会略显复杂。<br>如果你真的很懒的话，只需要在回溯的时候找到第一棵不平衡的树重构即可，并且据说这个样子对于时间复杂度的影响不会很大。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>替罪羊树使用惰性删除，只需要将对应节点上代表节点内数据数量的标记自减一即可。</p>
<p>对于一个节点内数据数量为0的点，我们会忽略对其的任何操作，并在下一次重构时将其丢弃掉，除非再有插入操作将其插入回去。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>替罪羊树的一个节点内需要存储很多信息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Scapegoat</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ls, rs;</span><br><span class="line">    <span class="type">int</span> w, wn;</span><br><span class="line">    <span class="type">int</span> s, sz, sd;</span><br><span class="line">&#125;tr[N];</span><br></pre></td></tr></table></figure>

<p>解释一下：</p>
<ul>
<li><code>ls</code>&amp;<code>rs</code>：左右儿子。</li>
<li><code>w</code>：节点权值。</li>
<li><code>wn</code>：节点内数据数量。</li>
<li><code>s</code>：子树内节点个数。</li>
<li><code>sz</code>：子树内数据个数。</li>
<li><code>sd</code>：子树内不计删除节点的节点个数。</li>
</ul>
<p>我们这样来（重新）计算当前节点的子树大小：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].s = tr[tr[p].ls].s + tr[tr[p].rs].s + <span class="number">1</span>;</span><br><span class="line">    tr[p].sz = tr[tr[p].ls].sz + tr[tr[p].rs].sz + tr[p].wn;</span><br><span class="line">    tr[p].sd = tr[tr[p].ls].sd + tr[tr[p].rs].sd + (tr[p].wn != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p>我们重构分两种情况：一是子树不平衡了，即左右子树之一的大小占其本身子树大小的比例超过 $\alpha$；二是被删除的节点太多了，这样也会影响效率。</p>
<p>首先我们需要判断是否需要重构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canrbu</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tr[p].wn)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(alpha * tr[p].s &lt;= <span class="built_in">double</span>(<span class="built_in">max</span>(tr[tr[p].ls].s, tr[tr[p].rs].s)))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">double</span>(tr[p].sd) &lt;= alpha * tr[p].s)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="comment">//can rebuild</span></span><br></pre></td></tr></table></figure>

<p>一句话版：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canrbu</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tr[k].wn &amp;&amp; (alpha * tr[k].s &lt;= ( <span class="type">double</span> )<span class="built_in">max</span>(tr[tr[k].ls].s, tr[tr[k].rs].s) || ( <span class="type">double</span> )tr[k].sd &lt;= alpha * tr[k].s);</span><br><span class="line">&#125;<span class="comment">//can rebuild</span></span><br></pre></td></tr></table></figure>

<p>然后就是重构的具体操作：</p>
<p>首先我们将需要重构的子树经中序遍历展开之后存入数组中，然后将新得到的数组二分建树。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbuunf</span><span class="params">(<span class="type">int</span> &amp;ldc, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">rbuunf</span>(ldc, tr[p].ls);</span><br><span class="line">    <span class="keyword">if</span>(tr[p].wn)ldr[++ldc] = p;</span><br><span class="line">    <span class="built_in">rbuunf</span>(ldc, tr[p].rs);</span><br><span class="line">&#125;<span class="comment">//rebuild-unfold</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rbubld</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    tr[ldr[mid]].ls = <span class="built_in">rbubld</span>(l, mid);</span><br><span class="line">    tr[ldr[mid]].rs = <span class="built_in">rbubld</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">calc</span>(ldr[mid]);</span><br><span class="line">    <span class="keyword">return</span> ldr[mid];</span><br><span class="line">&#125;<span class="comment">//rebuild-build</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbuild</span><span class="params">(<span class="type">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ldc = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rbuunf</span>(ldc, p);</span><br><span class="line">    p = <span class="built_in">rbubld</span>(<span class="number">1</span>, ldc);</span><br><span class="line">&#125;<span class="comment">//rebuild</span></span><br></pre></td></tr></table></figure>

<h2 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h2><p>插入时，我们需要找到对应节点并 <code>tr[p].wn++</code>。如果没有节点就新建一个，回溯时需要判断是否能够重构，如果可以的话就重构。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">    &#123;</span><br><span class="line">        p = ++cnt;</span><br><span class="line">        <span class="keyword">if</span>(!rt)rt = <span class="number">1</span>;</span><br><span class="line">        tr[p].w = k;</span><br><span class="line">        tr[p].ls = tr[p].rs = <span class="number">0</span>;</span><br><span class="line">        tr[p].wn = tr[p].s = tr[p].sz = tr[p].sd = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[p].w == k)tr[p].wn++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].w &lt; k)<span class="built_in">insert</span>(tr[p].rs, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">insert</span>(tr[p].ls, k);</span><br><span class="line">        <span class="built_in">calc</span>(p);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">canrbu</span>(p))<span class="built_in">rbuild</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><p>替罪羊树使用惰性删除，找到对应节点之后只需要 <code>tr[p].wn--</code> 即可。当然，回溯时候遇到可以重构的节点时要重构。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">loschn</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].w == k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[p].wn)tr[p].wn--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[p].w &lt; k)<span class="built_in">loschn</span>(tr[p].rs, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">loschn</span>(tr[p].ls, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">calc</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">canrbu</span>(p))<span class="built_in">rbuild</span>(p);</span><br><span class="line">&#125;<span class="comment">//löschen，delete是关键字就不用了</span></span><br></pre></td></tr></table></figure>

<h1 id="查询函数"><a href="#查询函数" class="headerlink" title="查询函数"></a>查询函数</h1><p>然后就是一些其他的函数，都是在二分查找树上进行查找操作的。</p>
<h2 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound"></a><code>upper_bound</code></h2><p>与原来upper_bound的用途一样，返回第一个大于其权值的位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">uprbnd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].w == k &amp;&amp; tr[p].wn)</span><br><span class="line">        <span class="keyword">return</span> tr[tr[p].ls].sz + tr[p].wn + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].w &gt; k)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">uprbnd</span>(tr[p].ls, k);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> tr[tr[p].ls].sz + tr[p].wn + <span class="built_in">uprbnd</span>(tr[p].rs, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个其反义函数，相当于是对当前序列反转之后的结果进行upper_bound，返回的是第一个小于其权值的位置。</p>
<p>查询某一个数字的排名的时候可以使用 <code>uprgtr(rt,k)+1</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">uprgtr</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].w == k &amp;&amp; tr[p].wn)</span><br><span class="line">        <span class="keyword">return</span> tr[tr[p].ls].sz;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].w &lt; k)</span><br><span class="line">        <span class="keyword">return</span> tr[tr[p].ls].sz + tr[p].wn + <span class="built_in">uprgtr</span>(tr[p].rs, k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">uprgtr</span>(tr[p].ls, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="getk"><a href="#getk" class="headerlink" title="getk"></a><code>getk</code></h2><p>getk函数返回的是当前排名上的数字。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getk</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[tr[p].ls].sz &lt; k &amp;&amp; k &lt;= tr[tr[p].ls].sz + tr[p].wn)</span><br><span class="line">        <span class="keyword">return</span> tr[p].w;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[tr[p].ls].sz + tr[p].wn &lt; k)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getk</span>(tr[p].rs, k - tr[tr[p].ls].sz - tr[p].wn);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getk</span>(tr[p].ls, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="前驱与后继"><a href="#前驱与后继" class="headerlink" title="前驱与后继"></a>前驱与后继</h2><p>将上面两个函数结合起来就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">precsr</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getk</span>(p, <span class="built_in">uprgtr</span>(p, k));</span><br><span class="line">&#125;<span class="comment">//precursor</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">succsr</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getk</span>(p, <span class="built_in">uprbnd</span>(p, k));</span><br><span class="line">&#125;<span class="comment">//successor</span></span><br></pre></td></tr></table></figure>

<details class="note success"><summary><p>封装好的结构体</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> alpha = <span class="number">0.75</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Scapegoat</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ls[N], rs[N];</span><br><span class="line">    <span class="type">int</span> w[N], wn[N];</span><br><span class="line">    <span class="type">int</span> s[N], sz[N], sd[N];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt, rt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        s[p] = s[ls[p]] + s[rs[p]] + <span class="number">1</span>;</span><br><span class="line">        sz[p] = sz[ls[p]] + sz[rs[p]] + wn[p];</span><br><span class="line">        sd[p] = sd[ls[p]] + sd[rs[p]] + (wn[p] != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canrbu</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> wn[p] &amp;&amp; (alpha * s[p] &lt;= <span class="built_in">double</span>(<span class="built_in">max</span>(s[ls[p]], s[rs[p]])) || <span class="built_in">double</span>(sd[p] &lt;= alpha * s[p]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ldr[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rbuunf</span><span class="params">(<span class="type">int</span> &amp;ldc, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p)<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">rbuunf</span>(ldc, ls[p]);</span><br><span class="line">        <span class="keyword">if</span>(wn[p])ldr[ldc++] = p;</span><br><span class="line">        <span class="built_in">rbuunf</span>(ldc, rs[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rbubld</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        ls[ldr[mid]] = <span class="built_in">rbubld</span>(l, mid);</span><br><span class="line">        rs[ldr[mid]] = <span class="built_in">rbubld</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">calc</span>(ldr[mid]);</span><br><span class="line">        <span class="keyword">return</span> ldr[mid];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rbuild</span><span class="params">(<span class="type">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ldc = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rbuunf</span>(ldc, p);</span><br><span class="line">        p = <span class="built_in">rbubld</span>(<span class="number">0</span>, ldc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p)</span><br><span class="line">        &#123;</span><br><span class="line">            p = ++cnt;</span><br><span class="line">            <span class="keyword">if</span>(!rt)rt = <span class="number">1</span>;</span><br><span class="line">            w[p] = k;</span><br><span class="line">            ls[p] = rs[p] = <span class="number">0</span>;</span><br><span class="line">            wn[p] = s[p] = sz[p] = sd[p] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(w[p] == k)wn[p]++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(w[p] &lt; k)<span class="built_in">insert</span>(rs[p], k);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">insert</span>(ls[p], k);</span><br><span class="line">            <span class="built_in">calc</span>(p);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">canrbu</span>(p))<span class="built_in">rbuild</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loschn</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(w[p] == k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(wn[p])wn[p]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(w[p] &lt; k)<span class="built_in">loschn</span>(rs[p], k);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">loschn</span>(ls[p], k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">calc</span>(p);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">canrbu</span>(p))<span class="built_in">rbuild</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uprbnd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(w[p] == k &amp;&amp; wn[p])</span><br><span class="line">            <span class="keyword">return</span> sz[ls[p]] + wn[p] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(w[p] &gt; k)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">uprbnd</span>(ls[p], k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> sz[ls[p]] + wn[p] + <span class="built_in">uprbnd</span>(rs[p], k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uprgtr</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(w[p] == k &amp;&amp; wn[p])</span><br><span class="line">            <span class="keyword">return</span> sz[ls[p]];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(w[p] &lt; k)</span><br><span class="line">            <span class="keyword">return</span> sz[ls[p]] + wn[p] + <span class="built_in">uprgtr</span>(rs[p], k);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">uprgtr</span>(ls[p], k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getk</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sz[ls[p]] &lt; k &amp;&amp; k &lt;= sz[ls[p]] + wn[p])</span><br><span class="line">            <span class="keyword">return</span> w[p];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sz[ls[p]] + wn[p] &lt; k)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getk</span>(rs[p], k - sz[ls[p]] - wn[p]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getk</span>(ls[p], k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">precrs</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getk</span>(p, <span class="built_in">uprgtr</span>(p, k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">succsr</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getk</span>(p, <span class="built_in">uprbnd</span>(p, k));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tr;</span><br></pre></td></tr></table></figure>
</details>

<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>洛谷上的<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzNjk=">板子<i class="fa fa-external-link-alt"></i></span>：</p>
<p>示例代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3369/p3369_scapegoat.cpp"><code>Luogu P3369-scapegoat</code></a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>Splay</title>
    <url>/OI/splay/</url>
    <content><![CDATA[<p>Splay.</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>
（2022年5月24日重构）

<p>Splay是一种很好地维护一棵二叉搜索树的方法。<br>如果不知道什么是二叉搜索树，请看<span class="exturl" data-url="aHR0cHM6Ly9vaS13aWtpLm9yZy9kcy9ic3Qv">此页面<i class="fa fa-external-link-alt"></i></span>。</p>
<h1 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h1><p>Splay的基本思想是，通过一系列的旋转操作，维持整棵二叉搜索树的平衡。</p>
<p>首先，我们假设我们需要维护的结构体是这个样子的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s[<span class="number">2</span>], fa;</span><br><span class="line">    <span class="type">int</span> v, w;</span><br><span class="line">    <span class="type">int</span> sz;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> _v, <span class="type">int</span> _fa)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        v = _v, fa = _fa;</span><br><span class="line">        sz = w = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tr[N];</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li><code>s[2]</code>：左右子树。</li>
<li><code>fa</code>：父亲。</li>
<li><code>v</code>：节点权值。</li>
<li><code>w</code>：节点大小。</li>
<li><code>sz</code>：节点及其子树大小。</li>
</ul>
<p>还有一些其他的东西就一一列举了，比如懒标记等等。</p>
<h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>Splay之所以能够维持其平衡，依赖的就是这样的简单旋转操作。</p>
<h3 id="左旋与右旋"><a href="#左旋与右旋" class="headerlink" title="左旋与右旋"></a>左旋与右旋</h3><p>对于这样一个图：</p>
<img src="https://s2.loli.net/2022/01/07/i8JVbaGELdNQOAx.png" alt="splay1.png" width="40%" />

<p>其中x节点有两个子树，A与B；x节点的父亲y节点还有一棵子树C；z节点是y节点的父亲。<br>我们将x节点旋转（这里x节点是其父亲y节点的左儿子，所以我们会将其右旋），结果是这个样子的：</p>
<img src="https://s2.loli.net/2022/01/07/hlkn8QXvHYgCtyr.png" alt="splay2.png" width="40%" />

<p>当然，如果我们把x旋转回去的话，那就是左旋操作了。</p>
<p>总体来看是这个样子：</p>
<img src="https://s2.loli.net/2022/05/24/WQhxLqiVDOIzrmc.png" alt="splay3.png" width="80%" />

<p>在进行旋转操作时，我们需要保持其中序遍历序列不变。</p>
<p>在刚刚的右旋操作中，我们来分析一下我们需要改变的边：</p>
<img src="https://s2.loli.net/2022/03/23/uqVYj9LzJvDKZMn.png" alt="splay4.png" width="40%" />

<p>就是这三条标红的边。</p>
<p>那么对于这三条边，我们分别进行重构操作。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> k = tr[y].s[<span class="number">1</span>] == x;<span class="comment">//x是y的哪个儿子</span></span><br><span class="line">tr[z].s[tr[z].s[<span class="number">1</span>] == y] = x, tr[x].fa = z;<span class="comment">//重构z-x边</span></span><br><span class="line">tr[y].s[k] = tr[x].s[k ^ <span class="number">1</span>], tr[tr[x].s[k ^ <span class="number">1</span>]].fa = y;<span class="comment">//重构y-B边</span></span><br><span class="line">tr[x].s[k ^ <span class="number">1</span>] = y, tr[y].fa = x;<span class="comment">//重构x-y边</span></span><br></pre></td></tr></table></figure>

<p>旋转完成之后，因为我们改变了树的结构，所以我们需要重新计算x和y的大小，有时候还有需要维护的其他信息。<br>注意这里需要先维护较低的y，再维护较高的x。</p>
<p>所以总的函数是这个样子的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].sz = tr[p].w;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].s[<span class="number">0</span>])tr[p].sz += tr[tr[p].s[<span class="number">0</span>]].sz;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].s[<span class="number">1</span>])tr[p].sz += tr[tr[p].s[<span class="number">1</span>]].sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> y = tr[x].fa, z = tr[y].fa;</span><br><span class="line">    <span class="type">int</span> k = tr[y].s[<span class="number">1</span>] == x;</span><br><span class="line">    tr[z].s[tr[z].s[<span class="number">1</span>] == y] = x, tr[x].fa = z;</span><br><span class="line">    tr[y].s[k] = tr[x].s[k ^ <span class="number">1</span>], tr[tr[x].s[k ^ <span class="number">1</span>]].fa = y;</span><br><span class="line">    tr[x].s[k ^ <span class="number">1</span>] = y, tr[y].fa = x;</span><br><span class="line">    <span class="built_in">pushup</span>(y), <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a>核心函数</h2><p>我们在向splay中插入一个数之后，会强制将其旋转到根。<br>而在刚才的示例中，我们看到了，我们将x右旋之后，x就向上走了一点。<br>而经过不断的旋转，我们就可以让x节点走到根。</p>
<p>当然，我们也不是随便瞎转，因为旋转操作也是需要复杂度的。<br>而我们的最后目标是使之均摊之后达到尽量小的复杂度。<br>引用闫学灿的一句话：</p>
<blockquote>
<p>“如果我们瞎转的话，就达不到$O(\log n)$的复杂度了。”</p>
</blockquote>
<p>所以我们要根据x所处的位置来制定不同的旋转方案。</p>
<p>首先，我们对于x可能出现的几种情况分析一下：</p>
<ol start="0">
<li><p>x就是目标节点。<br>那么就不用转了。</p>
</li>
<li><p>x是目标节点的子节点。<br>那我们直接转一下x就可以了。</p>
</li>
</ol>
<p>对于x的父亲也不是目标节点的情况，我们也分两种情况讨论。</p>
<ol start="2">
<li><p>x的父亲也不是目标节点，且x与其父亲的所在子树类型相同。<br>可以理解为x，x的父亲和x的父亲的父亲三个节点在一条直线上。<br>这样的话，我们就先旋转x的父节点，再旋转x。</p>
</li>
<li><p>x的父亲也不是目标节点，且x与其父亲的所在子树类型不同。<br>可以理解为x，x的父亲和x的父亲的父亲三个节点的连线是一条折线。<br>这样的话，我们旋转两次x。</p>
</li>
</ol>
<p>这样不断判断，直到x到达目标节点。</p>
<p>同时我们需要注意，因为我们根节点是随着我们的不断旋转而不断变化的，所以我们需要即使更新根节点的信息。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(tr[x].fa != k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = tr[x].fa, z = tr[y].fa;</span><br><span class="line">        <span class="keyword">if</span>(z != k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((tr[y].s[<span class="number">1</span>] == x) ^ (tr[z].s[<span class="number">1</span>] == y))</span><br><span class="line">                <span class="built_in">rotate</span>(x);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">rotate</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!k) rt = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h1><p>我们假设我们需要维护的是一棵可重序列的二叉搜索树。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>Splay的插入操作是比较复杂的。<br>假设我们需要向树中插入一个元素 $k$，那么我们分下列几种情况讨论：</p>
<ul>
<li>如果树是空的，那就直接插入根节点。</li>
<li>如果当前节点的权值等于 $k$，那就增加当前节点的大小，并更新其与其父亲的信息。</li>
<li>否则就按照二叉搜索树的性质继续向下面的节点查找。</li>
</ul>
<p>最后不要忘记将节点旋转到根。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[++idx].<span class="built_in">init</span>(k, <span class="number">0</span>);</span><br><span class="line">        rt = idx;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> p = rt, fa = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[p].v == k)</span><br><span class="line">        &#123;</span><br><span class="line">            tr[p].w++;</span><br><span class="line">            <span class="built_in">pushup</span>(p), <span class="built_in">pushup</span>(fa);</span><br><span class="line">            <span class="built_in">splay</span>(p, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fa = p;</span><br><span class="line">        p = tr[p].s[tr[p].v &lt; k];</span><br><span class="line">        <span class="keyword">if</span>(!p)</span><br><span class="line">        &#123;</span><br><span class="line">            tr[++idx].<span class="built_in">init</span>(k, fa);</span><br><span class="line">            tr[fa].s[tr[fa].v &lt; k] = idx;</span><br><span class="line">            <span class="built_in">pushup</span>(fa);</span><br><span class="line">            <span class="built_in">splay</span>(idx, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>Splay不使用惰性删除，其删除操作也是比较复杂的。<br>假设我们想要删除节点 $x$。</p>
<p>首先，我们将 $x$ 旋转到根。</p>
<p>然后我们分类讨论：</p>
<ul>
<li>如果 $x$ 的大小不为1，那就减少其大小。</li>
<li>否则直接合并其两棵子树。</li>
</ul>
<p>合并两棵树的操作很简单。如果我们假设需要合并的两棵树 $x$ 和 $y$ 中，$x$ 的最大值大于 $y$ 的话，只需要将的 $x$ 的最大值旋转到根，同时将 $y$ 设置为其根节点的右子树即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">loschn</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">get_rk</span>(k);</span><br><span class="line">    <span class="keyword">if</span>(tr[rt].w &gt; <span class="number">1</span>)<span class="comment">//节点内部包含多个相同元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[rt].w--;</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!tr[rt].s[<span class="number">0</span>] &amp;&amp; !tr[rt].s[<span class="number">1</span>])<span class="comment">//全树上下只剩这一个点了！</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[rt].<span class="built_in">clear</span>();</span><br><span class="line">        rt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!tr[rt].s[<span class="number">0</span>])<span class="comment">//没有左子树，这个点是整棵树最小的点了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p = rt;</span><br><span class="line">        rt = tr[rt].s[<span class="number">1</span>];</span><br><span class="line">        tr[rt].fa = <span class="number">0</span>;</span><br><span class="line">        tr[p].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!tr[rt].s[<span class="number">1</span>])<span class="comment">//没有右子树，这个点是整棵树最大的点了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p = rt;</span><br><span class="line">        rt = tr[rt].s[<span class="number">0</span>];</span><br><span class="line">        tr[rt].fa = <span class="number">0</span>;</span><br><span class="line">        tr[p].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一般情况</span></span><br><span class="line">    <span class="type">int</span> p = rt, x = <span class="built_in">precrs</span>();</span><br><span class="line">    tr[tr[p].s[<span class="number">1</span>]].fa = x;</span><br><span class="line">    tr[x].s[<span class="number">1</span>] = tr[p].s[<span class="number">1</span>];</span><br><span class="line">    tr[p].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查询k的排名"><a href="#查询k的排名" class="headerlink" title="查询k的排名"></a>查询k的排名</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_rk</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, p = rt;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &lt; tr[p].v)<span class="comment">//在左子树中</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = tr[p].s[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[p].s[<span class="number">0</span>])res += tr[tr[p].s[<span class="number">0</span>]].sz;</span><br><span class="line">            <span class="keyword">if</span>(k == tr[p].v)<span class="comment">//就是这个点了！</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">splay</span>(p, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//搜索右子树</span></span><br><span class="line">            res += tr[p].w;</span><br><span class="line">            p = tr[p].s[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查询排名为k的数"><a href="#查询排名为k的数" class="headerlink" title="查询排名为k的数"></a>查询排名为k的数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_k</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = rt;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[tr[p].s[<span class="number">0</span>]].sz &gt;= k)<span class="comment">//在左子树中</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = tr[p].s[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            k -= tr[p].w;</span><br><span class="line">            <span class="keyword">if</span>(tr[p].s[<span class="number">0</span>])k -= tr[tr[p].s[<span class="number">0</span>]].sz;</span><br><span class="line">            <span class="keyword">if</span>(k &lt;= <span class="number">0</span>)<span class="comment">//就是这个点了！</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">splay</span>(p, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> tr[p].v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//搜索右子树</span></span><br><span class="line">            p = tr[p].s[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查询k的前驱或后继"><a href="#查询k的前驱或后继" class="headerlink" title="查询k的前驱或后继"></a>查询k的前驱或后继</h2><p>前驱定义为小于这个数的最大数，后继定义为大于这个数的最小数。</p>
<p>我们的思路是，先将其插入进去，这样它就会到根节点；然后查询其左子树内的最大值或右子树内的最小值即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">precsr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = tr[rt].s[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">while</span>(tr[p].s[<span class="number">1</span>])p = tr[p].s[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">splay</span>(p, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">succsr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = tr[rt].s[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">while</span>(tr[p].s[<span class="number">0</span>])p = tr[p].s[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">splay</span>(p, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="维护可重有序序列"><a href="#维护可重有序序列" class="headerlink" title="维护可重有序序列"></a>维护可重有序序列</h2><p>洛谷<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzNjk=">板子题<i class="fa fa-external-link-alt"></i></span>，要求我们支持维护一个有序序列，并支持上面讲的六种操作。</p>
<p>示例代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3369/p3369_splay.cpp"><code>Luogu P3369-splay</code></a></p>
<h2 id="维护不可重序列，支持区间翻转"><a href="#维护不可重序列，支持区间翻转" class="headerlink" title="维护不可重序列，支持区间翻转"></a>维护不可重序列，支持区间翻转</h2><p>给个洛谷<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzOTE=">板子题<i class="fa fa-external-link-alt"></i></span>的代码:</p>
<p>它这里面要求区间翻转，那么我们在进行每一次旋转操作时，我们首先将左边界的前驱旋转至根节点，接着再把右边界的后继旋转至根节点的下面，此时右边界的后继的左子树就是我们所要翻转的区间了。<br>我们顺便增加一个<code>flag</code>标记，用来标记翻转次数。</p>
<p>示例代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3391/p3391.cpp"><code>Luogu P3391</code></a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀自动机</title>
    <url>/OI/suffix-avtomat/</url>
    <content><![CDATA[<p>后缀自动机(SAM)。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>后缀自动机，是一个能够解决许多字符串相关问题的，十分强力的数据结构。<br>不要被博客的链接迷惑了，后缀自动机是 <strong>S</strong>uffix <strong>A</strong>uto<strong>m</strong>aton 。<br>（博客标题来自俄语 Суффиксный автомат -&gt; Suffiksneyy avtomat）</p>
<p>后缀自动机可以存储下一个字符串的所有子串，并且做到线性时空复杂度。<br>准确来说，对于一个长度为 $n$ 的字符串构造后缀自动机，其中至多有 $2n-1$ 个节点与 $3n-4$ 条转移边。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>后缀自动机是一个DFA（确定性有限自动机或确定性有限状态自动机）。它接受且只接受 $s$ 的所有子串。</p>
<p>展开来说的话，可以概括成这么几点：</p>
<ol>
<li>后缀自动机是一个有向无环图。其中的节点叫做<strong>状态</strong>，边叫做<strong>转移</strong>。</li>
<li>图中包含一个初始节点 $t_0$ ，任何节点都可以由之经过一系列的转移到达。</li>
<li>每一个转移都标有一个字母，且从某一个节点出发的每一个转移都是不同的。</li>
<li>自动机存在多个终止状态。如果我们从初始状态 $t_0$ 出发，最终转移到了一个终止状态，则路径上的所有转移连接起来一定是字符串 $s$ 的一个后缀。 $s$ 的每个后缀均可用一条从 $t_0$ 到某个终止状态的路径构成。</li>
<li>在所有满足上述条件的自动机中，后缀自动机的结点数是最少的。</li>
</ol>
<h1 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h1><p>一个字符串的后缀自动机包含关于这个字符串子串的所有信息。<br>更准确地来说，对于任意从初始节点 $t_0$ 开始的路径，我们将其转移边上的字符拿下来按顺序排列，都可以得到原字符串的一个子串。<br>这里需要注意：一条路径对应一个子串，但是一个子串不一定只对应一条路径。</p>
<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><h2 id="结束位置-endpos"><a href="#结束位置-endpos" class="headerlink" title="结束位置 endpos"></a>结束位置 <code>endpos</code></h2><p>对于字符串 $s$ 的一个子串 $t$ ，我们记其在字符串 $s$ 中的所有结束位置为 $\operatorname{endpos}(t)$ 。例如对于字符串 $aabbabd$ ，我们有 $\operatorname{endpos}(ab)&#x3D;\{ 2,4 \} $。<br>两个子串 $t_1$ 与 $t_2$ 的endpos集合可能相等。这样，所有字符串 $s$<br>的非空子串都可以根据其endpos集合分为若干<strong>等价类</strong>。<br>而我们知道，后缀自动机中的每个状态对应一个或多个endpos相同的子串，即一个等价类。<br>这就很好地解释了上面所说的除了最小性之外的所有性质。</p>
<p>基于endpos，我们可以得到一系列重要结论：</p>
<blockquote>
<p><strong>引理1</strong>： 字符串 $s$ 的两个非空子串 $u$ 和 $v$ （假设 $|u| \leq |v|$ ）的endpos相同，当且仅当字符串 $u$ 在 $s$ 中的每次出现，都是以 $v$ 后缀的形式存在的。</p>
</blockquote>
<p>证明：自己画图看看。既然 $u$ 与 $v$ 的endpos已经相同了，那么说明两者拥有相同的后缀（不理解就画图！）。而当 $|u| \leq |v|$ 时， $u$ 显然为 $v$ 的一个后缀。</p>
<blockquote>
<p><strong>引理2</strong>： 考虑两个非空子串 $u$ 与 $v$ （仍然假设 $|u| \leq |v|$ ）。两者的endpos满足这样的一个关系：<br>$$<br>\begin{cases}<br>\operatorname{endpos}(v) \subseteq \operatorname{endpos}(u) &amp; \text{if } u \text{ is a suffix of } v\\<br>\operatorname{endpos}(v) \cap \operatorname{endpos}(u) &#x3D; \varnothing &amp; \text{otherwise}<br>\end{cases}<br>$$</p>
</blockquote>
<p>证明：如果 $\operatorname{endpos}(u) \cap \operatorname{endpos}(v) \neq \varnothing$ ，那么结合我们刚刚证明完的引理1，我们可以知道 $u$ 是 $v$ 的一个后缀。既然 $u$ 是 $v$ 的一个后缀了，那么对于所有 $v$ 出现的地方， $u$ 也会出现，即 $\operatorname{endpos}(u) \subseteq \operatorname{endpos}(v)$ 。而如果 $u$ 的长度小于 $v$ 且 $u$ 还不是 $v$ 的后缀，那么 $v$ 出现的地方 $u$ 一定不会出现，即 $\operatorname{endpos}(u) \cap \operatorname{endpos}(v) &#x3D; \varnothing$ 。</p>
<blockquote>
<p><strong>引理3</strong>: 对于任意一个endpos等价类（或者一个状态），其包含的所有子串都是最长子串的连续后缀。</p>
</blockquote>
<p>证明：我们考虑等价类中两个子串：最长的，记为 $u$ ；最短的，记为 $v$ 。如果 $u&#x3D;v$ 那么显然不用证明。如果不是，那么对于长度在区间 $[ |u| , |v| ]$ 内的子串。根据引理1，在这个等价类中，必定存在子串有 $v$ 为后缀且同时为 $u$ 的后缀。</p>
<h2 id="后缀链接-link"><a href="#后缀链接-link" class="headerlink" title="后缀链接 link"></a>后缀链接 <code>link</code></h2><p>根据引理3，我们可以知道对于任意状态，其中包含的字串都是其中最长子串的一段连续后缀。这段连续后缀不一定可以覆盖 $[ 1,|\text{最长子串}| ]$ 这一整个区间，但一定是连续的。<br>我们可以将其看做是不断将最长子串的首个字符删去得到子串的一个过程。</p>
<p>而当我们不断删去，直到删去最短子串的首个字符的时候，我们会发现我们已经离开了这个状态。<br>我们可以根据这样一个走向创建一系列的新边。<br>这些新边就被称为link边，也叫做后缀链接。<br>有些地方也叫fa&#x2F;father边。 </p>
<blockquote>
<p><strong>引理4</strong>： 所有后缀链接构成一棵根节点为 $t_0$ 的树。</p>
</blockquote>
<p>证明：根据后缀链接的定义及引理3，我们可以看出，当前状态的后缀链接到达的是严格更短的字符串。而沿着后缀链接走，最后总能到达代表着空字符串的 $t_0$ 。</p>
<p>我们将后缀链接与endpos关联一下。<br>根据引理2，我们可以得出，两个endpos等价类不是互相包含，就是互不相交。根据这个包含关系，我们可以列出一棵endpos等价类的树。<br>对应在后缀自动机上就是对状态建树。</p>
<blockquote>
<p><strong>引理5</strong>： 通过 $\operatorname{endpos}$ 集合构造的树（每个子节点的子集都包含在父节点的子集中）与通过后缀链接构造的树相同。</p>
</blockquote>
<p>证明：是树的证明上面有了，我们看一下对于两者相同的证明。<br>考虑任意非 $t_0$ 的状态 $u$ 及其后缀链接 $\operatorname{link}(u)$ 。根据引理2和后缀链接的定义，我们可以知道 $\operatorname{endpos}(u) \varsubsetneqq \operatorname{endpos}(\operatorname{link}(u))$ 。这样，我们在建树的时候，就会在 $u$ 与 $\operatorname{link}(u)$ 之间连一条边。</p>
<h1 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h1><p>下面是对字符串 $aabbabcd$ 构建后缀自动机得到的结果。<br>其中，蓝色(#1453AD)的边代表的是转移，绿色(#14AD53)的边代表的是后缀链接。<br>蓝色(#1453AD)的点代表状态，紫色(#AD1453)的点代表终止状态。</p>
<p><img src="/pics/SAM.svg" alt="SAM"></p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>构建后缀自动机的算法是个<strong>在线</strong>算法。我们逐个加入字符串中的每个字符，并在每一步中相应地维护刚刚得到的后缀自动机。<br>为了保证线性的空间复杂度，我们只保存<code>len</code>与<code>link</code>的值。终止状态的值可以在构建完自动机之后求出。</p>
<p>在最开始，整个后缀自动机只会包含一个节点： $t_0$ ，编号为0。我们指定<code>len[0] = 0</code>，<code>link[0] = -1</code>。这里的$-1$表示的是一个虚拟的状态。<br>然后我们就可以向后缀自动机内添加字符了。</p>
<p>我们向后缀自动机内添加一个字符 $c$ 的算法流程如下：</p>
<p>我们令<code>last</code>为先前对应整个字符串的状态（一开始我们设<code>last = 0</code>）。</p>
<p>创建一个新的状态<code>cur</code>，并使<code>len[cur] = len[last] + 1</code>。</p>
<p>从状态<code>last</code>开始，不断遍历后缀链接。<br>如果还没有到字符 $c$ 的转移，我们就添加一个指向<code>cur</code>的转移。<br>如果在某个点已经存在到字符 $c$ 的转移，我们就停下来，并将这个状态记为<code>p</code>。<br>如果没有找到这样的状态<code>p</code>，我们最终会到达虚拟状态$-1$，这时我们使<code>link[cur] = 0</code>并退出。</p>
<p>如果我们找到了一个状态<code>p</code>，其可以通过字符 $c$ 转移，我们将这样转移到的状态标记为<code>q</code>。<br>现在我们考虑我们找到的<code>q</code>是否满足<code>len[p] + 1 = len[q]</code>这个条件。</p>
<p>如果满足，那么我们就只需要使<code>link[cur] = q</code>并退出。</p>
<p>如果不满足，那么情况就会变得复杂。<br>我们需要复制一个状态<code>q</code>，标记为<code>nq</code>。<code>nq</code>将会获得<code>q</code>除了<code>len</code>以外的所有信息。我们将<code>len[nq]</code>赋值为<code>len[p] + 1</code>。之后，我们使<code>link[cur] = link[q] = nq</code>。<br>之后，使用后缀链接从<code>p</code>往回走，并把沿途所有指向<code>q</code>的转移重定向至<code>nq</code>。</p>
<p>最后，我们将<code>last</code>的值更新为<code>cur</code>。</p>
<h3 id="寻找终止状态"><a href="#寻找终止状态" class="headerlink" title="寻找终止状态"></a>寻找终止状态</h3><p>如果我们还想要知道哪些状态是终止状态而那些不是，我们可以在构建完 $s$ 对应的后缀自动机之后再进行寻找。</p>
<p>我们从刚才最后一步得到的<code>last</code>处开始遍历后缀链接，直到最终到达初始节点。<br>我们将沿途的所有状态都标记为终止状态，因为他们存储着原字符串 $s$ 的至少一个后缀。</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>这里就不证明了，可以看<span class="exturl" data-url="aHR0cHM6Ly9vaS13aWtpLm9yZy9zdHJpbmcvc2FtLyNfNg==">OI-Wiki<i class="fa fa-external-link-alt"></i></span>上的证明。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM4MDQ=">洛谷板子题<i class="fa fa-external-link-alt"></i></span>代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3804/p3804.cpp"><code>Luogu P3804</code></a></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="检查字符串是否出现"><a href="#检查字符串是否出现" class="headerlink" title="检查字符串是否出现"></a>检查字符串是否出现</h2><blockquote>
<p>给定一个字符串 $S$ 和多个模式串 $P$ ，我们需要检查模式串 $P$ 是否作为 $S$ 的一个子串出现过。</p>
</blockquote>
<p>我们首先给字符串 $S$ 构建后缀自动机。构建完了之后，我们从初始节点 $t_0$ 开始，不断向遍历trie树一样遍历后缀自动机。由于字符串 $S$ 内的每个字串都是其某个后缀的前缀，所以我们仅从初始节点开始遍历即可。<br>如果遍历完整个自动机都没有完全匹配，那么就说明模式串没有在原字符串里面出现过，反之亦然。</p>
<p>如果我们在这样历的同时记录下最大匹配长度，那么还可以得到模式串在字符串内匹配的最大前缀长度。</p>
<h2 id="求不同子串个数"><a href="#求不同子串个数" class="headerlink" title="求不同子串个数"></a>求不同子串个数</h2><blockquote>
<p>给定一个字符串 $S$ ，计算其不同子串的个数。</p>
</blockquote>
<p>对其构造后缀自动机。<br>字符串 $S$ 中的每一个子串都相当于是自动机中的一些路径。因此不同字串的个数就等于自动几种以 $t_0$ 为起点的不同路径的条数。<br>考虑到后缀自动机是一个有向无环图，不同路径的条数可以通过动态规划来计算。<br>OI-wiki上给的方法是这样的：</p>
<blockquote>
<p>令 $d_v$ 为从状态 $v$ 开始的路径数量（包括长度为零的路径），则我们有如下递推方程：<br>$$<br>d_v &#x3D; 1 + \sum_{w:(v,w,c)\in DAWG} d_w<br>$$<br>即， $d_v$ 可以表示为所有 $v$ 的转移的末端的和。<br>所以不同字串的个数为 $d_{t_0}-1$ （因为需要去掉空字串）</p>
</blockquote>
<p>我个人更喜欢另一种方法：<br>利用后缀自动机的树形结构，每个节点对应的子串数量就是<code>len[i] - len[link[i]]</code>，对自动机所有节点求和即可。<br>这个在洛谷给的板子题内有应用。</p>
<p>其他的应用可以见<span class="exturl" data-url="aHR0cHM6Ly9vaS13aWtpLm9yZy9zdHJpbmcvc2FtLyNfMTM=">OIwiki<i class="fa fa-external-link-alt"></i></span>。</p>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>字符串</tag>
        <tag>自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/OI/tree-array/</url>
    <content><![CDATA[<p>简介： 树状数组</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><p>一种神奇的数据结构。</p>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>当我们想要对一个数组进行单点加时，我们可以选择使用普通数组，时间复杂度是 $O(1)$；<br>当我们想要对一个数组进行区间求和时，我们可以选择使用前缀和数组，时间复杂度也是 $O(1)$；</p>
<p>但是，前缀和数组在进行单点加时，时间复杂度是 $O(n)$ ；<br>而普通数组在进行区间求和时，时间复杂度也是 $O(n)$ ；</p>
<p>我们能不能设计出一个数据结构，让我们在进行这两个操作时牺牲某一个操作的时间复杂度，而减少了另一个操作的时间复杂度呢？</p>
<p>于是，树状数组就应运而生。</p>
<h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h2><p>树状数组的存储原理是这个样子的：</p>
<p>我们称原数组为 $a[i]$ ，我们正常所输入的数据就存储在这里。</p>
<p>在原数组 $a[i]$ 的基础上，我们创建一个新的数组 $c[i]$ 。<br>数组 $c[i]$ 是以这个规则存储信息的：</p>
<p>我们先列出所有的数组下标：</p>
<p><img src="https://i.loli.net/2021/10/14/w8Q9VlYpkiRZOuK.png" alt="树状数组1.png"></p>
<p>接下来我们开始考虑数字的 $lowbit$ 。</p>
<p>所有奇数的 $lowbit$ 都是1。<br>我们在第一层标记上 $lowbit$ 为1的所有数字：</p>
<p><img src="https://i.loli.net/2021/10/14/etBbyiMgNhHA2zQ.png" alt="树状数组2.png"></p>
<p>接下来，我们依次标上数字的 $lowbit$ ：</p>
<p><img src="https://i.loli.net/2021/10/14/7J41bdLejGiP9wF.png" alt="树状数组3.png"></p>
<p><img src="https://i.loli.net/2021/10/14/vCznWK9uGPhIwO8.png" alt="树状数组4.png"></p>
<p><img src="https://i.loli.net/2021/10/14/j1TmJIP9xBknas5.png" alt="树状数组5.png"></p>
<p>最后，我们再进行一下延长，每一个块向左延长至长度为 $2^{lowbit(i)}$ 。</p>
<p><img src="https://i.loli.net/2021/10/14/PAUqE1a8D6CGh3d.png" alt="树状数组6.png"></p>
<p>我们对块进行一下标号：</p>
<p><img src="https://i.loli.net/2021/10/14/r8mtGfDANz2XWHv.png" alt="树状数组7.png"></p>
<p>这些绿色的块里面存储的是其下方所有数字的和。</p>
<p>当然，我们进行值的更新的时候，不可能一个一个加起来再更新，这样复杂度又回到了原先的样子。</p>
<p>我们更新时遵循的是这样一个路线：</p>
<p><img src="https://i.loli.net/2021/10/14/JWnIe5SftkZjpL7.png" alt="树状数组8.png"></p>
<p>因为每一个数有 $\log (n)$ 位，所以最终两个操作的时间复杂度都是 $O(\log n)$ 。</p>
<h2 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h2><div class="tabs" id="model"><ul class="nav-tabs"><li class="tab active"><a href="#model-1">Luogu板子题1</a></li><li class="tab"><a href="#model-2">Luogu板子题2</a></li></ul><div class="tab-content"><div class="tab-pane active" id="model-1"><p>Luogu P3374 【模板】 树状数组1：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzNzQ=">https://www.luogu.com.cn/problem/P3374<i class="fa fa-external-link-alt"></i></span></p>
<p>示例代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3374/p3374.cpp"><code>Luogu P3374</code></a></p></div><div class="tab-pane" id="model-2"><p>Luogu P3368 【模板】 树状数组2：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzNjg=">https://www.luogu.com.cn/problem/P3368<i class="fa fa-external-link-alt"></i></span></p>
<div class="note info"><p>思路：维护差分序列，而不是原序列。</p>
</div>

<p>示例代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3368/p3368.cpp"><code>Luogu P3368</code></a></p></div></div></div>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie 与 AC自动机</title>
    <url>/OI/trie-and-AK-avtomat/</url>
    <content><![CDATA[<p>Trie树（字典树）与AC自动机。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h1><p>Trie树，又称字典树，是一种数据结构。</p>
<p>Trie树可以存储大量不同的字符串，同时支持对其以 $O(|S|)$ 的复杂度进行查询。</p>
<p>首先我们可以放一张图上来：</p>
<p><img src="https://s2.loli.net/2022/04/06/DjtOJRCaSzxwZAB.png" alt="trie1.png"></p>
<p>这就是我们向Trie中顺序插入了aa,aba,ba,bbc,bca,caba,cba,cc八个字符串之后的结果。</p>
<p>我们可以发现，Trie使用边来代表字母，而用点来表示字符串。<br>某一个点表示的字符串就是从根节点到该节点的路径上的字母顺序排列组合而成的字符串。<br>比如说17号节点就代表着cba这一个字符串。</p>
<p><img src="https://s2.loli.net/2022/04/06/udZE5v41asjfBYh.png" alt="trie2.png"></p>
<p>每一个点虽说都代表着一个字符串，但是这个字符串不一定被插入过。我们将实际上有的字符串进行了标红。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>我们将每一个节点存储到一个结构体里面：</p>
<div class="tabs" id="struct"><ul class="nav-tabs"><li class="tab active"><a href="#struct-1">数组</a></li><li class="tab"><a href="#struct-2">指针</a></li></ul><div class="tab-content"><div class="tab-pane active" id="struct-1"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">trie</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">&#125;tr[N];</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="struct-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">trie</span></span><br><span class="line">&#123;</span><br><span class="line">    trie *s[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">&#125;tr[N];</span><br></pre></td></tr></table></figure></div></div></div>

<p>这里 <code>s</code> 数组的大小是根据字符集的大小来定的，一般情况下是小写字母集，所以这里填的是26。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>具体思想就是，如果当前节点的下一位所对应的儿子非空就跳到对应的儿子，是空的那就新建一个儿子。</p>
<div class="tabs" id="insert"><ul class="nav-tabs"><li class="tab active"><a href="#insert-1">数组</a></li><li class="tab"><a href="#insert-2">指针</a></li></ul><div class="tab-content"><div class="tab-pane active" id="insert-1"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[u].s[s[i] - <span class="string">&#x27;a&#x27;</span>] != <span class="number">0</span>)u = tr[u].s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tr[u].s[s[i] - <span class="string">&#x27;a&#x27;</span>] = ++idx;</span><br><span class="line">            u = idx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tr[u].cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="insert-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *u = &amp;tr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>] != <span class="number">0</span>)u = u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>] = &amp;tr[++idx];</span><br><span class="line">            u = u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    u-&gt;cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除这个操作使用的范围不是很广。具体思想就是将对应我们想要删除的字符串的点的<code>cnt</code>值减去1即可。</p>
<div class="tabs" id="loeschen"><ul class="nav-tabs"><li class="tab active"><a href="#loeschen-1">数组</a></li><li class="tab"><a href="#loeschen-2">指针</a></li></ul><div class="tab-content"><div class="tab-pane active" id="loeschen-1"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">loeschen</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">        u = tr[u].s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    tr[u].cnt--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="loeschen-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">loeschen</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *u = &amp;tr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">        u = u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    u-&gt;cnt--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>查询操作的思想就是，不断从根节点沿着字符串跳，直到调到空节点或者跳完整个字符串为止。</p>
<div class="tabs" id="chq"><ul class="nav-tabs"><li class="tab active"><a href="#chq-1">数组</a></li><li class="tab"><a href="#chq-2">指针</a></li></ul><div class="tab-content"><div class="tab-pane active" id="chq-1"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">chq</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[u].s[s[i] - <span class="string">&#x27;a&#x27;</span>] != <span class="number">0</span>)u = tr[u].s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tr[u].cnt &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="chq-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">chq</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *u = &amp;tr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>] != <span class="number">0</span>)u = u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u-&gt;cnt &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="全部加起来"><a href="#全部加起来" class="headerlink" title="全部加起来"></a>全部加起来</h3><div class="tabs" id="all"><ul class="nav-tabs"><li class="tab active"><a href="#all-1">数组</a></li><li class="tab"><a href="#all-2">指针</a></li></ul><div class="tab-content"><div class="tab-pane active" id="all-1"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">trie</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[u].s[s[i] - <span class="string">&#x27;a&#x27;</span>] != <span class="number">0</span>)u = tr[u].s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tr[u].s[s[i] - <span class="string">&#x27;a&#x27;</span>] = ++idx;</span><br><span class="line">            u = idx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tr[u].cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loeschen</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">        u = tr[u].s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    tr[u].cnt--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">chq</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[u].s[s[i] - <span class="string">&#x27;a&#x27;</span>] != <span class="number">0</span>)u = tr[u].s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tr[u].cnt &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="all-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">trie</span></span><br><span class="line">&#123;</span><br><span class="line">    trie *s[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *u = &amp;tr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>] != <span class="number">0</span>)u = u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>] = &amp;tr[++idx];</span><br><span class="line">            u = u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    u-&gt;cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loeschen</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *u = &amp;tr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">        u = u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    u-&gt;cnt--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">chq</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *u = &amp;tr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>] != <span class="number">0</span>)u = u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u-&gt;cnt &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>Luogu P2580：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI1ODA=">https://www.luogu.com.cn/problem/P2580<i class="fa fa-external-link-alt"></i></span></p>
<p>参考代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p2000-p2999/p2580/p2580.cpp"><code>Luogu P2580</code></a></p>
<h2 id="01-Trie"><a href="#01-Trie" class="headerlink" title="01-Trie"></a>01-Trie</h2><p>01-Trie是Trie的一种变体。其字符集不是一般见到的Trie的小写字符集，而是 $\lbrace 0,1 \rbrace$。</p>
<p>由于01-Trie的字符集仅限于0和1，所以它被人们用来处理一些与位运算有关的东西，比如说异或和或者集合内数字两两异或的极值什么的。</p>
<h3 id="异或极值"><a href="#异或极值" class="headerlink" title="异或极值"></a>异或极值</h3><p>我们假定我们需要维护这样一个操作：<br>给出一个集合 $A$，再给出一个数 $k$，我们需要在集合内找到一个数 $a_i$，使之与 $k$ 的异或值最大（或最小）。</p>
<p>因为异或操作就是将两个数按照二进制逐位进行比对，相同为0，不同为1，所以我们就可以将上文提到的那个集合 $A$ 内的所有数根据二进制位分解之后再插入Trie中。</p>
<p>然后我们就像查找字符串一样，将 $k$ 进行二进制分解后得到的01串放进去匹配。<br>如果我们需要的是异或最小值的话，就按照正常查找字符串的方式跳。<br>如果我们需要的是异或最大值的话，就让每一次跳儿子的时候跳到与当前位置不同的儿子。</p>
<p>我们还需要注意一点，就是我们需要保证这棵Trie的深度与数据范围的最大二进制位数一致。</p>
<p>由于我们是从高位到低位建的，而高位远比低位重要，所以我们就可以大胆贪心，能跳就跳，不能跳就跳到相反的那个儿子上。而且我们保证了Trie的高度是一定的，这就保证了我们一定可以跳到底。</p>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQ1NTE=">Luogu P4551 最长异或路径<i class="fa fa-external-link-alt"></i></span></p>
<p>参考代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p4000-p4999/p4551/p4551.cpp"><code>Luogu P4551</code></a></p>
<h2 id="可持久化Trie"><a href="#可持久化Trie" class="headerlink" title="可持久化Trie"></a>可持久化Trie</h2><p>有的时候题目要求我们能够随时访问某个历史版本，或甚至回溯到某个历史版本并对其进行修改。</p>
<p>暴力的做法是每一次都开一个新的Trie。</p>
<p>这时候，我们就可以将Trie持久化以完成这些题目的要求。</p>
<p>之前我们每一次插入的时候都是从根节点开始的，添加的字符串也是一条从根节点开始的路径，所以我们每一次插入只需要增加新的一整条路径，并把这条路径与上一个版本中未被更新的部分连接上即可。</p>
<h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h4><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjU4Lw==">AcWing 256. 最大异或和<i class="fa fa-external-link-alt"></i></span></p>
<p>参考代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/AcWing/256/ac256.cpp"><code>AcWing 256</code></a></p>
<h1 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h1><p>这个AC自动机啊，他是 Aho-Corasick Automaton，不是什么Automation。</p>
<p>（博客的标题来自于俄语 Ахо-Корасик автомат -&gt; Aho-Korasik avtomat）</p>
<p>AC自动机就像是Trie和KMP的结合。<br>AC自动机基于的是Trie，同时其匹配字符串时的行为与KMP有异曲同工之妙。</p>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><h3 id="改造-Trie"><a href="#改造-Trie" class="headerlink" title="改造 Trie"></a>改造 Trie</h3><p>这是一个简单的Trie结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">trie</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">&#125;tr[N];</span><br></pre></td></tr></table></figure>

<p>对于KMP算法，我们是根据前缀函数来对字符串匹配进行优化的。<br>而对于Trie呢？</p>
<h3 id="fail指针"><a href="#fail指针" class="headerlink" title="fail指针"></a>fail指针</h3><p>我们考虑使用前缀函数的原因：</p>
<blockquote>
<p>我们需要找到一个前缀，在保证其与某个后缀相等的前提下，使得当前匹配的进度最大地保留下来。</p>
</blockquote>
<p>把同样的思想挪到Trie树上，我们需要找的就是：</p>
<blockquote>
<p>我们需要找到一个节点，其代表的字符串是当前节点代表的字符串的最长后缀。</p>
</blockquote>
<p>于是，我们就可以根据这样的情况来构建fail指针。</p>
<p>举个例子：</p>
<p>如下图，是依次向Trie树中添加he,his,him,her,hers,they,them,their,theirs,she的结果：</p>
<p><img src="https://s2.loli.net/2022/04/07/2QdAr9Jchl4tunG.png" alt="AC1-1.png"></p>
<p>然后我们开始依次构建fail指针。</p>
<p>我们利用BFS来帮助我们构建fail指针。</p>
<p>考虑一个已经构建了fail指针的节点 $u$，其对应字符 $c$ 的儿子 $s[u][c]$ 的fail指针的构建遵循下列原则：</p>
<ol>
<li>如果 $s[fail[u]][c]$ 存在，则让 $s[u][c]$ 的fail指针指向 $s[fail[u]][c]$。这样相当于是在 $u$ 和 $fail[u]$ 后面加一个字符 $c$，分别对应 $s[u][c]$ 和 $s[fail[u]][c]$。</li>
<li>如果 $s[fail[u]][c]$ 不存在，那么我们就递归寻找 $s[fail[fail[u]]][c]$，并重复上面的判断过程，直到跳到根节点。</li>
<li>如果真的什么都没有了，那就让 $s[u][c]$ 的fail指针指向根节点。</li>
</ol>
<p>下图中用不同的颜色来区分不同状态的边、点：</p>
<p>#FF9955 代表在队列中，等待构建fail指针的点；<br>#FFCC00 代表正在构建fail指针的点；<br>#AAD400 代表已经构建完fail指针的点；</p>
<p>#FF0000 代表正在构建的fail指针；<br>#FFDD55 代表已经构建完成的fail指针。</p>
<p><img src="/pics/AC2.gif" alt="AC2.gif"></p>
<p>最终效果图：</p>
<p><img src="https://s2.loli.net/2022/04/08/up7tvA28h9R3E5a.png" alt="AC2-38.png"></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct trie</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int s[26];</span></span><br><span class="line"><span class="comment">    int cnt;</span></span><br><span class="line"><span class="comment">    int fail;</span></span><br><span class="line"><span class="comment">&#125;tr[N];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_fail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(tr[<span class="number">0</span>].s[i])q.<span class="built_in">push</span>(tr[u].s[i]);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[u].s[i])</span><br><span class="line">            &#123;</span><br><span class="line">                tr[tr[u].s[i]].fail = tr[tr[u].fail].s[i];</span><br><span class="line">                q.<span class="built_in">push</span>(tr[u].s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tr[u].s[i] = tr[tr[u].fail].s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码可能与我们刚才的叙述有部分出入，原因是这份代码做了些许优化。<br>事实证明这些优化虽然会修改Trie的结构，使之由树变为图，但是对我们存储的信息是有利无害的。</p>
<p>我们首先将根节点的所有儿子入队。<br>如果我们第一步将根节点入队的话，会导致根节点的所有子节点的fail指针指向自己，而不是指向根节点。</p>
<p>然后是遍历在队列中的节点。<br>对于其非空的儿子，我们照常构建fail指针。由于当前节点的fail指针已经构建完毕，且沿着fail指针形成的通往根节点的链上的所有节点都已经构建完毕了，所以我们直接指向当前节点的fail指针指向的节点的所对应的儿子。如果有这个儿子的话就指向他，如果没有的话就相当于是指向根节点。</p>
<p>然后我们将当前节点的部分空儿子指向当前节点的fail指针指向的节点的对应儿子上。<br>原因就是，反正也是失配了，与其花时间判失配跳fail指针再访问，不如直接访问我们想要它到的节点。<br>所以我们在匹配的时候一直走（结构体意义上的）树边，直到整个跑完就可以了。</p>
<p>照这样建完fail指针之后，我们会将原先的Trie树变为一张“Trie图”。</p>
<p>由于边太多太密，我就不画了。可能会补上一张CSAcademy的图。<br>（太糊了，感觉会不久后撤下，就先存本地了）</p>
<p><img src="/pics/AC3.png"></p>
<p>（这是原数据）</p>
<p><img src="/pics/AC4.png"></p>
<p>（这是图）</p>
<h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><p>匹配的思路是这个样子的：</p>
<ol>
<li>沿着Trie图的边跳，直到遍历完整个字符串为止。<br> 由于我们在之前已经将Trie树改造为了Trie图，且fail指针已经在某种意义上失去了其作为失配指针的意义，所以我们只需要跳Trie图内的边即可。</li>
<li>每走到一个节点，就沿着当前节点的fail指针累加答案。<br> 由于fail边跳到的是当前字符串在Trie内存在的最长后缀，且如果当前的模式串出现在了文本串内的话，其子串也会出现在文本串内，所以我们可以沿着fail指针一路遍历当前模式串的所有后缀。</li>
</ol>
<p>这里有一份对于多模式串匹配，且允许模式串多次被统计的，用来统计所有模式串的总出现次数的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u = tr[u].s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = u; j &gt; <span class="number">0</span>; j = tr[j].fail)</span><br><span class="line">            res += tr[j].cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>res</code>是所有模式串的总出现次数。</p>
<h2 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM4MDg=">P3808 【模板】 AC 自动机（简单版）<i class="fa fa-external-link-alt"></i></span></p>
<p>参考代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3808/p3808.cpp"><code>Luogu P3808</code></a></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM3OTY=">P3796 【模板】 AC 自动机（加强版)<i class="fa fa-external-link-alt"></i></span></p>
<p>参考代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3796/p3796.cpp"><code>Luogu P3796</code></a></p>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>字符串</tag>
        <tag>自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>虚树</title>
    <url>/OI/virtual-tree/</url>
    <content><![CDATA[<p>虚树。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<p>虚树，顾名思义，是一棵树。</p>
<p>有时候题目给的树太大了，同时每一次处理询问的时候总会有大量的不可避免的冗余信息需要处理，这时候就需要我们对当前的树建立一棵虚树来选择性地忽略掉一些不重要的信息，进而减小了时间复杂度。</p>
<p>一般需要建立虚树的题目会在树上选择出几个关键点进行询问，而不关心其它的信息。同时我们还可以注意到，关键点的个数一般是与树的大小是同阶的（即在同一个数量级内）。这指的是，假如我们每一次询问的关键点个数是 $k_i$ 个，一共有 $m$ 次询问，那么 $\log_{10} (\sum k_i) &#x3D; \log_{10} n$。</p>
<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>比如说这道题：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI0OTU=">Luogu P2495<i class="fa fa-external-link-alt"></i></span> [SDOI2011] 消耗战</p>
<p>这一道题需要我们找到使所有关键点都不与根节点连接的割边方案，并且需要使这个割边方案中边的权值和最小。</p>
<p>对于这个问题，我们有一套经典的DP方案：</p>
<p>设 $dp[u]$ 表示使编号为 $u$ 的点不与其子树中任意一个关键点联通的最小代价。</p>
<p>设 $w(i,j)$ 表示连接 $i$ 与 $j$ 的边的权值。</p>
<p>那么我们可以枚举 $u$ 的儿子 $v$：</p>
<ul>
<li>若 $v$ 不是关键点，那么 $dp[u]&#x3D;dp[u]+\min(dp[v],w(u,v))$；</li>
<li>若 $v$ 是关键点，那么 $dp[u]&#x3D;dp[u]+w(u,v)$。</li>
</ul>
<p>单次DP的时间复杂度是 $O(n)$ 的。因为题目给出了 $m$ 次询问，并且每一次询问时关键点的信息还会改变，所以我们每一次询问的时候必须得重新DP一遍，这让我们总体的时间复杂度成为了 $O(nm)$。</p>
<p>然后看题目要求：</p>
<blockquote>
<p>对于 $100\%$ 的数据，$2\leq n \leq 2.5\times 10^5, 1\leq m\leq 5\times 10^5, \sum k_i \leq 5\times 10^5$。</p>
</blockquote>
<p>我们一眼就可以看出来以 $O(nm)$ 的复杂度是绝对过不去的。</p>
<p>经试验验证(LibreOJ)，以下面的代码可以跑出来50分的好成绩：<span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcy8xNDc2ODM0">提交寄录<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="虚树"><a href="#虚树" class="headerlink" title="虚树"></a>虚树</h1><p>我们重新来看一遍DP的过程。</p>
<p>我们在枚举某一个节点的所有儿子的时候，假设这个节点 $u$ 下面的子树内没有一个关键点，那么这个DP的过程就是冗余的。</p>
<p>既然我们不需要 $u$ 及其子树的信息了，那么它也就没有了继续存在于图内的必要了。</p>
<p>而如果 $u$ 下面的子树内有关键点，那么他也不一定能留下。</p>
<p>鉴于我们只关心关键点之间的连通性，我们关心的只有两类点：一是关键点，二是可能是两个关键点的LCA的点。<br>前者的数量是给定的，而后者只会在树分叉的地方出现，数量不会大于关键点的个数。</p>
<p>我们就可以对这两种点建立一棵新的树，而树上的边权就是我们关心的信息——在这道题内就是两端点在原树上的路径中的最小边权。</p>
<p>然后我们就可以对着明显缩水了的树进行DP了。</p>
<p>如果我们使用正确的求LCA算法的话（比如 $O(\log n)$ 的树剖），我们的时间复杂度就是 $O(\log \sum k_i)$ 了。</p>
<p>而由于 $\sum k_i$ 与 $n$ 同阶，所以我们可以近似的将我们的时间复杂度看为 $O(n \log n)$。</p>
<h1 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h1><p>既然有了思想，我们就可以着手建立虚树了。</p>
<p>我们当然不可能逐个枚举关键点的LCA并加进去来建立，这样的复杂度仍然是 $O(k^2)$ 级别的，我们无法接受。</p>
<p>我们需要尝试将这个算法优化，至少优化到 $O(k)$ 级别（不算LCA的 $O(\log n)$），这样我们才能够通过上面的数据范围。</p>
<p>自己手模一下，可以发现LCA只会在树分叉的地方出现，所以我们只需要维护树分叉的地方就可以了。</p>
<p>那怎么维护呢？</p>
<p>我们可以尝试维护极右链。</p>
<p>对于这样的一棵树：</p>
<img src="https://s2.loli.net/2022/06/06/MWQe1lCIjOadpfs.png" alt="vt1.png" width="50%" />

<p>现在它的极右链是这块红色的链：</p>
<img src="https://s2.loli.net/2022/06/06/8hxmdLiXeOlfGtQ.png" alt="vt2.png" width="50%" />

<p>那么假设我们最后的点是这个红色点，美剧导的下一个点是这个蓝色的点：</p>
<img src="https://s2.loli.net/2022/06/06/oEYqybwUDK7VZGg.png" alt="vt3.png" width="50%" />

<p>蓝色的点向上到根节点的路径有与之前已经建好了的树重合的部分，也有之前没有出现过的部分（蓝色的链）。</p>
<p>我们把这个点加入树中的同时，还需要加入它与之前的极右链中的交点，即其与上一个关键点的LCA。</p>
<p>然后，最新的极右链就是这个：</p>
<img src="https://s2.loli.net/2022/06/06/VsBZlrqPUDuJweT.png" alt="vt4.png" width="50%" />

<p>为了保证不会损坏虚树的结构，首先我们将所有的关键点按照DFS序来排序，保证逐个遍历的时候不会有新的关键点出现在当前极右链的左边。</p>
<p>然后我们使用栈来维护遍历的顺序，就像我们DFS时的系统栈一样，记录下之前遍历的点。</p>
<p>下面的代码里面的注释就是对该步骤的解释：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v.<span class="built_in">init</span>();<span class="comment">//清空链式前向星</span></span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + k, cmp);<span class="comment">//将关键点按照DFS序排序</span></span><br><span class="line">    sta[tt = <span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//1号节点入栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> g = <span class="built_in">lca</span>(a[i], sta[tt]);</span><br><span class="line">        <span class="comment">//拎出来当前节点与栈顶节点在原树上的LCA</span></span><br><span class="line">        <span class="keyword">if</span>(g != sta[tt])</span><br><span class="line">        &#123;<span class="comment">//如果LCA不是栈顶的节点，就意味着当前节点不在当前节点所维护的链上</span></span><br><span class="line">            <span class="keyword">while</span>(id[g] &lt; id[sta[tt - <span class="number">1</span>]])</span><br><span class="line">            &#123;<span class="comment">//当次大节点的DFS序大于LCA的DFS序</span></span><br><span class="line">                <span class="type">int</span> p = sta[tt - <span class="number">1</span>], q = sta[tt--];</span><br><span class="line">                ll d = <span class="built_in">minpath</span>(p, q);</span><br><span class="line">                v.<span class="built_in">add</span>(p, q, d);</span><br><span class="line">                v.<span class="built_in">add</span>(q, p, d);</span><br><span class="line">                <span class="comment">//那就说明栈顶节点不需要再维护了</span></span><br><span class="line">                <span class="comment">//连边，弹栈</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(id[g] &gt; id[sta[tt - <span class="number">1</span>]])</span><br><span class="line">            &#123;<span class="comment">//如果LCA不是次大节点</span></span><br><span class="line">                ll d = <span class="built_in">minpath</span>(g, sta[tt]);</span><br><span class="line">                v.<span class="built_in">add</span>(g, sta[tt], d);</span><br><span class="line">                v.<span class="built_in">add</span>(sta[tt], g, d);</span><br><span class="line">                tt--;</span><br><span class="line">                sta[++tt] = g;</span><br><span class="line">                <span class="comment">//那就说明LCA从来没有在栈内出现过</span></span><br><span class="line">                <span class="comment">//与栈顶元素连边并弹出之</span></span><br><span class="line">                <span class="comment">//然后就入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;<span class="comment">//否则LCA就是次大节点</span></span><br><span class="line">                <span class="type">int</span> p = sta[tt - <span class="number">1</span>], q = sta[tt--];</span><br><span class="line">                ll d = <span class="built_in">minpath</span>(p, q);</span><br><span class="line">                v.<span class="built_in">add</span>(p, q, d);</span><br><span class="line">                v.<span class="built_in">add</span>(q, p, d);</span><br><span class="line">                <span class="comment">//直接连边弹栈即可，不用入栈了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sta[++tt] = a[i];<span class="comment">//当前节点入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(tt &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;<span class="comment">//将剩下的最后一条极右链连接起来</span></span><br><span class="line">        <span class="type">int</span> p = sta[tt - <span class="number">1</span>], q = sta[tt];</span><br><span class="line">        ll d = <span class="built_in">minpath</span>(p, q);</span><br><span class="line">        v.<span class="built_in">add</span>(p, q, d);</span><br><span class="line">        v.<span class="built_in">add</span>(q, p, d);</span><br><span class="line">        tt--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以愉快地在虚树上进行dp了，方法与之前一样。</p>
<p>现在我们的复杂度大大减小，就可以拿到——80分的好成绩！<span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcy8xNDc2NjAy">提交寄录<i class="fa fa-external-link-alt"></i></span></p>
<p>然后我们就不理解了。</p>
<p>我的理论复杂度也是对的，应该没有什么问题。</p>
<p>我们回忆一下我们代码的实现：</p>
<p>我们在每一次建立虚树之前，都把整个链式前向星都清空了一遍。</p>
<p>这时我们可以再懒一点，我们可以不需要清空链式前向星，只需要将每一个入栈的节点在入栈的时候清空该节点的表头即可。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">void build()</span><br><span class="line">&#123;</span><br><span class="line"><span class="deletion">-   v.init();</span></span><br><span class="line"><span class="addition">+   v.idx = 0;</span></span><br><span class="line">    sort(a + 1, a + 1 + k, cmp);</span><br><span class="line">    sta[tt = 1] = 1;</span><br><span class="line"><span class="addition">+   v.h[1] = -1;</span></span><br><span class="line">    for(int i = 1; i &lt;= k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int g = lca(a[i], sta[tt]);</span><br><span class="line">        if(g != sta[tt])</span><br><span class="line">        &#123;</span><br><span class="line">            while(id[g] &lt; id[sta[tt - 1]])</span><br><span class="line">            &#123;</span><br><span class="line">                int p = sta[tt - 1], q = sta[tt--];</span><br><span class="line">                ll d = minpath(p, q);</span><br><span class="line">                v.add(p, q, d);</span><br><span class="line">                v.add(q, p, d);</span><br><span class="line">            &#125;</span><br><span class="line">            if(id[g] &gt; id[sta[tt - 1]])</span><br><span class="line">            &#123;</span><br><span class="line">                ll d = minpath(g, sta[tt]);</span><br><span class="line"><span class="addition">+               v.h[g] = -1;</span></span><br><span class="line">                v.add(g, sta[tt], d);</span><br><span class="line">                v.add(sta[tt], g, d);</span><br><span class="line">                tt--;</span><br><span class="line">                sta[++tt] = g;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                int p = sta[tt - 1], q = sta[tt--];</span><br><span class="line">                ll d = minpath(p, q);</span><br><span class="line">                v.add(p, q, d);</span><br><span class="line">                v.add(q, p, d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="addition">+       v.h[a[i]] = -1;</span></span><br><span class="line">        sta[++tt] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    while(tt &gt; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        int p = sta[tt - 1], q = sta[tt--];</span><br><span class="line">        ll d = minpath(p, q);</span><br><span class="line">        v.add(p, q, d);</span><br><span class="line">        v.add(q, p, d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩下的节点我们就不需要管了，因为我们甚至没有访问他们的机会。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="Luogu-P2495-SDOI2011-消耗战"><a href="#Luogu-P2495-SDOI2011-消耗战" class="headerlink" title="Luogu P2495 [SDOI2011] 消耗战"></a>Luogu P2495 [SDOI2011] 消耗战</h2><p>题面在这里：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI0OTU=">https://www.luogu.com.cn/problem/P2495<i class="fa fa-external-link-alt"></i></span></p>
<p>上面已经讲了做法了，就是一个树形DP。</p>
<p>代码见这里：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p2000-p2999/p2495/p2495.cpp"><code>Luogu P2495</code></a></p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉和莫比乌斯</title>
    <url>/maths/eular-and-m%C3%B6bius/</url>
    <content><![CDATA[<p>简介：欧拉定理，欧拉函数和莫比乌斯函数</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<p>初稿写于2021-10-10，<br>再修改于2022-02-07</p>
<p><strong>Achtung: 本文章使用p来代指“任意质数”，请勿混淆。</strong></p>
<p>首先让我们膜拜一下莱昂哈德·欧拉(Leonhard Euler):</p>
<p><img src="/pics/eular.jpg" alt="eular"></p>
<h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><p>欧拉函数 $φ(n)$ 的概念是在 $[0,n-1]$ 范围内有多少个整数与 $n$ 互质。</p>
<p>其中，我们规定 $φ(1)&#x3D;1$，</p>
<p>且不难发现，$φ(p)&#x3D;p-1$。</p>
<h2 id="欧拉函数的一些性质"><a href="#欧拉函数的一些性质" class="headerlink" title="欧拉函数的一些性质"></a>欧拉函数的一些性质</h2><h3 id="欧拉函数是积性函数"><a href="#欧拉函数是积性函数" class="headerlink" title="欧拉函数是积性函数"></a>欧拉函数是积性函数</h3><p>即 $φ(mn) &#x3D; φ(m) φ(n)$</p>
<p>并且当 $n \bmod{2} \equiv 1$ 时，$φ(2n) &#x3D; φ(n)$，</p>
<p>而当 $n \bmod{2} \equiv 0$（即 $2|n$)时，$φ(2n) &#x3D; 2 φ(n)$</p>
<h3 id="displaystyle-sum-m-n-n-m-x3D-n-frac-φ-n-2"><a href="#displaystyle-sum-m-n-n-m-x3D-n-frac-φ-n-2" class="headerlink" title="$\displaystyle \sum_{m|n}^{n} m &#x3D; n \frac{φ(n)}{2}$"></a>$\displaystyle \sum_{m|n}^{n} m &#x3D; n \frac{φ(n)}{2}$</h3><p>$$<br>\sum_{m|n}^{n} m &#x3D; n \frac{φ(n)}{2}<br>$$</p>
<p>易证。</p>
<h3 id="displaystyle-sum-d-n-φ-d-x3D-n"><a href="#displaystyle-sum-d-n-φ-d-x3D-n" class="headerlink" title="$\displaystyle \sum_{d|n} φ(d) &#x3D; n$"></a>$\displaystyle \sum_{d|n} φ(d) &#x3D; n$</h3><p>$$<br>\sum_{d|n} φ(d) &#x3D; n<br>$$</p>
<p>我们利用莫比乌斯反演的相关知识可以得出。</p>
<p>或者我们这样考虑：<br>如果 $\gcd(k,n) &#x3D; d$ ，那么 $\gcd(\frac{k}{d} , \frac{n}{d}) &#x3D; 1 (k &lt; n)$ 。<br>我们如果设 $f(x)$ 为满足 $\gcd(k,n) &#x3D; x$ 的数的个数，那么 $n &#x3D; \sum_{i-1}^n f(i)$ 。<br>根据上面的证明，我们可以发现， $f(x) &#x3D; φ(\frac{n}{x})$ ，从而得到 $n &#x3D; \sum_{d|n} φ(\frac{n}{d})$ 。注意此时我们的约数 $d$ 和 $\frac{n}{d}$ 具有对称性，所以上面的式子可以化为 $n &#x3D; \sum_{d|n} φ(d)$ 。</p>
<h3 id="displaystyle-φ-p-k-x3D-p-k-p-k-1"><a href="#displaystyle-φ-p-k-x3D-p-k-p-k-1" class="headerlink" title="$\displaystyle φ(p^k) &#x3D; p^k - p^{k-1}$"></a>$\displaystyle φ(p^k) &#x3D; p^k - p^{k-1}$</h3><p>若 $n &#x3D; p^k$ ，那么 $φ(n) &#x3D; p^k - p^{k-1}$ 。</p>
<p>由定义可知。<br>因为有 $n \perp p^k \iff p \not \mid n$ 。在 ${ 0,1,p,\cdots ,p^k-1 }$ 中， $p$ 的倍数是 ${ 0,p,2p,\cdots ,p^k-p }$ ，共有 $p^{k-1}$ 个。</p>
<h3 id="displaystyle-φ-prod-i-x3D-1-s-p-i-k-i-x3D-prod-i-x3D-1-s-p-i-k-i-1-·-p-i-1"><a href="#displaystyle-φ-prod-i-x3D-1-s-p-i-k-i-x3D-prod-i-x3D-1-s-p-i-k-i-1-·-p-i-1" class="headerlink" title="$\displaystyle φ(\prod_{i&#x3D;1}^s p_i^{k_i}) &#x3D; \prod_{i&#x3D;1}^s p_i^{k_i - 1} · (p_i - 1)$"></a>$\displaystyle φ(\prod_{i&#x3D;1}^s p_i^{k_i}) &#x3D; \prod_{i&#x3D;1}^s p_i^{k_i - 1} · (p_i - 1)$</h3><p>由唯一分解定理，设 $n &#x3D; \prod_{i&#x3D;1}^s p_i^{k_i}$ ，则有 $φ(n) &#x3D; \prod_{i&#x3D;1}^s \frac{p_i - 1}{p_i}$。</p>
<p>证明：</p>
<p>$$<br>\begin{align}<br>φ(n) &amp;&#x3D; \prod_{i&#x3D;1}^s φ(p_i^{k_i}) \\<br>&amp;&#x3D; \prod_{i&#x3D;1}^s p_i^{k_i} - p_i^{k_i - 1} \\<br>&amp;&#x3D; \prod_{i&#x3D;1}^s (p_i - 1) \times p_i^{k_i - 1} \\<br>&amp;&#x3D; \prod_{i&#x3D;1}^s (1 - \frac{1}{p_i}) p_i^{k_i} \\<br>&amp;&#x3D; n \prod_{i&#x3D;1}^s (1 - \frac{1}{p_i})<br>\end{align}<br>$$</p>
<h2 id="计算欧拉函数的值"><a href="#计算欧拉函数的值" class="headerlink" title="计算欧拉函数的值"></a>计算欧拉函数的值</h2><h3 id="单点求值"><a href="#单点求值" class="headerlink" title="单点求值"></a>单点求值</h3><p>我们不难发现，当 $m$ 是一个质数的整数幂 $p^k$ 时，我们有<br>$$<br>φ(p^k)&#x3D;p^k-p^{k-1}<br>$$<br>;<br>如果 $m&gt;1$ 不是一个质数的整数幂，那我们可以把 $m$ 拆分成 $m&#x3D;m_1 m_2$ ，其中 $m_1 \perp m_2$。这样这个数就可以在剩余系里表示为 $(n \bmod m_1 , n \bmod m_2)$ 。如果你不知道什么是剩余系，可以看我的博客：（咕了）。</p>
<p>根据<br>$$<br>k \perp m 且 k \perp n \iff k \perp mn<br>$$<br>和<br>$$<br>\gcd(m,n) &#x3D; \gcd(n \bmod m,m)<br>$$<br>可得<br>$$<br>n \perp m \iff n \bmod m_1 \perp m_1 且 n \bmod m_2 \perp m_2<br>$$<br>，由此，我们可以推得<br>$$<br>φ(m)&#x3D;φ(m_1)φ(m_2),m_1 \perp m_2<br>$$<br>所以，欧拉函数是一个积性函数。</p>
<p>欧拉函数的通项公式是<br>$$<br>φ(m)&#x3D;\prod_{p|m} (p^{m_p}-p^{m_p-1})&#x3D;m \prod_{p|m}(1-\frac{1}{p})<br>$$</p>
<p>上代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">euler_phi</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">int</span>(<span class="built_in">sqrt</span>(n + <span class="number">0.5</span>));</span><br><span class="line">    <span class="type">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>) ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果将代码改为下面的形式可以优化一些：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">euler_phi</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>) ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="区间筛"><a href="#区间筛" class="headerlink" title="区间筛"></a>区间筛</h3><p>而我们可以使用筛法来求连续区间的欧拉函数值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> phi[N], prime[N / <span class="number">100</span>];</span><br><span class="line"><span class="type">bool</span> visit[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getphi</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visit[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime[prime[<span class="number">0</span>] + <span class="number">1</span>] = i;</span><br><span class="line">            prime[<span class="number">0</span>]++;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= prime[<span class="number">0</span>] &amp;&amp; i * prime[j] &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            visit[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i % prime[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                phi[i * prime[j]] = phi[i] * (prime[j] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有OI Wiki上提供的代码：</p>
<details class="note default"><summary><p>from OI Wiki</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(is_prime, <span class="number">1</span>, <span class="built_in">sizeof</span>(is_prime));</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    is_prime[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">5000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(is_prime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= <span class="number">5000000</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            is_prime[i * prime[j]] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j])</span><br><span class="line">                phi[i * prime[j]] = phi[i] * phi[prime[j]];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>复杂度均为线性。</p>
<h1 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h1><p>我们先看一下费马小定理。</p>
<h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p>众所周知，费马小定理是：<br>$$<br>a^{p-1} \equiv 1 \pmod{p},a \perp p<br>$$<br>还有另一种形式，是这样的：<br>$$<br>\forall a \in \mathbb{N} ,a^p \equiv a \pmod{p}<br>$$<br>。</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>我们首先取一个不为 $p$ 倍数的数 $a$ 。<br>构造一个序列： $A &#x3D; \lbrace 1,2,3, \cdots , p - 1 \rbrace$ ，这个序列拥有这样的一个性质：<br>$$<br>\prod_{i&#x3D;1}^n A_i \equiv \prod_{i&#x3D;1}^n (A_i \times a) \pmod{p}<br>$$</p>
<p>证明：<br>$$<br>\because (A_i,p) &#x3D; 1 , (A_i \times a,p) &#x3D; 1<br>$$<br>又因为每一个 $A_i \times a \pmod{p}$ 都是独一无二的，且 $A_i \times a \pmod{p} &lt; p$ ，得证（每一个 $A_i \times a$ 都对应了一个 $A_i$）。<br>设 $f &#x3D; (p-1)!$，则<br>$$<br>\begin{align}<br>f &amp;\equiv (a \times A_1)(a \times A_2)(a \times A_3) \cdots (a \times A_{p-1}) \pmod{p} \\<br>a^{p-1} · f &amp;\equiv f \pmod{p} \\<br>a^{p-1} &amp;\equiv 1 \pmod{p}<br>\end{align}<br>$$<br>证毕。</p>
<p>或者也可以使用归纳法证明：</p>
<p>显然 $1^p \equiv 1 \pmod{p}$。那么假设 $a^p \equiv a \pmod{p}$ 成立，那么通过二项式定理有<br>$$<br>(a+1)^p &#x3D; a^p + C_p^1 a^{p-1} + C_p^2 a^{p-2} + \cdots + C_p^{p-1} a + 1<br>$$<br>因为 $C_p^k &#x3D; \frac{p!}{(n-k)!k!}$ 对于 $k \in [ 1,p-1 ]$ 成立，在模 $p$ 意义下 $C_p^1 \equiv C_p^2 \equiv \cdots \equiv C_p^{p-1} \equiv 0 \pmod{p}$，那么 $(a+1)^p \equiv a^p + 1 \pmod{p}$，将 $a^p \equiv a \pmod{p}$ 代入得 $(a+1)^p \equiv a+1 \pmod{p}$。<br>证毕。</p>
<h2 id="欧拉定理-1"><a href="#欧拉定理-1" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>欧拉定理的内容如下：</p>
<p>若 $\gcd(a,m) &#x3D; 1$，则 $a^{φ(m)} \equiv 1 \pmod{m}$。</p>
<h3 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h3><p>欧拉定理的证明过程与费马小定理的证明过程十分相似。<br>我们同样首先构造一个与 $m$ 互质的序列，再进行操作。</p>
<p>设 $r_1,r_2, \cdots ,r_{φ(m)}$ 为模 $m$ 意义下的一个简化剩余系，则 $ar_1,ar_2, \cdots ,ar_{φ(m)}$ 同样也为模 $m$ 意义下的一个简化剩余系。所以，$\prod_{i&#x3D;1}^{φ(m)} r_i \equiv \prod_{i&#x3D;1}^{φ(m)} ar_i \equiv a^{φ(m)} \prod_{i&#x3D;1}^{φ(m)} r_i \pmod{m}$，约去 $\prod_{i&#x3D;1}^{φ(m)} r_i$ 后可得 $a^{φ(m)} \equiv 1 \pmod{m}$。<br>证毕。</p>
<p>当 $m&#x3D;p$ 时，由于 $φ(m) &#x3D; m-1$，将之代入可得费马小定理。</p>
<h2 id="扩展欧拉定理"><a href="#扩展欧拉定理" class="headerlink" title="扩展欧拉定理"></a>扩展欧拉定理</h2><p>扩展欧拉定理是这个样子的：</p>
<p>$$<br>a^b \equiv \begin{cases}a^{b \ \bmod \ φ(m)}, &amp; \gcd(a,m) &#x3D; 1,\\a^b, &amp; \gcd(a,m) \neq 1, b &lt; φ(m),\\a^{(b \ \bmod \ φ(m))+φ(m)}, &amp; \gcd(a,m) \neq 1,b \geq φ(m). \end{cases} \pmod{m}<br>$$</p>
<p>证明见<span class="exturl" data-url="aHR0cHM6Ly9vaS13aWtpLm9yZy9tYXRoL251bWJlci10aGVvcnkvZmVybWF0LyNfNg==">OI Wiki<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>我们把一个数字分解质因数为 $n&#x3D;p_1^{c_1}p_2^{c_2} \cdots p_k^{c_k}$，则<br>$$<br>μ(n)&#x3D;<br>\begin{cases}<br>1 &amp; n&#x3D;1 \\<br>0 &amp; \forall i \in [1,k] , c_i &gt; 1 \\<br>(-1)^k &amp; \forall i \in [1,k] , c_i &#x3D; 1<br>\end{cases}<br>$$</p>
<p>解释一下：</p>
<ol>
<li>当 $n&#x3D;1$ 时， $μ(n)&#x3D;1$；</li>
<li>当 $n \neq 1$ 时：<ol>
<li>当存在 $i\in [1,k]$，使得 $c_i &gt; 1$ 时，$μ(n)&#x3D;0$，也就是说只要某个质因子出现的次数超过一次，$μ(n)$ 就等于 $0$；</li>
<li>当任意 $i\in[1,k]$，都有 $c_i&#x3D;1$ 时，$μ(n)&#x3D;(-1)^k$，也就是说每个质因子都仅仅只出现过一次时，$μ(n)$ 等于 $-1$ 的 $k$ 次幂，此处 $k$ 指的便是仅仅只出现过一次的质因子的总个数。</li>
</ol>
</li>
</ol>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>莫比乌斯函数不仅是积性函数，还有如下性质：<br>$$<br>\sum_{d|m} μ(d) &#x3D; [m&#x3D;&#x3D;1]<br>$$<br>其中 $[m&#x3D;&#x3D;1]$ 代表 <code>m==1?1:0</code> 。</p>
<h2 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a>证明</h2><p>设<br>$$<br>n&#x3D;\prod_{i&#x3D;1}^k{p_i}^{c_i},n’&#x3D;\prod_{i&#x3D;1}^k p_i<br>$$<br>那么<br>$$<br>\sum_{d\mid n}μ(d)&#x3D;\sum_{d\mid n’}μ(d)&#x3D;\sum_{i&#x3D;0}^k C_k^i·(-1)^i&#x3D;(1+(-1))^k<br>$$</p>
<h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><p>如果两个的函数 $f(n)$ 与 $g(n)$ 满足<br>$$<br>f(n) &#x3D; \sum_{d|n} g(d)<br>$$<br>则<br>$$<br>g(n) &#x3D; \sum_{d|n} μ(d) f(\frac{n}{d})<br>$$</p>
<h3 id="证明-3"><a href="#证明-3" class="headerlink" title="证明"></a>证明</h3><details class="note info"><summary><p>摘自《混凝土数学》</p>
</summary>
<h4 id="充分性"><a href="#充分性" class="headerlink" title="充分性"></a>充分性</h4><p>$$<br>\begin{align}<br>f(n) &amp;&#x3D; \sum_{d|n} g (d)\\<br>&amp;&#x3D; \sum_{d|n} g (\frac{n}{d})<br>\end{align}<br>$$</p>
<p>$$<br>\sum_{d|n} μ(d) f(\frac{n}{d}) &#x3D; \sum_{d|n} μ(d) \sum_{d_1|\frac{n}{d}} g(d_1)<br>$$</p>
<p>$$<br>\begin{align}<br>\sum_{d|n} \sum_{d_1|\frac{n}{d}} μ(d) g (d_1) &amp;&#x3D; \sum_{d_1|n} g(d_1) \sum_{d|\frac{n}{d_1}} μ(d) \\<br>&amp;&#x3D; g(n)<br>\end{align}<br>$$</p>
<p>考虑到<br>$$<br>\sum_{d|\frac{n}{d_1}} μ(d) &#x3D;<br>\begin{cases}<br>1 &amp; d_1 &#x3D; n \\<br>0 &amp; d_1 &lt; n<br>\end{cases}<br>$$<br>因此<br>$$<br>\begin{align}<br>g(n) &amp;&#x3D; \sum_{d|n} μ(d) f(\frac{n}{d}) \\<br>&amp;&#x3D; \sum_{d|n} μ(\frac{n}{d}) f(d)<br>\end{align}<br>$$</p>
<h4 id="必要性"><a href="#必要性" class="headerlink" title="必要性"></a>必要性</h4><p>$$<br>\begin{align}<br>g(n) &amp;&#x3D; \sum_{d|n} μ(d) f(\frac{n}{d}) \\<br>&amp;&#x3D; \sum_{d|n} μ(\frac{n}{d}) f(d)<br>\end{align}<br>$$</p>
<p>$$<br>\begin{align}<br>\sum_{d|n} g(d) &amp;&#x3D; \sum_{d|n}g(\frac{n}{d}) \\<br>&amp;&#x3D; \sum_{d|n} \sum_{d_1|\frac{n}{d}} μ(\frac{n}{d d_1})f(d_1) \\<br>&amp;&#x3D; \sum_{d d_1|n} μ(\frac{n}{d d_1}) f(d_1) \\<br>&amp;&#x3D; \sum_{d_1|n} f(d_1) \sum_{d|\frac{n}{d}} μ(\frac{n}{d d_1}) \\<br>&amp;&#x3D; f(n)<br>\end{align}<br>$$</p>
<p>考虑到</p>
<p>$$<br>\begin{align}<br>\sum_{d|\frac{n}{d_1}} μ(\frac{n}{d d_1}) &amp;&#x3D; \sum_{d|\frac{n}{d_1}} μ(d) \\<br>&amp;&#x3D; \begin{cases} 1 &amp; d_1 &#x3D; n \\ 0 &amp; d_1 &lt; n \end{cases}<br>\end{align}<br>$$</p>
<p>因此</p>
<p>$$<br>\begin{align}<br>f(n) &amp;&#x3D; \sum_{d|n} g(d) \\<br>&amp;&#x3D; \sum_{d|n} g(\frac{n}{d})<br>\end{align}<br>$$</p>

</details>

<h2 id="求莫比乌斯函数的值"><a href="#求莫比乌斯函数的值" class="headerlink" title="求莫比乌斯函数的值"></a>求莫比乌斯函数的值</h2><h3 id="单点求值-1"><a href="#单点求值-1" class="headerlink" title="单点求值"></a>单点求值</h3><p>自己算。</p>
<h3 id="区间筛法"><a href="#区间筛法" class="headerlink" title="区间筛法"></a>区间筛法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getMu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flg[i]) p[++tot] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * p[j] &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            flg[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % p[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mu[i * p[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i * p[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="莫比乌斯变换"><a href="#莫比乌斯变换" class="headerlink" title="莫比乌斯变换"></a>莫比乌斯变换</h2><p>设 $f(n)$，$g(n)$ 为两个数论函数。<br>如果有 $f(n) &#x3D; \sum_{d|n} g(d)$ 那么有：</p>
<p>形式1： $g(n) &#x3D; \sum_{d|n} μ(d) f(\frac{n}{d})$。</p>
<p>这种形式下，函数 $f(n)$ 被称为函数 $g(n)$ 的莫比乌斯变换，反之则称之为其的莫比乌斯逆变换（反演）。</p>
<p>形式2： $g(n) &#x3D; \sum_{d|n} μ(\frac{d}{n}) f(d)$。</p>
<p>据说这种形式更常考一点。</p>
<h3 id="证明-4"><a href="#证明-4" class="headerlink" title="证明"></a>证明</h3><ul>
<li>方法一：对原式做数论变换。</li>
</ul>
<p>$$<br>\begin{align}<br>&amp; \sum_{d\mid n}μ(d)f(\frac{n}{d}) \\<br>&#x3D;&amp; \sum_{d\mid n}μ(d)\sum_{k\mid \frac{n}{d}}g(k) \\<br>&#x3D;&amp; \sum_{k\mid n}g(k)\sum_{d\mid \frac{n}{k}}μ(d) \\<br>&#x3D;&amp; g(n)<br>\end{align}<br>$$</p>
<p>用 $\displaystyle\sum_{d\mid n}g(d)$ 来替换 $f(\dfrac{n}{d})$，再变换求和顺序。最后一步变换的依据：$\displaystyle\sum_{d\mid n}μ(d)&#x3D;[n&#x3D;1]$，因此在 $\dfrac{n}{k}&#x3D;1$ 时第二个和式的值才为 $1$。此时 $n&#x3D;k$，故原式等价于 $\displaystyle\sum_{k\mid n}[n&#x3D;k]\cdot g(k)&#x3D;g(n)$</p>
<ul>
<li>方法二：运用卷积。</li>
</ul>
<p>原问题为：已知 $f&#x3D;g * 1$，证明 $g&#x3D;f * μ$</p>
<p>易知如下转化：$f * μ&#x3D;g * 1 * μ\implies f * μ&#x3D;g$（其中 $1 * μ&#x3D;ε$）。</p>
<p>对于第二种形式：</p>
<p>类似上面的方法一，我们考虑逆推这个式子。</p>
<p>$$<br>\begin{align}<br>&amp; \sum_{n|d}{μ(\frac{d}{n})f(d)} \\<br>&#x3D;&amp; \sum_{k&#x3D;1}^{+\infty}{μ(k)f(kn)} \\<br>&#x3D;&amp; \sum_{k&#x3D;1}^{+\infty}{μ(k)\sum_{kn|d}{g(d)}} \\<br>&#x3D;&amp; \sum_{n|d}{g(d)\sum_{k|\frac{d}{n}}{μ(k)}} \\<br>&#x3D;&amp; \sum_{n|d}{g(d)ε(\frac{d}{n})} \\<br>&#x3D;&amp; g(n)<br>\end{align}<br>$$</p>
<p>我们把 $d$ 表示为 $kn$ 的形式，然后把 $f$ 的原定义代入式子。</p>
<p>发现枚举 $k$ 再枚举 $kn$ 的倍数可以转换为直接枚举 $n$ 的倍数再求出 $k$，发现后面那一块其实就是 $ε$, 整个式子只有在 $d&#x3D;n$ 的时候才能取到值。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>《混凝土数学》<br>OI Wiki</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>拉格朗日插值</title>
    <url>/maths/lagrange-interpolation/</url>
    <content><![CDATA[<p>拉格朗日插值。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<p>在学完函数以后，AJ想让我们求出一个函数，使得其带入自然数时生成的序列时给定的，并让武嘉给出了一个数列。</p>
<p>崇尚<ruby>野獣<rt>やじゅう</rt></ruby><ruby>先輩<rt>せんぱい</rt></ruby>的武嘉给出了这样的一个序列：</p>
<p>$$<br>1,3,5,7,9,114514<br>$$</p>
<p>光看前五项貌似可以构建出 $f(x)&#x3D;2x-1$ 来糊过去，但是第6项就不好办了。</p>
<p>王哥说：“这都不会，快用<strong>拉格朗日插值</strong>！”<br>(P.S.: 其实我们班里初三的时候真的有讲拉插)</p>
<hr>
<p>引入完毕。</p>
<p>拉格朗日插值法可以很快地将一系列的点值转化为一个经过所有给定点值的函数（或者称多项式）。</p>
<p>拉格朗日给出的方法是这样的：</p>
<p>首先我们给出两个二次多项式，分别称之为 $f(x)$ 与 $g(x)$。<br>两者的系数分别为 $a_f,b_f,c_f$ 与 $a_g,b_g,c_g$。</p>
<p>假设有一个函数 $h(x)$ ，它等于 $f(x)+g(x)$，那么</p>
<p>$$<br>\begin{align}<br>h(x) &amp;&#x3D; f(x)+g(x) \\<br>&amp;&#x3D; a_fx^2+b_fx+c_f + a_gx^2+b_gx+c_g \\<br>&amp;&#x3D; (a_f+a_g)x^2 + (b_f+b_g)x + (c_f+c_g)<br>\end{align}<br>$$</p>
<p>$h(x)$ 的每一项系数竟然是 $f(x)$ 与 $g(x)$ 该项系数之和。</p>
<p>我们再来看代入数值之后的结果。</p>
<p>我们不难看出，对于每一个 $x$ ，其对应的函数值 $f(x)$，$g(x)$ 与 $h(x)$ 满足 $h(x)&#x3D;f(x)+g(x)$。</p>
<p>然后拉格朗日就想，对于每一个点值，我们分别构造一个函数，使得其刚好经过当前点值代表的点，而其他点值处均为 $0$。<br>我们最后将所有的函数加起来，就得到了完美经过每个点值的函数了。</p>
<p>而每一个函数又怎么求呢？</p>
<p>我们先想个简单一点的，让这个函数在当前 $x$ 处为 $1$，其他 $x$ 处都为 $0$。</p>
<p>首先，我们为了表示这些点值且与自由元 $x$ 区分，设其分别为 $(X_i,Y_i)$，总共有 $n$ 个，当前函数为 $F_k(x)$，代表着第 $k$ 个点值。</p>
<p>那么，我们让函数为 $\displaystyle \prod_{i&#x3D;1,i \neq k}^n (x - X_i)$，这样可以使除当前点之外的数都是 $0$。</p>
<p>然后，我们将整个函数除以代入 $X_k$ 时的值，使 $F_k(X_k)&#x3D;1$。<br>那么整个函数就变为了 $\displaystyle \prod_{i&#x3D;1,i \neq k}^n \frac{x - X_i}{X_k - X_i}$。</p>
<p>最后再乘上 $Y_k$，就可以得出我们当前的函数：$\displaystyle F_k(x) &#x3D; Y_k \prod_{i&#x3D;1,i \neq k}^n \frac{x - X_i}{X_k - X_i}$</p>
<p>再把所有的东西加起来，得到</p>
<p>$$<br>G(x) &#x3D; \sum_{k&#x3D;1}^n \bigg( Y_k \prod_{i&#x3D;1,i \neq k}^n \frac{x - X_i}{X_k -X_i} \bigg)<br>$$</p>
<hr>
<p>或者说，我们对于每一个点值列一个方程，将所有的系数作为未知量来求解。</p>
<p>对于一个 $n$ 次多项式，我们一共有 $n+1$ 个系数。我们设这些系数分别为 $a_0,a_1,a_2,a_3,\cdots ,a_n$。</p>
<p>我们如果有一个点值 $(x,y)$，那么我们就可以根据其列出一个方程：</p>
<p>$$<br>a_0 + a_1 x + a_2 x^2 + a_3 x^3 + \cdots + a_n x^n &#x3D; y<br>$$</p>
<p>首先，众所周知，我们需要不少于 $n$ 个方程才能求出 $n$ 个未知数。<br>其次，我们利用克拉默法则来接方程式的时候，也需要形成行列式才能解出来值。</p>
<p>所以说，我们给定 $n+1$ 个点值，能唯一地确定一个 $n$ 次多项式。</p>
<hr>
<p>所以，我们如果用拉格朗日插值法来计算AJ的课后作业的话，得到的式子就是这个样子的：</p>
<p>$$<br>\begin{align}<br>G(x) &amp;&#x3D; 1·\frac{(x-2)(x-3)(x-4)(x-5)(x-6)}{(1-2)(1-3)(1-4)(1-5)(1-6)}<br>\\ &amp;+ 3·\frac{(x-1)(x-3)(x-4)(x-5)(x-6)}{(2-1)(2-3)(2-4)(2-5)(2-6)}<br>\\ &amp;+ 5·\frac{(x-1)(x-2)(x-4)(x-5)(x-6)}{(3-1)(3-2)(3-4)(3-5)(3-6)}<br>\\ &amp;+ 7·\frac{(x-1)(x-2)(x-3)(x-5)(x-6)}{(4-1)(4-2)(4-3)(4-5)(4-6)}<br>\\ &amp;+ 9·\frac{(x-1)(x-2)(x-3)(x-4)(x-6)}{(5-1)(5-2)(5-3)(5-4)(5-6)}<br>\\ &amp;+ 114514·\frac{(x-1)(x-2)(x-3)(x-4)(x-5)}{(6-1)(6-2)(6-3)(6-4)(6-5)} \\<br>&amp;&#x3D; \frac{114503}{120} x^5 - \frac{114503}{8} x^4 + \frac{1946551}{24} x^3 - \frac{1717545}{8} x^2 + \frac{15687031}{60} x - 114504<br>\end{align}<br>$$</p>
<p>这里有一个 $O(n^2)$ 求出最后得出的多项式的系数的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5050</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll t = mod - <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t &amp; <span class="number">1</span>)ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll x[N], y[N], c[N], fs[N], g[N], f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;x[i], &amp;y[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span>(i != j)</span><br><span class="line">                c[i] = c[i] * (x[i] - x[j]) % mod;</span><br><span class="line">        c[i] = <span class="built_in">qpow</span>(c[i]) * y[i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    fs[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = n; j; j--)</span><br><span class="line">            fs[j] = (fs[j - <span class="number">1</span>] + fs[j] * (mod - x[i])) % mod;</span><br><span class="line">        fs[<span class="number">0</span>] = fs[<span class="number">0</span>] * (mod - x[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll buf = <span class="built_in">qpow</span>(mod - x[i]);</span><br><span class="line">        g[<span class="number">0</span>] = fs[<span class="number">0</span>] * buf % mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            g[j] = (fs[j] - g[j - <span class="number">1</span>]) * buf % mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            f[j] = (f[j] + c[i] * g[j]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, (f[i] + mod) % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3Uub3JnL2Jsb2cvY29tbWFuZC1ibG9jay96b25nLWxhLWNoYS1kYW8ta3VhaS1zdS1jaGEtemhpLXFpdS16aGk=">$\blacktriangleright$<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数学杂项整理</title>
    <url>/maths/mathematics/</url>
    <content><![CDATA[<p>这里是一个数学杂项（也就是太短暂时写不成博客）的整理。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h1><p>参见 <strong>陈卓裕质数三大公理</strong> (<span class="exturl" data-url="aHR0cHM6Ly9rYW1vbWUubW9lL2luZGV4LnBocC8yMDIxLzA5LzI2L3RoZXlfY2hhbmdlZF9tYXRoLw==">Link is here<i class="fa fa-external-link-alt"></i></span>) 。</p>
<p>在 $[1,n]$范围内，质数个数的数量级是 $\dfrac{n}{\log n}$ 的，</p>
<p>即， $\pi(n) \sim O(\dfrac{n}{\log n})$</p>
<p>（此处的$\log$指的是$\ln$）</p>
<h1 id="组合计数"><a href="#组合计数" class="headerlink" title="组合计数"></a>组合计数</h1><h2 id="排列数"><a href="#排列数" class="headerlink" title="排列数"></a>排列数</h2><p>排列数，通常用 $A$ (Arrangement)来表示。<br>公式为：</p>
<p>$$<br>\begin{equation}<br>A^n_m &#x3D; \frac{n!}{(n-m)!}<br>\end{equation}<br>$$</p>
<p>还有以下递推式：</p>
<p>$$<br>A_n^m &#x3D; m \times A_{n-1}^{m-1} + A_{n-1}^m<br>$$</p>
<h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><p>组合数，通常用 $C$ (Conbination)来表示。</p>
<p>常见的表示方法有$\binom{m}{n}$ 和 $C^n_m$ 两种。</p>
<p>公式为：</p>
<p>$$<br>\begin{equation}<br>C^n_m &#x3D; \frac{A^n_m}{A^n_n} &#x3D; \frac{n!}{(n-m)!m!}<br>\end{equation}<br>$$</p>
<p>还有以下递推式：</p>
<p>$$<br>C_n^m &#x3D; C_{n-1}^{m-1} + C_{n-1}^m<br>$$</p>
<h3 id="快速计算组合数"><a href="#快速计算组合数" class="headerlink" title="快速计算组合数"></a>快速计算组合数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m &gt; n || m &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[n] * ifac[m] % mod * ifac[n - m] % mod;</span><br><span class="line">&#125;<span class="comment">//组合数</span></span><br></pre></td></tr></table></figure>

<h3 id="常见组合恒等式"><a href="#常见组合恒等式" class="headerlink" title="常见组合恒等式"></a>常见组合恒等式</h3><ul>
<li>$\displaystyle C_n^m &#x3D; C_n^{n-m}$</li>
</ul>
<p>因为</p>
<p>$$<br>C_n^m &#x3D; \frac{n!}{(n-m)!m!} &#x3D; \frac{n!}{(n-(n-m))!(n-m)!} &#x3D; C_n^{n-m}<br>$$</p>
<ul>
<li>$\displaystyle m \times C_n^m &#x3D; n \times C_{n-1}^{m-1}$</li>
</ul>
<p>因为</p>
<p>$$<br>m \times C_n^m &#x3D; \frac{n!}{(n-m)!(m-1)!} &#x3D; n \times \frac{(n-1)!}{(n-m)!(m-1)!} &#x3D; n \times C_{n-1}^{m-1}<br>$$</p>
<ul>
<li>$\displaystyle \sum_{i&#x3D;0}^n C_n^i &#x3D; 2^n$</li>
</ul>
<p>就类似于考虑每一个物品到底是选还是不选。</p>
<ul>
<li>$\displaystyle C_n^0 + C_n^2 + \cdots &#x3D; C_n^1 + C_n^3 + \cdots &#x3D; 2^{n-1} (n \geq 1)$</li>
</ul>
<p>跟上面的那个差不多。</p>
<ul>
<li>$\displaystyle \sum_{i&#x3D;0}^n (-1)^i C_n^i &#x3D; C_n^0 - C_n^1 + C_n^2 - C_n^3 + \cdots &#x3D; [ n&#x3D;&#x3D;0 ]$</li>
</ul>
<p>上面那个的衍生。</p>
<ul>
<li>$\displaystyle \sum_{i&#x3D;0}^k C_n^i \times C_m^{k-i} &#x3D; C_{n+m}^k$</li>
</ul>
<p>考虑将 $n+m$ 的一堆物品分为一堆 $n$ 的和一堆 $m$ 的，分别从两堆里面取。<br>然后分别考虑从两堆里面各挑出来几个物品。</p>
<ul>
<li>$\displaystyle \sum_{i&#x3D;0}^n (C_n^i)^2 &#x3D; C_{2n}^n$</li>
</ul>
<p>上面的那个的特殊化。<br>因为 $C_n^i &#x3D; C_n^{n-i}$，所以我们可以将其替换为这样的形式。</p>
<h1 id="上升幂与下降幂"><a href="#上升幂与下降幂" class="headerlink" title="上升幂与下降幂"></a>上升幂与下降幂</h1><h2 id="上升幂"><a href="#上升幂" class="headerlink" title="上升幂"></a>上升幂</h2><p>$$<br>x^{\bar{k}} &#x3D; \prod_{i&#x3D;i}^k (x+i-1)<br>$$</p>
<h2 id="下降幂"><a href="#下降幂" class="headerlink" title="下降幂"></a>下降幂</h2><p>$$<br>x^{\underline{k}} &#x3D; \prod_{i&#x3D;1}^k (x-i+1)<br>$$</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵</title>
    <url>/maths/matrix/</url>
    <content><![CDATA[<p>矩阵与矩阵相关运算。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<p>在数学中，矩阵是一种很重要的表现形式；在OI中，矩阵也是一种很重要的数据结构。<br>矩阵通常可以用在线性齐次递推式的加速上，比如说加速斐波那契数列的递推过程。<br>矩阵还可以让多个数据关联起来，并简便地进行区间维护。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>为了更好地区分矩阵与其他量，我们这里将代表矩阵的符号进行了特殊处理，就像这个样子：</p>
<p>$A \to \mathbf{A}$</p>
<h2 id="矩阵是什么"><a href="#矩阵是什么" class="headerlink" title="矩阵是什么"></a>矩阵是什么</h2><p>由 $n \times m$ 个元素组成的，形如<br>$$<br>\mathbf{A} &#x3D;<br>\begin{bmatrix}<br>a_{1,1} &amp; a_{1,2} &amp; a_{1,3} &amp; \dots &amp; a_{1,m} \\<br>a_{2,1} &amp; a_{2,2} &amp; a_{2,3} &amp; \dots &amp; a_{2,m} \\<br>a_{3,1} &amp; a_{3,2} &amp; a_{3,3} &amp; \dots &amp; a_{3,m} \\<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>a_{n,1} &amp; a_{n,2} &amp; a_{n,3} &amp; \dots &amp; a_{n,m}<br>\end{bmatrix}<br>$$<br>的 $n$ 行 $m$ 列的数表，我们称之为大小为 $n \times m$ 的矩阵，可以简记为 $\mathbf{A_{\mathcal{n \times m}}}$ 。</p>
<h2 id="特殊的矩阵"><a href="#特殊的矩阵" class="headerlink" title="特殊的矩阵"></a>特殊的矩阵</h2><p>特殊的矩阵由很多种，比如单位矩阵、上三角矩阵等等。</p>
<h3 id="行矩阵与列矩阵"><a href="#行矩阵与列矩阵" class="headerlink" title="行矩阵与列矩阵"></a>行矩阵与列矩阵</h3><p>行矩阵就是只有一行的矩阵，列矩阵就是只有一列的矩阵。</p>
<h3 id="零矩阵"><a href="#零矩阵" class="headerlink" title="零矩阵"></a>零矩阵</h3><p>元素全为 $0$ 的矩阵。<br>零矩阵简记为 $\mathbf{0}$。</p>
<h3 id="负矩阵"><a href="#负矩阵" class="headerlink" title="负矩阵"></a>负矩阵</h3><p>对于一个矩阵 $\mathbf{A}$ 的负矩阵 $-\mathbf{A}$，其中每个元素都与矩阵 $\mathbf{A}$ 内相同位置的元素互为相反数。</p>
<h3 id="方阵"><a href="#方阵" class="headerlink" title="方阵"></a>方阵</h3><p>方阵指的就是正方形的矩阵，其行数与列数相等。<br>此时，其行数（或列数，反正他们相等）就可以被称作该矩阵的阶。</p>
<p>简单来说，一个 $n$ 阶方阵 $\mathbf{A_{\mathcal{n}}}$ 其实就是相当于一个 $n \times n$ 的矩阵 $\mathbf{A_{\mathcal{n \times n}}}$。</p>
<h3 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h3><p>单位矩阵就是指，在主对角线上的元素都是 $1$，其余元素都为 $0$ 的矩阵。<br>主对角线就是指 $(1,1)$ 到 $(n,n)$。这也说明单位矩阵都是正方形的。</p>
<p>单位矩阵简记为 $\mathbf{I}$。</p>
<p>单位矩阵也有其相应的阶，比如1到4阶的单位矩阵分别是这个样子的：$\mathbf{I_{\mathrm{1}}}&#x3D;\begin{bmatrix}1\end{bmatrix}$，$\mathbf{I_{\mathrm{2}}}&#x3D;\begin{bmatrix}1&amp;\\&amp;1\end{bmatrix}$，$\mathbf{I_{\mathrm{3}}}&#x3D;\begin{bmatrix}1&amp;&amp;\\&amp;1&amp;\\&amp;&amp;1\end{bmatrix}$，$\mathbf{I_{\mathrm{4}}}&#x3D;\begin{bmatrix}1&amp;&amp;&amp;\\&amp;1&amp;&amp;\\&amp;&amp;1&amp;\\&amp;&amp;&amp;1\end{bmatrix}$。</p>
<p>形象一点，就是这样：<br>（为 $0$ 的元素太多时一般将其省略）</p>
<p>$$<br>\mathbf{I} &#x3D;<br>\begin{bmatrix}<br>1&amp; &amp; &amp; \\<br> &amp;1&amp; &amp; \\<br> &amp; &amp; \ddots &amp; \\<br> &amp; &amp; &amp;1<br>\end{bmatrix}<br>$$</p>
<p>单位矩阵的一个很重要的性质就是，任何矩阵乘以单位矩阵的结果还是其本身，即 $\mathbf{AI} &#x3D; \mathbf{IA} &#x3D; \mathbf{A}$。</p>
<p>有时候还可能将单位矩阵称为 $\mathbf{E}$，但是很少见，我目前还没有见过。</p>
<h2 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h2><p>矩阵可以进行四则运算，但是与正常的数字还是有所不同。</p>
<h3 id="加减"><a href="#加减" class="headerlink" title="加减"></a>加减</h3><p>矩阵的加减要求两个矩阵必须行数列数均相同才可以进行。</p>
<p>加减的时候，每一对位置相同的元素相加或者相减。</p>
<p>形象一点就是这个样子：</p>
<p>$$<br>\mathbf{A} \pm \mathbf{B}<br>&#x3D;<br>\begin{bmatrix}<br>a &amp; b &amp; c \\<br>d &amp; e &amp; f<br>\end{bmatrix}<br>\pm<br>\begin{bmatrix}<br>g &amp; h &amp; i \\<br>j &amp; k &amp; l<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>a \pm g &amp; b \pm h &amp; c \pm i \\<br>d \pm j &amp; e \pm k &amp; f \pm l<br>\end{bmatrix}<br>$$</p>
<p>矩阵的加法满足交换律和结合律。</p>
<h3 id="数乘"><a href="#数乘" class="headerlink" title="数乘"></a>数乘</h3><p>就是一个矩阵乘以一个数。</p>
<p>乘起来的时候，矩阵内的每一个元素都要乘以这个数。</p>
<p>形象一点就是这样：</p>
<p>$$<br>λ\mathbf{A}<br>&#x3D;<br>λ \times<br>\begin{bmatrix}<br>a &amp; b &amp; c \\<br>d &amp; e &amp; f<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>λa &amp; λb &amp; λc \\<br>λd &amp; λe &amp; λf<br>\end{bmatrix}<br>$$</p>
<p>矩阵的数乘满足交换律、结合律和分配律。</p>
<p>如果将刚才这个过程反过来的话，就叫做矩阵提公因子。</p>
<h3 id="点乘"><a href="#点乘" class="headerlink" title="点乘"></a>点乘</h3><p>点乘是矩阵运算中很重要的一部分。</p>
<p>点乘又叫做矩阵乘法，（基本上）是OI中矩阵的精髓。</p>
<p>矩阵乘法不满足交换律，是因为其需要满足左侧矩阵的列数与右侧矩阵的行数相等。</p>
<p>形象一点，就是 $\mathbf{A_{\mathcal{n \times p}}} \times \mathbf{B_{\mathcal{p \times m}}} &#x3D; \mathbf{C_{\mathcal{n \times m}}}$。</p>
<p>具体操作的时候是这个样子的：</p>
<p>我们以 $\mathbf{A_{\mathrm{3 \times 3}}} \times \mathbf{B_{\mathrm{3 \times 2}}}$ 为例。</p>
<p>$$<br>\begin{align}<br>&amp; \mathbf{A_{\mathrm{3 \times 3}}} \times \mathbf{B_{\mathrm{3 \times 2}}} \\<br>&#x3D;{} &amp;<br>\begin{bmatrix}<br>a_{1,1} &amp; a_{1,2} &amp; a_{1,3} \\ a_{2,1} &amp; a_{2,2} &amp; a_{2,3} \\ a_{3,1} &amp; a_{3,2} &amp; a_{3,3}<br>\end{bmatrix}<br>\times<br>\begin{bmatrix}<br>b_{1,1} &amp; b_{1,2} \\ b_{2,1} &amp; b_{2,2} \\ b_{3,1} &amp; b_{3,2}<br>\end{bmatrix}\\<br>&#x3D;{} &amp;<br>\begin{bmatrix}<br>a_{1,1}b_{1,1}+a_{1,2}b_{2,1}+a_{1,3}b_{3,1} &amp; a_{2,1}b_{1,1}+a_{2,2}b_{2,1}+a_{2,3}b_{3,1} &amp; a_{3,1}b_{1,1}+a_{3,2}b_{2,1}+a_{3,3}b_{3,1} \\<br>a_{1,1}b_{1,2}+a_{1,2}b_{2,2}+a_{1,3}b_{3,2} &amp; a_{2,1}b_{1,2}+a_{2,2}b_{2,2}+a_{2,3}b_{3,2} &amp; a_{3,1}b_{1,2}+a_{3,2}b_{2,2}+a_{3,3}b_{3,2}<br>\end{bmatrix}<br>\end{align}<br>$$</p>
<p>除了交换律以外，矩阵乘法只满足结合律和左、右分配律。</p>
<h3 id="幂"><a href="#幂" class="headerlink" title="幂"></a>幂</h3><p>矩阵的幂运算与正常的幂运算一样，都是自乘多少次，但是由于矩阵乘法的特殊性质，我们只能给方阵求幂。</p>
<p>$\mathbf{A^{\mathcal{k}}} &#x3D; \underbrace{\mathbf{AAAA \cdots AA}}_{\text{k of}}$</p>
<p>根据这种性质，我们可以像对数字一样进行快速幂，逻辑与之前一样。</p>
<h3 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h3><p>转置就是将一个矩阵顺时针旋转90度。</p>
<p>例：<br>$$<br>\begin{bmatrix}<br>1&amp;1&amp;4\\5&amp;1&amp;4<br>\end{bmatrix}^T<br>&#x3D;<br>\begin{bmatrix}<br>5&amp;1\\1&amp;1\\4&amp;4<br>\end{bmatrix}<br>$$</p>
<p>我们使用 $\mathbf{A}^T$ 来表示矩阵 $\mathbf{A}$ 的转置。</p>
<p>转置满足以下法则：<br>$$<br>\begin{align}<br>(\mathbf{A}^T)^T &amp;&#x3D; \mathbf{A} \\<br>(\lambda \mathbf{A})^T &amp;&#x3D; \lambda \mathbf{A}^T \\<br>(\mathbf{AB})^T &amp;&#x3D; \mathbf{B}^T \mathbf{A}^T<br>\end{align}<br>$$</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我们可以使用一个二维数组来存储矩阵。</p>
<p>就像这个样子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> a[N][N];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定义一个初始化函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Matrix</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">Matrix</span>(<span class="type">int</span> n, <span class="type">int</span> m) : <span class="built_in">n</span>(n), <span class="built_in">m</span>(m) &#123; <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a)) &#125;;</span><br></pre></td></tr></table></figure>

<p>重载一下运算符：</p>
<p>加：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> Matrix <span class="keyword">operator</span> + (<span class="type">const</span> Matrix &amp;lhs, <span class="type">const</span> Matrix &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">res</span><span class="params">(lhs.n, lhs.m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lhs.n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lhs.m; j++)</span><br><span class="line">            res.a[i][j] = lhs.a[i][j] + rhs.a[i][j];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乘：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> Matrix <span class="keyword">operator</span> * (<span class="type">const</span> Matrix &amp;lhs, <span class="type">const</span> Matrix &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">res</span><span class="params">(lhs.n, rhs.m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lhs.n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= rhs.m; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= lhs.m; k++)</span><br><span class="line">                res.a[i][j] += lhs.a[i][k] * rhs.a[k][j];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乘方（快速幂）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> Matrix <span class="keyword">operator</span> ^ (Matrix rhs, <span class="type">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">res</span><span class="params">(rhs.n, rhs.n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= rhs.n; i++)res.a[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) res = res * rhs;</span><br><span class="line">        rhs = rhs * rhs;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再继续加一些其他的重载运算符之后就是这个样子：</p>
<details class="note default"><summary><p>矩阵结构体</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> a[N][N];</span><br><span class="line">    <span class="built_in">Matrix</span>() &#123;&#125;;</span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="type">int</span> n, <span class="type">int</span> m) : <span class="built_in">n</span>(n), <span class="built_in">m</span>(m) &#123; <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a)) &#125;;</span><br><span class="line">    <span class="keyword">friend</span> Matrix <span class="keyword">operator</span> + (<span class="type">const</span> Matrix &amp;lhs, <span class="type">const</span> Matrix &amp;rhs)</span><br><span class="line">    &#123;<span class="comment">//加</span></span><br><span class="line">        <span class="function">Matrix <span class="title">res</span><span class="params">(lhs.n, lhs.m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lhs.n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lhs.m; j++)</span><br><span class="line">                res.a[i][j] = lhs.a[i][j] + rhs.a[i][j];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Matrix <span class="keyword">operator</span> - (<span class="type">const</span> Matrix &amp;lhs, <span class="type">const</span> Matrix &amp;rhs)</span><br><span class="line">    &#123;<span class="comment">//减</span></span><br><span class="line">        <span class="function">Matrix <span class="title">res</span><span class="params">(lhs.n, lhs.m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lhs.n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lhs.m; j++)</span><br><span class="line">                res.a[i][j] = lhs.a[i][j] - rhs.a[i][j];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> -() <span class="type">const</span></span><br><span class="line">    &#123;<span class="comment">//取反</span></span><br><span class="line">        <span class="function">Matrix <span class="title">res</span><span class="params">(n, m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">                res.a[i][j] = -a[i][j];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Matrix <span class="keyword">operator</span> * (<span class="type">const</span> Matrix &amp;lhs, <span class="type">const</span> Matrix &amp;rhs)</span><br><span class="line">    &#123;<span class="comment">//点乘</span></span><br><span class="line">        <span class="function">Matrix <span class="title">res</span><span class="params">(lhs.n, rhs.m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lhs.n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= rhs.m; j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= lhs.m; k++)</span><br><span class="line">                    res.a[i][j] += lhs.a[i][k] * rhs.a[k][j];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Matrix <span class="keyword">operator</span> * (<span class="type">const</span> Matrix &amp;lhs, <span class="type">int</span> k)</span><br><span class="line">    &#123;<span class="comment">//数乘</span></span><br><span class="line">        <span class="function">Matrix <span class="title">res</span><span class="params">(lhs.n, lhs.m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lhs.n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lhs.m; j++)</span><br><span class="line">                res.a[i][j] = lhs.a[i][j] * k;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Matrix <span class="keyword">operator</span> ^ (Matrix lhs, <span class="type">int</span> n)</span><br><span class="line">    &#123;<span class="comment">//快速幂</span></span><br><span class="line">        <span class="function">Matrix <span class="title">res</span><span class="params">(lhs.n, lhs.n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lhs.n; i++)res.a[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n &amp; <span class="number">1</span>) res = res * lhs;</span><br><span class="line">            lhs = lhs * lhs;</span><br><span class="line">            x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>

<p>但其实更常见的是这样子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> a[N][N];</span><br><span class="line">    <span class="built_in">Matrix</span>() &#123;&#125;;</span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="type">int</span> n, <span class="type">int</span> m) : <span class="built_in">n</span>(n), <span class="built_in">m</span>(m) &#123; <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a)) &#125;;</span><br><span class="line">    <span class="keyword">friend</span> Matrix <span class="keyword">operator</span> + (<span class="type">const</span> Matrix &amp;lhs, <span class="type">const</span> Matrix &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">res</span><span class="params">(lhs.n, lhs.m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lhs.n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lhs.m; j++)</span><br><span class="line">                res.a[i][j] = lhs.a[i][j] + rhs.a[i][j];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Matrix <span class="keyword">operator</span> * (<span class="type">const</span> Matrix &amp;lhs, <span class="type">const</span> Matrix &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">res</span><span class="params">(lhs.n, rhs.m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lhs.n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= rhs.m; j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= lhs.m; k++)</span><br><span class="line">                    res.a[i][j] += lhs.a[i][k] * rhs.a[k][j];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Matrix <span class="keyword">operator</span> ^ (Matrix lhs, <span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">res</span><span class="params">(lhs.n, lhs.n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lhs.n; i++)res.a[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n &amp; <span class="number">1</span>) res = res * lhs;</span><br><span class="line">            lhs = lhs * lhs;</span><br><span class="line">            x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="矩阵加速递推"><a href="#矩阵加速递推" class="headerlink" title="矩阵加速递推"></a>矩阵加速递推</h2><p>就以矩阵加速斐波那契数列递推为例吧。</p>
<p>我们将第 $n$ 项斐波那契数简写为 $F_n$。</p>
<p>我们知道 $F_n &#x3D; F_{n-1} + F_{n-2}$，我们就考虑把斐波那契数列的相邻两项放在一个行（或者列，根据个人习惯）矩阵里面，就像这个样子：$\begin{bmatrix}F_i&amp;F_{i-1}\end{bmatrix}$。</p>
<p>我们需要把 $\begin{bmatrix}F_i&amp;F_{i-1}\end{bmatrix}$ 变成 $\begin{bmatrix}F_{i-1}+F_i&amp;F_i\end{bmatrix}$，同时需要用到矩阵乘法。</p>
<p>因为<br>$$<br>\begin{bmatrix}<br>a &amp; b<br>\end{bmatrix}<br>\times<br>\begin{bmatrix}<br>x &amp; y\\<br>z &amp; w<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>ax+bz &amp; ay+bw<br>\end{bmatrix}<br>$$</p>
<p>所以我们如果想让 $\begin{bmatrix}a&amp;b\end{bmatrix}$ 变成 $\begin{bmatrix}a+b&amp;a\end{bmatrix}$ 的话，我们就需要将其乘以 $\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}$。</p>
<p>然后就是矩阵快速幂了。<br>因为我们一开始的 $\begin{bmatrix}1&amp;1\end{bmatrix}$ 是 $\begin{bmatrix}F_2&amp;F_1\end{bmatrix}$，所以我们只需要将其乘以 $\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}^{n-2}$ 即可得到 $F_n$。</p>
<h3 id="如何构建转移矩阵"><a href="#如何构建转移矩阵" class="headerlink" title="如何构建转移矩阵"></a>如何构建转移矩阵</h3><p>我们考虑我们是如何从一个状态转移到下一个状态的。</p>
<p>对于一个函数 $f(x)$，我们假定它具有这样的转移式子：</p>
<p>$$<br>f(x) &#x3D; f(x-1) + 2f(x-2) + 2^x + 2<br>$$</p>
<p>我们的状态矩阵就是这个样子的：$\begin{bmatrix}f(x)&amp;f(x-1)&amp;2^x&amp;1\end{bmatrix}$。</p>
<p>然后我们考虑我们如何从 $\begin{bmatrix}f(x-1)&amp;f(x-2)&amp;2^{x-1}&amp;1\end{bmatrix}$ 变为 $\begin{bmatrix}f(x)&amp;f(x-1)&amp;2^x&amp;1\end{bmatrix}$</p>
<p>我们将 $\begin{bmatrix}f(x)&amp;f(x-1)&amp;2^x&amp;1\end{bmatrix}$ 展开，得</p>
<p>$$<br>\begin{align}<br>f(x) &amp;&#x3D; f(x-1) \times 1 + f(x-2) \times 2 + 2^{x-1} \times 2 + 1 \times 2 \\<br>f(x-1) &amp;&#x3D; f(x-1) \times 1 + f(x-2) \times 0 + 2^{x-1} \times 0 + 1 \times 0 \\<br>2^x &amp;&#x3D; f(x-1) \times 0 + f(x-2) \times 0 + 2^{x-1} \times 2 + 1 \times 0 \\<br>1 &amp;&#x3D; f(x-1) \times 0 + f(x-2) \times 0 + 2^{x-1} \times 0 + 1 \times 1<br>\end{align}<br>$$</p>
<p>然后我们就可以得到我们的转移矩阵了：</p>
<p>$$<br>\begin{bmatrix}<br>1&amp;1&amp;0&amp;0\\<br>2&amp;0&amp;0&amp;0\\<br>2&amp;0&amp;2&amp;0\\<br>2&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$</p>
<h2 id="矩阵辅助维护信息"><a href="#矩阵辅助维护信息" class="headerlink" title="矩阵辅助维护信息"></a>矩阵辅助维护信息</h2><p>这种一般就是对于那种同时需要维护多种信息，还需要支持一大堆复杂的操作，但是推式子的时候不会超过一次的那种题，就比如说这一个：</p>
<p><a href="/solutions/solution-l2980/">THUSC 大魔法师</a></p>
<p>我们可以发现其操作（$A_i &#x3D; A_i + k$，$B_i &#x3D; B_i \times k$，$C_i &#x3D; k$）均未出现两个未知量相乘的情况，即可判定其可以利用矩阵乘法来维护。</p>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>特殊的数</title>
    <url>/maths/special-numbers/</url>
    <content><![CDATA[<p>简介： 卡特兰数，斯特林数，欧拉数，调和级数</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="卡特兰数-Catalan-Numbers"><a href="#卡特兰数-Catalan-Numbers" class="headerlink" title="卡特兰数(Catalan Numbers)"></a>卡特兰数(Catalan Numbers)</h1><p>卡特兰数 (<del>Català</del>Catalan Numbers) 十分常用，序列的开头是 $1,1,2,5,14,42,\cdots$</p>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>有关卡特兰数的例题有很多，其中最经典的是<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwNDQ=">下面这个<i class="fa fa-external-link-alt"></i></span>：</p>
<p>我们有 $n$ 个元素和一个栈。这 $n$ 各元素是 $[1,n]$ 的所有整数，并且以升序排列。</p>
<p>现在我们将所有的元素放入栈中，并最终让所有元素都出栈。栈的<code>pop()</code>和<code>push()</code>的顺序由你自己来决定，问有多少种可能的出栈顺序。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>我们显然可以看出，我们不能对着一个空的栈疯狂<code>pop()</code>，也不能对着一个空的进栈序列疯狂<code>push()</code>。<br>所以，每一个<code>pop()</code>操作必定对应着之前的一个<code>pop()</code>操作，且所有<code>pop()</code>操作的次数与<code>push()</code>操作的次数相等。</p>
<p>我们尝试将<code>push()</code>和<code>pop()</code>抽象为前缀和的形式。<br>我们可以将<code>push()</code>转化为<code>+1</code>，<code>pop()</code>转化为<code>-1</code>。<br>那么，我们的要求就是：</p>
<p>该序列的每一个前缀和必定大于等于0，且整个序列的和必定为0。</p>
<p>这就需要我们使用卡特兰数。</p>
<h2 id="求值"><a href="#求值" class="headerlink" title="求值"></a>求值</h2><p>我们这里使用 $c_n$ 来代表第 $n$ 项卡特兰数。</p>
<p>我们通常使用的都是单个的卡特兰数（除非有多组测试数据），所以这里首先给出了通项公式。</p>
<p>卡特兰数的通项公式是这个样子的：</p>
<p>$$<br>c_n&#x3D;\frac{C_{2n}^n}{n+1}<br>$$</p>
<p>如果需要生成卡特兰数数列，那么我们可以进行递推：</p>
<p>首先，$c_0&#x3D;c_1&#x3D;1$，这两个我们先自己手动输入进去。<br>之后我们可以根据这个递推公式来计算：</p>
<p>$$<br>c_n &#x3D; c_{n-1} \frac{4n-2}{n+1}<br>$$</p>
<p>我们需要注意，在 $n \in [ 0,16 ] $ 的时候可以只开<code>int</code>；在 $n \in [ 17,35 ] $ 的时候就需要开<code>long long</code>了；而当 $n \geq 36$ 的时候就只能使用高精度或者用 Python 来求了。</p>
<p>递推代码示例：</p>
<p>Python：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ans = <span class="number">1</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;项数：&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1:&quot;</span> + <span class="built_in">str</span>(ans))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">    ans = ans * (<span class="number">4</span> * i - <span class="number">2</span>) // (i + <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(i) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(ans))</span><br></pre></td></tr></table></figure>

<p>例题 <span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwNDQ=">Luogu P1044<i class="fa fa-external-link-alt"></i></span> 代码示例：</p>
<p>Python：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ans = <span class="number">1</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">    ans = ans * (<span class="number">4</span> * i - <span class="number">2</span>) // (i + <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(ans))</span><br></pre></td></tr></table></figure>

<p>C++：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        ans = ans * (<span class="number">4</span> * i - <span class="number">2</span>) / (i + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="斯特林数-Stirling-Numbers"><a href="#斯特林数-Stirling-Numbers" class="headerlink" title="斯特林数(Stirling Numbers)"></a>斯特林数(Stirling Numbers)</h1><p>斯特林数 (Stirling Numbers) 分为第一类斯特林数和第二类斯特林数。</p>
<p>我们使用 $s_1(n,k)$ 来表示第一类斯特林数，使用 $s_2(n,k)$ 来表示第二类斯特林数。<br>通常的表达方式是这样的：<br>使用 $\begin{bmatrix} n \\ k \end{bmatrix}$ 来表示第一类斯特林数，使用 $\begin{Bmatrix} n \\ k \end{Bmatrix}$ 来表示第二类斯特林数。<br>但是因为这个样子在 $ \LaTeX $ 里面并不好打，所以我就索性换了个表达方式，以便我能够打出来。</p>
<h2 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h2><p>第二类斯特林数比第一类更加常用（其实是所有这些数里除了组合数外最常用的），所以我们先介绍第二类斯特林数。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>第二类斯特林数 $s_2(n,k)$ $(n \geq k)$ 表示讲一个有 $n$ 件互不相同的物品的集合划分为 $k$ 个非空子集的方法数。</p>
<p>例：</p>
<p>$s_2(4,2)$ 有下列几种情况：</p>
<p>$$<br>\begin{align}<br>\{ 1 , 2 , 3 \} &amp; \cup \{ 4 \} \\<br>\{ 1 , 2 , 4 \} &amp; \cup \{ 3 \} \\<br>\{ 1 , 3 , 4 \} &amp; \cup \{ 2 \} \\<br>\{ 2 , 3 , 4 \} &amp; \cup \{ 1 \} \\<br>\{ 1 , 2 \} &amp; \cup \{ 3 , 4 \} \\<br>\{ 1 , 3 \} &amp; \cup \{ 2 , 4 \} \\<br>\{ 1 , 4 \} &amp; \cup \{ 2 , 3 \}<br>\end{align}<br>$$</p>
<p>所以 $s_2(4,2)&#x3D;7$ 。</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol>
<li><p>显而易见的，$s_2(n,1)&#x3D;1$ ，$s_2(n,n)&#x3D;1$ 。</p>
</li>
<li><p>特别的，我们规定 $s_2(0,0)&#x3D;1$ ，$s_2(n,0)&#x3D;0$ 。</p>
</li>
</ol>
<h3 id="求值-1"><a href="#求值-1" class="headerlink" title="求值"></a>求值</h3><p>我们从较小的 $k$ 来入手。</p>
<p>当 $k \leq 1$ 时 比较好办，我们可以通过上面两个显而易见的性质推出来。</p>
<p>而当 $k&#x3D;2$ 时，我们可以这样想：<br>一个物品不是放在一个篮子里面就是放在另一个篮子里面，所以 $n$ 个物品一共有 $n^2$ 中不同的划分方式。<br>而因为两个篮子不区分，且有着非空的要求，所以最终的划分方式就只有 $2^{n-1}-1$ 种了。<br>所以，</p>
<p>$$<br>s_2(n,k) &#x3D; 2^{n-1}-1 \quad (n&gt;0)<br>$$</p>
<p>或者使用更难打出来但更眼熟的方式：</p>
<p>$$<br>\begin{Bmatrix}<br>n \\ 2<br>\end{Bmatrix}<br>&#x3D; 2^{n-1}-1<br>$$</p>
<p>再来看 $k&gt;2$ 的情况。</p>
<p>我们仍然对每一个物品进行分析，只不过我们这次是倒序分析的。</p>
<p>对于最后的一个物品，我们可以将其单独分成一堆，也可以将其放入之前的 $n-1$ 个物品组成的 $k$ 堆中的一堆中。</p>
<p>对于前一个选择，我们有 $s_2(n-1,k-1)$ 中排列的方法；而对于后一种，我们有 $s_2(n-1,k)$ 中方法，最后还需乘以我们可以做出的选择数 $k$。</p>
<h4 id="递推式"><a href="#递推式" class="headerlink" title="递推式"></a>递推式</h4><p>所以总结一一下，我们有以下递推式：</p>
<p>$$<br>s_2(n,k) &#x3D; k · s_2(n-1,k) + s_2(n-1,k-1)<br>$$</p>
<p>或者使用更难打出来但更眼熟的表达方式：</p>
<p>$$<br>\begin{Bmatrix}<br>n \\ k<br>\end{Bmatrix}<br>&#x3D;<br>k<br>\begin{Bmatrix}<br>n-1 \\ k<br>\end{Bmatrix}<br>+<br>\begin{Bmatrix}<br>n-1 \\ k-1<br>\end{Bmatrix}<br>$$</p>
<h4 id="通项式"><a href="#通项式" class="headerlink" title="通项式"></a>通项式</h4><p>还有一种直接求的通项公式，是这个样子的：</p>
<p>$$<br>s_2(n,m)&#x3D;\sum_{i&#x3D;0}^m \frac{(-1)^{m-i} i^n}{i! (m-i)!}<br>$$</p>
<h2 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>第一类斯特林数 $s_1(n,k) (n \geq k)$ 也是一种描述将 $n$ 个互不相同的物品划分为 $k$ 个不同的轮换的方案。</p>
<p>所谓轮换，就是指像项链一样的环形排列，可以类比成把所有的元素像珠子一样穿到项链上。</p>
<p>比如说一个轮换 $[A,B,C,D]$，它有4种异构体：</p>
<p>$$<br>[A,B,C,D]&#x3D;[B,C,D,A]&#x3D;[C,D,A,B]&#x3D;[D,A,B,C]<br>$$</p>
<p>所以说对于 $s_1(4,2)$，有下列几种情况：</p>
<p>$$<br>\begin{align}<br>[ 1,2,3 ] [ 4 ] \quad [ 1,3,2 ] [ 4 ] \\<br>[ 1,2,4 ] [ 3 ] \quad [ 1,4,2 ] [ 3 ] \\<br>[ 1,3,4 ] [ 2 ] \quad [ 1,4,3 ] [ 2 ] \\<br>[ 2,3,4 ] [ 1 ] \quad [ 2,4,3 ] [ 1 ]<br>\end{align}<br>$$<br>$$<br>[ 1,2 ] [ 3,4 ] \quad<br>[ 1,3 ] [ 2,4 ] \quad<br>[ 1,4 ] [ 2,3 ]<br>$$</p>
<p>一共11种。</p>
<p>所以， $s_1(4,2)&#x3D;11$。</p>
<p>我们不难看出，$s_1(n,k) \geq s_2(n,k)$。</p>
<h3 id="求值-2"><a href="#求值-2" class="headerlink" title="求值"></a>求值</h3><p>我们仍然从较小的 $k$ 开始。</p>
<p>当 $k&#x3D;1$ 时，我们对于每一个空位考虑。第 $i$ 个空位可以随意选择 $n-i+1$ 个物品，总体就是 $\displaystyle \prod_{i&#x3D;1}^n (n-i+1)$，显而易见是 $(n-1)!$。<br>所以：</p>
<p>$$<br>s_1(n,1)&#x3D;(n-1)!<br>$$</p>
<p>当所有的轮换都至多含两个物品的时候，我们就会发现，此时的轮换与子集是等价的。<br>这种情况只能在 $k&#x3D;n-1$ 的时候成立，也就是说，<br>$$<br>\begin{align}<br>s_1(n,n) &amp;&#x3D; s_2(n,n) &#x3D; 1 \\<br>s_1(n,n-1) &amp;&#x3D; s_2(n,n-1) &#x3D; C^2_n<br>\end{align}<br>$$</p>
<h4 id="递推式-1"><a href="#递推式-1" class="headerlink" title="递推式"></a>递推式</h4><p>我们考虑一般的情况。</p>
<p>还是类似之前考虑 $s_2$ 时的方法，我们还是考虑最后一个元素。</p>
<p>对于这个元素，我们可以将其单独成堆，也可以将其放在之前的任意一个轮换里面。</p>
<p>显然，对于前者，我们有 $s_1(n-1,k-1)$ 种方案；对于后者，我们有 $s_1(n-1,k)$ 种方案，而这个物品有 $n-1$ 种放置的位置（指插在任意一个元素的后面），所以总共是这样的式子：</p>
<p>$$<br>s_1(n,k) &#x3D; (n-1) · s_1(n-1,k) + s_1(n-1,k-1)<br>$$</p>
<p>或者使用更难打出来但更眼熟的表达方式：</p>
<p>$$<br>\begin{bmatrix}<br>n \\ k<br>\end{bmatrix}<br>&#x3D;<br>(n-1)<br>\begin{bmatrix}<br>n-1 \\ k<br>\end{bmatrix}<br>+<br>\begin{bmatrix}<br>n-1 \\ k-1<br>\end{bmatrix}<br>$$</p>
<p>第一类斯特林数没有实用的通项公式。</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>L2759 蜜袋鼯（フクロモモンガ） 题解</title>
    <url>/solutions/solution-l2759/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name"><ruby>蜜袋鼯<rt>フクロモモンガ</rt></ruby></div>
<div id="problem-info-from">JOI 2014 Final T4</div>
<div id="problem-info-difficulty">none</div>
<div id="problem-info-color">#0e1d69</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yNzU5">LibreOJ L2759<i class="fa fa-external-link-alt"></i></span></li></ul></div>

<hr>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>首先我们考虑一下我们的策略。</p>
<p>无论给出何种方案，我们都需要遵守一个原则：非必要不爬升，且爬升时只爬升至足够飞过去的高度即可。</p>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>对于前半句，我们这样分析：</p>
<p>我们假设可以突破高度只能大于等于0的限制。</p>
<p>那我们就可以持续进行飞行操作，直到到达终点再向上爬到树顶。</p>
<p>也就是说，我们将我们的操作从一系列的“飞跃-爬升”操作变成了一串连续的飞跃操作和一个爬升操作。</p>
<p>显然，只要我们选择的路径一定，我们最后爬升的路程一定是一定的。<br>我们不妨设其为 $h$ 。</p>
<p>如果我们在这种情况下，选择在中间进行一次爬升操作，假设我们爬升的高度为 $h’$ 。<br>那么，我们到达最后的高度就是$H_N - h + h’$。</p>
<p>然而，我们总共还是爬升了 $h-h’+h’&#x3D;h$ 的高度，总共爬升操作所用的时间也是不变的。</p>
<p>更何况我们还会遇到到一棵树正上方时高度大于树高的时候，这时候我们就只能降低高度，而在最后多的时间来爬升刚才降低的那一段距离。<br>这会导致如果我们瞎爬升的话，结果会劣于非必要不爬升的结果。</p>
<p>那么对于后半句，我们这样分析：</p>
<p>假设一种极限情况，一路上的树一棵比一棵矮，且每一次从树顶开始飞行都会飞跃目标树。<br>那么如果我们选择爬升的高度太多，就会导致爬升高度的浪费。</p>
<p>我们完全可以选择一种极端的情况，那么就是让我们的高度保持为0即可。<br>我们在每次飞跃一条边（假设其为 $(u,v)$ ）时，我们如果之前已经保持了高度为0的话，我们就只需爬升 $w_{(u,v)}$ 的高度即可，即到达 $v$ 点时高度仍然为零。而如果我们仍有高度$x$的话，我们就爬升 <code>(x-w[(u,v)]&gt;=0)?0:(w[(u,v)]-x)</code> 即可。<br>如果按照这样操作的话，我们只会在达到高度为0之前的时候才可能下降高度以适配较低的树高，最终得到的就是最优的结果。</p>
<hr>
<p>之后对每一条边进行分析。</p>
<p>对于每一条边 $(u,v)$ ，会有以下四种情况：</p>
<ol>
<li>到达点正上方时的高度大于树高。<br>需要先向下爬到高度为 $h_v + w_{(u,v)}$ 的点才能从该边飞过，可以证明这是最优选择。</li>
<li>在飞行途中不得不落地。<br>我们无论如何都无法通过这一条边，只能在向有向图中加边时忽略这一条边。</li>
<li>不向上爬无法正常飞到下一个点。<br>根据上面的证明，我们只需向上爬升至高度 $w_{(u,v)}$ ，保证尽量靠近地面。</li>
<li>可以正常飞到下一个点。<br>直接飞跃即可。</li>
</ol>
<p>这样这个问题就变成了一个最短路问题。<br>而对于最短路的寻找，我们采用dijkstra算法。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">300005</span>;</span><br><span class="line"><span class="type">int</span> head[N], ne[M &lt;&lt; <span class="number">1</span>], to[M &lt;&lt; <span class="number">1</span>], cost[M &lt;&lt; <span class="number">1</span>], idx;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> add(a,b,c) to[++idx]=b,ne[idx]=head[a],head[a]=idx,cost[idx]=c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bianli(x) for(int i=head[x];i;i=ne[i])</span></span><br><span class="line"><span class="type">int</span> val[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">ll sum[N];</span><br><span class="line"><span class="type">int</span> H[N];</span><br><span class="line"><span class="type">bool</span> mark[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    ll v;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;A)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> v &gt; A.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> at)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)sum[i]=<span class="number">1e18</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123; <span class="number">0</span>,<span class="number">1</span> &#125;);</span><br><span class="line">    H[<span class="number">1</span>] = at;</span><br><span class="line">    sum[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    ll v;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        node now = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(mark[now.id])<span class="keyword">continue</span>;</span><br><span class="line">        mark[now.id] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> h = H[now.id];</span><br><span class="line">        <span class="built_in">bianli</span>(now.id)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(h - cost[i] &gt; val[to[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                v = sum[now.id] + h - cost[i] - val[to[i]] + cost[i];</span><br><span class="line">                <span class="keyword">if</span>(sum[to[i]] &gt; v)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum[to[i]] = v;</span><br><span class="line">                    H[to[i]] = val[to[i]];</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123; sum[to[i]],to[i] &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(h - cost[i] &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                v = sum[now.id] + cost[i] - h + cost[i];</span><br><span class="line">                <span class="keyword">if</span>(sum[to[i]] &gt; v)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum[to[i]] = v;</span><br><span class="line">                    H[to[i]] = <span class="number">0</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123; sum[to[i]],to[i] &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(sum[to[i]] &gt; sum[now.id] + cost[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    sum[to[i]] = sum[now.id] + cost[i];</span><br><span class="line">                    H[to[i]] = h - cost[i];</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123; sum[to[i]],to[i] &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> at;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;at);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;val[i]);</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">if</span>(val[a] &gt;= c)<span class="built_in">add</span>(a, b, c);</span><br><span class="line">        <span class="keyword">if</span>(val[b] &gt;= c)<span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>(at);</span><br><span class="line">    <span class="keyword">if</span>(sum[n] == <span class="number">1e18</span>)<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, sum[n] + val[n] - H[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>P1117 [NOI2016] 优秀的拆分 题解</title>
    <url>/solutions/solution-p1117/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">优秀的拆分</div>
<div id="problem-info-from">NOI 2016</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDExMTc=">Luogu P1117<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yMDgz">LibreOJ L2083<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAwOC8=">AcWing 1006<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly91b2ouYWMvcHJvYmxlbS8yMTk=">UOJ #219<i class="fa fa-external-link-alt"></i></span></li></ul></div>

<hr>
<div class="note warning"><p>本文图片出了一些大病，不建议点击放大。</p>
</div>

<p>据说暴力用哈希扫可以拿到95分。</p>
<p>这一道题的思路是这个样子的：</p>
<p>我们首先准备两个数组<code>a[]</code>和<code>b[]</code>，分别表示以 $i$ 结尾的形似AA的字串个数和以 $i$ 开头的形似AA的字串的个数，最终答案其实就是 $\displaystyle \sum_{i&#x3D;1}^n a[i] \times b[i+1]$。</p>
<p>然后考虑如何求出这两个数组。</p>
<p>对于每一个位置，我们尝试枚举一个 $len$，然后求出当前位置 $i$ 与 $i+len$ 位置处的 <code>lcp</code> 与 <code>lcs</code> 。</p>
<p>当两者长度加起来不小于 $len$ 的时候，就意味着我们可以找到至少一个长度为 $2len$ 的AA串。</p>
<p>为什么呢？</p>
<p>我们考虑从两个位置的 <code>lcs</code> 的开头处开始，分别向后截取出一段长度为 $len$ 的串。</p>
<p>如果这个串被两者的 <code>lcs</code> 和两者的 <code>lcp</code> 拼起来组成的一个字串覆盖，那么我们就可以把这两个串拼起来，形成一个长度为 $2len$ 的AA串。<br>就像这样：</p>
<img src="https://s2.loli.net/2022/03/22/mo9Hg7zp3YlCWjf.png" alt="p1117-1.png" width="60%" />

<p>当两者长度加起来不够 $len$ 时，我们截出来的两端字串就不保证一样。<br>不，应该是保证不一样，要不然两者的 <code>lcp</code> 还可以更长一点。<br>这样就拼不出来一个长度为 $2len$ 的AA串了。</p>
<img src="https://s2.loli.net/2022/03/22/1Yo3UAOuptlvKz5.png" alt="p1117-2.png" width="60%" />

<p>如果两者甚至有重合，那么我们就可以挑出来多个字串。我们这些会累积到后面。</p>
<img src="https://s2.loli.net/2022/03/22/EdSZAXvpG17hPYF.gif" alt="p1117-3.gif" width="60%" />

<p>就是这样。</p>
<p>简单来说，我们需要做的就是：</p>
<ol>
<li>枚举 $len$；这个操作的复杂度是 $O(n \log n)$</li>
<li>求 <code>lcp</code> 与 <code>lcs</code>；使用后缀数组即可。</li>
<li>区间加；差分即可。</li>
</ol>
<p>上代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1001000</span>;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line">ll a[N], b[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SuffixArray</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> S[N]; <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> cnt[N], sa[N], rk[N], height[N];</span><br><span class="line">    <span class="type">int</span> st[N][<span class="number">25</span>], lg2[N];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> id, x, y;</span><br><span class="line">    &#125;aa[N], bb[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">buildsa</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n = <span class="built_in">strlen</span>(S + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        <span class="built_in">memset</span>(height, <span class="number">0</span>, <span class="built_in">sizeof</span>(height));</span><br><span class="line">        <span class="built_in">memset</span>(sa, <span class="number">0</span>, <span class="built_in">sizeof</span>(sa));</span><br><span class="line">        <span class="built_in">memset</span>(rk, <span class="number">0</span>, <span class="built_in">sizeof</span>(rk));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) aa[i] = bb[i] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cnt[S[i]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">256</span>; i++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) rk[i] = cnt[S[i]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> L = <span class="number">1</span>; L &lt; n; L *= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) aa[i] = &#123; i,rk[i],rk[i + L] &#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cnt[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cnt[aa[i].y]++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--) bb[cnt[aa[i].y]--] = aa[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cnt[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cnt[aa[i].x]++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--) aa[cnt[bb[i].x]--] = bb[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                <span class="keyword">if</span>((aa[i].x == aa[i - <span class="number">1</span>].x) &amp;&amp; (aa[i].y == aa[i - <span class="number">1</span>].y))</span><br><span class="line">                    rk[aa[i].id] = rk[aa[i - <span class="number">1</span>].id];</span><br><span class="line">                <span class="keyword">else</span> rk[aa[i].id] = rk[aa[i - <span class="number">1</span>].id] + <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sa[rk[i]] = i; <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k) k--;</span><br><span class="line">            <span class="type">int</span> j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span>((i + k &lt;= n) &amp;&amp; (j + k &lt;= n) &amp;&amp; (S[i + k] == S[j + k])) k++;</span><br><span class="line">            height[rk[i]] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">buildst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lg2[<span class="number">0</span>] = <span class="number">-1</span>; <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++) lg2[i] = lg2[i / <span class="number">2</span>] + <span class="number">1</span>; lg2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) st[i][<span class="number">0</span>] = height[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++)</span><br><span class="line">                st[i][j] = <span class="built_in">min</span>(st[i][j - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Lcp</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        l = rk[l], r = rk[r];</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r) <span class="built_in">swap</span>(l, r); l++;</span><br><span class="line">        <span class="type">int</span> k = lg2[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(st[l][k], st[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;SA[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, SA[<span class="number">0</span>].S + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">strlen</span>(SA[<span class="number">0</span>].S + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = b[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            SA[<span class="number">1</span>].S[i] = SA[<span class="number">0</span>].S[n - i + <span class="number">1</span>];</span><br><span class="line">        SA[<span class="number">0</span>].<span class="built_in">buildsa</span>(), SA[<span class="number">1</span>].<span class="built_in">buildsa</span>();</span><br><span class="line">        SA[<span class="number">0</span>].<span class="built_in">buildst</span>(), SA[<span class="number">1</span>].<span class="built_in">buildst</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> Len = <span class="number">1</span>; Len &lt;= n / <span class="number">2</span>; Len++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = Len; i &lt;= n; i += Len)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> l = i, r = i + Len;</span><br><span class="line">                <span class="type">int</span> L = n - (r - <span class="number">1</span>) + <span class="number">1</span>, R = n - (l - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> lcp = SA[<span class="number">0</span>].<span class="built_in">Lcp</span>(l, r); lcp = <span class="built_in">min</span>(lcp, Len);</span><br><span class="line">                <span class="type">int</span> lcs = SA[<span class="number">1</span>].<span class="built_in">Lcp</span>(L, R); lcs = <span class="built_in">min</span>(lcs, Len - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(lcp + lcs &gt;= Len)</span><br><span class="line">                &#123;</span><br><span class="line">                    b[i - lcs]++, b[i - lcs + (lcp + lcs - Len + <span class="number">1</span>)]--;</span><br><span class="line">                    a[r + lcp - (lcp + lcs - Len + <span class="number">1</span>)]++, a[r + lcp]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] += a[i - <span class="number">1</span>], b[i] += b[i - <span class="number">1</span>];</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) ans += a[i] * b[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>L2980. [THUSCH 2017] 大魔法师 题解</title>
    <url>/solutions/solution-l2980/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">大魔法师</div>
<div id="problem-info-from">THUSCH 2017</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDc0NTM=">Luogu P7453<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yOTgw">LibreOJ L2980<i class="fa fa-external-link-alt"></i></span></li></ul></div>

<hr>
<p>首先看题：</p>
<p>题目要求我们在 $[ 1,n ]$ 的区间上维护三个值 $A_i,B_i,C_i$，要求支持查询区间和和下面六中操作：</p>
<ol>
<li>区间内 $A_i &#x3D; A_i + B_i$；</li>
<li>区间内 $B_i &#x3D; B_i + C_i$；</li>
<li>区间内 $C_i &#x3D; C_i + A_i$；</li>
<li>区间内 $A_i &#x3D; A_i + k$（$k$ 给定）；</li>
<li>区间内 $B_i &#x3D; B_i \times k$（$k$ 给定）；</li>
<li>区间内 $C_i &#x3D; k$（$k$ 给定）。</li>
</ol>
<p>显然这道题需要使用线段树来维护区间操作。<br>但是我们不能给每一个操作附上一个懒标记，最后懒标记下放的时候还不得麻烦死。</p>
<p>我们可以尝试一下转化一下我们的操作。</p>
<p>众所周知，一个矩阵乘以一个单位矩阵 $I$ 还等于它本身。<br>单位矩阵的形状是这样的：$\begin{bmatrix}1 &amp; &amp; &amp;\\ &amp; 1 &amp; &amp; \\ &amp; &amp; \ddots &amp; \\ &amp; &amp; &amp; 1 \end{bmatrix}$</p>
<p>如果我们将 $A_i,B_i,C_i$ 三个数值化作一个矩阵的话，那么这个矩阵 $\begin{bmatrix} A_i &amp; B_i &amp; C_i \end{bmatrix}$ 所对应的单位矩阵是这个样子的：$\begin{bmatrix}1&amp;&amp;\\&amp;1&amp;\\&amp;&amp;1\end{bmatrix}$。</p>
<p>而 $\begin{bmatrix} A_i &amp; B_i &amp; C_i \end{bmatrix}$ 想要变成 $\begin{bmatrix} A_i+B_i &amp; B_i &amp; C_i \end{bmatrix}$ 的话可以让它乘以一个 $\begin{bmatrix}1&amp;&amp;\\1&amp;1&amp;\\&amp;&amp;1\end{bmatrix}$。$(2,1)$ 处多出来的那个1就代表着给结果行矩阵的第<strong>1</strong>个位置加上<strong>1</strong>个原先的行矩阵矩阵第<strong>2</strong>个位置的值，也就相当于是给结果的 $A_i$ 加上了一个 $B_i$。</p>
<p>同理，第二个操作乘以的是一个 $\begin{bmatrix}1&amp;&amp;\\&amp;1&amp;\\&amp;1&amp;1\end{bmatrix}$，第三个操作乘以的是一个 $\begin{bmatrix}1&amp;&amp;1\\&amp;1&amp;\\&amp;&amp;1\end{bmatrix}$。</p>
<p>然后就是可恶的第四个操作。我们需要给 $A_i$ 加上一个 $k$，但是我们无法从刚才的房费里面推出来一个类似的方法。</p>
<p>于是我们可以考虑将我们维护的矩阵由 $\begin{bmatrix} A_i &amp; B_i &amp; C_i \end{bmatrix}$ 变为 $\begin{bmatrix} A_i &amp; B_i &amp; C_i &amp; 1 \end{bmatrix}$。<br>这样我们就只需要乘以一个 $\begin{bmatrix}1&amp;&amp;&amp;\\&amp;1&amp;&amp;\\&amp;&amp;1&amp;\\k&amp;&amp;&amp;1\end{bmatrix}$ 即可。</p>
<p>为了适配我们新的需要维护的矩阵，前面三个就变成了 $\begin{bmatrix}1&amp;&amp;&amp;\\1&amp;1&amp;&amp;\\&amp;&amp;1&amp;\\&amp;&amp;&amp;1\end{bmatrix}$，$\begin{bmatrix}1&amp;&amp;&amp;\\&amp;1&amp;&amp;\\&amp;1&amp;1&amp;\\&amp;&amp;&amp;1\end{bmatrix}$ 和 $\begin{bmatrix}1&amp;&amp;1&amp;\\&amp;1&amp;&amp;\\&amp;&amp;1&amp;\\&amp;&amp;&amp;1\end{bmatrix}$。</p>
<p>第五个操作的思路也很简单，只需要乘以一个 $\begin{bmatrix}1&amp;&amp;&amp;\\&amp;k&amp;&amp;\\&amp;&amp;1&amp;\\&amp;&amp;&amp;1\end{bmatrix}$ 即可。</p>
<p>第六个操作有点难，我们可以先把 $C_i$ 变成0，通过乘以一个 $\begin{bmatrix}1&amp;&amp;&amp;\\&amp;1&amp;&amp;\\&amp;&amp;&amp;\\&amp;&amp;&amp;1\end{bmatrix}$，然后再乘以一个 $\begin{bmatrix}1&amp;&amp;&amp;\\&amp;1&amp;&amp;\\&amp;&amp;1&amp;\\&amp;&amp;k&amp;1\end{bmatrix}$，就可以给 $C_i$ 赋成 $k$ 了。<br>最终效果跟直接乘以 $\begin{bmatrix}1&amp;&amp;&amp;\\&amp;1&amp;&amp;\\&amp;&amp;&amp;\\&amp;&amp;k&amp;1\end{bmatrix}$ 效果一样。</p>
<p>于是我们的线段树只需要维护一个区间乘和区间求和即可。</p>
<p>矩阵结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    ll a[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">Matrix</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="type">int</span> _n, <span class="type">int</span> _m) :<span class="built_in">n</span>(_n), <span class="built_in">m</span>(_m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> + (<span class="type">const</span> Matrix &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">res</span><span class="params">(n, m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">                res.a[i][j] = (a[i][j] + rhs.a[i][j]) % p;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> * (<span class="type">const</span> Matrix &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">res</span><span class="params">(n, rhs.m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= rhs.m; j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= m; k++)</span><br><span class="line">                    res.a[i][j] = (res.a[i][j] + a[i][k] * rhs.a[k][j]) % p;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>总代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">250010</span>;</span><br><span class="line"><span class="type">const</span> ll p = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    ll a[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">Matrix</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="type">int</span> _n, <span class="type">int</span> _m) :<span class="built_in">n</span>(_n), <span class="built_in">m</span>(_m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> + (<span class="type">const</span> Matrix &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">res</span><span class="params">(n, m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">                res.a[i][j] = (a[i][j] + rhs.a[i][j]) % p;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> * (<span class="type">const</span> Matrix &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">res</span><span class="params">(n, rhs.m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= rhs.m; j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= m; k++)</span><br><span class="line">                    res.a[i][j] = (res.a[i][j] + a[i][k] * rhs.a[k][j]) % p;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Matrix num[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    Matrix sum, tag;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">Matrix base1, base2, base3, base4, base5, base6;</span><br><span class="line">Matrix base;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[p], &amp;left = tr[p &lt;&lt; <span class="number">1</span>], &amp;rght = tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    left.sum = left.sum * root.tag;</span><br><span class="line">    rght.sum = rght.sum * root.tag;</span><br><span class="line">    left.tag = left.tag * root.tag;</span><br><span class="line">    rght.tag = rght.tag * root.tag;</span><br><span class="line">    root.tag = base;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].l = l, tr[p].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum = num[l];</span><br><span class="line">        tr[p].tag = base;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    tr[p].sum = tr[p &lt;&lt; <span class="number">1</span>].sum + tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">    tr[p].tag = base;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">segadd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, Matrix k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].tag = tr[p].tag * k;</span><br><span class="line">        tr[p].sum = tr[p].sum * k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)<span class="built_in">segadd</span>(p &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)<span class="built_in">segadd</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">    tr[p].sum = tr[p &lt;&lt; <span class="number">1</span>].sum + tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">segsum</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)<span class="keyword">return</span> tr[p].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="function">Matrix <span class="title">res</span><span class="params">(<span class="number">4</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res = res + <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)res = res + <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    base = <span class="built_in">Matrix</span>(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">        base.a[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    base1:| base2:| base3:</span></span><br><span class="line"><span class="comment">    1 0 0 | 1 0 0 | 1 0 1</span></span><br><span class="line"><span class="comment">    1 1 0 | 0 1 0 | 0 1 0</span></span><br><span class="line"><span class="comment">    0 0 1 | 0 1 1 | 0 0 1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    base1 = base;</span><br><span class="line">    base1.a[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    base2 = base;</span><br><span class="line">    base2.a[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    base3 = base;</span><br><span class="line">    base3.a[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    base4:  | base5:  | base6:</span></span><br><span class="line"><span class="comment">    1 0 0 0 | 1 0 0 0 | 1 0 0 0</span></span><br><span class="line"><span class="comment">    0 1 0 0 | 0 v 0 0 | 0 1 0 0</span></span><br><span class="line"><span class="comment">    0 0 1 0 | 0 0 1 0 | 0 0 0 0</span></span><br><span class="line"><span class="comment">    v 0 0 1 | 0 0 0 1 | 0 0 v 1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    base4 = base;</span><br><span class="line">    base5 = base;</span><br><span class="line">    base6 = base;</span><br><span class="line">    base6.a[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        num[i] = <span class="built_in">Matrix</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;num[i].a[<span class="number">1</span>][<span class="number">1</span>], &amp;num[i].a[<span class="number">1</span>][<span class="number">2</span>], &amp;num[i].a[<span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">        num[i].a[<span class="number">1</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op, l, r, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">segadd</span>(<span class="number">1</span>, l, r, base1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">segadd</span>(<span class="number">1</span>, l, r, base2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">segadd</span>(<span class="number">1</span>, l, r, base3);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v);</span><br><span class="line">            base4.a[<span class="number">4</span>][<span class="number">1</span>] = v;</span><br><span class="line">            <span class="built_in">segadd</span>(<span class="number">1</span>, l, r, base4);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v);</span><br><span class="line">            base5.a[<span class="number">2</span>][<span class="number">2</span>] = v;</span><br><span class="line">            <span class="built_in">segadd</span>(<span class="number">1</span>, l, r, base5);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v);</span><br><span class="line">            base6.a[<span class="number">4</span>][<span class="number">3</span>] = v;</span><br><span class="line">            <span class="built_in">segadd</span>(<span class="number">1</span>, l, r, base6);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">7</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Matrix res = <span class="built_in">segsum</span>(<span class="number">1</span>, l, r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld %lld\n&quot;</span>, res.a[<span class="number">1</span>][<span class="number">1</span>], res.a[<span class="number">1</span>][<span class="number">2</span>], res.a[<span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P1486 [NOI2004] 郁闷的出纳员 题解</title>
    <url>/solutions/solution-p1486/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">郁闷的出纳员</div>
<div id="problem-info-from">NOI 2004</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDE0ODY=">Luogu P1486<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8xMDE0NQ==">LibreOJ L10145<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvOTUwLw==">AcWing 950<i class="fa fa-external-link-alt"></i></span></li></ul></div>

<hr>
<p>这道题要求我们完成两个操作：插入和查询。</p>
<p>我们最多分别有 $10^5$ 次插入和 $10^5$ 次查询。<br>而在通常是方法中，查询和插入的复杂度都是很高的，尤其是查询前还需要进行一次排序。</p>
<p>所以我们需要降低复杂度。</p>
<p>正好，平衡树可以帮助我们减轻这个负担。</p>
<p>我们尝试使用平衡树来维护一个有序的序列，以避免任何不必要的排序操作，城区排序需要的复杂度。</p>
<p>FHQ的无旋Treap可以过，具体实现见<span class="exturl" data-url="aHR0cHM6Ly9vaS5iYW9zaHVvLnJlbi9sdW9ndS1wMTQ4Ni8=">这篇博客<i class="fa fa-external-link-alt"></i></span>；STL貌似也能水过，具体实现见<span class="exturl" data-url="aHR0cHM6Ly9vaS5iYW9zaHVvLnJlbi9sdW9ndS1wMTQ4Ni8=">这篇博客<i class="fa fa-external-link-alt"></i></span>；而我们这里采用的是Splay。</p>
<p>对于插入，我们就像平常插入一样，不断递归直到可以插入为止。<br>同时注意：如果这个员工还没有来就发现自己的工资不足工资下界，那么他就不会来了。我们直接忽略即可。</p>
<p>对于修改工资，我们存储一个 $\Delta$ 以方便随时加减工资。<br>假设某个员工的工资是 $k$ ，那么我们存到平衡树里面的数据是 $k - \Delta$。<br>$\Delta$ 初始为0，我们每次加工资或减工资只需要对 $\Delta$ 进行更改就可以了。</p>
<p>同时我们还需要注意离职的员工。每一次减工资的时候，我们都需要看一下有哪些员工需要离职。<br>方法很简单：查找工资下界对应的节点——旋上来——清空子树。</p>
<p>对于查找，我们只需要在平衡树的节点上面维护一个 $size$，到时候直接查找就行了。<br>查找的思路是这个样子的：<br>我们使用一个参数 $k$，从根节点开始搜索。<br>当当前的左子树的 $size \geq k$ 时，证明我们的目标节点在左子树里面，我们递归搜索左子树。<br>如果当前的左子树的 $size + 1 &#x3D; k$ 时，证明我们的目标节点就是我们当前搜索到的节点，直接<code>return</code>。<br>其他情况就是证明我们的目标节点在右子树里面，我们把当前的 $k$ 减去左子树的 $size$，再减去代表当前节点的 $1$，然后带着新的 $k$ 去递归搜索右子树。</p>
<p>上代码：</p>
<div class="note warning"><p>注意：我这里使用了非ASCII字符<code>Δ</code>做变量名，这种情况下只能在C++20的情况下通过编译，请根据需要修改变量名。</p>
</div>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n, m, Δ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s[<span class="number">2</span>], p, v;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> _v, <span class="type">int</span> _p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        v = _v, p = _p;</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> root, idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].size = tr[tr[x].s[<span class="number">0</span>]].size + tr[tr[x].s[<span class="number">1</span>]].size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> y = tr[x].p, z = tr[y].p;</span><br><span class="line">    <span class="type">int</span> k = tr[y].s[<span class="number">1</span>] == x;</span><br><span class="line">    tr[z].s[tr[z].s[<span class="number">1</span>] == y] = x, tr[x].p = z;</span><br><span class="line">    tr[y].s[k] = tr[x].s[k ^ <span class="number">1</span>], tr[tr[x].s[k ^ <span class="number">1</span>]].p = y;</span><br><span class="line">    tr[x].s[k ^ <span class="number">1</span>] = y, tr[y].p = x;</span><br><span class="line">    <span class="built_in">pushup</span>(y), <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(tr[x].p != k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = tr[x].p, z = tr[y].p;</span><br><span class="line">        <span class="keyword">if</span>(z != k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((tr[y].s[<span class="number">1</span>] == x) ^ (tr[z].s[<span class="number">1</span>] == y))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">rotate</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">rotate</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!k) root = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = root, p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(u) p = u, u = tr[u].s[v &gt; tr[u].v];</span><br><span class="line">    u = ++idx;</span><br><span class="line">    <span class="keyword">if</span>(p) tr[p].s[v &gt; tr[p].v] = u;</span><br><span class="line">    tr[u].<span class="built_in">init</span>(v, p);</span><br><span class="line">    <span class="built_in">splay</span>(u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = root, res;</span><br><span class="line">    <span class="keyword">while</span>(u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[u].v &gt;= v)</span><br><span class="line">        &#123;</span><br><span class="line">            res = u;</span><br><span class="line">            u = tr[u].s[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            u = tr[u].s[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_k</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[tr[u].s[<span class="number">0</span>]].size &gt;= k)</span><br><span class="line">        &#123;</span><br><span class="line">            u = tr[u].s[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tr[tr[u].s[<span class="number">0</span>]].size + <span class="number">1</span> == k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> tr[u].v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            k -= tr[tr[u].s[<span class="number">0</span>]].size + <span class="number">1</span>;</span><br><span class="line">            u = tr[u].s[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="type">int</span> L = <span class="built_in">insert</span>(-INF), R = <span class="built_in">insert</span>(INF);</span><br><span class="line">    <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, &amp;op, &amp;k);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k &gt;= m)</span><br><span class="line">            &#123;</span><br><span class="line">                k -= Δ;</span><br><span class="line">                <span class="built_in">insert</span>(k);</span><br><span class="line">                tot++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Δ += k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Δ -= k;</span><br><span class="line">            R = <span class="built_in">get</span>(m - Δ);</span><br><span class="line">            <span class="built_in">splay</span>(R, <span class="number">0</span>), <span class="built_in">splay</span>(L, R);</span><br><span class="line">            tr[L].s[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">pushup</span>(L), <span class="built_in">pushup</span>(R);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[root].size - <span class="number">2</span> &lt; k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">get_k</span>(tr[root].size - k) + Δ);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tot - (tr[root].size - <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>P1251 餐巾计划问题 题解</title>
    <url>/solutions/solution-p1251/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">餐巾计划问题</div>
<div id="problem-info-from">网络流24题</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEyNTE=">Luogu P1251<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC82MDA4">LibreOJ L6008<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjE4Ni8=">AcWing 2184<i class="fa fa-external-link-alt"></i></span></li></ul></div>

<hr>
<p>题目要求我们安排餐巾的清洗分配。</p>
<p>可能是戴森球计划搭产线搭多了吧，这道题我一开始就把餐巾从一个地方到另一个地方（如从餐厅到快洗部）想成了一道流。</p>
<p>我们就可以把餐厅向快洗部和慢洗部连边。</p>
<p>但是呢，我们还需要处理快洗部和慢洗部需要的时间问题，还有处理所有的延时送洗的操作。</p>
<p>我们于是就考虑将每天的餐厅拆成不同的点。<br>当然，每天的快洗部和慢洗部也需要拆成不同的点。</p>
<p>这样就可以保证我们可以让餐巾进行时间穿梭了，而不再是只局限于一天之内。</p>
<p>还有，我们需要将餐巾进行最大化利用来省钱，毕竟每多存在一块餐巾，就多需要花费我们 $p$ 分钱。</p>
<p>我们考虑将拆分后的餐厅继续拆分，拆成一个输入和一个输出。输入代表今天餐厅的餐巾到底是从哪里运过来的，而输出就代表今天使用的餐巾的最终去处。</p>
<p>这时候，我们就已经需要了 $4n$ 个点了（不包括源点和汇点），其中餐厅输入，餐厅输出，快洗部和慢洗部各 $n$ 个点。</p>
<p>但是我们考虑简化一下。</p>
<p>我们考虑省去快洗部和慢洗部，可以看做自己内部员工洗干净了。<br>这样，我们可以直接连接某一天的输出和另一天的输入了。</p>
<p>最后开始连边。</p>
<ol>
<li>源点与餐厅输出连一条容量为当天用量，费用为0的边；</li>
<li>汇点与餐厅输入连一条容量为当天用量，费用为0的边；</li>
<li>餐厅输出与下一日的餐厅输出连一条容量为无限，费用为0的边。</li>
<li>源点与餐厅输入连一条容量为无限，费用为 $p$ 的边；</li>
<li>餐厅输出与 $n$ 天后的餐厅输入连一条容量为无限，费用为 $s$ 的边，代表快洗部；</li>
<li>餐厅输出与 $m$ 天后的餐厅输入连一条容量为无限，费用为 $f$ 的边，代表慢洗部。</li>
</ol>
<p>然后跑一个最小费用最大流即可，最终的费用就是答案。</p>
<p>上代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5010</span>, M = <span class="number">100010</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">int</span> p, x, xp, y, yp;</span><br><span class="line"><span class="type">int</span> need[N];</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="type">int</span> h[N], e[M], f[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> q[N], d[N], pre[N], incf[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a]; h[a] = idx++;</span><br><span class="line">    e[idx] = a, f[idx] = <span class="number">0</span>, w[idx] = -d, ne[idx] = h[b], h[b] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="built_in">memset</span>(incf, <span class="number">0</span>, <span class="keyword">sizeof</span> incf);</span><br><span class="line">    q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, incf[S] = INF;</span><br><span class="line">    <span class="keyword">while</span>(hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh == N) hh = <span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ver = e[i];</span><br><span class="line">            <span class="keyword">if</span>(f[i] &amp;&amp; d[ver] &gt; d[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[ver] = d[t] + w[i];</span><br><span class="line">                pre[ver] = i;</span><br><span class="line">                incf[ver] = <span class="built_in">min</span>(f[i], incf[t]);</span><br><span class="line">                <span class="keyword">if</span>(!st[ver])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++] = ver;</span><br><span class="line">                    <span class="keyword">if</span>(tt == N) tt = <span class="number">0</span>;</span><br><span class="line">                    st[ver] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incf[T] &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">EK</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = incf[T];</span><br><span class="line">        cost += t * d[T];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = T; i != S; i = e[pre[i] ^ <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            f[pre[i]] -= t;</span><br><span class="line">            f[pre[i] ^ <span class="number">1</span>] += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    S = <span class="number">0</span>, T = n * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;need[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld%lld&quot;</span>, &amp;p, &amp;x, &amp;xp, &amp;y, &amp;yp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> r = need[i];</span><br><span class="line">        <span class="built_in">add</span>(S, i, r, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">add</span>(n + i, T, r, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">add</span>(S, n + i, INF, p);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; n) <span class="built_in">add</span>(i, i + <span class="number">1</span>, INF, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(i + x &lt;= n) <span class="built_in">add</span>(i, n + i + x, INF, xp);</span><br><span class="line">        <span class="keyword">if</span>(i + y &lt;= n) <span class="built_in">add</span>(i, n + i + y, INF, yp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">EK</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>P1505 [国家集训队] 旅游 题解</title>
    <url>/solutions/solution-p1505/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">旅游</div>
<div id="problem-info-from">国家集训队</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDE1MDU=">Luogu P1505<i class="fa fa-external-link-alt"></i></span></li></ul></div>

<hr>
<p>题目给定一棵 n 个节点的树，边带权，编号 $0 \sim n-1$，需要我们支持五种操作：</p>
<ul>
<li><code>C i w</code> 将输入的第 $i$ 条边权值改为 $w$</li>
<li><code>N u v</code> 将 $u,v$ 节点之间的边权都变为相反数</li>
<li><code>SUM u v</code> 询问 $u,v$ 节点之间边权和</li>
<li><code>MAX u v</code> 询问 $u,v$ 节点之间边权最大值</li>
<li><code>MIN u v</code> 询问 $u,v$ 节点之间边权最小值</li>
</ul>
<p>我们可以使用树剖来解决这个问题。</p>
<p>但是树剖作用的是点权，而我们可以使用边权转点权的方法来解决。</p>
<p>我们将边权转入其下方的节点里面，在访问的时候忽略掉最顶端的节点即可。</p>
<p>还有区间取反。</p>
<p>我们考虑使用一个懒标记来异或维护一下，当我们需要访问的时候就让min和max取反并互换即可。</p>
<p>上代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> cnt, h[N], e[N &lt;&lt; <span class="number">1</span>], ne[N &lt;&lt; <span class="number">1</span>], val[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> idx, fa[N], son[N], top[N], dep[N], dfn[N], sz[N], tmp[N], w[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum, max, min, tag;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">3</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;id[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[++cnt] = h[x]; e[cnt] = y; val[cnt] = w; h[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[x] = dep[f] + <span class="number">1</span>; fa[x] = f; sz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[x]; i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i];</span><br><span class="line">        <span class="keyword">if</span>(v == f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v, x);</span><br><span class="line">        tmp[v] = val[i];</span><br><span class="line">        sz[x] += sz[v];</span><br><span class="line">        <span class="keyword">if</span>(sz[son[x]] &lt; sz[v]) son[x] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> topf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x] = ++idx; w[idx] = tmp[x]; top[x] = topf;</span><br><span class="line">    <span class="keyword">if</span>(son[x]) <span class="built_in">dfs2</span>(son[x], topf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[x]; i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i];</span><br><span class="line">        <span class="keyword">if</span>(v == fa[x] || v == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].sum = tr[p &lt;&lt; <span class="number">1</span>].sum + tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">    tr[p].max = <span class="built_in">max</span>(tr[p &lt;&lt; <span class="number">1</span>].max, tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].max);</span><br><span class="line">    tr[p].min = <span class="built_in">min</span>(tr[p &lt;&lt; <span class="number">1</span>].min, tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].min);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[p], &amp;left = tr[p &lt;&lt; <span class="number">1</span>], &amp;rght = tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    left.tag ^= <span class="number">1</span>; rght.tag ^= <span class="number">1</span>;</span><br><span class="line">    left.sum = -left.sum; rght.sum = -rght.sum;</span><br><span class="line">    left.max = -left.max; rght.max = -rght.max;</span><br><span class="line">    left.min = -left.min; rght.min = -rght.min;</span><br><span class="line">    <span class="built_in">swap</span>(left.max, left.min);</span><br><span class="line">    <span class="built_in">swap</span>(rght.max, rght.min);</span><br><span class="line">    root.tag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].l = l, tr[p].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum = tr[p].max = tr[p].min = w[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((tr[p].l == q) &amp;&amp; (tr[p].r == q))</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum = tr[p].max = tr[p].min = k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].tag) <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(q &lt;= mid) <span class="built_in">change</span>(p &lt;&lt; <span class="number">1</span>, q, k);</span><br><span class="line">    <span class="keyword">if</span>(q &gt; mid)  <span class="built_in">change</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, q, k);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">segrev</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((l &lt;= tr[p].l) &amp;&amp; (r &gt;= tr[p].r))</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].tag ^= <span class="number">1</span>;</span><br><span class="line">        tr[p].sum = -tr[p].sum;</span><br><span class="line">        tr[p].max = -tr[p].max;</span><br><span class="line">        tr[p].min = -tr[p].min;</span><br><span class="line">        <span class="built_in">swap</span>(tr[p].max, tr[p].min);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].tag) <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">segrev</span>(p &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)  <span class="built_in">segrev</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">segsum</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((l &lt;= tr[p].l) &amp;&amp; (r &gt;= tr[p].r))<span class="keyword">return</span> tr[p].sum;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].tag)<span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res += <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)res += <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">segmax</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((l &lt;= tr[p].l) &amp;&amp; (r &gt;= tr[p].r))<span class="keyword">return</span> tr[p].max;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">-2147483647</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].tag)<span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res = <span class="built_in">max</span>(res, <span class="built_in">segmax</span>(p &lt;&lt; <span class="number">1</span>, l, r));</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)res = <span class="built_in">max</span>(res, <span class="built_in">segmax</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">segmin</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((l &lt;= tr[p].l) &amp;&amp; (r &gt;= tr[p].r))<span class="keyword">return</span> tr[p].min;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">2147483647</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].tag)<span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res = <span class="built_in">min</span>(res, <span class="built_in">segmin</span>(p &lt;&lt; <span class="number">1</span>, l, r));</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)res = <span class="built_in">min</span>(res, <span class="built_in">segmin</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">revpath</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="built_in">segrev</span>(<span class="number">1</span>, dfn[top[x]], dfn[x]);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &gt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">if</span>(x != y) <span class="built_in">segrev</span>(<span class="number">1</span>, dfn[x] + <span class="number">1</span>, dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">sumpath</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        res += <span class="built_in">segsum</span>(<span class="number">1</span>, dfn[top[x]], dfn[x]);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &gt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">if</span>(x != y) res += <span class="built_in">segsum</span>(<span class="number">1</span>, dfn[x] + <span class="number">1</span>, dfn[y]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">maxpath</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">-2147483647</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">segmax</span>(<span class="number">1</span>, dfn[top[x]], dfn[x]));</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &gt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">if</span>(x != y) res = <span class="built_in">max</span>(res, <span class="built_in">segmax</span>(<span class="number">1</span>, dfn[x] + <span class="number">1</span>, dfn[y]));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">minpath</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">2147483647</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        res = <span class="built_in">min</span>(res, <span class="built_in">segmin</span>(<span class="number">1</span>, dfn[top[x]], dfn[x]));</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &gt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">if</span>(x != y) res = <span class="built_in">min</span>(res, <span class="built_in">segmin</span>(<span class="number">1</span>, dfn[x] + <span class="number">1</span>, dfn[y]));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(++a, ++b, c);</span><br><span class="line">        <span class="built_in">add</span>(b, a, c);</span><br><span class="line">        id[i].x = a;</span><br><span class="line">        id[i].y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> s[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%lld%lld&quot;</span>, s, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> target;</span><br><span class="line">            <span class="keyword">if</span>(dep[id[a].x] &gt; dep[id[a].y]) target = id[a].x;</span><br><span class="line">            <span class="keyword">else</span> target = id[a].y;</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>, dfn[target], b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;N&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">revpath</span>(++a, ++b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">sumpath</span>(++a, ++b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;M&#x27;</span> &amp;&amp; s[<span class="number">1</span>] == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">maxpath</span>(++a, ++b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;M&#x27;</span> &amp;&amp; s[<span class="number">1</span>] == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">minpath</span>(++a, ++b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>P1712 [NOI2016] 区间 题解</title>
    <url>/solutions/solution-p1712/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">区间</div>
<div id="problem-info-from">NOI 2016</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDE3MTI=">Luogu P1712<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yMDg2">LibreOJ L2086<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAxMS8=">AcWing 1009<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzQ2NTM=">BZOJ #4653<i class="fa fa-external-link-alt"></i></span></li></ul></div>

<hr>
<p>既然题目没有规定覆盖的顺序，且想让我们最小化选定的区间长度的极差，那我们不妨就先按照区间长度排一个序。</p>
<p>这一道题中的区间长度计算方式是 $l_i - r_i$，但是无伤大雅，毕竟我们按照比较常见的方式计算之后的结果会将1约掉，使得最后的结果没有差别。</p>
<p>之后，我们考虑一下如何枚举答案，最朴素的做法就是利用尺取法来不断判断现在选出的区间是否满足了要求，满足了就更新一下答案。<br>更新完答案之后，我们将左端点右移到不满足条件了就可以了。</p>
<p>最后我们考虑区间覆盖的时候如何快速判断是否符合要求，答案是线段树维护区间最大值。<br>当然，我们这里值域太大了，需要进行一发离散化。</p>
<p>于是我们就顺利地解决了这个问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> max, tag;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].max = <span class="built_in">max</span>(tr[p &lt;&lt; <span class="number">1</span>].max, tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].tag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;root = tr[p], &amp;left = tr[p &lt;&lt; <span class="number">1</span>], &amp;rght = tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">        left.tag += root.tag;</span><br><span class="line">        left.max += root.tag;</span><br><span class="line">        rght.tag += root.tag;</span><br><span class="line">        rght.max += root.tag;</span><br><span class="line">        root.tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].l = l, tr[p].r = r;</span><br><span class="line">    tr[p].max = tr[p].tag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">segadd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].max += k;</span><br><span class="line">        tr[p].tag += k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)<span class="built_in">segadd</span>(p &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)<span class="built_in">segadd</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">query</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> query &amp;a)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> len &lt; a.len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="type">int</span> x[N &lt;&lt; <span class="number">1</span>], idx;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;dic;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a[i].l, &amp;a[i].r);</span><br><span class="line">        a[i].len = a[i].r - a[i].l;</span><br><span class="line">        x[i * <span class="number">2</span> - <span class="number">2</span>] = a[i].l, x[i * <span class="number">2</span> - <span class="number">1</span>] = a[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(x, x + <span class="number">2</span> * n);</span><br><span class="line">    idx = <span class="built_in">unique</span>(x, x + <span class="number">2</span> * n) - x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++)</span><br><span class="line">        dic.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(x[i], i + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, idx);</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = dic[a[i].l], r = dic[a[i].r];</span><br><span class="line">        <span class="built_in">segadd</span>(<span class="number">1</span>, l, r, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(tr[<span class="number">1</span>].max &gt;= m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(tr[<span class="number">1</span>].max &gt;= m &amp;&amp; hh &lt;= n)</span><br><span class="line">            &#123;</span><br><span class="line">                hh++;</span><br><span class="line">                <span class="type">int</span> hl = dic[a[hh].l], hr = dic[a[hh].r];</span><br><span class="line">                <span class="built_in">segadd</span>(<span class="number">1</span>, hl, hr, <span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, a[i].len - a[hh].len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">0x3f3f3f3f</span>)<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P2042 [NOI2005] 维护数列 题解</title>
    <url>/solutions/solution-p2042/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">维护数列</div>
<div id="problem-info-from">NOI 2005</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDIwNDI=">Luogu P2042<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvOTU3Lw==">AcWing 955<i class="fa fa-external-link-alt"></i></span></li></ul></div>

<hr>
<p>题目要求我们维护一个数列，支持下面六种操作：</p>
<ol>
<li>插入：在当前数列的第 $posi$ 个数字后面插入 $c_1,c_2,\cdots,c_tot$ 共计 $tot$ 个数字；</li>
<li>删除：从当前数列的第 $posi$ 个数字开始连续删除 $tot$ 个数字；</li>
<li>推平：从当前数列的第 $posi$ 个数字开始的连续 $tot$ 个数字改为 $c$；</li>
<li>翻转：将区间 $[ posi,posi+tot-1 ]$ 翻转；</li>
<li>求和：求出区间 $[ posi,posi+tot-1 ]$ 内所有数字的和；</li>
<li>求最大子序列和：求出当前数列中最大的一段子序列并输出其序列和。</li>
</ol>
<p>看见区间翻转我就想到了平衡树。</p>
<p>幸好上面需要我们支持的操作都是可以利用平衡树来维护的。</p>
<p>我们在维护区间翻转的时候就用到了懒标记的思想，这里我们也可以使用懒标记。</p>
<p>我们的结构体长的是这个样子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s[<span class="number">2</span>], p, v;</span><br><span class="line">    <span class="type">int</span> rev, same;</span><br><span class="line">    <span class="type">int</span> sz, sum, ms, ls, rs;</span><br><span class="line">&#125;tr[N];</span><br></pre></td></tr></table></figure>

<p>其中分别维护的是：</p>
<ul>
<li><code>s[2]</code>：左右儿子；</li>
<li><code>p</code>：父亲；</li>
<li><code>v</code>：当前节点的值；</li>
<li><code>rev</code>：翻转懒标记；</li>
<li><code>same</code>：推平懒标记；</li>
<li><code>sz</code>：子树大小；</li>
<li><code>sum</code>：区间和；</li>
<li><code>ms</code>：区间最大子序列和；</li>
<li><code>ls</code>：区间最大前缀和；</li>
<li><code>rs</code>：区间最大后缀和。</li>
</ul>
<p>我们初始化的时候这样初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> _v, <span class="type">int</span> _p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s[<span class="number">0</span>] = s[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    p = _p, v = _v;</span><br><span class="line">    rev = same = <span class="number">0</span>;</span><br><span class="line">    sz = <span class="number">1</span>;</span><br><span class="line">    sum = ms = v;</span><br><span class="line">    ls = rs = <span class="built_in">max</span>(v, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是区间合并：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;u = tr[x], &amp;l = tr[u.s[<span class="number">0</span>]], &amp;r = tr[u.s[<span class="number">1</span>]];</span><br><span class="line">    u.sz = l.sz + r.sz + <span class="number">1</span>;</span><br><span class="line">    u.sum = l.sum + r.sum + u.v;</span><br><span class="line">    u.ls = <span class="built_in">max</span>(l.ls, l.sum + u.v + r.ls);</span><br><span class="line">    u.rs = <span class="built_in">max</span>(r.rs, r.sum + u.v + l.rs);</span><br><span class="line">    u.ms = <span class="built_in">max</span>(<span class="built_in">max</span>(l.ms, r.ms), l.rs + u.v + r.ls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>维护当前区间的最大子序列可以看<a href="/OI/segment-tree/#%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C">这里</a>的思路。</p>
<p>再然后是标记的下传：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;u = tr[x], &amp;l = tr[u.s[<span class="number">0</span>]], &amp;r = tr[u.s[<span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">if</span>(u.same)</span><br><span class="line">    &#123;</span><br><span class="line">        u.same = u.rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(u.s[<span class="number">0</span>]) l.same = <span class="number">1</span>, l.v = u.v, l.sum = l.v * l.sz;</span><br><span class="line">        <span class="keyword">if</span>(u.s[<span class="number">1</span>]) r.same = <span class="number">1</span>, r.v = u.v, r.sum = r.v * r.sz;</span><br><span class="line">        <span class="keyword">if</span>(u.v &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(u.s[<span class="number">0</span>]) l.ms = l.ls = l.rs = l.sum;</span><br><span class="line">            <span class="keyword">if</span>(u.s[<span class="number">1</span>]) r.ms = r.ls = r.rs = r.sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(u.s[<span class="number">0</span>]) l.ms = l.v, l.ls = l.rs = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(u.s[<span class="number">1</span>]) r.ms = r.v, r.ls = r.rs = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(u.rev)</span><br><span class="line">    &#123;</span><br><span class="line">        u.rev = <span class="number">0</span>, l.rev ^= <span class="number">1</span>, r.rev ^= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">swap</span>(l.ls, l.rs), <span class="built_in">swap</span>(r.ls, r.rs);</span><br><span class="line">        <span class="built_in">swap</span>(l.s[<span class="number">0</span>], l.s[<span class="number">1</span>]), <span class="built_in">swap</span>(r.s[<span class="number">0</span>], r.s[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区间推平的优先级是先于区间翻转的，且如果这个区间整体被推平了，那么这个区间翻转了和没翻转没有什么区别，所以每一次标记下传的时候只需要下传两者其一即可。</p>
<p>然后是六种操作：</p>
<ol>
<li>插入一整段区间的操作与一开始建树的时候差不多。<br> 我们需要首先预留出来新区间的位置，比如说 $posi+1$ 节点的左子树。此时这棵树长这个样子：<br> <img src="/%5Cpics%5Cp2042-1.bmp" alt="p2042-1.bmp"><br> 我们就是要在肩头指向的位置插入我们的新序列。<br> 然后就像一开始的时候那样，基于新读入的序列建立一棵平衡树，根节点为 $u$。<br> 然后让 $u$ 成为 $posi+1$ 的左儿子，就像这样：<br> <img src="/%5Cpics%5Cp2042-2.bmp" alt="p2042-2.bmp"><br> 现在我们就在 $posi$ 后面插入了一段新的序列。</li>
<li>删除一整段区间的操作与正常的删除操作没有什么区别。<br> 这里就不讲了。</li>
<li>区间推平与区间翻转的道理类似，都是给整个区间打上一个标记，同时区间推平还会额外修改一下区间和、区间最大子段和、区间最大前缀和与区间最大后缀和，别的就没有什么好说的了。</li>
<li>区间求和的思路与区间翻转、区间推平类似，只不过不是修改而是查询。截出来询问区间之后直接输出值即可。</li>
<li>上面的五种操作都需要截出对应区间，但是询问区间最大子段和只需要访问当前根节点即可。</li>
</ol>
<p>最后放一下总的代码：</p>
<details class="note success"><summary><p>示例代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>, INF = <span class="number">1000000000</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s[<span class="number">2</span>], p, v;</span><br><span class="line">    <span class="type">int</span> rev, same;</span><br><span class="line">    <span class="type">int</span> sz, sum, ms, ls, rs;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> _v, <span class="type">int</span> _p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        s[<span class="number">0</span>] = s[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        p = _p, v = _v;</span><br><span class="line">        rev = same = <span class="number">0</span>;</span><br><span class="line">        sz = <span class="number">1</span>;</span><br><span class="line">        sum = ms = v;</span><br><span class="line">        ls = rs = <span class="built_in">max</span>(v, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="type">int</span> rt, recycle[N], tt;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;u = tr[x], &amp;l = tr[u.s[<span class="number">0</span>]], &amp;r = tr[u.s[<span class="number">1</span>]];</span><br><span class="line">    u.sz = l.sz + r.sz + <span class="number">1</span>;</span><br><span class="line">    u.sum = l.sum + r.sum + u.v;</span><br><span class="line">    u.ls = <span class="built_in">max</span>(l.ls, l.sum + u.v + r.ls);</span><br><span class="line">    u.rs = <span class="built_in">max</span>(r.rs, r.sum + u.v + l.rs);</span><br><span class="line">    u.ms = <span class="built_in">max</span>(<span class="built_in">max</span>(l.ms, r.ms), l.rs + u.v + r.ls);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;u = tr[x], &amp;l = tr[u.s[<span class="number">0</span>]], &amp;r = tr[u.s[<span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">if</span>(u.same)</span><br><span class="line">    &#123;</span><br><span class="line">        u.same = u.rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(u.s[<span class="number">0</span>]) l.same = <span class="number">1</span>, l.v = u.v, l.sum = l.v * l.sz;</span><br><span class="line">        <span class="keyword">if</span>(u.s[<span class="number">1</span>]) r.same = <span class="number">1</span>, r.v = u.v, r.sum = r.v * r.sz;</span><br><span class="line">        <span class="keyword">if</span>(u.v &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(u.s[<span class="number">0</span>]) l.ms = l.ls = l.rs = l.sum;</span><br><span class="line">            <span class="keyword">if</span>(u.s[<span class="number">1</span>]) r.ms = r.ls = r.rs = r.sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(u.s[<span class="number">0</span>]) l.ms = l.v, l.ls = l.rs = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(u.s[<span class="number">1</span>]) r.ms = r.v, r.ls = r.rs = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(u.rev)</span><br><span class="line">    &#123;</span><br><span class="line">        u.rev = <span class="number">0</span>, l.rev ^= <span class="number">1</span>, r.rev ^= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">swap</span>(l.ls, l.rs), <span class="built_in">swap</span>(r.ls, r.rs);</span><br><span class="line">        <span class="built_in">swap</span>(l.s[<span class="number">0</span>], l.s[<span class="number">1</span>]), <span class="built_in">swap</span>(r.s[<span class="number">0</span>], r.s[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> y = tr[x].p, z = tr[y].p;</span><br><span class="line">    <span class="type">int</span> k = tr[y].s[<span class="number">1</span>] == x;</span><br><span class="line">    tr[z].s[tr[z].s[<span class="number">1</span>] == y] = x, tr[x].p = z;</span><br><span class="line">    tr[y].s[k] = tr[x].s[k ^ <span class="number">1</span>], tr[tr[x].s[k ^ <span class="number">1</span>]].p = y;</span><br><span class="line">    tr[x].s[k ^ <span class="number">1</span>] = y, tr[y].p = x;</span><br><span class="line">    <span class="built_in">pushup</span>(y), <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(tr[x].p != k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = tr[x].p, z = tr[y].p;</span><br><span class="line">        <span class="keyword">if</span>(z != k)</span><br><span class="line">            <span class="keyword">if</span>((tr[y].s[<span class="number">1</span>] == x) ^ (tr[z].s[<span class="number">1</span>] == y)) <span class="built_in">rotate</span>(x);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">rotate</span>(y);</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!k) rt = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_k</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = rt;</span><br><span class="line">    <span class="keyword">while</span>(u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="keyword">if</span>(tr[tr[u].s[<span class="number">0</span>]].sz &gt;= k) u = tr[u].s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tr[tr[u].s[<span class="number">0</span>]].sz + <span class="number">1</span> == k) <span class="keyword">return</span> u;</span><br><span class="line">        <span class="keyword">else</span> k -= tr[tr[u].s[<span class="number">0</span>]].sz + <span class="number">1</span>, u = tr[u].s[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> u = recycle[tt--];</span><br><span class="line">    tr[u].<span class="built_in">init</span>(w[mid], p);</span><br><span class="line">    <span class="keyword">if</span>(l &lt; mid) tr[u].s[<span class="number">0</span>] = <span class="built_in">build</span>(l, mid - <span class="number">1</span>, u);</span><br><span class="line">    <span class="keyword">if</span>(mid &lt; r) tr[u].s[<span class="number">1</span>] = <span class="built_in">build</span>(mid + <span class="number">1</span>, r, u);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].s[<span class="number">0</span>]) <span class="built_in">del</span>(tr[u].s[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(tr[u].s[<span class="number">1</span>]) <span class="built_in">del</span>(tr[u].s[<span class="number">1</span>]);</span><br><span class="line">    recycle[++tt] = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++) recycle[++tt] = i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    tr[<span class="number">0</span>].ms = w[<span class="number">0</span>] = w[n + <span class="number">1</span>] = -INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    rt = <span class="built_in">build</span>(<span class="number">0</span>, n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> op[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;INSERT&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> posi, tot;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;posi, &amp;tot);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; tot; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">get_k</span>(posi + <span class="number">1</span>), r = <span class="built_in">get_k</span>(posi + <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">splay</span>(l, <span class="number">0</span>), <span class="built_in">splay</span>(r, l);</span><br><span class="line">            <span class="type">int</span> u = <span class="built_in">build</span>(<span class="number">0</span>, tot - <span class="number">1</span>, r);</span><br><span class="line">            tr[r].s[<span class="number">0</span>] = u;</span><br><span class="line">            <span class="built_in">pushup</span>(r), <span class="built_in">pushup</span>(l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;DELETE&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> posi, tot;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;posi, &amp;tot);</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">get_k</span>(posi), r = <span class="built_in">get_k</span>(posi + tot + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">splay</span>(l, <span class="number">0</span>), <span class="built_in">splay</span>(r, l);</span><br><span class="line">            <span class="built_in">del</span>(tr[r].s[<span class="number">0</span>]);</span><br><span class="line">            tr[r].s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">pushup</span>(r), <span class="built_in">pushup</span>(l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;MAKE-SAME&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> posi, tot, c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;posi, &amp;tot, &amp;c);</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">get_k</span>(posi), r = <span class="built_in">get_k</span>(posi + tot + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">splay</span>(l, <span class="number">0</span>), <span class="built_in">splay</span>(r, l);</span><br><span class="line">            <span class="keyword">auto</span> &amp;son = tr[tr[r].s[<span class="number">0</span>]];</span><br><span class="line">            son.same = <span class="number">1</span>, son.v = c, son.sum = c * son.sz;</span><br><span class="line">            <span class="keyword">if</span>(c &gt; <span class="number">0</span>) son.ms = son.ls = son.rs = son.sum;</span><br><span class="line">            <span class="keyword">else</span> son.ms = c, son.ls = son.rs = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">pushup</span>(r), <span class="built_in">pushup</span>(l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;REVERSE&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> posi, tot;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;posi, &amp;tot);</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">get_k</span>(posi), r = <span class="built_in">get_k</span>(posi + tot + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">splay</span>(l, <span class="number">0</span>), <span class="built_in">splay</span>(r, l);</span><br><span class="line">            <span class="keyword">auto</span> &amp;son = tr[tr[r].s[<span class="number">0</span>]];</span><br><span class="line">            son.rev ^= <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">swap</span>(son.ls, son.rs);</span><br><span class="line">            <span class="built_in">swap</span>(son.s[<span class="number">0</span>], son.s[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">pushup</span>(r), <span class="built_in">pushup</span>(l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;GET-SUM&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> posi, tot;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;posi, &amp;tot);</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">get_k</span>(posi), r = <span class="built_in">get_k</span>(posi + tot + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">splay</span>(l, <span class="number">0</span>), <span class="built_in">splay</span>(r, l);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tr[tr[r].s[<span class="number">0</span>]].sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tr[rt].ms);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>P2146 软件包管理器 题解</title>
    <url>/solutions/solution-p2146/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">软件包管理器</div>
<div id="problem-info-from">NOI 2015</div>
<div id="problem-info-difficulty">提高+ /省选-</div>
<div id="problem-info-color">#3498db</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDIxNDY=">Luogu P2146<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yMTMw">LibreOJ L2130<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvOTIwLw==">AcWing 918<i class="fa fa-external-link-alt"></i></span></li></ul></div>

<hr>
<p>树剖模板题。</p>
<p>首先我们看一下<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDIxNDY=">题面<i class="fa fa-external-link-alt"></i></span>；</p>
<p>将题面简化一下，就是下面这样：</p>
<blockquote>
<p>给定一棵大小为 $n$ 的，根节点为0的树，我们需要对这棵树进行两种操作，并求出有多少个节点的状态被改变：</p>
<ol>
<li>将根节点到给定节点的路径全部变成1，输入格式为 <code>install x</code> ；</li>
<li>将给定节点及其子树全部变成0，输入格式为 <code>uninstall x</code> ；<br>初始情况下所有节点都是0。</li>
</ol>
</blockquote>
<p>对于我们的结果，我们直接可以对比操作前后整棵树的权值和（存在根节点里面），然后直接输出两数之差即可。</p>
<p>但是我们还需要注意一点：<strong>默认懒标记值</strong>。<br>我们之前一直设懒标记的默认值为0，而在此题的环境内，0代表的是一种状态，而非一个值。如果将懒标记值为0的时候直接跳过的话，就无法卸载所有需要卸载的软件。<br>所以我们在此将默认懒标记值定为-1。pushup的时候也是一样。</p>
<p>当然，本题要求的是区间覆盖而非区间增减，而这个就只将segadd和pushdown两个函数里面的<code>+=</code>换成<code>=</code>即可。<br>比如这样：</p>
<p>segadd：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">segadd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((l &lt;= tr[p].l) &amp;&amp; (r &gt;= tr[p].r))</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].add = k;</span><br><span class="line">        tr[p].sum = k * (tr[p].r - tr[p].l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">segadd</span>(p &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">segadd</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pushdown：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[p], &amp;left = tr[p &lt;&lt; <span class="number">1</span>], &amp;rght = tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(root.add!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        left.add = root.add, left.sum = root.add * (left.r - left.l + <span class="number">1</span>);</span><br><span class="line">        rght.add = root.add, rght.sum = root.add * (rght.r - rght.l + <span class="number">1</span>);</span><br><span class="line">        root.add = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为本题的根节点是0，所以我将所有节点的编号都加上了1，这样就与正常情况下差不多了。<br>完整代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> id[N], cnt;</span><br><span class="line"><span class="type">int</span> dep[N], sz[N], top[N], fa[N], son[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segtree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    ll add, sum;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> father, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[p] = depth, fa[p] = father, sz[p] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == father) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(j, p, depth + <span class="number">1</span>);</span><br><span class="line">        sz[p] += sz[j];</span><br><span class="line">        <span class="keyword">if</span>(sz[son[p]] &lt; sz[j]) son[p] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id[p] = ++cnt, top[p] = t;</span><br><span class="line">    <span class="keyword">if</span>(!son[p]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[p], t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == fa[p] || j == son[p]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(j, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].sum = tr[p &lt;&lt; <span class="number">1</span>].sum + tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[p], &amp;left = tr[p &lt;&lt; <span class="number">1</span>], &amp;rght = tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(root.add!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        left.add = root.add, left.sum = root.add * (left.r - left.l + <span class="number">1</span>);</span><br><span class="line">        rght.add = root.add, rght.sum = root.add * (rght.r - rght.l + <span class="number">1</span>);</span><br><span class="line">        root.add = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p] = &#123; l, r, <span class="number">-1</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">//pushup(p);</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">segadd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((l &lt;= tr[p].l) &amp;&amp; (r &gt;= tr[p].r))</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].add = k;</span><br><span class="line">        tr[p].sum = k * (tr[p].r - tr[p].l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">segadd</span>(p &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">segadd</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">install</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll prev = tr[<span class="number">1</span>].sum;</span><br><span class="line">    <span class="type">int</span> v = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[p] != top[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[p]] &lt; dep[top[v]]) <span class="built_in">swap</span>(p, v);</span><br><span class="line">        <span class="built_in">segadd</span>(<span class="number">1</span>, id[top[p]], id[p], <span class="number">1</span>);</span><br><span class="line">        p = fa[top[p]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[p] &lt; dep[v]) <span class="built_in">swap</span>(p, v);</span><br><span class="line">    <span class="built_in">segadd</span>(<span class="number">1</span>, id[v], id[p], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> tr[<span class="number">1</span>].sum - <span class="number">114514</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">uninstall</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll prev = tr[<span class="number">1</span>].sum;</span><br><span class="line">    <span class="built_in">segadd</span>(<span class="number">1</span>, id[p], id[p] + sz[p] - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">114514</span> - tr[<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        a++;</span><br><span class="line">        <span class="built_in">add</span>(a, i);</span><br><span class="line">        <span class="built_in">add</span>(i, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">install</span>(x + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;u&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">uninstall</span>(x + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Youwike AK IOI!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">114514</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>P2414 [NOI2011] 阿狸的打字机 题解</title>
    <url>/solutions/solution-p2414/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">阿狸的打字机</div>
<div id="problem-info-from">NOI 2011</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI0MTQ=">Luogu P2414<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yNDQ0">LibreOJ L2444<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvOTg1Lw==">AcWing 983<i class="fa fa-external-link-alt"></i></span></li></ul></div>

<hr>
<p>题目这个样子就相当于是构造了一个字符串的集合，同时询问我们某一个字符串在另一个字符串内出现了多少次。</p>
<p>首先看一下数据范围：<br>字符串数量 $n \leq 10^5$，询问数量 $m \leq 10^5$。</p>
<p>况且字符串的输入格式还特别奇怪：</p>
<blockquote>
<p>阿狸喜欢收藏各种稀奇古怪的东西，最近他淘到一台老式的打字机。打字机上只有 $28$ 个按键，分别印有 $26$ 个小写英文字母和 <code>B</code>、<code>P</code> 两个字母。经阿狸研究发现，这个打字机是这样工作的：</p>
<ul>
<li>输入小写字母，打字机的一个凹槽中会加入这个字母(这个字母加在凹槽的最后)。</li>
<li>按一下印有 <code>B</code> 的按键，打字机凹槽中最后一个字母会消失。</li>
<li>按一下印有 <code>P</code> 的按键，打字机会在纸上打印出凹槽中现有的所有字母并换行，但凹槽中的字母不会消失。</li>
</ul>
<p>例如，阿狸输入 <code>aPaPBbP</code>，纸上被打印的字符如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">aa</span><br><span class="line">ab</span><br></pre></td></tr></table></figure>
<p>我们把纸上打印出来的字符串从 $1$ 开始顺序编号，一直到 $n$。</p>
</blockquote>
<p>然后我们就可以由此联想到Trie，以及以其为基础的AC自动机。</p>
<p>AC自动机是有字符串匹配的功能的，但是这样直接匹配还是有点慢。<br>其每一次询问的时间复杂度都是与文本串的长度成正相关的。</p>
<p>当然我们可以想到离线询问，对于处理相同文本串的询问确实是节省了时间。</p>
<p>同时我们考虑一个性质：</p>
<p><strong>我们的所有文本串均会出现在AC自动机中。</strong></p>
<p>或者说，我们相当于是拿模式串与模式串相比对。</p>
<p>这样我们就完全是在AC自动机内部做匹配，不需要考虑什么被抛弃的部分了。</p>
<hr>
<p>如何解决询问？</p>
<p>我们刚才考虑过离线并按照文本串分组。</p>
<p>我们对于某一个文本串，要如何才能提溜出来其所有的子串呢？</p>
<p>我们考虑这样一个有关fail边的性质：</p>
<blockquote>
<p>由于fail边跳到的是当前字符串在Trie内存在的最长后缀，且如果当前的模式串出现在了文本串内的话，其子串也会出现在文本串内，所以我们可以沿着fail指针一路遍历当前模式串的所有后缀。</p>
</blockquote>
<p>所以对于某一个字符串 $s$，从根节点到代表 $s$ 的节点的这一条路径上所有节点及沿着其fail指针跳到根节点的所有路径上的点代表的字符串都在 $s$ 里面出现过。</p>
<p>这其中包含了 $s$ 的所有子串，因为其的某个子串一定是某一个后缀的某个前缀。</p>
<hr>
<p>既然这个样子了，我们不如就不直接遍历整个AC自动机，而单独把fail指针提溜出来建成一张图遍历好了。</p>
<p>这里还附加了一个特殊性质，就是我们单独把fail指针拎出来之后会构建出来一棵树，而不是一张图。</p>
<p>然后我们考虑记录两个值：当前节点的DFS序和回溯到当前节点时的时间。</p>
<p>我们记录了这两个值以后，就可以单独把这个节点的子树给提溜出来了。</p>
<p>由于我们fail边指向的是当前字符串的最长后缀，那么我们fail树里面某一个节点绝对是其子树内所有点的某一个后缀。<br>那么如果这个节点出现过一次，那么这个节点代表的字符串在其子树内节点所代表的字符串内就必定出现过一次。<br>同理，如果这个节点的子树内的节点代表的字符串出现过一次，这个节点代表的字符串必定也出现过一次。<br>所以我们统计某一个字符串出现的次数的时候，我们需要统计该节点及其子树的所有信息。</p>
<p>那我们好像可以使用树状数组或线段树维护……</p>
<hr>
<p>那我们怎么统计信息呢？</p>
<p>顺序遍历字符串即可。<br>同时还要沿着AC自动机跳。</p>
<p>每一次遇到一个新的字符的时候分类讨论：</p>
<ul>
<li>如果是小写字母，那就沿着AC自动机跳，同时该节点出现的次数<code>+1</code>。</li>
<li>如果是 <code>P</code>，那就意味着（可能）有询问需要处理。遍历所有该字符串下的询问，并存储答案。</li>
<li>如果是 <code>B</code>，那就意味着上一个字符串遍历的所有信息就不算了，该节点出现的次数<code>-1</code>，同时跳到当前节点的父亲。</li>
</ul>
<p>分析完毕。</p>
<hr>
<p>然后是代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, flag = <span class="number">1</span>; <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>((c = <span class="built_in">getchar</span>()) &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) flag = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (c ^ <span class="number">48</span>), c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x * flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++idx] = b, ne[idx] = h[a], h[a] = idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> dfn[N], out[N], indx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AC</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> v, fail, fa;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, now = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!tr[now].s[s[i] - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                tr[now].s[s[i] - <span class="string">&#x27;a&#x27;</span>] = ++cnt;</span><br><span class="line">                tr[cnt].fa = now;</span><br><span class="line">            &#125;</span><br><span class="line">            now = tr[now].s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;P&#x27;</span>)</span><br><span class="line">            a[++n] = now;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">            now = tr[now].fa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_fail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(tr[<span class="number">0</span>].s[i])q.<span class="built_in">push</span>(tr[<span class="number">0</span>].s[i]);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[u].s[i])</span><br><span class="line">            &#123;</span><br><span class="line">                tr[tr[u].s[i]].fail = tr[tr[u].fail].s[i];</span><br><span class="line">                q.<span class="built_in">push</span>(tr[u].s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tr[u].s[i] = tr[tr[u].fail].s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = ++indx;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i];</span><br><span class="line">        <span class="keyword">if</span>(v ^ p)<span class="built_in">dfs</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    out[u] = indx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">segadd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= indx; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">        c[i] += v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">segsum</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &gt; <span class="number">0</span>; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">        ans += c[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">query</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, id;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;query&gt;g[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    <span class="built_in">insert</span>();</span><br><span class="line">    <span class="built_in">build_fail</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">        <span class="built_in">add</span>(i, tr[i].fail), <span class="built_in">add</span>(tr[i].fail, i);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        g[y].<span class="built_in">push_back</span>(&#123; x,i &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, now = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;P&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; g[j].<span class="built_in">size</span>(); k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x = g[j][k].x, id = g[j][k].id;</span><br><span class="line">                ans[id] = <span class="built_in">segsum</span>(out[a[x]]) - <span class="built_in">segsum</span>(dfn[a[x]] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">segadd</span>(dfn[now], <span class="number">-1</span>);</span><br><span class="line">            now = tr[now].fa;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            now = tr[now].s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="built_in">segadd</span>(dfn[now], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>P2824 [HEOI2016/TJOI2016] 排序 题解</title>
    <url>/solutions/solution-p2824/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">排序</div>
<div id="problem-info-from">HEOI 2016<br>TJOI 2016</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI4MjQ=">Luogu P2824<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yMDU1">LibreOJ L2055<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjkzMi8=">AcWing 2929<i class="fa fa-external-link-alt"></i></span></li></ul></div>

<hr>
<p>一看见排序我们就感觉开始复杂起来了，毕竟排序是一个复杂而又缓慢的过程。</p>
<p>我们来想简单一点的排序。</p>
<p>如果我们对一个排列进行升序或者降序排序应该很简单，就是将这个排列所包含的数进行正向或者反向输出即可。</p>
<p>假如我们每一次排列的时候都是对一个排列排序该多好啊。</p>
<p>可惜这样无法满足我们接下来的询问，毕竟这样对其没有任何影响，该得不出来还是得不出来。</p>
<p>那么如果我们对的是一个01序列排序呢？</p>
<p>也很简单，就把1全部放在一边，0放在另一边即可。</p>
<p>那这样有什么可以利用的性质呢？</p>
<p>我们可以设想，当我们把大于一个值的数字全部变成1，其余的变成0，再排序，询问的时候得到的就是当前位置比这个值大还是小。</p>
<p>然后我们发现，我们可以利用这个东西进行二分。</p>
<p>我们每一次指定一个值，按照上面的步骤得到询问的位置是0还是1，然后根据答案二分即可。</p>
<p>但是我们每一次还是需要进行枚举，时间仍然没有达到我们的要求。</p>
<p>既然是区间修改了，那么我们就可以使用——线段树！</p>
<p>每一次询问当前区间内有多少个1，然后根据上面的想法区间覆盖即可，而询问区间内1的个数可以使用维护区间和的方式来得出。</p>
<p>然后就显而易见了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> q;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum, tag;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].sum = tr[p &lt;&lt; <span class="number">1</span>].sum + tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[p], &amp;left = tr[p &lt;&lt; <span class="number">1</span>], &amp;rght = tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(root.tag != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        left.sum = (left.r - left.l + <span class="number">1</span>) * root.tag;</span><br><span class="line">        rght.sum = (rght.r - rght.l + <span class="number">1</span>) * root.tag;</span><br><span class="line">        left.tag = root.tag;</span><br><span class="line">        rght.tag = root.tag;</span><br><span class="line">        root.tag = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].l = l, tr[p].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].tag = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l == tr[p].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum = (a[tr[p].l] &gt;= k);</span><br><span class="line">        tr[p].tag = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>(p &lt;&lt; <span class="number">1</span>, k);</span><br><span class="line">    <span class="built_in">init</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, k);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">segchg</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum = (tr[p].r - tr[p].l + <span class="number">1</span>) * k;</span><br><span class="line">        tr[p].tag = k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)<span class="built_in">segchg</span>(p &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)<span class="built_in">segchg</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">segsum</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)<span class="keyword">return</span> tr[p].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res += <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)res += <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> op[N], L[N], R[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op[i], &amp;L[i], &amp;R[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">init</span>(<span class="number">1</span>, mid);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="built_in">segsum</span>(<span class="number">1</span>, L[i], R[i]);</span><br><span class="line">            <span class="keyword">if</span>(op[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">segchg</span>(<span class="number">1</span>, L[i], R[i] - cnt, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">segchg</span>(<span class="number">1</span>, R[i] - cnt + <span class="number">1</span>, R[i], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(op[i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">segchg</span>(<span class="number">1</span>, L[i], L[i] + cnt - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">segchg</span>(<span class="number">1</span>, L[i] + cnt, R[i], <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> pos = <span class="built_in">segsum</span>(<span class="number">1</span>, q, q);</span><br><span class="line">        <span class="keyword">if</span>(pos == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">            ans = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>P2906 [USACO08OPEN] Cow Neighborhoods 题解</title>
    <url>/solutions/solution-p2906/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">Cow Neighborhoods</div>
<div id="problem-info-from">USACO 2008 OPEN Gold</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI5MDY=">Luogu P2906<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzE2MDQ=">BZOJ #1604<i class="fa fa-external-link-alt"></i></span></li></ul></div>

<hr>
<p>看到这一题的时候我感觉非常熟悉。<br>这不就是<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQwNDc=">[JSOI2010]部落划分<i class="fa fa-external-link-alt"></i></span>吗！<br>只不过这道题给定了奶牛之间的距离，并且是让求连通块的个数以及最大连通块的大小。</p>
<p>（可能只有我一个人觉得很类似罢）</p>
<p>然后做了一发，T了。</p>
<p>一看数据范围：$N \leq 10^5$。</p>
<p>秉承着“N方过百万，暴力碾标算”的精神，我认为是常数的问题加上复杂度跑满，于是就做了一些小小的优化：</p>
<p>首先，我将每一个坐标按照横坐标为第一关键字，纵坐标为第二关键字进行了一发排序。</p>
<p>因为我们不关心节点的编号，所以我们可以直接排序。</p>
<p>然后，我将原题中的曼哈顿距离转变为了切比雪夫距离，从而不让算法跑满。</p>
<p><img src="https://s2.loli.net/2022/06/07/VQ4sIFJ5MnOmfdW.jpg" alt="manhattan.jpg"></p>
<p>这是曼哈顿距离，其在 $k$ 维空间中的定义为：</p>
<p>$$<br>Dis(x,y) &#x3D; \sum_{i&#x3D;1}^k |x_i-y_i|<br>$$</p>
<p>放到二维平面里面就是 $Dis(u,v) &#x3D; |x_u-x_v|+|y_u-y_v|$。</p>
<p><img src="https://s2.loli.net/2022/06/07/pM4XwIRPrUaeiSW.jpg" alt="chebyshev.jpg"></p>
<p>这是切比雪夫距离，其在 $k$ 维空间中的定义为：</p>
<p>$$<br>Dis(x,y) &#x3D; \max_{i&#x3D;1}^k |x_i-y_i|<br>$$</p>
<p>放到二维平面里面就是 $Dis(u,v) &#x3D; \max(|x_u-x_v|,|y_u-y_v|)$。</p>
<p>如果我们将曼哈顿距离转化为了切比雪夫距离的话，就可以利用单调队列来取出 $[x-c,x+c]$ 的一段来，并在其中进行判断并连边即可，可以减小算法复杂度。</p>
<p>怎么转化呢？</p>
<p>我们考虑对于某一个点距离为定值的点构成的集合。<br>我们设这个点是原点 $(0,0)$，这个距离为 $c$。</p>
<p>当这个距离是曼哈顿距离的时候，我们这些点构成的集合就是一个倾斜了$45^{\circ}$的正方形，顶点分别为 $(0,c)$，$(c,0)$，$(0,-c)$，$(-c,0)$。</p>
<p>当这个距离是切比雪夫距离的时候，我们这些点构成的集合就是一个正方形，顶点分别为 $(c,c)$，$(c,-c)$，$(-c,-c)$，$(-c,c)$。</p>
<p>然后我们就可以发现，我们将曼哈顿距离下的这个正方形旋转$45^{\circ}$并扩大$\sqrt{2}$倍之后就是切比雪夫距离下的这个正方形。</p>
<p>对于一个点的情况下，我们将其坐标变为 $(x+y,x-y)$，可以达到同样的效果。</p>
<p>最后试了一发，T了。<br>看来N方还是过不了十万。</p>
<p>尝试减小连边的次数，我们可以尝试只连线性级别的边。</p>
<p>对于每一个点，我们只考虑与其左边的点连边。<br>同时，每一个点我们最多只连两条边，这在保证了联通性的前提下大幅度减少了连边的次数。</p>
<p>连哪两个点呢？</p>
<p>纵坐标与当前点最接近的两个即可。<br>其中一个在当前点上方，一个在当前点下方。</p>
<p>考虑正确性。</p>
<p>因为其他边都是冗余的，所以只连这两条边即可。</p>
<p>对于任意两者均可触及的点，两点向其连边之后得到的是一个三角形；<br>又因为当前点较靠后，所以我们可以断开当前点与其连结的边，这样也能保证连通性。</p>
<p>证毕。</p>
<p>然后就是考虑如何快速找到与当前点纵坐标最接近的两个点。</p>
<p>我们可以使用<code>set</code>来维护，使用<code>lower_bound()</code>来进行查找。</p>
<p>我们记录当前<code>set</code>维护的左端点，并尝试将其右移，直到左端点所对应的点与当前点的切比雪夫距离不超过 $c$。<br>然后就可以使用<code>lower_bound()</code>查找了，找到对应的节点之后连边即可。<br>最后要把当前节点加入<code>set</code>中。</p>
<p>交一发，过了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) f = -f; c = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="number">48</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll c;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node &amp;a) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x == a.x ? y &lt; a.y : x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>&lt;<span class="type">int</span>&gt;(), c = <span class="built_in">read</span>&lt;ll&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll x = <span class="built_in">read</span>&lt;ll&gt;(), y = <span class="built_in">read</span>&lt;ll&gt;();</span><br><span class="line">        a[i] = &#123; x + y,x - y &#125;;</span><br><span class="line">        p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    set&lt; pair&lt;ll, <span class="type">int</span>&gt; &gt;s;</span><br><span class="line">    set&lt; pair&lt;ll, <span class="type">int</span>&gt; &gt;::iterator it;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(a[<span class="number">1</span>].y, <span class="number">1</span>));</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>((<span class="number">1ll</span> &lt;&lt; <span class="number">60</span>), <span class="number">0</span>));</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>((<span class="number">-1ll</span> &lt;&lt; <span class="number">60</span>), <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, l = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(a[i].x - a[l].x &gt; c)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">erase</span>(<span class="built_in">make_pair</span>(a[l].y, l));</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        it = s.<span class="built_in">lower_bound</span>(<span class="built_in">make_pair</span>(a[i].y, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span>(it-&gt;first - a[i].y &lt;= c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = it-&gt;second;</span><br><span class="line">            <span class="type">int</span> pa = <span class="built_in">find</span>(i), pb = <span class="built_in">find</span>(j);</span><br><span class="line">            <span class="keyword">if</span>(pa != pb)p[pa] = pb;</span><br><span class="line">        &#125;</span><br><span class="line">        it--;</span><br><span class="line">        <span class="keyword">if</span>(a[i].y - it-&gt;first &lt;= c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = it-&gt;second;</span><br><span class="line">            <span class="type">int</span> pa = <span class="built_in">find</span>(i), pb = <span class="built_in">find</span>(j);</span><br><span class="line">            <span class="keyword">if</span>(pa != pb)p[pa] = pb;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(a[i].y, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, maxn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt += (<span class="built_in">find</span>(i) == i);</span><br><span class="line">        maxn = <span class="built_in">max</span>(maxn, ++sum[<span class="built_in">find</span>(i)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, cnt, maxn);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>并查集</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>P3574 [POI2014] FAR-FarmCraft 题解</title>
    <url>/solutions/solution-p3574/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">FarmCraft</div>
<div id="problem-info-from">POI 2014</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM1NzQ=">Luogu P3574<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzM4Mjk=">BZOJ #3829<i class="fa fa-external-link-alt"></i></span></li></ul></div>

<hr>
<p>题目需要我们从一号节点开始遍历整棵树，并给每一个节点记录下遍历到其的时间。<br>同时每一个节点又有一个自己的倒计时，当遍历到其的时候就开始计时。<br>我们需要求出所有节点中倒计时结束最慢的那一个的结束时间，并最小化之。</p>
<p>我们不难想象出一个简单的DP式子来求得最终的答案：</p>
<p>对于节点 $u$ 的子树 $v$，我们有如下的DP式子：</p>
<center>$\operatorname{dp}[u]=\max(\operatorname{dp}[u],\operatorname{dp}[v]+\operatorname{sz}[u]+1)$</center>

<p>其中 $\operatorname{dp}[u]$ 代表当前子树中最大的答案；<br>$\operatorname{sz}[u]$ 代表遍历过 $v$ 所在的子树之前已经经过的所有子树的大小之和再乘以2，这个在遍历完毕整个子树之后会更新为该子树的大小乘以2。</p>
<p>我们可以发现，我们最终的答案跟遍历子树的顺序有关，于是我们考虑对其进行排序。</p>
<p>对于一个节点 $x$ 的两个子树 $y$ 和 $z$，我们假设先遍历 $y$ 再遍历 $z$。<br>这样的话，我们的答案就是 $\max(\operatorname{dp}[y]+\operatorname{sz}[u]+1,\operatorname{dp}[z]+\operatorname{sz}[u]+\operatorname{sz}[y]+2+1)$。<br>我们假定这个方案比交换两个子树的遍历顺序得到的答案更优。<br>交换两个子树的遍历顺序之后得到的答案就是 $\max(\operatorname{dp}[z]+\operatorname{sz}[u]+1,\operatorname{dp}[y]+\operatorname{sz}[u]+\operatorname{sz}[z]+2+1)$。</p>
<p>我们最终得到如下式子：</p>
<center>$\max(\operatorname{dp}[y]+\operatorname{sz}[u]+1,\operatorname{dp}[z]+\operatorname{sz}[u]+\operatorname{sz}[y]+2+1) > \max(\operatorname{dp}[z]+\operatorname{sz}[u]+1,\operatorname{dp}[y]+\operatorname{sz}[u]+\operatorname{sz}[z]+2+1)$</center>

<p>我们将不等式左右两边同时约掉 $\operatorname{sz}[u]+1$，得到</p>
<center>$\max(\operatorname{dp}[y],\operatorname{dp}[z]+\operatorname{sz}[y]+2) > \max(\operatorname{dp}[z],\operatorname{dp}[y]+\operatorname{sz}[z]+2)$</center>

<p>因为 $\operatorname{dp}[y] &lt; \operatorname{dp}[y]+\operatorname{sz}[z]+2$，$\operatorname{dp}[z] &lt; \operatorname{dp}[z]+\operatorname{sz}[y]+2$，所以一定是 $\operatorname{dp}[y]+\operatorname{sz}[z]+2$ 与 $\operatorname{dp}[z]+\operatorname{sz}[y]+2$ 之间的差值导致了答案的变化。</p>
<p>因此，我们可以得到</p>
<center>$\operatorname{dp}[y]-\operatorname{sz}[y] < \operatorname{dp}[z]-\operatorname{sz}[z]$</center>

<p>然后我们就可以按照这样的方法排序了。</p>
<p>参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>)f = <span class="number">-1</span>; c = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))x = x * <span class="number">10</span> + (c ^ <span class="number">48</span>), c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N];</span><br><span class="line"><span class="type">int</span> val[N];</span><br><span class="line"><span class="type">int</span> f[N], sz[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a, <span class="type">const</span> <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sz[a] - f[a] &lt; sz[b] - f[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="number">1</span>)f[p] = val[p];</span><br><span class="line">    <span class="keyword">if</span>(e[p].<span class="built_in">empty</span>())<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : e[p])</span><br><span class="line">        <span class="keyword">if</span>(i != fa)<span class="built_in">dfs</span>(i, p);</span><br><span class="line">    <span class="built_in">sort</span>(e[p].<span class="built_in">begin</span>(), e[p].<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : e[p])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == fa)<span class="keyword">continue</span>;</span><br><span class="line">        f[p] = <span class="built_in">max</span>(f[p], f[i] + sz[p] + <span class="number">1</span>);</span><br><span class="line">        sz[p] += sz[i] + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        val[i] = <span class="built_in">read</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">read</span>&lt;<span class="type">int</span>&gt;(), v = <span class="built_in">read</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        e[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">max</span>(f[<span class="number">1</span>], sz[<span class="number">1</span>] + val[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>树形DP</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>P3586 [POI2015] Logistyka 题解</title>
    <url>/solutions/solution-p3586/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">Logistyka</div>
<div id="problem-info-from">POI 2015</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM1ODY=">Luogu P3586<i class="fa fa-external-link-alt"></i></span></li></ul></div>

<hr>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这道题想让我们维护一个数列，支持对其的修改与询问。</p>
<p>题目给出了两种操作：</p>
<ol>
<li><code>U k a</code> 将序列中第 $k$ 个数修改为 $a$。</li>
<li><code>Z c s</code> 在这个序列上，每次选出 $c$ 个正数，并将它们都减去 $1$，询问能否进行 $s$ 次操作。</li>
</ol>
<p>回答询问的思路是这个样子的：</p>
<p>我们假设在这个数列里面，$( 0,s )$ 范围内的数有 $x$ 个，$[ s, \infty )$ 范围内的数有 $y$ 个。</p>
<p>如果 $x+y &lt; c$ 的话就绝对不行，直接返回 <code>NIE</code>。</p>
<p>我们贪一下心，反正题目询问的是可行性，不如就先让着 $y$ 个数先顶上。</p>
<p>如果这 $y$ 个数都顶上去之后就可以完成任务，甚至还有些富余，就可以直接返回 <code>TAK</code>。<br>而如果 $y &lt; c$，那么我们就需要继续往下讨论。</p>
<p>我们考虑让剩下的数顶上去。</p>
<p>如果这些数字的和小于 $s \times c$，那就绝对完不成任务。<br>反之则一定完得成任务。</p>
<p>QED.</p>
<hr>
<p>所以，我们需要维护两个信息，一是大于某个数的数有多少个，二是大于某个数的所有数之和。</p>
<p>我们可以使用树状数组。</p>
<p>但是我不会，所以就用动态开点权值线段树了。</p>
<p>我们考虑结构体里面存什么：</p>
<p>首先我们需要存区间左右端点（按个人情况）和左右儿子。<br>我们还需要维护区间内数的个数。</p>
<p>为了不多写数据结构，我也将第二个要求写进了线段树里面。</p>
<p>于是我的结构体长的是这个样子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> ls, rs;</span><br><span class="line">    ll sum;</span><br><span class="line">    ll tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>sum</code> 维护的是当前区间内数的个数，<code>tot</code> 维护的是当前区间内所有数的和。两者同时维护，但是查询的时候是分开的。</p>
<p>线段树部分代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> ls, rs;</span><br><span class="line">    ll sum;</span><br><span class="line">    ll tot;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">segadd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pos, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l == tr[p].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum += k;</span><br><span class="line">        tr[p].tot = tr[p].sum * tr[p].l;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[p].ls)</span><br><span class="line">        &#123;</span><br><span class="line">            tr[p].ls = ++idx;</span><br><span class="line">            tr[tr[p].ls].l = tr[p].l;</span><br><span class="line">            tr[tr[p].ls].r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">segadd</span>(tr[p].ls, pos, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pos &gt; mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[p].rs)</span><br><span class="line">        &#123;</span><br><span class="line">            tr[p].rs = ++idx;</span><br><span class="line">            tr[tr[p].rs].l = mid + <span class="number">1</span>;</span><br><span class="line">            tr[tr[p].rs].r = tr[p].r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">segadd</span>(tr[p].rs, pos, k);</span><br><span class="line">    &#125;</span><br><span class="line">    tr[p].sum = tr[tr[p].ls].sum + tr[tr[p].rs].sum;</span><br><span class="line">    tr[p].tot = tr[tr[p].ls].tot + tr[tr[p].rs].tot;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">segsum</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//求区间内数的个数</span></span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)<span class="keyword">return</span> tr[p].sum;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res += <span class="built_in">segsum</span>(tr[p].ls, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)res += <span class="built_in">segsum</span>(tr[p].rs, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">segtot</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//求区间内所有数的和</span></span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)<span class="keyword">return</span> tr[p].tot;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res += <span class="built_in">segtot</span>(tr[p].ls, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)res += <span class="built_in">segtot</span>(tr[p].rs, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>（需要O2）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> ls, rs;</span><br><span class="line">    ll sum;</span><br><span class="line">    ll tot;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">segadd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pos, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l == tr[p].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum += k;</span><br><span class="line">        tr[p].tot = tr[p].sum * tr[p].l;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[p].ls)</span><br><span class="line">        &#123;</span><br><span class="line">            tr[p].ls = ++idx;</span><br><span class="line">            tr[tr[p].ls].l = tr[p].l;</span><br><span class="line">            tr[tr[p].ls].r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">segadd</span>(tr[p].ls, pos, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pos &gt; mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[p].rs)</span><br><span class="line">        &#123;</span><br><span class="line">            tr[p].rs = ++idx;</span><br><span class="line">            tr[tr[p].rs].l = mid + <span class="number">1</span>;</span><br><span class="line">            tr[tr[p].rs].r = tr[p].r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">segadd</span>(tr[p].rs, pos, k);</span><br><span class="line">    &#125;</span><br><span class="line">    tr[p].sum = tr[tr[p].ls].sum + tr[tr[p].rs].sum;</span><br><span class="line">    tr[p].tot = tr[tr[p].ls].tot + tr[tr[p].rs].tot;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">segsum</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)<span class="keyword">return</span> tr[p].sum;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res += <span class="built_in">segsum</span>(tr[p].ls, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)res += <span class="built_in">segsum</span>(tr[p].rs, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">segtot</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)<span class="keyword">return</span> tr[p].tot;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res += <span class="built_in">segtot</span>(tr[p].ls, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)res += <span class="built_in">segtot</span>(tr[p].rs, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="type">int</span> maxn = <span class="number">0</span>;</span><br><span class="line">    tr[++idx] = &#123; <span class="number">0</span>,<span class="number">100000001</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        string op;</span><br><span class="line">        <span class="type">int</span> x, k;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;k);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;U&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">segadd</span>(<span class="number">1</span>, k, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[x] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">segadd</span>(<span class="number">1</span>, a[x], <span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            a[x] = k;</span><br><span class="line">            maxn = <span class="built_in">max</span>(maxn, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ll pos = <span class="built_in">segsum</span>(<span class="number">1</span>, <span class="number">1</span>, maxn), cnt = <span class="built_in">segsum</span>(<span class="number">1</span>, <span class="number">1</span>, k);</span><br><span class="line">            <span class="keyword">if</span>(pos &lt; x)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;NIE&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pos - cnt &gt;= x)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;TAK&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ll tot = <span class="built_in">segtot</span>(<span class="number">1</span>, <span class="number">1</span>, k);</span><br><span class="line">            <span class="keyword">if</span>(tot &gt;= (x + cnt - pos) * k)</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;TAK&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;NIE&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P3644 [APIO2015] 巴邻旁之桥 题解</title>
    <url>/solutions/solution-p3644/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">巴邻旁之桥</div>
<div id="problem-info-from">APIO 2015</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM2NDQ=">Luogu P3644<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yODg4">LibreOJ L2888<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly91b2ouYWMvcHJvYmxlbS8xMTI=">UOJ #112<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzQwNzE=">BZOJ #4071<i class="fa fa-external-link-alt"></i></span></li></ul></div>

<hr>
<p>题目大意：</p>
<p>现在有一条河，将巴邻旁市分成了 $A$、$B$ 两个区域。<br>河的两岸均有 $10^9+1$ 栋房子。每一栋房子均有其编号，从 $A_1,B_1$ 一直到 $A_{10^9+1},B_{10^9+1}$。其中，编号为 $A_i$ 的房子与编号与 $B_i$ 的房子正好隔河相望。<br>相邻两栋房子之间的距离为 $1$。这包括类似 $A_i,A_{i+1}$ 的情况，也包括 $A_i,B_i$ 的情况。</p>
<p>现在有 $n$ 条通勤线路，有一些是需要跨河才能到达的。<br>以前人们都坐船，但是现在政府决定建造 $k$ 座大桥来帮助市民进行日常的通勤，使得所有人都可以（且必须）开车来通勤。</p>
<p>现在政府交给了你这 $n$ 条通勤线路和桥梁的个数 $k$，要求你最小化所有人通勤所需要的时间之和。</p>
<p>所有的桥梁必须垂直于河流。</p>
<hr>
<p>首先猛地一看可能没有什么太大的思路，总觉得是个贪心，或者是个结论题。</p>
<p>然后看一眼数据范围：</p>
<p>$1 \leq K \leq 2$<br>$1 \leq N \leq 10^5$</p>
<p>那就简单多了。</p>
<p>我们可以分类讨论：</p>
<h1 id="K-x3D-1"><a href="#K-x3D-1" class="headerlink" title="$K&#x3D;1$"></a>$K&#x3D;1$</h1><p>首先我们需要忽略所有不跨河的人。<br>这个在输入的时候就直接统计入答案了。</p>
<p>当我们只有一座桥的时候，就意味着<strong>所有人都必须通过这座桥。</strong></p>
<p>那么我们就可以将这些所有的路线拆成三部分：在A岸的、在桥上的和在B岸的。<br>而且因为桥是垂直于河流的，那么我们完全可以把在B岸的和在A岸的放在一起统计。</p>
<p>那么我们的问题就可以转化为，找一个点，使得所有的点到这个点的距离之和最小。</p>
<p>容易得出我们需要求的就是所有数字的中位数。</p>
<p>统计答案即可。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> t[N], tot, ans;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;k, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%lld%s%lld&quot;</span>, x, &amp;u, y, &amp;v);</span><br><span class="line">    <span class="keyword">if</span>(x[<span class="number">0</span>] == y[<span class="number">0</span>]) ans += <span class="built_in">abs</span>(u - v);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        t[++tot] = u, t[++tot] = v;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(t + <span class="number">1</span>, t + <span class="number">1</span> + tot);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++)</span><br><span class="line">    ans += <span class="built_in">abs</span>(t[tot &gt;&gt; <span class="number">1</span>] - t[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br></pre></td></tr></table></figure>

<h1 id="K-x3D-2"><a href="#K-x3D-2" class="headerlink" title="$K&#x3D;2$"></a>$K&#x3D;2$</h1><p>我们考虑一下每一个路线的实际路程。</p>
<p>假设一个路线的端点的编号分别是 $i$ 和 $j$（$i \leq j$），那么：</p>
<ul>
<li>如果 $i$、$j$ 分别在桥的两侧，其实际路程为 $j-i$。</li>
<li>如果 $i$、$j$ 夹在两个桥的中间，其实际路程与 $\frac{i+j}{2}$ 有关。</li>
</ul>
<p>于是我们可以考虑按照 $i+j$ 来对所有的通勤路线进行排序。同时枚举一个划分的位置，左边的都走左边的桥，右边的都走右边的桥。</p>
<p>那么我们需要求的就是动态中位数问题了。</p>
<p>我们仍然考虑使用一个大根堆和一个小根堆来维护动态中位数，只不过我们统计答案的时候换个思路。</p>
<p>我们可以统计前缀和，并且把这个前缀和按照桥的位置分成左右两部分。</p>
<p>此时的最小距离之和就是桥右侧点的坐标和减去左侧点的坐标和。</p>
<p>桥左边的部分枚举的是前缀和，右边的部分枚举的是后缀和。</p>
<p>然后我们取最小值即可。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">need</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> need &amp;a) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (x + y) &lt; (a.x + a.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;order[N];</span><br><span class="line">priority_queue &lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;               &gt; q1;</span><br><span class="line">priority_queue &lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; q2;</span><br><span class="line"><span class="type">int</span> n, k, u, v, cnt;</span><br><span class="line"><span class="type">int</span> ans1[N], ans2[N];</span><br><span class="line"><span class="type">int</span> res, sum1, sum2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exchange</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q1.<span class="built_in">top</span>() &gt; q2.<span class="built_in">top</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q1.<span class="built_in">top</span>(), v = q2.<span class="built_in">top</span>();</span><br><span class="line">        q1.<span class="built_in">pop</span>(), q1.<span class="built_in">push</span>(v);</span><br><span class="line">        q2.<span class="built_in">pop</span>(), q2.<span class="built_in">push</span>(u);</span><br><span class="line">        sum1 += v - u, sum2 -= v - u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>()) q1.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">while</span>(!q2.<span class="built_in">empty</span>()) q2.<span class="built_in">pop</span>();</span><br><span class="line">    sum1 = sum2 = <span class="number">0</span>;</span><br><span class="line">    u = v = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">senhan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q1.<span class="built_in">push</span>(order[i].x), q1.<span class="built_in">push</span>(order[i].y);</span><br><span class="line">        sum1 += order[i].x + order[i].y, sum1 -= q1.<span class="built_in">top</span>(), sum2 += q1.<span class="built_in">top</span>();</span><br><span class="line">        q2.<span class="built_in">push</span>(q1.<span class="built_in">top</span>()); q1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">exchange</span>();</span><br><span class="line">        ans1[i] = sum2 - sum1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gohan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = cnt; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        q1.<span class="built_in">push</span>(order[i].x), q1.<span class="built_in">push</span>(order[i].y);</span><br><span class="line">        sum1 += order[i].x + order[i].y, sum1 -= q1.<span class="built_in">top</span>(), sum2 += q1.<span class="built_in">top</span>();</span><br><span class="line">        q2.<span class="built_in">push</span>(q1.<span class="built_in">top</span>()); q1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">exchange</span>();</span><br><span class="line">        ans2[i] = sum2 - sum1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">sort</span>(order + <span class="number">1</span>, order + <span class="number">1</span> + cnt);</span><br><span class="line"><span class="built_in">senhan</span>();</span><br><span class="line"><span class="built_in">gohan</span>();</span><br><span class="line">res = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= cnt; i++)</span><br><span class="line">    res = <span class="built_in">min</span>(res, ans1[i] + ans2[i + <span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans + res);</span><br></pre></td></tr></table></figure>

<p>全部加起来：</p>
<details class="note success"><summary><p>示例代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">400010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">need</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> need &amp;a) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (x + y) &lt; (a.x + a.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;order[N];</span><br><span class="line">priority_queue &lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;               &gt; q1;</span><br><span class="line">priority_queue &lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; q2;</span><br><span class="line"><span class="type">int</span> n, k, ans, u, v, cnt;</span><br><span class="line"><span class="type">int</span> ans1[N], ans2[N];</span><br><span class="line"><span class="type">char</span> x[<span class="number">2</span>], y[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> t[N], tot, res, sum1, sum2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exchange</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q1.<span class="built_in">top</span>() &gt; q2.<span class="built_in">top</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q1.<span class="built_in">top</span>(), v = q2.<span class="built_in">top</span>();</span><br><span class="line">        q1.<span class="built_in">pop</span>(), q1.<span class="built_in">push</span>(v);</span><br><span class="line">        q2.<span class="built_in">pop</span>(), q2.<span class="built_in">push</span>(u);</span><br><span class="line">        sum1 += v - u, sum2 -= v - u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>()) q1.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">while</span>(!q2.<span class="built_in">empty</span>()) q2.<span class="built_in">pop</span>();</span><br><span class="line">    sum1 = sum2 = <span class="number">0</span>;</span><br><span class="line">    u = v = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">senhan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q1.<span class="built_in">push</span>(order[i].x), q1.<span class="built_in">push</span>(order[i].y);</span><br><span class="line">        sum1 += order[i].x + order[i].y, sum1 -= q1.<span class="built_in">top</span>(), sum2 += q1.<span class="built_in">top</span>();</span><br><span class="line">        q2.<span class="built_in">push</span>(q1.<span class="built_in">top</span>()); q1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">exchange</span>();</span><br><span class="line">        ans1[i] = sum2 - sum1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gohan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = cnt; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        q1.<span class="built_in">push</span>(order[i].x), q1.<span class="built_in">push</span>(order[i].y);</span><br><span class="line">        sum1 += order[i].x + order[i].y, sum1 -= q1.<span class="built_in">top</span>(), sum2 += q1.<span class="built_in">top</span>();</span><br><span class="line">        q2.<span class="built_in">push</span>(q1.<span class="built_in">top</span>()); q1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">exchange</span>();</span><br><span class="line">        ans2[i] = sum2 - sum1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;k, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%lld%s%lld&quot;</span>, x, &amp;u, y, &amp;v);</span><br><span class="line">        <span class="keyword">if</span>(x[<span class="number">0</span>] == y[<span class="number">0</span>]) ans += <span class="built_in">abs</span>(u - v);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            order[++cnt] = &#123; u, v &#125;;</span><br><span class="line">            t[++tot] = u, t[++tot] = v;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(t + <span class="number">1</span>, t + <span class="number">1</span> + tot);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++)</span><br><span class="line">            ans += <span class="built_in">abs</span>(t[tot &gt;&gt; <span class="number">1</span>] - t[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(order + <span class="number">1</span>, order + <span class="number">1</span> + cnt);</span><br><span class="line">        <span class="built_in">senhan</span>();</span><br><span class="line">        <span class="built_in">gohan</span>();</span><br><span class="line">        res = <span class="number">1e18</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= cnt; i++)</span><br><span class="line">            res = <span class="built_in">min</span>(res, ans1[i] + ans2[i + <span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans + res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>P3645 [APIO2015] 雅加达的摩天楼 题解</title>
    <url>/solutions/solution-p3645/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">雅加达的摩天楼</div>
<div id="problem-info-from">APIO 2015</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM2NDU=">Luogu P3645<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yODg3">LibreOJ L2887<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly91b2ouYWMvcHJvYmxlbS8xMTE=">UOJ #111<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzQwNzA=">BZOJ #4070<i class="fa fa-external-link-alt"></i></span></li></ul></div>

<hr>
<p>题目说，只要一栋楼里面的一只doge知道了消息，那么他就可以在不产生任何代价的情况下将这条消息传递给这栋楼里面的所有doge。</p>
<p>利用这一条信息，我们可以将doge的行动转化为摩天楼之间的边，一只doge能够前往的两栋楼之间会直接或间接联通。</p>
<p>于是我们就可以想到跑最短路。图上的所有边权均为1，从0到1的最短路即为传递消息的代价。</p>
<p>然后再看数据范围：</p>
<p>$N \in [1,30000 ] , M \in [ 2,30000 ] , P_i \in [ 1,30000 ]$</p>
<p>当头一棒。</p>
<p>我们可怜的最短路算法承受不起如此多的边（$O(n^2)$ 级别），我们甚至可以将这张图看做一张完全图来计算时间复杂度，而结果必然是爆炸。</p>
<p>我们如果一开始分析错误了，把它当做费用流来跑SPFA的话，最多能拿到36分(UOJ&amp;LibreOJ)&#x2F;75分(Luogu)。</p>
<p>我们如果使用链式前向星连边、建边，跑Dijkstra的话，可以拿到36分(UOJ&amp;LibreOJ)&#x2F;80分(Luogu)的好成绩。</p>
<p>然后我们会发现上面会MLE，于是选用vector存边。<br>我们如果使用vector连边、建边，跑Dijkstra的话，可以拿到和上面一样的好成绩，并且仍然MLE。</p>
<p>然后我们考虑换个连边方式，不在让每一条边的边权都是相同的了，考虑从一栋楼向其他的楼连边，边权为跳跃次数，妄图减少内存用量。</p>
<p>结果仍为失败。</p>
<p>我们不再考虑显式连边，而考虑在转移的时候再连边，这里就需要用SPFA了。</p>
<p>然后再跑一遍就可以过了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N];</span><br><span class="line"><span class="type">int</span> dis[N], vis[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">63</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[s] = <span class="number">0</span>, vis[s] = <span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : e[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; u + i * j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> v = u + i * j;</span><br><span class="line">                <span class="keyword">if</span>(dis[v] &gt; dis[u] + j)</span><br><span class="line">                &#123;</span><br><span class="line">                    dis[v] = dis[u] + j;</span><br><span class="line">                    <span class="keyword">if</span>(!vis[v])</span><br><span class="line">                    &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(v);</span><br><span class="line">                        vis[v] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; u - i * j &gt;= <span class="number">0</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> v = u - i * j;</span><br><span class="line">                <span class="keyword">if</span>(dis[v] &gt; dis[u] + j)</span><br><span class="line">                &#123;</span><br><span class="line">                    dis[v] = dis[u] + j;</span><br><span class="line">                    <span class="keyword">if</span>(!vis[v])</span><br><span class="line">                    &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(v);</span><br><span class="line">                        vis[v] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="type">int</span> s, t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)s = a;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t = a;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spfa</span>(s);</span><br><span class="line">    <span class="keyword">if</span>(dis[t] == <span class="number">0x3f3f3f3f</span>)<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; dis[t] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>P4643 [国家集训队] 阿狸和桃子的游戏 题解</title>
    <url>/solutions/solution-p4643/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">阿狸和桃子的游戏</div>
<div id="problem-info-from">国家集训队</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQ2NDM=">Luogu P4643<i class="fa fa-external-link-alt"></i></span></li></ul></div>

<hr>
<p>题目大意是，我们需要从一个带有边权和点权的图上对点进行染色，并按照一个特定的规则计分，最终输出两人得分之差，要求差最大。</p>
<p>某一个人的得分是其染色的点权值之和，再加上两端点均被其染色的边权之和。</p>
<hr>
<p>因为我们需要求的是两人得分之差，所以原本一条边的两端点分别被两人染色之后边权互不归属的情况可以看做两人各取一半。<br>同理，如果一条边的两个端点都被同一个人染了色之后，这条边的两半权值都被这个人拿走了，与我们题目里的情况符合。</p>
<p>那我们就可以将边的权值一分为二，分别加到两个端点上，然后将这道题目变成选择最大点权和。</p>
<p>因为两人均采取最优策略，所以桃子取到了最大值之后，阿狸就会取次大值，然后桃子去第三大的值，如此往复。</p>
<p>于是我们就可以将点按照权值降序两两一组，求所有组内点权之差的总和。</p>
<p>然后我们就可以输出答案了。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">        a[i] = k &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        a[x] += z;</span><br><span class="line">        a[y] += z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i -= <span class="number">2</span>)ans += a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>P5290 [十二省联考 2019] 春节十二响 题解</title>
    <url>/solutions/solution-p5290/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">春节十二响</div>
<div id="problem-info-from">十二省联考 2019</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDUyOTA=">Luogu P5290<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8zMDUy">LibreOJ L3052<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzA3NC8=">AcWing 3071<i class="fa fa-external-link-alt"></i></span></li></ul></div>

<hr>
<p>在想不到正解之前，我们可以看到出题人对于树是一条链的情况给了15分。</p>
<p>我们可以先想想一条链上的做法，毕竟树可以被剖成若干条链嘛。</p>
<p>然后就是看根节点的儿子数量。<br>如果只有一个儿子的话就输出 $\sum M_i$，<br>如果有两个儿子的话就对其左右子树分别建立一个堆，每一次取出两个堆的堆顶进行比较，取$\max$之后加入答案。当一个堆取尽之后，把另一个对中的所有元素加入答案，最后加入 $M_1$ 即可。</p>
<p>然后考虑将这个推到树上去。</p>
<p>如果我们从下往上合并每一个节点的所有子树的话，其实还是几条链的合并，因为我们最终会将一棵树合并为一条链，忽略了其他对答案不产生影响的信息。</p>
<p>从而最终还是进行了类似上面的链与链之间的合并，正确性也是毋庸置疑的。</p>
<p>时间复杂度 $O(n^2)$，预期得分60分。</p>
<p>然后我们尝试优化复杂度。</p>
<p>对于两棵子树 $x$ 和 $y$，我们假定 $\operatorname{sz}(x) \geq \operatorname{sz}(y)$。那么，按照我们上面的做法，我们的复杂度是 $O(\operatorname{sz}(x))$ 的。</p>
<p>我们考虑将 $y$ 合并到 $x$ 内，这样就省去了再将 $x$ 中的多余节点加入新堆中的操作了，时间复杂度就可以优化为 $O(\operatorname{sz}(y))$。</p>
<p>最后总的复杂度就是 $O(n \log n)$。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) f = -f; c = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="number">48</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, a[N], f;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N], t;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; tr[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].<span class="built_in">size</span>() &lt; tr[y].<span class="built_in">size</span>()) <span class="built_in">swap</span>(tr[x], tr[y]);</span><br><span class="line">    <span class="keyword">while</span>(tr[y].<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        t.<span class="built_in">push_back</span>(<span class="built_in">max</span>(tr[x].<span class="built_in">top</span>(), tr[y].<span class="built_in">top</span>()));</span><br><span class="line">        tr[x].<span class="built_in">pop</span>(), tr[y].<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(t.<span class="built_in">size</span>()) tr[x].<span class="built_in">push</span>(t.<span class="built_in">back</span>()), t.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; e[x].<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="built_in">dfs</span>(e[x][i]), <span class="built_in">merge</span>(x, e[x][i]);</span><br><span class="line">    tr[x].<span class="built_in">push</span>(a[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        a[i] = <span class="built_in">read</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f = <span class="built_in">read</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        e[f].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(tr[<span class="number">1</span>].<span class="built_in">size</span>()) ans += tr[<span class="number">1</span>].<span class="built_in">top</span>(), tr[<span class="number">1</span>].<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>STL</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>#549. 农夫奶牛的约翰们 题解</title>
    <url>/solutions/solution-sy549/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">农夫奶牛的约翰们</div>
<div id="problem-info-from">none</div>
<div id="problem-info-difficulty">none</div>
<div id="problem-info-color"></div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguMC4xMTE6MTkyNi9wcm9ibGVtLzU0OQ==">SEZSY OJ #549<i class="fa fa-external-link-alt"></i></span></li></ul></div>

<hr>
<h1 id="题意转化"><a href="#题意转化" class="headerlink" title="题意转化"></a>题意转化</h1><p>这道题目要求我们求出树上两点 $x$、$y$ 之间最短路的长度。</p>
<p>首先，我们需要知道一个结论，就是树上连接两个点的简单路径有且只有一条，即为从一个点经过两个点的最近公共祖先再到另一个点的路径。</p>
<p>于是这道题目就被分解成为了两个小一点的问题：求两个点的LCA，和求出这两个点分别到LCA的距离。</p>
<h1 id="分析做法"><a href="#分析做法" class="headerlink" title="分析做法"></a>分析做法</h1><p>对于前者，我们已经有了一些选项：朴素、倍增或者树剖。</p>
<p>瞄一眼数据范围，$n \leq 10^6$，$m \leq 2 \times 10^5$。</p>
<p>（之前有人问了，那我就在这里讲一下）<br>（下面我这里使用形如 $O(\text{预处理}) \sim O(\text{单次询问})$ 的形式来描述复杂度）</p>
<p>朴素算法的时间复杂度是 $O(n) \sim \Theta(n)$，总体的时间复杂度（对于随机数据）大概在 $10^7$ 级别，优化一下应该可以过。<br>但是如果数据有意卡掉朴素算法，那么其时间复杂度会被卡到 $O(nm)$，大概在 $10^11$ 级别，这样子的运算量绝对是过不去的。<br><del>（所以为什么朴素算法可以过）</del></p>
<p>倍增算法的时间复杂度是 $O(n \log n) \sim O(\log n)$，总体的时间复杂度大概在 $10^8$ 级别，但是一般不会跑太满。<br>虽然看上去是挺唬人的，但是毕竟是优化过的算法，时间复杂度的稳定性也是比较高的，虽然说应付随机数据不如朴素好罢了。</p>
<p>树剖算法的时间复杂度是 $O(n) \sim O(\log n)$，总体的时间复杂度大概在 $10^6$ 级别左右，且常数一般较小。</p>
<p>综合比对了以下，看上去还是树剖比较靠谱。</p>
<hr>
<p>对于后者，我们可以用一次 DFS 来求出所有节点到根节点的距离 $\operatorname{dis}(x)$。<br>由于这道题没有给出根节点，我这里习惯使用1号节点来当做根节点。<br>根节点的选择是不会影响算法的正确性的，两个点之间的路径盖世哪条还是哪条，不会因为根节点变了而改变的。</p>
<p>每次在询问的时候，我们对于给出的节点 $x$ 和 $y$，只需要回答 $\operatorname{dis}(x) + \operatorname{dis}(y) - 2 \times \operatorname{dis}(\operatorname{lca}(x,y))$ 即可。<br>因为 $x$ 到根的路径可以分为 $x$ 到 $\operatorname{lca}(x,y)$ 和 $\operatorname{lca}(x,y)$ 到根两段，$y$ 也同理。我们只需要回答 $x$ 到 $\operatorname{lca}(x,y)$ 和 $y$ 到 $\operatorname{lca}(x,y)$ 这两段路径的长度之和即可。</p>
<p>当然，我们可以选择在进行树剖的时候结合线段树或者树状数组维护区间和，同时进行一下边权转点权的方法来维护这个东西。</p>
<h1 id="树剖？"><a href="#树剖？" class="headerlink" title="树剖？"></a>树剖？</h1><p>树剖，全称为树链剖分，是一种通过将一棵树按照一定的规则分为若干条链的方案。</p>
<p>按照不同的法则，树链剖分可以分为重链剖分、长链剖分、实链剖分等等。一般比较常用的是重链剖分。</p>
<h2 id="重链剖分"><a href="#重链剖分" class="headerlink" title="重链剖分"></a>重链剖分</h2><p>重链剖分的思想是，将一棵树按照“重边”来划分称为若干条“重链”。</p>
<h3 id="重链"><a href="#重链" class="headerlink" title="重链"></a>重链</h3><p>“重链”的定义是若干条首尾衔接的“重边”。<br>那么，如果想要了解重链，就需要先了解<strong>重边</strong>。</p>
<h3 id="重边"><a href="#重边" class="headerlink" title="重边"></a>重边</h3><p>“重边”的划分标准是它连接向一个重儿子。<br>这里需要注意的是，它只需要结束于一个重儿子，而无其他限制。<br>那么<strong>重儿子</strong>又是什么呢？</p>
<h3 id="重儿子"><a href="#重儿子" class="headerlink" title="重儿子"></a>重儿子</h3><p>“重儿子”是“重子节点”的别称。<br>我们判断一个子节点是否为重子节点的标准是它的子树大小。</p>
<p>对于一个节点的所有儿子，其中子树最大的那个儿子称为“重儿子”，其余的，则相对地称之为“轻儿子”。<br>连接某个节点和其重儿子的边叫做“重边”，而连接其与其轻儿子的边则相应地叫做“轻边”。</p>
<p>详细一点的解释可以看<span class="exturl" data-url="aHR0cHM6Ly9vaS13aWtpLm9yZy9ncmFwaC9obGQv">OI-Wiki<i class="fa fa-external-link-alt"></i></span>或者<span class="exturl" data-url="aHR0cHM6Ly9rYWlzZXJ3aWxoZWltLmV1Lm9yZy9PSS9oZWF2eS1wYXRoLWRlY29tcG9zaXRpb24v">我的博客<i class="fa fa-external-link-alt"></i></span>。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>树剖的实现是通过两个DFS进行的。</p>
<p>我们这次使用邻接表来存储树的边信息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> w[N], h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个DFS记录了每个节点的父节点(fa)、深度(dep)、子树大小(sz)和重儿子(son)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dep[N], sz[N], fa[N], son[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> father, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[p] = depth, fa[p] = father, sz[p] = <span class="number">1</span>;<span class="comment">//初始化节点状态，记录其深度和父节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])<span class="comment">//遍历其所有儿子</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == father) <span class="keyword">continue</span>;<span class="comment">//防止遍历其父亲</span></span><br><span class="line">        <span class="built_in">dfs1</span>(j, p, depth + <span class="number">1</span>);<span class="comment">//搜索当前儿子</span></span><br><span class="line">        sz[p] += sz[j];<span class="comment">//更新子树大小</span></span><br><span class="line">        <span class="keyword">if</span>(sz[son[p]] &lt; sz[j]) son[p] = j;<span class="comment">//判断是否为重儿子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个DFS记录了每个节点所在重链的链顶节点(top)、dfs序(id)和重新定向的节点权值(nw)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> id[N], top[N], nw[N], cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id[p] = ++cnt, nw[cnt] = w[p], top[p] = t;<span class="comment">//初始化节点信息，记录其DFS序</span></span><br><span class="line">    <span class="keyword">if</span>(!son[p]) <span class="keyword">return</span>;<span class="comment">//是否为叶节点</span></span><br><span class="line">    <span class="built_in">dfs2</span>(son[p], t);<span class="comment">//优先搜索在同一条重链上的重儿子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == fa[p] || j == son[p]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(j, j);<span class="comment">//搜索轻儿子，开一条新的重链，链顶为当前轻儿子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时我们将每一条重链都转化为了一段连续的区间，同时每一个节点的子树也转化为了一段连续的区间，这样子就会方便我们结合线段树或者树状数组等针对区间的数据结构进行维护。</p>
<p>这一点也是树剖对树上路径的问题很友好的原因所在。</p>
<hr>
<p>这里我们实现的时候需要将边权转为点权，我们的方法是将每一条边的边权都转到其两个端点深度较大的那一个上面。</p>
<p>我们在第一遍DFS的时候，就首先将边权转到对应的点上去。<br>我们考虑记录一个<code>rw</code>数组，在第一个DFS里面遍历当前节点的所有子节点的时候加上一个<code>rw[j] = w[i]</code>就可以了。<br>而在第二遍DFS的时候，我们就把<code>rw</code>数组里面的值代替在正常情况下存储点权的<code>w</code>数组赋到<code>nw</code>里面去就可以了。</p>
<p>而在查询的时候，因为 $\operatorname{lca}(x,y)$ 这个点里面存的是它与 $fa[\operatorname{lca}(x,y)]$ 之间的这条边的边权，不在我们需要求的路径上，我们就不需要访问它了。</p>
<hr>
<p>查询的时候，我们定义两个游标，初始位置分别在两个点上，然后不断向上跳至当前重链链顶的父亲，也就是<code>fa[top[p]]</code>，直到跳到同一个重链上，此时深度较小的那一个就是两个点的LCA。</p>
<p>同时我们在每一次游标跳转之前记录一下游标当前位置到游标当前所在重链链顶的这一段区间的边权和，我们使用树状数组进行统计。（因为线段树常数太大，无法通过此题）</p>
<p>查询的代码长这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumpath</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[p] != top[q])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[p]] &lt; dep[top[q]])<span class="built_in">swap</span>(p, q);<span class="comment">//两个游标轮流跳，以防跳过了</span></span><br><span class="line">        res += <span class="built_in">segsum</span>(id[p]) - <span class="built_in">segsum</span>(id[top[p]] - <span class="number">1</span>);</span><br><span class="line">        p = fa[top[p]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[p] &lt; dep[q])<span class="built_in">swap</span>(p, q);</span><br><span class="line">    res += <span class="built_in">segsum</span>(id[p]) - <span class="built_in">segsum</span>(id[q]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在最后询问的时候只需要输出一个<code>sumpath(x,y)</code>即可。</p>
<p>参考代码见<span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguMC4xMTE6MTkyNi9zdWJtaXNzaW9uLzQ0NjM=">这个提交记录<i class="fa fa-external-link-alt"></i></span>。<br>加了个快读，但是影响不大。</p>
<hr>
<p>如果我们选择放弃树状数组的话，我们就可以魔改一下第一次DFS的函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> father, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[p] = depth, fa[p] = father, sz[p] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == father) <span class="keyword">continue</span>;</span><br><span class="line">        dis[j] = dis[p] + w[i];</span><br><span class="line">        <span class="built_in">dfs1</span>(j, p, depth + <span class="number">1</span>);</span><br><span class="line">        sz[p] += sz[j];</span><br><span class="line">        <span class="keyword">if</span>(sz[son[p]] &lt; sz[j]) son[p] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将查询的函数改一下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[p] != top[q])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[p]] &lt; dep[top[q]])<span class="built_in">swap</span>(p, q);</span><br><span class="line">        p = fa[top[p]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[p] &lt; dep[q])<span class="built_in">swap</span>(p, q);</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子就可以处理出来我们的 $\operatorname{dis}$ 和 $\operatorname{lca}(x,y)$，最后按照之前讲过的输出就可以了。</p>
<p>参考代码见<span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguMC4xMTE6MTkyNi9zdWJtaXNzaW9uLzQ0OTk=">这个提交记录<i class="fa fa-external-link-alt"></i></span>。这个没有加快读，但是也不慢。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流 做题记录</title>
    <url>/solution-flow/</url>
    <content><![CDATA[<p>网络流相关做题记录。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<p>（我为什么要造孽放代码上来……）</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="网络流24题"><a href="#网络流24题" class="headerlink" title="网络流24题"></a>网络流24题</h2><ul>
<li>LibreOJ #6000 &#x2F; Luogu P2756 飞行员配对方案问题 <a href="/solution-flow/#%E9%A3%9E%E8%A1%8C%E5%91%98%E9%85%8D%E5%AF%B9%E6%96%B9%E6%A1%88%E9%97%AE%E9%A2%98">&gt;</a></li>
<li>LibreOJ #6004 &#x2F; Luogu P3254 圆桌问题 <a href="/solution-flow/#%E5%9C%86%E6%A1%8C%E9%97%AE%E9%A2%98">&gt;</a></li>
<li>LibreOJ #6007 &#x2F; Luogu P2774 方格取数问题 <a href="/solution-flow/#%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0%E9%97%AE%E9%A2%98">&gt;</a></li>
<li>LibreOJ #6008 &#x2F; Luogu P1251 餐巾计划问题 <a href="/solution-flow/#%E9%A4%90%E5%B7%BE%E8%AE%A1%E5%88%92%E9%97%AE%E9%A2%98">&gt;</a></li>
<li>LibreOJ #6011 &#x2F; Luogu P4015 运输问题 <a href="/solution-flow/#%E8%BF%90%E8%BE%93%E9%97%AE%E9%A2%98">&gt;</a></li>
<li>LibreOJ #6012 &#x2F; Luogu P4014 分配问题 <a href="/solution-flow/#%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98">&gt;</a></li>
<li>LibreOJ #6013 &#x2F; Luogu P4016 负载平衡问题 <a href="/solution-flow/#%E8%B4%9F%E8%BD%BD%E5%B9%B3%E8%A1%A1%E9%97%AE%E9%A2%98">&gt;</a></li>
<li>LibreOJ #6015 &#x2F; Luogu P2754 [CTSC1999] 家园 <a href="/solution-flow/#CTSC1999-%E5%AE%B6%E5%9B%AD">&gt;</a></li>
<li>LibreOJ #6122 &#x2F; Luogu P2770 航空路线问题 <a href="/solution-flow/#%E8%88%AA%E7%A9%BA%E8%B7%AF%E7%BA%BF%E9%97%AE%E9%A2%98">&gt;</a></li>
<li>LibreOJ #6224 &#x2F; Luogu P4012 深海机器人问题 <a href="/solution-flow/#%E6%B7%B1%E6%B5%B7%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%97%AE%E9%A2%98">&gt;</a></li>
</ul>
<h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><ul>
<li>Luogu P1343 地震逃生 <a href="/solution-flow/#%E5%9C%B0%E9%9C%87%E9%80%83%E7%94%9F">&gt;</a></li>
<li>Luogu P2472 [SCOI2007] 蜥蜴 <a href="/solution-flow/#SCOI2007-%E8%9C%A5%E8%9C%B4">&gt;</a></li>
<li>Luogu P2891 [USACO07OPEN] Dining G <a href="/solution-flow/#USACO07OPEN-Dining-G">&gt;</a><br>Luogu P1402 酒店之王 ^<br>Luogu P1231 教辅的组成 ^</li>
<li>Luogu P3701 主主树 <a href="/solution-flow/#%E4%B8%BB%E4%B8%BB%E6%A0%91">&gt;</a></li>
<li>LibreOJ #2239 &#x2F; Luogu P3163 [CQOI2014]危桥 <a href="/solution-flow/#CQOI2014-%E5%8D%B1%E6%A1%A5">&gt;</a></li>
</ul>
<h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><ul>
<li>Luogu P7368 [USACO05NOV] Asteroids G <a href="/solution-flow/#USACO05NOV-Asteroids-G">&gt;</a></li>
</ul>
<h2 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h2><ul>
<li>Luogu P3931 SAC E#1 - 一道难题 Tree <a href="/solution-flow/#SAC-E-1-%E4%B8%80%E9%81%93%E9%9A%BE%E9%A2%98-Tree">&gt;</a></li>
<li>Luogu P1345 [USACO5.4] 奶牛的电信Telecowmunication <a href="/solution-flow/#USACO5-4-%E5%A5%B6%E7%89%9B%E7%9A%84%E7%94%B5%E4%BF%A1Telecowmunication">&gt;</a></li>
<li>Luogu P2057 [SHOI2007] 善意的投票 &#x2F; [JLOI2010] 冠军调查 <a href="/solution-flow/#SHOI2007-%E5%96%84%E6%84%8F%E7%9A%84%E6%8A%95%E7%A5%A8-x2F-JLOI2010-%E5%86%A0%E5%86%9B%E8%B0%83%E6%9F%A5">&gt;</a></li>
</ul>
<h2 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h2><ul>
<li>Luogu P1004 [NOIP2000 提高组] 方格取数 <a href="/solution-flow/#NOIP2000-%E6%8F%90%E9%AB%98%E7%BB%84-%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0">&gt;</a></li>
<li>Luogu P1006 [NOIP2008 提高组] 传纸条 <a href="/solution-flow/#NOIP2008-%E6%8F%90%E9%AB%98%E7%BB%84-%E4%BC%A0%E7%BA%B8%E6%9D%A1">&gt;</a></li>
<li>Luogu P2457 [SDOI2006] 仓库管理员的烦恼 <a href="/solution-flow/#SDOI2006-%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86%E5%91%98%E7%9A%84%E7%83%A6%E6%81%BC">&gt;</a></li>
<li>Luogu P2517 [HAOI2010] 订货 <a href="/solution-flow/#HAOI2010-%E8%AE%A2%E8%B4%A7">&gt;</a></li>
<li>Luogu P2153 [SDOI2009] 晨跑 <a href="/solution-flow/#SDOI2009-%E6%99%A8%E8%B7%91">&gt;</a></li>
</ul>
<h1 id="网络流24题-1"><a href="#网络流24题-1" class="headerlink" title="网络流24题"></a>网络流24题</h1><h2 id="飞行员配对方案问题"><a href="#飞行员配对方案问题" class="headerlink" title="飞行员配对方案问题"></a>飞行员配对方案问题</h2><p>英国飞行员连向源点，外籍飞行员连向汇点，可以搭配的英国飞行员连向外籍飞行员。边权均为 $1$。<br>跑一遍最大流即可。</p>
<p>最后枚举所有边，如果当前边连接一个外籍飞行员和一个英国飞行员，且其容量为空，那么这条边就被流经过，说明这条边代表的一堆飞行员可以配对，输出两端点即可。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p2000-p2999/p2756/p2756.cpp"><code>Luogu</code></a><br><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Libre%20OJ/6000/l6000.cpp"><code>Libre OJ</code></a></p>
</div>

<h2 id="圆桌问题"><a href="#圆桌问题" class="headerlink" title="圆桌问题"></a>圆桌问题</h2><p>因为我们想要让坐在一个桌子旁的人两两不属于同一个代表团，那就可以转化为让一个代表团的人分散在不同的桌子上。</p>
<p>于是我们将所有的代表团和桌子都抽象成点。<br>我们从源点向每个代表团的点连一条容量为代表团人数的边，再从每一张桌子向汇点连一条容量为桌子容量的边。</p>
<p>然后我们将每一个代表团都向每一个桌子连一条容量为1的边。</p>
<p>最后跑最大流，得到的得数就是最多能给多少个人安排上桌子。</p>
<p>如果有人没有安排上桌子，那么久直接输出0即可。<br>如果所有人都安排上桌子了，就搜一下来确定方案。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3254/p3254.cpp"><code>Luogu</code></a><br><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Libre%20OJ/6004/l6004.cpp"><code>Libre OJ</code></a></p>
</div> 

<h2 id="方格取数问题"><a href="#方格取数问题" class="headerlink" title="方格取数问题"></a>方格取数问题</h2><p>我们一旦取走一个数，那么这个数周围的四个格子里面的数就不能被取走了。</p>
<p>那我们可以转化一下，不考虑<strong>允许</strong>，而是考虑<strong>禁止</strong>。</p>
<p>那我们就可以按照权值和最小的原则来得到一种方案并取出，剩下的就是我们所要求的方案。</p>
<p>那我们按照国际象棋棋盘的染色方案进行染色，即对于位于第 $i$ 行 $j$ 列的点，如果 $i+j$ 为奇数则向源点连一条边权为当前格子权值的边，并同时向周围四个点连一条边权为无限大的边；否则连向汇点，边权为当前格子权值。</p>
<p>由于最小割最大流定理，我们在求出最大流之后，拿所有格子的权值总和减去最大流即使我们要的答案。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p2000-p2999/p2774/p2774.cpp"><code>Luogu</code></a><br><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Libre%20OJ/6007/l6007.cpp"><code>Libre OJ</code></a></p>
</div>

<h2 id="餐巾计划问题"><a href="#餐巾计划问题" class="headerlink" title="餐巾计划问题"></a>餐巾计划问题</h2><p>详细分析可以见之前写的<a href="/solutions/solution-p1251/">这篇博客</a>。</p>
<p>我们这样连边：</p>
<ol>
<li>源点与餐厅输出连一条容量为当天用量，费用为0的边；</li>
<li>汇点与餐厅输入连一条容量为当天用量，费用为0的边；</li>
<li>餐厅输出与下一日的餐厅输出连一条容量为无限，费用为0的边。</li>
<li>源点与餐厅输入连一条容量为无限，费用为 $p$ 的边；</li>
<li>餐厅输出与 $n$ 天后的餐厅输入连一条容量为无限，费用为 $s$ 的边，代表快洗部；</li>
<li>餐厅输出与 $m$ 天后的餐厅输入连一条容量为无限，费用为 $f$ 的边，代表慢洗部。</li>
</ol>
<p>然后跑一个最小费用最大流即可，最终的费用就是答案。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p1000-p1999/p1251/p1251.cpp"><code>Luogu</code></a><br><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Libre%20OJ/6008/l6008.cpp"><code>Libre OJ</code></a></p>
</div>

<h2 id="运输问题"><a href="#运输问题" class="headerlink" title="运输问题"></a>运输问题</h2><p>费用流。</p>
<p>源点向仓库连边，仓库向商店连边，商店向汇点连边。</p>
<p>跑费用流即可。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p4000-p4999/p4015/p4015.cpp"><code>Luogu</code></a><br><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Libre%20OJ/6011/l6011.cpp"><code>Libre OJ</code></a></p>
</div>

<h2 id="分配问题"><a href="#分配问题" class="headerlink" title="分配问题"></a>分配问题</h2><p>费用流。</p>
<p>源点向工人连边，工人向工件连边，工件向汇点连边。</p>
<p>跑费用流即可。</p>
<p>和上一道题惊人地相似。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p4000-p4999/p4014/p4014.cpp"><code>Luogu</code></a><br><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Libre%20OJ/6012/l6012.cpp"><code>Libre OJ</code></a></p>
</div>

<h2 id="负载平衡问题"><a href="#负载平衡问题" class="headerlink" title="负载平衡问题"></a>负载平衡问题</h2><p>首先每个点向左右两边的点连边，费用为1，然后：</p>
<p>如果这个点多于平均值，那就向源点连其权值与平均值之差；<br>如果这个点少于平均值，那就像汇点连其权值与平均值之差。</p>
<p>这两种边的费用为0。</p>
<p>然后跑费用流即可。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p4000-p4999/p4016/p4016.cpp"><code>Luogu</code></a><br><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Libre%20OJ/6013/l6013.cpp"><code>Libre OJ</code></a></p>
</div>

<h2 id="CTSC1999-家园"><a href="#CTSC1999-家园" class="headerlink" title="[CTSC1999]家园"></a>[CTSC1999]家园</h2><p>首先我们需要判断一下地球和月球是否联通，这个只需要使用并查集即可。</p>
<p>然后我们枚举天数，直到某一天转移的人达到要求了之后就停止循环，并输出天数。</p>
<p>我们在枚举的时候，逐天按照飞船的行进路线加边。因为每一次飞船都需要花一天时间来走一次的路程，所以我们每一条边都是从某一天的某一个站点到下一天的下一个站点，容量为飞船容量。</p>
<p>然后每一天跑最大流，得到的最大流结果就是当天以及之前所有天的转移人数总和。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p2000-p2999/p2754/p2754.cpp"><code>Luogu</code></a><br><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Libre%20OJ/6015/l6015.cpp"><code>Libre OJ</code></a></p>
</div>

<h2 id="航空路线问题"><a href="#航空路线问题" class="headerlink" title="航空路线问题"></a>航空路线问题</h2><p>题目要求我们找到一条从起点城市到重点城市再回到起点城市的路径，并要求除起点城市外每一个点只能经过一次。</p>
<p>我们考虑拆点，除起点和终点容量为2之外容量均为1，然后按照飞机航线来建边，容量为1。</p>
<p>当然这样我们是不可能得出最大经过的城市个数的，我们需要用到费用流的手段。</p>
<p>我们将每个城市拆点的时候建的边的费用赋为1，其他的边赋为0。</p>
<p>然后我们跑费用流即可。</p>
<p>然后题目还让我们输出一个可能的方案。</p>
<p>于是我们就直接大暴搜就可以了。<br>还要注意起点终点直通的情况。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p2000-p2999/p2770/p2770.cpp"><code>Luogu</code></a><br><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Libre%20OJ/6122/l6122.cpp"><code>Libre OJ</code></a></p>
</div>

<h2 id="深海机器人问题"><a href="#深海机器人问题" class="headerlink" title="深海机器人问题"></a>深海机器人问题</h2><p>这个就是很明显的最大费用最大流，我们只需要把生物标本的价值抽象成为费用即可。</p>
<p>按照题目要求，我们每一个点都向上和向右分别建两条边，一条代表采集了生物标本，容量为1价值为c，另外一条代表已经被采集完了，容量为无限价值为0。</p>
<p>把所有的可以出发的坐标连向源点，容量为 $k$；所有的可以作为目的地的坐标连向汇点，容量为 $r$。</p>
<p>然后跑一遍费用流即可。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p4000-p4999/p4012/p4012.cpp"><code>Luogu</code></a><br><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Libre%20OJ/6224/l6224.cpp"><code>Libre OJ</code></a></p>
</div>

<h1 id="最大流-1"><a href="#最大流-1" class="headerlink" title="最大流"></a>最大流</h1><h2 id="地震逃生"><a href="#地震逃生" class="headerlink" title="地震逃生"></a>地震逃生</h2><p>最大流板子，只不过在跑之前先要用并查集来判断一下连通性。<br>当然也可以直接跑，判断最大流量是否为0。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p1000-p1999/p1343/p1343.cpp"><code>Luogu</code></a></p>
</div>

<h2 id="SCOI2007-蜥蜴"><a href="#SCOI2007-蜥蜴" class="headerlink" title="[SCOI2007] 蜥蜴"></a>[SCOI2007] 蜥蜴</h2><p>这道题在做之前得首先解决<strong>平面距离</strong>是什么。</p>
<p>根据实际测试，本题中的<strong>平面距离</strong>其实指的就是<strong>欧几里得距离</strong>。</p>
<p>由于其 $d \leq 4$，我们就可以直接暴力枚举。</p>
<p>下面是一张图，代表着我们这道题某个点在不同的 $d$ 时需要连边的范围：</p>
<p><img src="https://s2.loli.net/2022/04/21/5IUqMYC4FfsnXSD.png" alt="flowsolu1.png"></p>
<p>然后处理题目所给的信息：<br>石柱的高度就是当前点的容量，所以我们需要拆点；<br>跳出地图外面了就代表可以连向汇点；<br>有蜥蜴就代表着可以连向源点。</p>
<p>然后就跑最大流，得到的是可以逃离地图的蜥蜴个数的最大值，输出蜥蜴总数与其之差即可。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p2000-p2999/p2472/p2472.cpp"><code>Luogu</code></a></p>
</div>

<h2 id="USACO07OPEN-Dining-G"><a href="#USACO07OPEN-Dining-G" class="headerlink" title="[USACO07OPEN] Dining G"></a>[USACO07OPEN] Dining G</h2><p>P1402、P2891和P1231实质上是一类问题，都是三种物品进行匹配，求最大匹配个数。</p>
<p>对于这类问题，我们的思路就是拆点。</p>
<p>将匹配的主体（比如P2891的奶牛、P1402的顾客和P1231的练习册）拆成两个点，中间连一条容量为1的边，然后两个点分别与剩下的两种物品连边，然后跑最大流即可。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p2000-p2999/p2891/p2891.cpp"><code>Luogu P2891</code></a><br><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p1000-p1999/p1402/p1402.cpp"><code>Luogu P1402</code></a><br><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p1000-p1999/p1231/p1231.cpp"><code>Luogu P1231</code></a></p>
</div>

<h2 id="主主树"><a href="#主主树" class="headerlink" title="主主树"></a>主主树</h2><p>经典题目。</p>
<p>我们需要思考一下为什么图中箭头指向的是输的一方。<br>加入我们按照这个思路，每一个byx的人都向能够赢的诗乃的人连一条边，这就是一个新的图。<br>我们想要找到最大的边集，使得边集内的边两两不共用端点，最后我们求出的边集的大小就是byx可以赢的场数。</p>
<p>那我们考虑对这张图建立网络流模型。<br>我们首先把原图中的所有边建立起来，容量为1。<br>然后把所有byx的人连向源点，所有诗乃的人连向汇点。这样每一个流量就代表byx能赢的一场。<br>然后我们需要限制点的访问次数，我们可以拆点。<br>然后就跑最大流即可。</p>
<p>注意我们需要将得到的最大流量与比赛的场次取<code>min</code>再输出，最后才是真正能赢的场数。（没比赛你赢个什么）</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3701/p3701.cpp"><code>Luogu</code></a></p>
</div>

<h2 id="CQOI2014-危桥"><a href="#CQOI2014-危桥" class="headerlink" title="[CQOI2014] 危桥"></a>[CQOI2014] 危桥</h2><p>往返算经过两次，所以我们可以将危桥所说的“经过两次”转化为“往返一次”。</p>
<p>然后，危桥只能往返一次，普通桥能往返无数次，两个人分别想要往返 $a_n$ 次和 $b_n$ 次。</p>
<p>于是我们就可以将一次往返当做一单位的流来走，$a_1$ 和 $b_1$ 连源点，$a_2$ 和 $b_2$ 连汇点，最大流就是能往返的最大次数。</p>
<p>但是这样会忽略一些问题：从 $a_2$ 流出的流到底是来自 $a_1$ 的还是来自 $b_1$的？同理，从 $b_2$ 流出的流到底是来自 $a_1$ 的还是来自 $b_1$的？</p>
<p>我们考虑反向跑一遍，只不过只针对于Bob。<br>这次我们将$a_1$ 和 $b_2$ 连源点，$a_2$ 和 $b_1$ 连汇点，最大流看是否还与上一次相等。</p>
<p>如果两次均等于 $a_n+b_n$ 的话，那么两人的愿望就可以达成，否则就不可以。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3163/p3163.cpp"><code>Luogu</code></a></p>
</div>

<h1 id="二分图-1"><a href="#二分图-1" class="headerlink" title="二分图"></a>二分图</h1><h2 id="USACO05NOV-Asteroids-G"><a href="#USACO05NOV-Asteroids-G" class="headerlink" title="[USACO05NOV] Asteroids G"></a>[USACO05NOV] Asteroids G</h2><p>我们如果想要消除一颗小行星，那么其肯定在列上或者行上有布置过一次武器，或者两者兼有。</p>
<p>那么，每一颗小行星就可以对应二分图上的一条边，我们就需要找一个点集，使得所有边的两个端点之一在这个点集中。</p>
<p>这便是二分图最小点覆盖。</p>
<p>我们就可以用二分图最大匹配来解决这个问题。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p6000%2B/p7368/p7368.cpp"><code>Luogu</code></a></p>
</div>

<h1 id="最小割-1"><a href="#最小割-1" class="headerlink" title="最小割"></a>最小割</h1><h2 id="SAC-E-1-一道难题-Tree"><a href="#SAC-E-1-一道难题-Tree" class="headerlink" title="SAC E#1 - 一道难题 Tree"></a>SAC E#1 - 一道难题 Tree</h2><p>这道题要求我们求出使任何叶子结点与根节点不连通的最小代价。</p>
<p>我们可以转化一下。</p>
<p>我们可以知道，如果我们要求任何叶子结点都与根节点不连通，那么从根节点到每一个叶子结点的路径上面一定被割开过边。<br>我们还需要让费用最小，那么我们最多每条路径上割开一条边。</p>
<p>于是我们就可以用最小割来求解。让根节点连上源点，所有叶子结点连上汇点，然后跑最小割即可。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3931/p3931.cpp"><code>Luogu</code></a></p>
</div>

<h2 id="USACO5-4-奶牛的电信-Telecowmunication"><a href="#USACO5-4-奶牛的电信-Telecowmunication" class="headerlink" title="[USACO5.4] 奶牛的电信 Telecowmunication"></a>[USACO5.4] 奶牛的电信 Telecowmunication</h2><p>题目要求我们求出，我们需要删除多少个点才能使题目给出的两个点之间不连通。</p>
<p>我们之前只做过割边的题目，没有做过这种题目，考虑将其转化一下。<br>方法很简单，就是拆点。</p>
<p>我们可以将删除点改为删除连接被拆的点的两部分的边，这样就可以转化为割边的问题了。</p>
<p>然后建图，原图中的边容量均为无限大，拆点得到的边的容量均为1即可。</p>
<p>然后跑最小割。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p1000-p1999/p1345/p1345.cpp"><code>Luogu</code></a></p>
</div>

<h2 id="SHOI2007-善意的投票-x2F-JLOI2010-冠军调查"><a href="#SHOI2007-善意的投票-x2F-JLOI2010-冠军调查" class="headerlink" title="[SHOI2007] 善意的投票 &#x2F; [JLOI2010] 冠军调查"></a>[SHOI2007] 善意的投票 &#x2F; [JLOI2010] 冠军调查</h2><p>题目告诉我们，我们需要求出来冲突数量。</p>
<p>我们先分析冲突的产生。</p>
<p>冲突之所以会产生，其根本原因就在于与自己至少一个好朋友的政见不合。他们要么违反自己的意愿而产生一单位的冲突，要么违反好朋友的意愿而产生一单位的冲突。</p>
<p>其中第一种冲突完全是由于第二种冲突而产生的。<br>如果这里没有好朋友关系，那么就不会有好朋友之间政见不合而导致的冲突了。</p>
<p>而第二种冲突呢？<br>来源是一对好朋友之间要求与对方持相同政见。</p>
<p>如何解决第二种冲突？<br>简单，不再持自己的立场或者不再为好朋友关系即可。</p>
<p>于是我们就可以连边了。</p>
<p>每一对好朋友之间连双向边，然后每一个小朋友向自己的立场（源点与汇点之间自己看着选）连一条边。容量均为1。</p>
<p>然后跑最小割即可。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p2000-p2999/p2057/p2057.cpp"><code>Luogu</code></a></p>
</div>

<h1 id="费用流-1"><a href="#费用流-1" class="headerlink" title="费用流"></a>费用流</h1><h2 id="NOIP2000-提高组-方格取数"><a href="#NOIP2000-提高组-方格取数" class="headerlink" title="[NOIP2000 提高组] 方格取数"></a>[NOIP2000 提高组] 方格取数</h2><p>每一个点向其右侧和下侧的两个点分别连边，同时每个点拆点，容量为2，边权为方格中的数。<br>$(0,0)$ 连向源点，$(n,n)$ 连向汇点。</p>
<p>然后跑最大费用最大流即可。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p1000-p1999/p1004/p1004.cpp"><code>Luogu</code></a></p>
</div>

<h2 id="NOIP2008-提高组-传纸条"><a href="#NOIP2008-提高组-传纸条" class="headerlink" title="[NOIP2008 提高组] 传纸条"></a>[NOIP2008 提高组] 传纸条</h2><p>每一个点向其右侧和下侧的两个点分别连边，同时每个点拆点，容量为1，边权为好感度。<br>$(0,0)$ 连向源点，$(n,m)$ 连向汇点。</p>
<p>然后跑最大费用最大流即可。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p1000-p1999/p1006/p1006.cpp"><code>Luogu</code></a></p>
</div>

<h2 id="SDOI2006-仓库管理员的烦恼"><a href="#SDOI2006-仓库管理员的烦恼" class="headerlink" title="[SDOI2006] 仓库管理员的烦恼"></a>[SDOI2006] 仓库管理员的烦恼</h2><p>我们想要找到的是一种方案，使得每一种货物能够以最小的代价各自被分到一个单独的仓库里面。<br>但是题目并不需要我们输出具体的方案，只需要我们输出最小代价。</p>
<p>因为本仓库的物品再运回到本仓库是不会产生代价的，所以我们每一个仓库运送货物的代价都可以表示为运进该仓库的商品的代价之和，这等于所有该类商品的数量之和减去当前仓库内的该种商品总数。</p>
<p>于是我们建立 $2n$ 个点，一半代表仓库，一半代表货物种类。<br>每一个仓库都向所有的货物种类连一条容量为1，费用为所有该类商品的数量之和减去当前仓库内的该种商品总数。</p>
<p>然后跑费用流即可。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p2000-p2999/p2457/p2457.cpp"><code>Luogu</code></a></p>
</div>

<h2 id="HAOI2010-订货"><a href="#HAOI2010-订货" class="headerlink" title="[HAOI2010] 订货"></a>[HAOI2010] 订货</h2><p>我们考虑以每月仓库的状态来建立节点。</p>
<p>每个节点都从源点连一条边，容量为无限，费用为 $d_i$，代表进货；<br>同时每个节点都向汇点连一条边，容量为 $U_i$，费用为0，代表供应市场；<br>每个不是最后一个节点的节点都向其下一个节点连一条边，容量为 $S$，代价为 $m$，代表存贮。</p>
<p>最后跑最小费用最大流即可。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p2000-p2999/p2517/p2517.cpp"><code>Luogu</code></a></p>
</div>

<h2 id="SDOI2009-晨跑"><a href="#SDOI2009-晨跑" class="headerlink" title="[SDOI2009] 晨跑"></a>[SDOI2009] 晨跑</h2><p>将十字路口抽象为节点，将街道抽象为边。<br>这道题就不需要我们另建源汇点了，题目中已经给出了源汇点。</p>
<p>一个周期就相当于是从源点到汇点的一个流，路程就相当于是其代价。</p>
<p>于是就建边，跑最小费用最大流。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p2000-p2999/p2153/p2153.cpp"><code>Luogu</code></a></p>
</div>

<!-- <div class="note success"></div> -->
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流</title>
    <url>/OI/flow/</url>
    <content><![CDATA[<p>网络流。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<p>（3-13至3-14重修）<br>（6-23至6-24增添上下界网络流相关内容）</p>
<h1 id="什么是网络流"><a href="#什么是网络流" class="headerlink" title="什么是网络流"></a>什么是网络流</h1><p>网络流是指在<strong>网络</strong>（或者流网络， Flow Network ）中的<strong>流</strong>。</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>网络是指一个有向图 $G&#x3D;(V,E)$。</p>
<p>每条边 $(u,v)\in E$ 都有一个权值 $c(u,v)$，称之为容量（Capacity），当 $(u,v)\notin E$ 时有 $c(u,v)&#x3D;0$。</p>
<p>其中有两个特殊的点：源点（Source）$s\in V$ 和汇点（Sink）$t\in V,(s\neq t)$。</p>
<h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>设 $f(u,v)$ 定义在二元组 $(u\in V,v\in V)$ 上的实数函数且满足</p>
<ol>
<li>容量限制：对于每条边，流经该边的流量不得超过该边的容量，即，$f(u,v)\leq c(u,v)$</li>
<li>斜对称性：每条边的流量与其相反边的流量之和为 0，即 $f(u,v)&#x3D;-f(v,u)$</li>
<li>流守恒性：从源点流出的流量等于汇点流入的流量，即 $\forall x\in V - \lbrace s,t \rbrace , \sum_{(u,x) \in E} f(u,x) &#x3D; \sum_{(x,v) \in E} f(x,v)$</li>
</ol>
<p>那么 $f$ 称为网络 $G$ 的流函数。对于 $(u,v)\in E$，$f(u,v)$ 称为边的<strong>流量</strong>，$c(u,v)-f(u,v)$ 称为边的<strong>剩余容量</strong>。整个网络的流量为 $\sum_{(s,v)\in E}f(s,v)$，即<strong>从源点发出的所有流量之和</strong>。</p>
<p>一般而言也可以把网络流理解为整个图的流量。而这个流量必满足上述三个性质。</p>
<p>流函数的完整定义为</p>
<p>$$<br>f(u,v)&#x3D;<br>\begin{cases}<br>f(u,v), &amp; (u,v) \in E, \\<br>-f(v,u), &amp; (v,u) \in E, \\<br>0, &amp; (u,v) \not\in E , (v,u) \not\in E.<br>\end{cases}<br>$$</p>
<h3 id="反向边"><a href="#反向边" class="headerlink" title="反向边"></a>反向边</h3><p>反向边是网络流中很重要的一类边。</p>
<p>一般的时候，在题目给定的流网络中是不包含有关反向边的信息的，我们画图的时候也一般不将反向边画出来。</p>
<p>但是，反向边可以利用流网络的一些性质，通过对其流量进行操作，使得我们的子程序可以经由其进行反悔的操作。</p>
<p>建立反向边的时候可以使用一些小trick。</p>
<p>我们如果使用邻接表（或称链式前向星）来建图的话，可以选择同时建正向边和反向边，并使边的编号从0开始，从而可以通过使用异或操作来访问当前边的反向边。</p>
<h2 id="网络流的常见问题"><a href="#网络流的常见问题" class="headerlink" title="网络流的常见问题"></a>网络流的常见问题</h2><p>网络流问题中常见的有以下三种：最大流，最小割，费用流。</p>
<p>解决网络流问题的难点不是算法或者代码，而是建图。对于大多数的网络流题目，我们需要仔细分辨琢磨才可以知道如何将问题转换为网络流这几种问题的其中一种或几种，并将题目中的限制用边&#x2F;点的限制体现出来。</p>
<h1 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>对于一个给定的网络，其合法的流函数其实有很多。其中使得整个网络的流量最大的流函数被称为网络的最大流。</p>
<p>求解一个网络的最大流其实有很多用处，例如可以将二分图的最大匹配问题转化为求解最大流。</p>
<p>求解最大流的算法有很多种，比如Ford-Fulkerson增广路算法、Push-Relable预流推进算法等等。<br>实际上，最常用的还是Ford-Fulkerson增广路算法中的EK和Dinic两种。</p>
<h2 id="Ford-Fulkerson-增广路算法"><a href="#Ford-Fulkerson-增广路算法" class="headerlink" title="Ford-Fulkerson 增广路算法"></a>Ford-Fulkerson 增广路算法</h2><p>该方法通过寻找增广路来更新最大流，有EK,dinic,SAP,ISAP等主流算法。</p>
<p>求解最大流之前，我们先认识一些概念。</p>
<h3 id="残量网络"><a href="#残量网络" class="headerlink" title="残量网络"></a>残量网络</h3><p>首先我们介绍一下一条边的剩余容量 $c_f(u,v)$（Residual Capacity），它表示的是这条边的容量与流量之差，即 $c_f(u,v) &#x3D; c(u,v) - f(u,v)$。</p>
<p>对于流函数 $f$，残存网络 $G_f$（Residual Network）是网络 $G$ 中所有结点和<strong>剩余容量大于 0</strong> 的边构成的子图。形式化的定义，即 $G_f &#x3D; (V_f &#x3D; V,E_f &#x3D; \lbrace(u,v) \in E,c_f(u,v) &gt; 0 \rbrace)$。</p>
<p>注意，剩余容量大于 0 的边可能不在原图 $G$ 中（根据容量、剩余容量的定义以及流函数的斜对称性得到）。可以理解为，残量网络中包括了那些还剩了流量空间的边构成的图，也包括虚边（即反向边）。</p>
<h3 id="增广路"><a href="#增广路" class="headerlink" title="增广路"></a>增广路</h3><p>在原图 $G$ 中若一条从源点到汇点的路径上所有边的<strong>剩余容量都大于 0</strong>，这条路被称为增广路（Augmenting Path）。</p>
<p>或者说，在残存网络 $G_f$ 中，一条从源点到汇点的路径被称为增广路。如图：</p>
<p><img src="https://s2.loli.net/2022/02/28/T4tHBFq3yCSarhu.png" alt="maxflow1.png"></p>
<p>我们从 $4$ 到 $3$，肯定可以先从流量为 $20$ 的这条边先走。那么这条边就被走掉了，不能再选，总的流量为 $20$（现在）。然后我们可以这样选择：</p>
<ol>
<li><p>$4 \to 2 \to 3$ 这条 <strong>增广路</strong> 的总流量为 $20$。到 $2$ 的时候还是 $30$，到 $3$ 了就只有 $20$ 了。</p>
</li>
<li><p>$4 \to 2 \to 1 \to 3$ 这样子我们就很好的保留了 $30$ 的流量。</p>
</li>
</ol>
<p>所以我们这张图的最大流就应该是 $20 + 30 &#x3D; 50$。</p>
<h3 id="Edmonds-Karp-动能算法"><a href="#Edmonds-Karp-动能算法" class="headerlink" title="Edmonds-Karp 动能算法"></a>Edmonds-Karp 动能算法</h3><p>这个算法很简单，就是BFS<strong>找增广路</strong>，然后对其进行<strong>增广</strong>，直到图上再也没有增广路了为止。</p>
<p>我们不用管我们找到的增广路的正确性，毕竟如果我们找到了一条更优的路径的话可以通过之前经过的反向边进行反悔。这也就意味着，我们每次需要BFS的边鸡是包括反向边的。</p>
<p>在具体实现的时候，我们每一次找到增广路的时候，记录下这条路径上所有的最小流量 $minf$ ，那么整个图的流量就增加了 $minf$。同时我们给这条路径上的所有边的反向边都加上 $minf$ 的容量，以便将来反悔。</p>
<p>EK 算法的时间复杂度为 $O(nm^2)$（其中 $n$ 为点数，$m$ 为边数）。<br>其效率还有很大提升空间，但实际情况下不一定能跑满，应付 $10^3 \sim 10^4$ 大小的图应该足够了。</p>
<details class="note success"><summary><p>参考代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">20010</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], f[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> q[N], d[N], pre[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">    e[idx] = a, f[idx] = <span class="number">0</span>, ne[idx] = h[b], h[b] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="built_in">sizeof</span>(st));</span><br><span class="line">    q[<span class="number">0</span>] = S, st[S] = <span class="literal">true</span>, d[S] = INF;</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ver = e[i];</span><br><span class="line">            <span class="keyword">if</span>(!st[ver] &amp;&amp; f[i])</span><br><span class="line">            &#123;</span><br><span class="line">                st[ver] = <span class="literal">true</span>;</span><br><span class="line">                d[ver] = <span class="built_in">min</span>(d[t], f[i]);</span><br><span class="line">                pre[ver] = i;</span><br><span class="line">                <span class="keyword">if</span>(ver == T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q[++tt] = ver;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">EK</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        r += d[T];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = T; i != S; i = e[pre[i] ^ <span class="number">1</span>])</span><br><span class="line">            f[pre[i]] -= d[T], f[pre[i] ^ <span class="number">1</span>] += d[T];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">EK</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h3 id="Dinic-算法"><a href="#Dinic-算法" class="headerlink" title="Dinic 算法"></a>Dinic 算法</h3><p>EK 算法每一次遍历残量网络的时候只能最多找到一条增广路，但很可能我们的子程序为此而遍历了整个残量网络。这里还有很大的优化空间。</p>
<p><strong>Dinic 算法</strong>的过程是这样的：每次增广前，我们先用 BFS 来将图分层。设源点的层数为 $0$，那么一个点的层数便是它离源点的最近距离。</p>
<p>通过分层，我们可以干两件事情：</p>
<ol>
<li>如果不存在到汇点的增广路（即汇点的层数不存在），我们即可停止增广。</li>
<li>确保我们找到的增广路是最短的。（原因见下文）</li>
</ol>
<p>接下来是 DFS 找增广路的过程。</p>
<p>我们每次找增广路的时候，都只找比当前点层数多 $1$ 的点进行增广（这样就可以确保我们找到的增广路是最短的）。</p>
<p>Dinic 算法会不断重复这两个过程，直到没有增广路了为止。</p>
<p>Dinic 算法有两个优化：</p>
<ol>
<li><strong>多路增广</strong>：每次找到一条增广路的时候，如果残余流量没有用完怎么办呢？我们可以利用残余部分流量，再找出一条增广路。这样就可以在一次 DFS 中找出多条增广路，大大提高了算法的效率。</li>
<li><strong>当前弧优化</strong>：如果一条边已经被增广过，那么它就没有可能被增广第二次。那么，我们下一次进行增广的时候，就可以不必再走那些已经被增广过的边。</li>
</ol>
<p>Dinic 算法的时间复杂度是 $O(n^2m)$ 级别的，但实际上其实跑不满这个上限。<br>Dinic算法可以说是算法实现难易程度与时间复杂度较为平衡的一个算法，可以应对 $10^4 \sim 10^5$级别的图。<br>特别的，Dinic算法在求解二分图最大匹配问题的时候的时间复杂度是 $O(m\sqrt{n})$ 级别的，实际情况下则比这更优。</p>
<details class="note success"><summary><p>参考代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = <span class="number">200010</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], f[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> q[N], d[N], cur[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">    e[idx] = a, f[idx] = <span class="number">0</span>, ne[idx] = h[b], h[b] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, cur[S] = h[S];</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[v] == <span class="number">-1</span> &amp;&amp; f[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">                cur[v] = h[v];</span><br><span class="line">                <span class="keyword">if</span>(v == T)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q[++tt] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == T)<span class="keyword">return</span> limit;</span><br><span class="line">    <span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        cur[u] = i;<span class="comment">//当前弧优化</span></span><br><span class="line">        <span class="type">int</span> v = e[i];</span><br><span class="line">        <span class="keyword">if</span>(d[v] == d[u] + <span class="number">1</span> &amp;&amp; f[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="built_in">find</span>(v, <span class="built_in">min</span>(f[i], limit - flow));</span><br><span class="line">            <span class="keyword">if</span>(!t)d[v] = <span class="number">-1</span>;</span><br><span class="line">            f[i] -= t, f[i ^ <span class="number">1</span>] += t;</span><br><span class="line">            flow += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>, flow;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>()) <span class="keyword">while</span>(flow = <span class="built_in">find</span>(S, INF)) r += flow;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dinic</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h1 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>对于一个给定的网络，我们删去网络中的一个边集，使得源点与汇点不连通，这个被删去的边集就是这张图的一个<strong>割</strong>。在所有的割中，边集的容量和最小的被称为最小割。</p>
<h2 id="最大流最小割定理"><a href="#最大流最小割定理" class="headerlink" title="最大流最小割定理"></a>最大流最小割定理</h2><p>任何一个网络的最大流量等于最小割中边的容量值和。</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>我们如果回想一下最大流算法走完之后的结果。</p>
<p>对于每一条从源点到汇点的流量为正的路径，我们都能找到至少一条容量跑满的边。</p>
<p>这些边的容量之和就是我们最终得到的最大流。</p>
<p>我们考虑将这些边删去。</p>
<p>那么我们如果对剩下的边跑最大流算法的话，我们得到的最大流将会是0，也就意味着源点将不再与汇点直接连通。</p>
<p>这些跑满的边构成的边集就满足了我们对割的定义。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>所以说，我们完全可以用求解最大流的算法来求解最小割问题。</p>
<h1 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>给定一个网络 $G&#x3D;(V,E)$，每条边除了有容量限制 $c(u,v)$，还有一个单位流量的费用 $w(u,v)$。</p>
<p>当 $(u,v)$ 的流量为 $f(u,v)$ 时，需要花费 $f(u,v)\times w(u,v)$ 的费用。</p>
<p>$w$ 也满足斜对称性，即 $w(u,v)&#x3D;-w(v,u)$。</p>
<p>则该网络中总花费最小的最大流称为<strong>最小费用最大流</strong>，即在最大化 $\sum_{(s,v)\in E}f(s,v)$ 的前提下最小化 $\sum_{(u,v)\in E}f(u,v)\times w(u,v)$。</p>
<p>最小费用最大流问题与带权二分图最大匹配问题的关系就和最大流问题和二分图最大匹配问题的关系类似，这就意味着我们可以使用求解费用流问题的算法来求解带权二分图最大匹配问题。</p>
<h2 id="SSP-算法"><a href="#SSP-算法" class="headerlink" title="SSP 算法"></a>SSP 算法</h2><p>SSP（Successive Shortest Path）算法是一个贪心的算法。它的思路是每次寻找单位费用最小的增广路进行增广，直到图上不存在增广路为止。</p>
<p>如果图上存在单位费用为负的圈，SSP 算法正确无法求出该网络的最小费用最大流。此时需要先使用消圈算法消去图上的负圈。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>如果使用 Bellman-Ford 算法求解最短路，每次找增广路的时间复杂度为 $O(nm)$。设该网络的最大流为 $f$，则最坏时间复杂度为 $O(nmf)$。事实上，这个时间复杂度是<strong>伪多项式的</strong>。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>只需将 EK 算法或 Dinic 算法中找增广路的过程，替换为用最短路算法寻找单位费用最小的增广路即可。</p>
<p>这里写的是SPFA，因为怕有负边权导致的奇怪的结果。</p>
<p>当然，如果没有负权的话可以使用dijkstra。</p>
<details class="note info"><summary><p>基于EK算法的实现</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5010</span>, M = <span class="number">100010</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], f[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> q[N], d[N], pre[N], incf[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">    e[idx] = a, f[idx] = <span class="number">0</span>, w[idx] = -d, ne[idx] = h[b], h[b] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">memset</span>(incf, <span class="number">0</span>, <span class="built_in">sizeof</span>(incf));</span><br><span class="line">    q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, incf[S] = INF;</span><br><span class="line">    <span class="keyword">while</span>(hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh == N) hh = <span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ver = e[i];</span><br><span class="line">            <span class="keyword">if</span>(f[i] &amp;&amp; d[ver] &gt; d[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[ver] = d[t] + w[i];</span><br><span class="line">                pre[ver] = i;</span><br><span class="line">                incf[ver] = <span class="built_in">min</span>(f[i], incf[t]);</span><br><span class="line">                <span class="keyword">if</span>(!st[ver])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++] = ver;</span><br><span class="line">                    <span class="keyword">if</span>(tt == N) tt = <span class="number">0</span>;</span><br><span class="line">                    st[ver] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> incf[T] &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EK</span><span class="params">(<span class="type">int</span> &amp;flow, <span class="type">int</span> &amp;cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    flow = cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = incf[T];</span><br><span class="line">        flow += t, cost += t * d[T];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = T; i != S; i = e[pre[i] ^ <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            f[pre[i]] -= t;</span><br><span class="line">            f[pre[i] ^ <span class="number">1</span>] += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c, d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c, d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> flow, cost;</span><br><span class="line">    <span class="built_in">EK</span>(flow, cost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, flow, cost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<details class="note info"><summary><p>基于 Dinic 算法的实现</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5010</span>, M = <span class="number">200010</span>, INF = <span class="number">1e16</span>;</span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], f[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> q[N], d[N], cur[N], pre[N], incf[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">    e[idx] = a, f[idx] = <span class="number">0</span>, w[idx] = -d, ne[idx] = h[b], h[b] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">memset</span>(incf, <span class="number">0</span>, <span class="built_in">sizeof</span>(incf));</span><br><span class="line">    <span class="built_in">memcpy</span>(cur, h, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, incf[S] = INF;</span><br><span class="line">    <span class="keyword">while</span>(hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh == N)hh = <span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ver = e[i];</span><br><span class="line">            <span class="keyword">if</span>((f[i]) &amp;&amp; (d[ver] &gt; d[t] + w[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                d[ver] = d[t] + w[i];</span><br><span class="line">                pre[ver] = i;</span><br><span class="line">                incf[ver] = <span class="built_in">min</span>(f[i], incf[t]);</span><br><span class="line">                <span class="keyword">if</span>(!st[ver])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++] = ver;</span><br><span class="line">                    <span class="keyword">if</span>(tt == N)tt = <span class="number">0</span>;</span><br><span class="line">                    st[ver] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incf[T] &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == T)<span class="keyword">return</span> lim;</span><br><span class="line">    <span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; lim; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        cur[u] = i;</span><br><span class="line">        <span class="type">int</span> ver = e[i];</span><br><span class="line">        <span class="keyword">if</span>((d[ver] == d[u] + <span class="number">1</span>) &amp;&amp; (f[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="built_in">dfs</span>(ver, <span class="built_in">min</span>(f[i], lim - flow));</span><br><span class="line">            <span class="keyword">if</span>(!t)d[ver] = <span class="number">-1</span>;</span><br><span class="line">            f[i] -= t, f[i ^ <span class="number">1</span>] += t, flow += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dinic</span><span class="params">(<span class="type">int</span> &amp;flow, <span class="type">int</span> &amp;cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    flow = cost = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(r = <span class="built_in">dfs</span>(S, INF))</span><br><span class="line">        &#123;</span><br><span class="line">            flow = r;</span><br><span class="line">            cost += r * d[T];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c, d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c, d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> flow, cost;</span><br><span class="line">    <span class="built_in">dinic</span>(flow, cost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, flow, cost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（貌似寄了，求调）</p>

</details>

<h1 id="上下界网络流"><a href="#上下界网络流" class="headerlink" title="上下界网络流"></a>上下界网络流</h1><p>现在我们每一条边不仅有流量的上界了，还有了流量的下界。</p>
<h2 id="无源汇有上下界可行流"><a href="#无源汇有上下界可行流" class="headerlink" title="无源汇有上下界可行流"></a>无源汇有上下界可行流</h2><p>现在我们手里拿到了一张图，上面没有给定源点和汇点，同时每一条边都有流量的上界和下界。<br>现在我们需要求出来一个方案，使得我们这张图的所有点满足流量平衡（即每一个点流出的流量和流入的流量是相等的），同时满足流量限制。</p>
<p>例题就是LibreOJ的<span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8xMTU=">#115. 无源汇有上下界可行流<i class="fa fa-external-link-alt"></i></span>。</p>
<p>我们的思路如下：</p>
<p>我们可以将我们的一个可行方案拆成两部分，为每一条边的下限加上超出每一条边下限的部分。<br>我们称超出每一条边下限的这部分流叫做附加流。</p>
<p>首先我们跑满所有边的下限，记录下每一个点流入流量与流出流量之差，设其为 $A_i$。</p>
<p>根据上面我们得到的信息，我们在建立一个新图，是正常的不带下界的网络流，并新建两个源汇点 $S$ 与 $T$。这张图里面的边与原先起始点一样，而流量变为了原边的上界减去下界。</p>
<p>因为部分点的流量不是平衡的，我们需要让其在加上附加流之后平衡，同时在求附加流的这个图中也需要保证流量平衡，所以我们需要将每一个点中不平衡的流量给到源点或汇点。</p>
<p>对于 $A_i &gt; 0$ 的，说明这个点流入较多，需要往出流，其附加流的流出流量是大于其流入流量的，所以需要从 $S$ 向其连一条流量为 $A_i$ 的边；<br>对于 $A_i &lt; 0$ 的，说明这个点流出较多，需要再流入，其附加流的流入流量是大于其流出流量的，所以需要从其向 $T$ 连一条流量为 $-A_i$ 的边。</p>
<p>我们对这个新图跑一个最大流，然后看起最大流量是否等于 $S$ 的所有出边流量之和。如果相等，那么原图也就流量平衡了，这时候我们就得到了一个可行的方案。</p>
<details class="note success"><summary><p>参考代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> m, n;</span><br><span class="line"><span class="type">int</span> S, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], f[M], l[M], idx;</span><br><span class="line"><span class="type">int</span> A[N];</span><br><span class="line"><span class="type">int</span> q[N], d[N], cur[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], f[idx] = d - c, l[idx] = c, h[a] = idx++;</span><br><span class="line">    e[idx] = a, ne[idx] = h[b], f[idx] = <span class="number">0</span>, h[b] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, cur[S] = h[S];</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[v] == <span class="number">-1</span> &amp;&amp; f[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">                cur[v] = h[v];</span><br><span class="line">                <span class="keyword">if</span>(v == T)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q[++tt] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == T)<span class="keyword">return</span> limit;</span><br><span class="line">    <span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        cur[u] = i;</span><br><span class="line">        <span class="type">int</span> v = e[i];</span><br><span class="line">        <span class="keyword">if</span>(d[v] == d[u] + <span class="number">1</span> &amp;&amp; f[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="built_in">find</span>(v, <span class="built_in">min</span>(f[i], limit - flow));</span><br><span class="line">            <span class="keyword">if</span>(!t)d[v] = <span class="number">-1</span>;</span><br><span class="line">            f[i] -= t, f[i ^ <span class="number">1</span>] += t;</span><br><span class="line">            flow += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>, flow;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())<span class="keyword">while</span>(flow = <span class="built_in">find</span>(S, INF))r += flow;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    S = <span class="number">0</span>, T = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c, d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c, d);</span><br><span class="line">        A[a] -= c, A[b] += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(S, i, <span class="number">0</span>, A[i]);</span><br><span class="line">            tot += A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A[i] &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(i, T, <span class="number">0</span>, -A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">dinic</span>();</span><br><span class="line">    <span class="keyword">if</span>(res != tot)<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m * <span class="number">2</span>; i += <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[i ^ <span class="number">1</span>] + l[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>






















]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/OI/segment-tree/</url>
    <content><![CDATA[<p>线段树及其衍生，如动态开点线段树、可持久化权值线段树等等。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="什么是线段树？"><a href="#什么是线段树？" class="headerlink" title="什么是线段树？"></a>什么是线段树？</h1><p>线段树是一种数据结构，其可以以 $O( \log n)$ 的时间复杂度处理维护区间信息的问题。<br>其维护的信息满足可以快速合并两个区间的信息（例如区间和、区间最大（小）值。</p>
<p>线段树同时可以支持区间修改，但是区间修改时必须能够快速求出每个区间维护的信息。</p>
<h1 id="线段树的结构"><a href="#线段树的结构" class="headerlink" title="线段树的结构"></a>线段树的结构</h1><p>线段树在建立的时候，会将每一个区间长度不为1的区间进行二分，并递归对这两个区间进行判定。</p>
<p>这是一棵区间长度为12的线段树：</p>
<p><img src="https://s2.loli.net/2022/04/13/wjkzCcr7e4pBQyS.png" alt="segtree1.png"></p>
<p>我们可以明显看到，线段树是一棵二叉树。<br>线段树的高度一般是 $\log n$ 的，这就需要我们建立 $2^{\lceil \log n \rceil + 1}$ 个节点，这将会耗费我们大量的空间。</p>
<p>一般情况下，我们为了访问方便，也为了节省空间，我们一般将一个节点（设其编号为 $p$）的左儿子和右儿子分别设为 $p &lt;&lt; 1$ 和 $p &lt;&lt; 1 | 1$，就相当于是在一棵满二叉树上面访问。</p>
<p>于是我们就给出编号：</p>
<p><img src="https://s2.loli.net/2022/04/13/BYmKAP7NDaSytMq.png" alt="segtree2.png"></p>
<p>下面给出示例代码：</p>
<p>假设我们维护的是区间和，并使用类似</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">&#125;tr;</span><br></pre></td></tr></table></figure>

<p>的结构体来存储数据，那么建立线段树的函数就是像下面这个样子的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].l = l, tr[p].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    tr[p].sum = tr[p &lt;&lt; <span class="number">1</span>].sum + tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线段树的区间询问"><a href="#线段树的区间询问" class="headerlink" title="线段树的区间询问"></a>线段树的区间询问</h1><p>我们这里以区间求和为例。</p>
<p>我们先手动模拟一下区间求和的过程：</p>
<p>假设我们对这样一个长度为12的序列 $\lbrace 1,1,4,5,1,4,1,9,1,9,8,1 \rbrace$ 建立线段树，那么我们每一个区间的数据是这个样子的：</p>
<p><img src="https://s2.loli.net/2022/04/13/kHphs28SOJVRoGT.png" alt="segtree3.png"></p>
<p>我们假设需要对 $[2,8]$ 这个区间内的数据进行求和，那么我们覆盖的区间就是这个样子的：</p>
<p><img src="https://s2.loli.net/2022/04/13/hRWnlYSrVU7d51f.png" alt="segtree4.png"></p>
<p>我们想象一下将区间向上推：</p>
<p><img src="https://s2.loli.net/2022/04/13/Zphkae3wVJO1Lrq.gif" alt="segtree4.gif"></p>
<p>最后我们将 $[2,8]$ 这个大区间分为 $[2,2] \cup [3,3] \cup [4,6] \cup [7,8]$ 这几个小区间。</p>
<p><img src="https://s2.loli.net/2022/04/13/O6IKkaHo5cg1i3V.png" alt="segtree5.png"></p>
<p>我们每一次二分递归的时候，如果当前区间被我们询问的区间完全包含就返回当前区间的值，如果没有完全包含就递归询问左右区间，并输出两个区间的返回值之和。</p>
<p>在递归询问左右两区间的时候需要注意一下子区间是否与询问的区间有重合部分，如果两者交集为空，那就不需要询问了。</p>
<p>下面给出示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">segadd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)<span class="keyword">return</span> tr[p].sum;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res += <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)res += <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线段树的区间修改"><a href="#线段树的区间修改" class="headerlink" title="线段树的区间修改"></a>线段树的区间修改</h1><p>区间修改和区间求和有着相同的思路。</p>
<p>我们这里以区间加为例。</p>
<p>还是之前的例子，如果我们想要给区间 $[2,8]$ 同时加上一个数会怎样？</p>
<p>让我们再来看一下这个图：</p>
<p><img src="https://s2.loli.net/2022/04/13/O6IKkaHo5cg1i3V.png" alt="segtree5.png"></p>
<p>其中白色的区间是完全和我们询问没有任何关系的区间，黄色的区间是与我们询问的区间有交集，但是没有被新闻区间所包含的区间。</p>
<p>红色的区间和橙色的区间都被询问区间所包含，其中红色的区间是我们在区间求和的时候返回了值的区间，橙色的区间虽然被询问区间包含，但是我们没有访问到他们。</p>
<p>区间修改也是一样的思路。我们只需要将需要的区间修改即可，剩下的被询问区间包含的区间只需要标记一下就可以了。</p>
<p>这里需要用到懒标记的思想。</p>
<h2 id="懒标记"><a href="#懒标记" class="headerlink" title="懒标记"></a>懒标记</h2><p>懒标记的意思就是很懒的标记。我们用到它的时候才会将它兑现，否则他就在那里静静地待着就可以了。</p>
<p>我们考虑给结构体里面加上一个懒标记，就像这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    <span class="type">int</span> tag;<span class="comment">//&lt;- 就是这个</span></span><br><span class="line">&#125;tr;</span><br></pre></td></tr></table></figure>

<p>当某个区间有懒标记的时候，就意味着它的子树里面的所有区间都应该被修改，但是目前没有应用上。</p>
<p>但是拥有懒标记的区间的值在修改的时候已经被修改好了。</p>
<p>每一次我们递归询问子区间的时候，我们就需要将这个懒标记下传（如果有的话）。<br>我们需要一个<code>pushdown</code>函数来完成这件事。</p>
<p>我们这里仍然以区间加为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[p], &amp;left = tr[p &lt;&lt; <span class="number">1</span>], &amp;rght = tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(root.tag)</span><br><span class="line">    &#123;</span><br><span class="line">        left.sum += root.tag * (left.r - left.l + <span class="number">1</span>);</span><br><span class="line">        rght.sum += root.tag * (rght.r - rght.l + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//更新子区间值</span></span><br><span class="line">        left.tag += root.tag;</span><br><span class="line">        rght.tag += root.tag;</span><br><span class="line">        <span class="comment">//更新子区间懒标记</span></span><br><span class="line">        root.tag = <span class="number">0</span>;<span class="comment">//懒标记清空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzNzI=">Luogu P3372 【模板】线段树 1<i class="fa fa-external-link-alt"></i></span></p>
<p>参考代码：<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20va2Fpc2Vyd2lsaGVpbS9PSWNvZGVzL2Jsb2IvbWFzdGVyL0x1b2d1L3AzMDAwLXAzOTk5L3AzMzcyL3AzMzcyLmNwcA==">Luogu P3372<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzNzM=">Luogu P3373 【模板】线段树 2<i class="fa fa-external-link-alt"></i></span></p>
<p>参考代码：<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20va2Fpc2Vyd2lsaGVpbS9PSWNvZGVzL2Jsb2IvbWFzdGVyL0x1b2d1L3AzMDAwLXAzOTk5L3AzMzczL3AzMzczLmNwcA==">Luogu P3373<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="标记永久化"><a href="#标记永久化" class="headerlink" title="标记永久化"></a>标记永久化</h2><p>我们可以尝试一个思路：不下传标记。</p>
<p>我们重新思考一下懒标记的意义。</p>
<p>懒标记代表的是，这个点的所有子区间都需要被这个标记更新他们的值。</p>
<p>于是我们就可以将标记放进函数里面，随着函数下传，到时候也可以起到更新值的作用。</p>
<p>这样的方法适用于不能<code>pushdown</code>的时候。</p>
<p>具体情况我也没有遇见过，据说是需要配合可持久化权值线段树（aka主席树）使用。</p>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">segsum</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)<span class="keyword">return</span> tr[p].sum + tag * (tr[p].r - tr[p].l + <span class="number">1</span>);</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res += <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span>, l, r, tag + tr[p].tag);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)res += <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, tag + tr[p].tag);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线段树上二分"><a href="#线段树上二分" class="headerlink" title="线段树上二分"></a>线段树上二分</h2><p>想不到吧，线段树还能优化二分！</p>
<p>我们考虑这样一个问题：我们需要找到一个位置 $pos$，使得 $[1,pos]$ 这个区间内数字的和不小于 $val$。保证所有权值非负。</p>
<p>那么我们可以直接进行二分，这样每做一次的复杂度是 $O(\log^2 n)$ 的。</p>
<p>我们可以用线段树来优化这样的过程。</p>
<p>我们带着 $val$ 在线段树上搜索。<br>如果当前节点的左儿子的权值 $\geq val$，就带着 $val$ 继续跳到左儿子搜索；<br>如果当前节点的左儿子的权值 $&lt; val$，就带着 $val-tr[tr[p].ls].val$ 继续跳到右儿子搜索。</p>
<h2 id="动态开点线段树"><a href="#动态开点线段树" class="headerlink" title="动态开点线段树"></a>动态开点线段树</h2><p>有时候我们需要维护的下标区域非常广（比如说 $10^9$），但是真正有值的地方其实很少。</p>
<p>我们当然不可能为这个序列直接创建一棵完整的线段树，这样子会耗费我们大量的空间维护许多无用的数据。</p>
<p>比如说维护一个序列里面有多少个数字大于某个数，但是这个数列的值域是 $10^9$，但是数列长度最多只有 $10^5$。</p>
<p>我们当然不可能直接创建一个覆盖整个值域的线段树，这样子会需要我们创建 $2^31$ 个节点，即使我们不考虑区间修改，只维护一个区间和的话也需要高达24GiB的空间，十分的浪费。</p>
<p>于是我们可以动态开点，只建立用到的区间，其他的就不会被声明，大大减少了我们需要用的空间。<br>或者说，我们什么时候需要用到某个节点了，我们就建立它。</p>
<p>但是这样做的代价就是我们无法再使用简单的 <code>p&lt;&lt;1</code> 和 <code>p&lt;&lt;1|1</code> 来访问当前节点的左右子节点了。<br>我们需要记录下当前节点的左右节点的编号。</p>
<p>我们以维护一个序列里面有多少个数字大于某个数为例。</p>
<p>那么我们的结构体就会变成这个样子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> ls, rs;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">&#125;tr;</span><br></pre></td></tr></table></figure>

<p>其中 <code>ls</code> 和 <code>rs</code> 分别代表了当前节点的左儿子和右儿子的编号。</p>
<p>那么我们就不需要<code>build</code>了，只需要一开始将第一个节点初始化为根节点即可。</p>
<p>然后我们的区间修改函数就是这个样子的。<br>我们可以有两种风格：</p>
<div class="tabs" id="dongtaikaidianxiugai"><ul class="nav-tabs"><li class="tab active"><a href="#dongtaikaidianxiugai-1">提前开点</a></li><li class="tab"><a href="#dongtaikaidianxiugai-2">用到再开</a></li></ul><div class="tab-content"><div class="tab-pane active" id="dongtaikaidianxiugai-1"><p>我们在访问子节点之前，首先看一下我们将要访问的这个子节点到底是否存在，如果不存在的话就新开一个。</p>
<p>这样子的话支持把当前区间的左右端点放在结构体里面存着，也支持将区间左右端点当做参数放到函数里面传。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">segadd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum += k * (tr[p].r - tr[p].l + <span class="number">1</span>);</span><br><span class="line">        tr[p].add += k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[p].ls)</span><br><span class="line">        &#123;</span><br><span class="line">            tr[p].ls = ++idx;</span><br><span class="line">            tr[tr[p].ls].l = tr[p].l;</span><br><span class="line">            tr[tr[p].ls].r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">segadd</span>(tr[p].ls, l, r, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[p].rs)</span><br><span class="line">        &#123;</span><br><span class="line">            tr[p].rs = ++idx;</span><br><span class="line">            tr[tr[p].rs].l = mid + <span class="number">1</span>;</span><br><span class="line">            tr[tr[p].rs].r = tr[p].r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">segadd</span>(tr[p].rs, l, r, k);</span><br><span class="line">    &#125;</span><br><span class="line">    tr[p].sum = tr[tr[p].ls].sum + tr[tr[p].rs].sum;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="dongtaikaidianxiugai-2"><p>我们在访问子节点的时候才看一下，我们的这个子节点是否存在。如果不存在的话就创建一个。</p>
<p>这样的话我们就在函数里面传节点编号的引用，并且同时把当前区间的左右端点放进函数里面当参数传。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">segadd</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> al, <span class="type">int</span> ar, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)p = ++idx;</span><br><span class="line">    <span class="keyword">if</span>(al &gt;= l &amp;&amp; ar &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum += k * (ar - al + <span class="number">1</span>);</span><br><span class="line">        tr[p].add += k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (al + ar) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)<span class="built_in">segadd</span>(tr[p].ls, l, r, al, mid, k);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)<span class="built_in">segadd</span>(tr[p].rs, l, r, mid + <span class="number">1</span>, ar, k);</span><br><span class="line">    tr[p].sum = tr[tr[p].ls].sum + tr[tr[p].rs].sum;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<p>而查询函数不需要做太大的变动，只需要看一下当前访问的节点是否存在就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">segsum</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)<span class="keyword">return</span> tr[p].sum;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res += <span class="built_in">segsum</span>(tr[p].ls, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)res += <span class="built_in">segsum</span>(tr[p].rs, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可持久化权值线段树"><a href="#可持久化权值线段树" class="headerlink" title="可持久化权值线段树"></a>可持久化权值线段树</h2><p>面对眼前的区间第 $k$ 小问题，我们应该怎么办？</p>
<p>我们的一个思路就是使用主席树。</p>
<p>主席树，全称为可持久化权值线段树，通过保存每次插入操作时的历史版本，以便查询区间第 $k$ 小。</p>
<p>怎么保存呢？</p>
<p>一种暴力的方法就是可以每一次插入的时候都开一棵线段树。<br>但是这样对空间的使用不是很友好。</p>
<p>那么我们分析一下，每一次修改的时候涉及的都只有一条从根节点到我们想要修改的节点的路径。<br>那么我们每一次只需要新建从根节点一直到我们想要修改的节点的一整条路径就可以了。</p>
<p>我们每一次就只新建了 $O(\log n)$ 个节点，大大节省了我们需要用的空间。</p>
<p>这种情况下，我们就不能采用堆式存储法（就是那个把左儿子和右儿子分别设为 $p &lt;&lt; 1$ 和 $p &lt;&lt; 1 | 1$ 的）了，必须使用动态开点。</p>
<p>对于预计需要的节点个数，我们可以采用这种办法：</p>
<p>我们每一次操作最多需要新开 $2^{\lceil \log n \rceil +1}$ 个节点，我们只需要根据 $n$ 和 $m$ 的大小来声明就可以了。</p>
<p>怎么维护区间第 $k$ 小？</p>
<p>一般情况下，我们可以用对区间建立一棵权值线段树的方法来维护当前区间的区间第 $k$ 小。<br>原理就是，权值线段树维护的是区间内每一个数有多少个。<br>我们只需要用类似线段树上二分的思想在线段树上搜索即可。</p>
<p>但是我们不能每一次都根据当前区间建立一棵线段树，这样又麻烦又浪费空间。</p>
<p>所以我们就像利用前缀和减去另一个前缀和得到区间和一样，将给当前区间建立一棵线段树的问题转化成了给分别建立在 $[1,l-1]$ 和 $[1,r]$ 上的两棵线段树做差。<br>而这样的两棵线段树可以通过每一次向线段树维护的区间最后追加一个数字来得到。</p>
<p>而这也就是主席树维护区间第 $k$ 小的主要思想。</p>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM4MzQ=">Luogu P3834 【模板】可持久化线段树 2<i class="fa fa-external-link-alt"></i></span></p>
<p>参考代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3834/p3834.cpp"><code>Luogu P3834</code></a></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM5MTk=">Luogu P3919 【模板】可持久化线段树 1（可持久化数组）<i class="fa fa-external-link-alt"></i></span></p>
<p>参考代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3919/p3919.cpp"><code>Luogu P3919</code></a></p>
<h2 id="区间最大子段和"><a href="#区间最大子段和" class="headerlink" title="区间最大子段和"></a>区间最大子段和</h2><p>区间最大子段和也可以使用线段树来维护。</p>
<p>我们考虑记录一下每一个区间内的最大前缀和、最大后缀和、最大子段和与区间和。</p>
<p>区间合并的时候这样合并：</p>
<ul>
<li>最大前缀和：左儿子的最大前缀和与（右儿子的最大前缀和与左儿子的区间和之和）取最大值；</li>
<li>最大后缀和：右儿子的最大后缀和与（左儿子的最大前缀和与右儿子的区间和之和）取最大值；</li>
<li>最大子段和：左儿子的最大子段和、右儿子的最大子段和与（左儿子的最大后缀和与右儿子的最大前缀和之和）取最大值；</li>
<li>区间和：直接加。</li>
</ul>
<p>写了个重载加号：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> lms, rms;</span><br><span class="line">    <span class="type">int</span> ms, sum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> SegTree <span class="keyword">operator</span> + (<span class="type">const</span> SegTree &amp;lhs, <span class="type">const</span> SegTree &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">        &#123;</span><br><span class="line">            lhs.l, </span><br><span class="line">            rhs.r,</span><br><span class="line">            <span class="built_in">max</span>(lhs.lms, rhs.lms + lhs.sum),</span><br><span class="line">            <span class="built_in">max</span>(rhs.rms, lhs.rms + rhs.sum),</span><br><span class="line">            <span class="built_in">max</span>(lhs.rms + rhs.lms, <span class="built_in">max</span>(lhs.ms, rhs.ms)),</span><br><span class="line">            lhs.sum + rhs.sum</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>然后查询函数就是这个样子的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">SegTree <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)<span class="keyword">return</span> tr[p].ms;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= mid)<span class="keyword">return</span> <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid)<span class="keyword">return</span> <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span>, l, r) + <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用线段树维护区间最大子段和的话还可以支持单点修改。</p>
<p>思路跟正常的单点修改一样。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pos, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l == tr[p].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p] = &#123; tr[p].l,tr[p].r,<span class="built_in">max</span>(k,<span class="number">0</span>),<span class="built_in">max</span>(k,<span class="number">0</span>),<span class="built_in">max</span>(k,<span class="number">0</span>),k &#125;;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid)<span class="built_in">modify</span>(p &lt;&lt; <span class="number">1</span>, pos, k);</span><br><span class="line">    <span class="keyword">if</span>(pos &gt; mid)<span class="built_in">modify</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, pos, k);</span><br><span class="line">    tr[p] = tr[p &lt;&lt; <span class="number">1</span>] + tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details class="note info"><summary><p>[SNOI2020] 区间和</p>
</summary>
<p>暴力修改，不是正解。<br>能过官方数据，但是不能过Hack数据。</p>
<p>提交记录：</p>
<p>洛谷：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDY3OTI=">题面<i class="fa fa-external-link-alt"></i></span>；<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3JlY29yZC83NDA2MDYwOA==">记录<i class="fa fa-external-link-alt"></i></span>。<br>LibreOJ：<span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8zMzI1">题面<i class="fa fa-external-link-alt"></i></span>；<span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcy8xNDcwODU2">记录<i class="fa fa-external-link-alt"></i></span>。</p>

</details>

<h2 id="线段树优化建图"><a href="#线段树优化建图" class="headerlink" title="线段树优化建图"></a>线段树优化建图</h2><p>线段树优化建图，又称线段树优化连边，是一种处理区间连边的方法。</p>
<p>有时候题目会让我们从一个点 $w$ 向一段区间 $[l,r]$ 内的所有点连上一条边权相等的边。</p>
<p>连边数量少的时候我们尚且还可以通过枚举来暴力建边，而当连边数量多起来的时候时间复杂度就不符合我们的要求了。</p>
<p>我们可以利用线段树来辅助我们建图。</p>
<p>线段树上的每一个节点都是一个虚拟的节点，其分别向其左儿子和右儿子连接一条没有影响的边。<br>这里的“没有影响”不仅指边权为0，还可以指流量为 $+\infty$、费用为0等等。</p>
<p>网络流相关的题目中利用这种方式优化建图的很多。</p>
<p>建图的时候，我们首先建立线段树，建立 $2^{\lfloor \log{n} \rfloor +1}$ 个节点和 $2^{\lfloor \log{n} \rfloor +2}$ 条双向边。</p>
<p>然后就是处理区间连边问题。<br>我们就像正常的线段树区间加一样，函数递归时，如果遇到了被完全包含在询问区间内的第一个区间，就从我们指定的点向代表该区间的点连一条边并返回即可。</p>
<h3 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDgwMjE=">洛谷 P8021<i class="fa fa-external-link-alt"></i></span> [ONTAK2015] Bajtman i Okrągły Robin</p>
<p>如果我们使用暴力建图的话，可以想到的是把每一个 Robin 向他能抢劫的时间点连一条容量为1、费用为 $c_i$ 的边。同时，源点向每一个 Robin 连一条容量为1费用为0的边，每一个时间点向汇点连一条容量为1费用为0的边，然后跑最大费用最大流就可以了。</p>
<p>我们如果使用线段树建图的话，就仿照上面的方法，到线段树上连边就可以了。因为我们是在这一段区间内选一个时间点抢劫，所以我们连边的时候仍然保持上面的方式，容量为1、费用为 $c_i$。</p>
<p>题解：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2Jsb2cvS2Fpc2VyLVdpbGhlaW0vc29sdXRpb24tcDgwMjE=">洛谷题解<i class="fa fa-external-link-alt"></i></span></p>
<p>参考代码：<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20va2Fpc2Vyd2lsaGVpbS9PSWNvZGVzL2Jsb2IvbWFzdGVyL0x1b2d1L3A2MDAwKy9wODAyMS9wODAyMS5jcHA=">Luogu P8021<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>2022寒假测试8解析</title>
    <url>/contestrecords/2022-wh-8/</url>
    <content><![CDATA[<p>2022年寒假第8次测试解析。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="T1-「JOISC-2016-Day-2」女装大佬"><a href="#T1-「JOISC-2016-Day-2」女装大佬" class="headerlink" title="T1 「JOISC 2016 Day 2」女装大佬"></a>T1 「JOISC 2016 Day 2」女装大佬</h1><p>原题为 JOISC 2016 Day2 T3 「トイレ」。</p>
<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><details class="note info"><summary><p>题面</p>
</summary>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>题目译自 JOISC 2016 Day2 T3 「トイレ」<br>题面魔改原因：原题是男选手太多所以要借用女厕所 译者表示无法接受<br>IOI 的队服有两种，一种男装，一种是女装。然而很遗憾，所有参赛队伍中并没有女生，只有女装大佬。现在 IOI 设置了两个发放点，一个点只发放男装，另一个点只发放女装。<br>现在，所有队伍总共 $2N$ 个参赛队员，他们排成一列来领取队服，领取队服的规则如下：</p>
<ol>
<li>当前队首是女装大佬，如果领取女装的地方是空的，那么他就会领取女装，否则如果领取男装的地方是空的，他会去领取男装；</li>
<li>当前队首是正常男生，如果领取男装的地方是空的，那么他会领取男装，否则如果女装位空着，他就发挥绅♂士精神，给身后的最前面的女装大佬让位，让他先领取女装。<br>已知任意一个人领取队服都需要一分钟的时间，现在你需要重排所有人的顺序，使他们在 $N$ 分钟内领完队服 。<br>定义一个人的 Dark 值为：在重排队伍之前在他后面，且重排队伍之后在他前面的人的数量。<br>你现在需要找出重排后整个队伍最大的 Dark 值至少为多少。</li>
</ol>
</blockquote>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote>
<p>第一行为一个数 $N$ ，为领完队服的时限，同时 $2N$ 代表着总领队服人数，需要注意的是，这不意味着正常男生和女装大佬刚好各占 $N$ 个；<br>第二行为一个数 $M$，指队伍共有 $M$ 种；<br>之后的 $M$ 行，第 $i$ 行包括一个字符串和一个数字，描述该队伍的组成，其中 <code>M</code> 表示正常男生，<code>F</code> 表示女装大佬，之后的一个数字，表示该字符串连续出现了几次。所有字符串长度乘上出现次数的和等于 $2N$。</p>
</blockquote>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote>
<p>一个数，表示重排后最大 Dark 值的最小值，如果在 $N$ 分钟内不能完成领取队服的任务，输出 $−1$。</p>
</blockquote>

</details>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>（这里的说法是基于原题“トイレ”的背景——撤硕分配来说的）</p>
<p>首先我们需要判断哪个序列是一个可行的方案。</p>
<p>我们虽然可以从头开始模拟，但是这样需要耗费的时间实在是太多了。<br>因此，我们考虑从最后一分钟倒推。</p>
<p>既然我们有两个撤硕，总共 $2N$ 个人，需要在 $N$ 分钟内解决问题，那么必须是每一分钟都有两个人在上厕所。</p>
<p>那么我们看一下最后一分钟。<br>如果最后一分钟在队列里面等待的是两个男生，那么他们已经可以商量谁去女厕所了。<br>所以我们可以猜想，男的必须尽量靠前。</p>
<p>我们尝试将每一个 <code>F</code> 当做 $-1$，<code>M</code> 当做 $1$，基于此统计其后缀和。<br>我们需要确保所有人加起来不大于0，即最多有 $N$ 个男生。<br>我们还需要确保每一段后缀和都不大于1。自己用手推算一下的话，那么我们可以轻易发现，一旦有后缀和超过1的情况的话，那么最后肯定有两个（或更多）男生需要决定谁进女厕所。</p>
<p>我们可以选择二分让队尾多少个男生去往队头，也可以统计整个序列中后缀和最大值之后再+1。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>100分代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll n, m;</span><br><span class="line">ll chq, ans, temp;</span><br><span class="line">ll t[N], p[N], maxp[N];</span><br><span class="line"><span class="type">char</span> s[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s + <span class="number">1</span> &gt;&gt; t[i];</span><br><span class="line">        <span class="type">int</span> lens = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = lens; j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            p[i] += (s[j] == <span class="string">&#x27;F&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>);</span><br><span class="line">            maxp[i] = <span class="built_in">max</span>(p[i], maxp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        chq += p[i] * t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(chq &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = m; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i] &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, temp + (t[i] - <span class="number">1</span>) * p[i] + maxp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, temp + maxp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        temp += p[i] * t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一发36分的Java8代码：</p>
<details class="note warning"><summary><p>Java8</p>
</summary>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//import java.util.Arrays;</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">S2544</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span>[] t=<span class="keyword">new</span> <span class="title class_">long</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span>[] p=<span class="keyword">new</span> <span class="title class_">long</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span>[] maxp=<span class="keyword">new</span> <span class="title class_">long</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span> chq=<span class="number">0</span>,ans=<span class="number">0</span>,temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner scan=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">long</span> n=scan.nextInt();</span><br><span class="line">        <span class="type">int</span> m=scan.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            String inp=scan.next();</span><br><span class="line">            t[i]=scan.nextInt();</span><br><span class="line">            <span class="type">int</span> len=inp.length();</span><br><span class="line">            <span class="type">char</span>[] s=inp.toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=len-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                p[i]+=(s[j]==<span class="string">&#x27;F&#x27;</span>?-<span class="number">1</span>:<span class="number">1</span>);</span><br><span class="line">                maxp[i]=max(p[i],maxp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            chq+=p[i]*t[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(chq&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    ans=max(ans,temp+(t[i]-<span class="number">1</span>)*p[i]+maxp[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans=max(ans,temp+maxp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                temp+=p[i]*t[i];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ans-<span class="number">1</span>);</span><br><span class="line">            scan.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">max</span><span class="params">(<span class="type">long</span> a,<span class="type">long</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h1 id="T2-【常中20180812T3】-test"><a href="#T2-【常中20180812T3】-test" class="headerlink" title="T2 【常中20180812T3】 test"></a>T2 【常中20180812T3】 test</h1><h2 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h2><details class="note info"><summary><p>题面</p>
</summary>
<h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><blockquote>
<p>Tom在学写动态树，但是做题时过了样例，提交RE。Tom抓住Jerry要他写个暴力来对拍。Jerry觉得这任务太简单了，就让你来完成一下。</p>
</blockquote>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>有一棵 $n$个节点的树，初始时根节点为1。现在要支持如下操作——</p>
<ol>
<li>将某节点设置为根；</li>
<li>改变某节点权值；</li>
<li>询问以某节点为根的子树内节点权值之和；</li>
<li>询问以某两点为端点的链上的节点权值之和。</li>
</ol>
</blockquote>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote>
<p>第一行两个正整数 $n$ 和 $q$ ，表示树的节点数和操作个数。<br>接着 $n−1$ 行每行两个整数 $u$ 和 $v$ ，表示有连接 $u$ 和 $v$ 的一条边。<br>随后一行 $n$ 个正整数，表示每个点的初始权值。<br>之后 $q$ 行每行格式如下：<br>首先一个范围为 $[1,4]$ 的正整数，表示该操作类型。<br>对于1操作，之后一个正整数 $x$ ，表示将 $x$ 节点设置为根。<br>对于2操作，之后两个正整数 $x$ 和 $v$ ，表示将 $x$ 节点的权值改为 $v$ 。<br>对于3操作，之后一个正整数 $x$ ，表示询问以 $x$ 为根的子树内节点权值之和。<br>对于4操作，之后两个正整数 $x$ 和 $y$ ，表示询问以 $x$ 和 $y$ 为端点的链上的节点权值之和。</p>
</blockquote>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote>
<p>对于每个操作3和操作4，输出一行一个整数表示询问的答案。</p>
</blockquote>

</details>

<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>根据题目所给出的要求，我们可以使用LCT做这道题。</p>
<p>但是LCT太难了我不会啊QwQ</p>
<p>所以我们考虑退而求其次，使用换根树剖来做。<br>实测可行。</p>
<p>换根操作只会影响作用于一个节点子树上的操作，比如子树加，子树求和等等。</p>
<p>巧了，这里就有一个。</p>
<p>那就有点头疼。</p>
<p>我们根据要需要操作的节点 $x$ 和现根节点 $rt$ 的关系来考虑分三种情况：</p>
<ol>
<li><p><code>x==rt</code><br>这种情况明显很简单——就是整棵树。</p>
</li>
<li><p><code>lca(x,rt)！=x</code><br>这样我们可以知道现在的根 $rt$ 没有在 $x$ 的子树里，此时 $x$ 的子树与根为1时的子树无异，可以直接操作。</p>
</li>
<li><p><code>lca(x,rt)==x</code><br>这时候我们发现 $rt$ 在 $x$ 的子树里面。<br>此时，$x$ 的子树就会发生很大的改变。原先 $x$ 的子树包含 $rt$ 的那个儿子现在成为了 $x$ 的父亲，而其他儿子不变。原先为 $x$ 父亲的节点成为了 $x$ 的其中一个儿子，原先除其子树以外的节点都成为了其子树。<br>我们称这个子树包含 $rt$ 的儿子为 $v$ 。<br>现在 $x$ 的子树是 $[ 1 , id_v ) \cup ( id_v + sz_v - 1 , n ]$ 这两段连续的区间。<br>我们可以考虑对这两段区间分别操作，也可以选择对整棵树操作以后在减去中间的那一块er。</p>
</li>
</ol>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>100分代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N], h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> id[N], nw[N], cnt;</span><br><span class="line"><span class="type">int</span> dep[N], sz[N], top[N], fa[N], son[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    ll sum;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> vater, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[p] = depth, fa[p] = vater, sz[p] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == vater)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(j, p, depth + <span class="number">1</span>);</span><br><span class="line">        sz[p] += sz[j];</span><br><span class="line">        <span class="keyword">if</span>(sz[son[p]] &lt; sz[j])son[p] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id[p] = ++cnt, nw[cnt] = w[p], top[p] = t;</span><br><span class="line">    <span class="keyword">if</span>(!son[p])<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[p], t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == fa[p] || j == son[p])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(j, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].sum = tr[p &lt;&lt; <span class="number">1</span>].sum + tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].l = l, tr[p].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum = nw[r];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">segchg</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> ed, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((tr[p].l == ed) &amp;&amp; (tr[p].r == ed))</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum = k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ed &lt;= mid)<span class="built_in">segchg</span>(p &lt;&lt; <span class="number">1</span>, ed, k);</span><br><span class="line">    <span class="keyword">if</span>(ed &gt; mid)<span class="built_in">segchg</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, ed, k);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">segsum</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((tr[p].l &gt;= l) &amp;&amp; (tr[p].r &lt;= r))<span class="keyword">return</span> tr[p].sum;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res += <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)res += <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sumtree</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">segsum</span>(<span class="number">1</span>, id[p], id[p] + sz[p] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sumpath</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[p] != top[q])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[p]] &lt; dep[top[q]])<span class="built_in">swap</span>(p, q);</span><br><span class="line">        res += <span class="built_in">segsum</span>(<span class="number">1</span>, id[top[p]], id[p]);</span><br><span class="line">        p = fa[top[p]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[p] &lt; dep[q])<span class="built_in">swap</span>(p, q);</span><br><span class="line">    res += <span class="built_in">segsum</span>(<span class="number">1</span>, id[q], id[p]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[p] != top[q])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[p]] &lt; dep[top[q]])<span class="built_in">swap</span>(p, q);</span><br><span class="line">        p = fa[top[p]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[p] &lt; dep[q])<span class="built_in">swap</span>(p, q);</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_v</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[p] != top[q])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[p]] &lt; dep[top[q]])<span class="built_in">swap</span>(p, q);</span><br><span class="line">        <span class="keyword">if</span>(fa[top[p]] == q)<span class="keyword">return</span> top[p];</span><br><span class="line">        p = fa[top[p]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[p] &lt; dep[q])<span class="built_in">swap</span>(p, q);</span><br><span class="line">    <span class="keyword">return</span> son[q];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">        <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="type">int</span> rt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rt = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ll z;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;z);</span><br><span class="line">            <span class="built_in">segchg</span>(<span class="number">1</span>, id[x], z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x == rt)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, tr[<span class="number">1</span>].sum);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">lca</span>(x, rt) != x)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">sumtree</span>(x));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, tr[<span class="number">1</span>].sum - <span class="built_in">sumtree</span>(<span class="built_in">get_v</span>(rt, x)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">sumpath</span>(x, y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>re的Java8代码（求调）：</p>
<details class="note warning"><summary><p>Java8</p>
</summary>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] w=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] h=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] e=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">200020</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] ne=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">200020</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> idx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] id=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] nw=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] dep=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] sz=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] top=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] fa=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] son=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">static</span> SegTree[] tr=<span class="keyword">new</span> <span class="title class_">SegTree</span>[<span class="number">800080</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Arrays.fill(h,-<span class="number">1</span>);</span><br><span class="line">        Scanner scan=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> n=scan.nextInt();</span><br><span class="line">        <span class="type">int</span> m=scan.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> a=scan.nextInt();</span><br><span class="line">            <span class="type">int</span> b=scan.nextInt();</span><br><span class="line">            add(a,b);</span><br><span class="line">            add(b,a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            w[i]=scan.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        dfs1(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="type">int</span> rt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="type">int</span> op=scan.nextInt();</span><br><span class="line">            <span class="type">int</span> x=scan.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">                rt=x;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="type">int</span> y=scan.nextInt();</span><br><span class="line">                segchg(<span class="number">1</span>,id[x],y);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x==rt)&#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%d\n&quot;</span>,tr[<span class="number">1</span>].sum);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(lca(x,rt)!=x)&#123;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;%d\n&quot;</span>,sumtree(x));</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;%d\n&quot;</span>,tr[<span class="number">1</span>].sum-sumtree(get_v(rt,x)));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">4</span>)&#123;</span><br><span class="line">                <span class="type">int</span> y=scan.nextInt();</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\n&quot;</span>,sumpath(x,y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        e[idx]=b;</span><br><span class="line">        ne[idx]=h[a];</span><br><span class="line">        h[a]=idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs1</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> father,<span class="type">int</span> depth)</span>&#123;</span><br><span class="line">        dep[p]=depth;</span><br><span class="line">        fa[p]=father;</span><br><span class="line">        sz[p]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[p];i!=-<span class="number">1</span>;i=ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(j==father)<span class="keyword">continue</span>;</span><br><span class="line">            dfs1(j,p,depth+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(sz[son[p]]&lt;sz[j])son[p]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs2</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> t)</span>&#123;</span><br><span class="line">        id[p]=++cnt;</span><br><span class="line">        nw[cnt]=w[p];</span><br><span class="line">        top[p]=t;</span><br><span class="line">        <span class="keyword">if</span>(son[p]==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        dfs2(son[p],t);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[p];i!=-<span class="number">1</span>;i=ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>((j==fa[p])||(j==son[p]))<span class="keyword">continue</span>;</span><br><span class="line">            dfs2(j,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">pushup</span><span class="params">(<span class="type">int</span> p)</span>&#123;</span><br><span class="line">        tr[p].sum=tr[p&lt;&lt;<span class="number">1</span>].sum+tr[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        tr[p].l=l;</span><br><span class="line">        tr[p].r=r;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            tr[p].sum=nw[r];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        build(p&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">        build(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        pushup(p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">segchg</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> ed,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((tr[p].l==ed)&amp;&amp;(tr[p].r==ed))&#123;</span><br><span class="line">            tr[p].sum=k;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=(tr[p].l+tr[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ed&lt;=mid)segchg(p&lt;&lt;<span class="number">1</span>,ed,k);</span><br><span class="line">        <span class="keyword">if</span>(ed&gt;mid)segchg(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,ed,k);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">segsum</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((tr[p].l&gt;=l)&amp;&amp;(tr[p].r&lt;=r))<span class="keyword">return</span> tr[p].sum;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mid=(tr[p].l+tr[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)res+=segsum(p&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)res+=segsum(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sumtree</span><span class="params">(<span class="type">int</span> p)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> segsum(<span class="number">1</span>,id[p],id[p]+sz[p]-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sumpath</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(top[p]!=top[q])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dep[top[p]]&lt;dep[top[q]])&#123;</span><br><span class="line">                <span class="type">int</span> temp=p;</span><br><span class="line">                p=q;</span><br><span class="line">                q=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            res+=segsum(<span class="number">1</span>,id[top[p]],id[p]);</span><br><span class="line">            p=fa[top[p]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dep[p]&lt;dep[q])&#123;</span><br><span class="line">            <span class="type">int</span> temp=p;</span><br><span class="line">            p=q;</span><br><span class="line">            q=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        res+=segsum(<span class="number">1</span>,id[q],id[p]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lca</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(top[p]!=top[q])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dep[top[p]]&lt;dep[top[q]])&#123;</span><br><span class="line">                <span class="type">int</span> temp=p;</span><br><span class="line">                p=q;</span><br><span class="line">                q=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            p=fa[top[p]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dep[p]&lt;dep[q])&#123;</span><br><span class="line">            <span class="type">int</span> temp=p;</span><br><span class="line">            p=q;</span><br><span class="line">            q=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">get_v</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(top[p]!=top[q])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dep[top[p]]&lt;dep[top[q]])&#123;</span><br><span class="line">                <span class="type">int</span> temp=p;</span><br><span class="line">                p=q;</span><br><span class="line">                q=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fa[top[p]]==q)<span class="keyword">return</span> top[p];</span><br><span class="line">            p=fa[top[p]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dep[p]&lt;dep[q])&#123;</span><br><span class="line">            <span class="type">int</span> temp=p;</span><br><span class="line">            p=q;</span><br><span class="line">            q=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> son[q];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegTree</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> l;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h1 id="T3-【20180819省队班】-取数字"><a href="#T3-【20180819省队班】-取数字" class="headerlink" title="T3 【20180819省队班】 取数字"></a>T3 【20180819省队班】 取数字</h1><h2 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h2><details class="note info"><summary><p>题面</p>
</summary>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>给定 $n$ 个整数 $a_i$，你需要从中选取若干个数，使得它们的和是 $m$ 的倍数。问有多少种方案。有多个询问，每次询问一个的 $m$ 对应的答案。</p>
</blockquote>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote>
<p>第一行两个正整数 $n$，$q$，分别表示整数的数量和询问的数量。<br>第二行 $n$ 个整数 $a_i$ 。<br>接下来 $q$ 行，每行表示一个 $m$。</p>
</blockquote>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote>
<p>对于每个询问，输出一行答案 $\bmod{1e9+7}$。</p>
</blockquote>

</details>

<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>这道题是个背包计数的问题，背包的容量是模m循环的。<br>记<code>f[i][j]</code>表示考虑了前 $i$个整数，当前余数是 $j$，有选和不选两种情况。那么对于一次询问 $q$，我们直接做的复杂度是 $O(nm)$，总复杂度 $O(nmq)$。这档暴力分应该拿到。</p>
<p>我们注意到m很小，而n很大，也就是说有很多重复的值，那么我们考虑设计一个下标为<code>dp[m][m]</code>的DP方法，每次考虑一类数。<br>假设第 $i$ 种数有 <code>k[i]</code> 个，我们的转移是：<br>$$<br>dp[i][j]&#x3D;\sum_{h&#x3D;0}^{k[i]} C_{k[i]}^h dp[i-1][j - h \times a[i] \bmod m]<br>$$<br>注意到 $\sum k[i]&#x3D;n$ ，以及dp数组的第二维最大只有m，因此我们可以每次 $O(k[i])$ 地预处理出组合数的系数，表示<code>dp[i-1][j]</code>的贡献。写成伪代码就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for h : [0, k[i]]</span><br><span class="line">    c[h % m] += C(k[i], h)</span><br></pre></td></tr></table></figure>

<p>然后我们再递推<code>dp[i][j]</code>，把 $dp[i-1][j]\times c[k]\to dp[i][j+k\times i\bmod m]$ 即可。</p>
<p>总复杂度$O(q(n+m^3))$。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>100分代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200020</span>, M = <span class="number">110</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll T, n, m, k;</span><br><span class="line">ll a[N], fac[N], inv[N];</span><br><span class="line">ll t[M], f[M][M], pre[M];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>)ans = (ans * x) % mod;</span><br><span class="line">        x = (x * x) % mod;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll b, ll a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (((fac[b] * inv[a]) % mod) * (inv[b - a])) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++)fac[i] = (fac[i - <span class="number">1</span>] * i) % mod;</span><br><span class="line">    inv[N - <span class="number">1</span>] = <span class="built_in">qpow</span>(fac[N - <span class="number">1</span>], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = N - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)inv[i] = ((i + <span class="number">1</span>) * inv[i + <span class="number">1</span>]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(t, <span class="number">0</span>, <span class="built_in">sizeof</span>(t));</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)t[(a[i] % m + m) % m]++;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">qpow</span>(<span class="number">2</span>, t[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="built_in">sizeof</span>(pre));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= t[i]; k++)pre[k % m] = (pre[k % m] + <span class="built_in">C</span>(t[i], k)) % mod;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="built_in">min</span>(m - <span class="number">1</span>, t[i]); k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    f[i][(j + i * k) % m] = (f[i][(j + i * k) % m] + f[i - <span class="number">1</span>][j] * pre[k] % mod) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[m - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>re的Java8代码（求调）：</p>
<details class="note warning"><summary><p>Java8</p>
</summary>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> N=<span class="number">200020</span>,M=<span class="number">110</span>,mod=(<span class="type">int</span>)(<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span>[] a=<span class="keyword">new</span> <span class="title class_">long</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span>[] fac=<span class="keyword">new</span> <span class="title class_">long</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span>[] inv=<span class="keyword">new</span> <span class="title class_">long</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span>[] t=<span class="keyword">new</span> <span class="title class_">long</span>[M];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span>[][] f=<span class="keyword">new</span> <span class="title class_">long</span>[M][M];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span>[] pre=<span class="keyword">new</span> <span class="title class_">long</span>[M];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner scan=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        init();</span><br><span class="line">        <span class="type">int</span> n=scan.nextInt();</span><br><span class="line">        <span class="type">int</span> T=scan.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i]=scan.nextInt();</span><br><span class="line">        <span class="keyword">while</span>((T--)!=<span class="number">0</span>)&#123;</span><br><span class="line">            Arrays.fill(t,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;M;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;M;j++)f[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> m=scan.nextInt();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)t[(<span class="type">int</span>)((a[i]%m+m)%m)]++;</span><br><span class="line">            f[<span class="number">0</span>][<span class="number">0</span>]=qpow(<span class="number">2</span>,t[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">                Arrays.fill(pre,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=t[i];k++)pre[k%m]=(pre[k%m]+C((<span class="type">int</span>)t[i],k))%mod;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=min(m-<span class="number">1</span>,(<span class="type">int</span>)t[i]);k++)&#123;</span><br><span class="line">                        f[i][(j+i*k)%m]=(f[i][(j+i*k)%m]+f[i-<span class="number">1</span>][j]*pre[k]%mod)%mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(f[m-<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">qpow</span><span class="params">(<span class="type">long</span> x,<span class="type">long</span> k)</span>&#123;</span><br><span class="line">        <span class="type">long</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((k&amp;<span class="number">1</span>)==<span class="number">1</span>)ans=(ans*x)%mod;</span><br><span class="line">            x=(x*x)%mod;</span><br><span class="line">            k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">C</span><span class="params">(<span class="type">int</span> b,<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (((fac[b]*inv[a])%mod)*(inv[b-a]))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        fac[<span class="number">0</span>]=<span class="number">1l</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)fac[i]=(fac[i-<span class="number">1</span>]*i)%mod;</span><br><span class="line">        inv[N-<span class="number">1</span>]=qpow(fac[N-<span class="number">1</span>],mod-<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=N-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)inv[i]=((i+<span class="number">1</span>)*inv[i+<span class="number">1</span>])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

]]></content>
      <categories>
        <category>比赛解析</category>
      </categories>
      <tags>
        <tag>比赛解析</tag>
      </tags>
  </entry>
  <entry>
    <title>傅里叶变换</title>
    <url>/maths/fourier-transform/</url>
    <content><![CDATA[<p>简介： 傅里叶变换和FFT、复数、单位根<br>（20220321重修）</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>今天AJ给大家留了一个作业：</p>
<p>多项式相乘。</p>
<p>$$<br>\begin{gather}<br>f(x) &#x3D; (x^2 + 3x - 1) \\<br>g(x) &#x3D; (2x^2 + x - 5) \\<br>f(x) \times g(x) &#x3D; ?<br>\end{gather}<br>$$</p>
<p>大家都很认真、很用心地做了出来。</p>
<p>$$<br>\begin{align}<br>f(x) \times g(x) &amp; &#x3D; (x^2 + 3x - 1) (2x^2 + x - 5) \\<br>&amp; &#x3D; x^2 \times g(x) + 3x \times g(x) - g(x) \\<br>&amp; &#x3D; (2x^4 + x^3 - 5x^2) + (6x^3 + 3x^2 - 15x) + (2x^2 + x - 5) \\<br>&amp; &#x3D; 2x^4 + x^3 - 5x^2 + 6x^3 + 3x^2 - 15x + 2x^2 + x - 5 \\<br>&amp; &#x3D; 2x^4 + 7x^3 - 4x^2 - 16x + 5<br>\end{align}<br>$$</p>
<p>看起来很复杂，对吗？</p>
<p>但是，精通数学的王哥在纸上写写画画几十秒钟之后，得出来的答案跟正确答案也是一样的。<br>惊呆了的tüe问王哥他用的是什么办法。<br>王哥回答：“ <strong>傅里叶变换</strong> 。”</p>
<h1 id="多项式乘法的本质"><a href="#多项式乘法的本质" class="headerlink" title="多项式乘法的本质"></a>多项式乘法的本质</h1><p>王哥说：“我们知道，所有多项式都拥有如下的形式：</p>
<p>$$<br>f(x) &#x3D; a_0 x^n + a_1 x^{n-1} + a_2 x^{n-2} + \cdots + a_{n-2} x^2 + a_{n-1} x +a_n<br>$$</p>
<p>我们也可以把一个多项式写成这样的形式：</p>
<p>$$<br>f(x) &#x3D; \sum_{i&#x3D;0}^n a_i x^{n-i}<br>$$</p>
<p>而两个多项式相乘 $f(x) \times g(x) &#x3D; h(x)$ 的时候，相乘的结果的第 $k$ 项系数 $h_{k-1}$ 等于所有 $f_{i}$ 与 $g_{k-i}$ 乘积之和。<br>所以，</p>
<p>$$<br>h_k &#x3D; \sum_{i&#x3D;0}^{k-1} f_i \times g_{k-1-i}<br>$$</p>
<p>这样的方法算出的结果是与两个多项式的次数相关的。”</p>
<p>或者（对于OIer）通俗一点来说，假设两个多项式的次数分别为 $n$ 和 $m$，那么这个算法的时间复杂度是 $O(nm)$ 的。</p>
<p>给个<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM4MDM=">模板题<i class="fa fa-external-link-alt"></i></span>的44分代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> X = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">char</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((ch &lt; <span class="number">48</span>) || (ch &gt; <span class="number">57</span>))ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>((ch &gt;= <span class="number">48</span>) &amp;&amp; (ch &lt;= <span class="number">57</span>))X = X * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">ll f[N], g[N], s[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(ll *s, ll *f, ll *g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n + m - <span class="number">1</span>; k++)</span><br><span class="line">        <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; i++)</span><br><span class="line">            s[k] += f[i] * g[k - i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m); n++; m++;</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)f[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)g[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">mul</span>(s, f, g);</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n + m - <span class="number">1</span>; i++)<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, s[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\color[rgb]{1,1,0.0625}{φ}$ （只保证44分）</p>
<h1 id="DFT"><a href="#DFT" class="headerlink" title="DFT"></a>DFT</h1><h2 id="多项式的点值表达"><a href="#多项式的点值表达" class="headerlink" title="多项式的点值表达"></a>多项式的点值表达</h2><p>为了简便表达，我们使用 $f_k$ 来代表 多项式 $f(x)$ 的第 $k+1$ 项系数。</p>
<p>今天AJ的作业是昨天的延伸：<br>给定一个 $n$ 次多项式的 $n+1$ 个点值，要求我们求出这个多项式。<br>（还让武嘉给了样例，而武嘉给的样例是1,3,5,7,9,114514）<br>全班只有王哥和某盒子做了出来。广告：<span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vNDcwOTUyMzc5">CoolHezi<i class="fa fa-external-link-alt"></i></span><br>他们用的是什么方法呢？</p>
<p><strong>拉格朗日插值</strong>。</p>
<p>想要了解拉格朗日插值，可以参考我的这个博客：<a href="/maths/lagrange-interpolation">拉格朗日插值</a></p>
<p>现在我们只需要知道，给定了 $n+1$ 个任意点值，可以求出来经过这几个点的一个 $n$ 次多项式。<br>如果两个多项式 $f(x)$ 和 $g(x)$ 在相同纵坐标上取点（设其分别为 $f(x)$  与 $g(x)$） 后相乘所得的结果（$f(x) \times g(x)$）等于两函数相乘后对应纵坐标处的点值（$h(x)$）。</p>
<p>举个栗子：</p>
<p>$$<br>\begin{align}<br>f(x) &amp;&#x3D; x^2 + 3x - 1 \\<br>g(x) &amp;&#x3D; 2x^2 + x -5<br>\end{align}<br>$$</p>
<p>我们分别取 $x \in [-1,1]$ 内的整数点所对应的点值：</p>
<img src="https://i.loli.net/2021/10/17/idm29GlQr7asBTc.png" alt="傅里叶1.png" width="60%" />

<p>我们可以清楚的看到：</p>
<p>$$<br>\begin{align}<br>f(-1) &amp; &#x3D; -3 &amp; f(0) &amp; &#x3D; -1 &amp; f(1) &amp; &#x3D; 3 \\<br>g(-1) &amp; &#x3D; -4 &amp; g(0) &amp; &#x3D; -5 &amp; g(1) &amp; &#x3D; -2<br>\end{align}<br>$$</p>
<p>相乘之后可得：</p>
<p>$$<br>\begin{align}<br>h(-1) &amp; &#x3D; 12 &amp; h(0) &amp; &#x3D; 5 &amp; h(1) &amp; &#x3D; -6<br>\end{align}<br>$$</p>
<p>检验一下：</p>
<img src="https://i.loli.net/2021/10/17/AvSKMrem6QlEtIU.png" alt="傅里叶2.png" width="60%" />

<p>但想要求出 $h(x)$ ，我们至少需要4+1&#x3D;5个点值。</p>
<p>怎么办？</p>
<p>多找几个啊。</p>
<p>于是我们就可以求出最终的多项式。</p>
<p>这就是FT的算法流程。<br>“把<strong>系数</strong>表达转换为<strong>点值</strong>表达”的算法叫做<strong>DFT</strong><br>“把<strong>点值</strong>表达转换为<strong>系数</strong>表达”的算法叫做<strong>IDFT</strong>(DFT的逆运算)</p>
<p>P.S:</p>
<ul>
<li>从一个多项式的系数表达确定其点值表达的过程称为<strong>求值</strong>(毕竟求点值表达的过程就是取了 n 个 x 然后扔进了多项式求了 n 个值出来)；</li>
<li>而求值运算的逆运算(也就是从一个多项式的点值表达确定其系数表达)被称为<strong>插值</strong>。</li>
</ul>
<p>F(Fourier)和T(Transform)有了，那F(Fast)呢？</p>
<h1 id="单位根与复数"><a href="#单位根与复数" class="headerlink" title="单位根与复数"></a>单位根与复数</h1><p>但是最终我们并没有觉得有什么可以加以利用的良好性质啊。<br>我们这些蒟蒻只会利用一些有理数和一些简单的无理数来进行一些简单的计算，再难一点的就不会了。</p>
<p><del>（而且这个多项式的次数和系数稍微一大就bz了）</del><br>准确来说，我们最终还是需要 $n+m$ 个点的求值与相乘，最终得到的时间复杂度与 $O(mn)$ 实际上差不太多，而且很可能在某些情况下更劣一些。</p>
<p>但是，法国数学家 <strong>傅里叶</strong> 横空出世，找了一些毒瘤数据代入，结果发现可以分治而使时间复杂度降低。<br>而他代入的正是单位根 $ω_{n+1}^{0 \to n}$ 。</p>
<h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>首先我们需要介绍复数。</p>
<p>已经会了的可以<a href="/maths/fourier-transform/#%E5%8D%95%E4%BD%8D%E6%A0%B9">跳过</a>。</p>
<p>（p.s.:下面我们使用的所有 $\sqrt{\quad}$ 标识都指的是平方根，算术平方根已使用+-来标记。）</p>
<h3 id="复数的概念"><a href="#复数的概念" class="headerlink" title="复数的概念"></a>复数的概念</h3><h4 id="虚数"><a href="#虚数" class="headerlink" title="虚数"></a>虚数</h4><p>我们所学的数轴是一条直线。</p>
<p><img src="https://i.loli.net/2021/10/18/ImBF56rhAYUQ2cL.png" alt="傅里叶3.png"></p>
<p>每一个有理数都能完美地与数轴上的某一个点一一对应。</p>
<p><img src="https://i.loli.net/2021/10/18/GBM34h7yDVjgzSm.png" alt="傅里叶4.png"></p>
<p>$+\sqrt2$ 、 $+\sqrt3$ 等无理数也能很好地对应在数轴上。</p>
<p><img src="https://i.loli.net/2021/10/18/pAs2ObDQ3Mf7Bv1.png" alt="傅里叶5.png"></p>
<p>但是人们说：“那 $+\sqrt{-1}$ 怎么办啊？”</p>
<p>我们找不到与 $+\sqrt{-1}$ 相对应的点。<br>而 $+\sqrt{-1}$ 又的的确确存在。</p>
<p>怎么办？</p>
<p>于是人们发明了一个概念：虚数。<br>而 $+\sqrt{-1}$ 在虚数里面叫做<strong>虚数单位</strong>，用 $i$ 表示。<br>所以，$i^2&#x3D;-1$ 。</p>
<p>但是又有人会问：“那 $-\sqrt{-1}$ 又怎么办？”</p>
<p>用 $-i$ 呗。</p>
<p>但是在数轴上，人们仍然找不到对应虚数的点。数轴上的每一个点都对应了一个实数，没有办法找到任何一个新的点来对应虚数了。<br>所以，人们就在数轴的 0 处添加了一条新的数轴，来代表虚数。这条新的数轴垂直于代表实数的数轴，单位是 $i$ 。</p>
<h3 id="复数及其运算"><a href="#复数及其运算" class="headerlink" title="复数及其运算"></a>复数及其运算</h3><p>复数形似 $a+bi$ 。<br>其中 $a$ 称为实部( $\Re$ )， $b$ 称为虚部( $\Im $ )。<br>复数也有加减乘除等运算。<br>复数加减时实部虚部分别加减：</p>
<p>$$<br>(a+bi) \pm (c+di) &#x3D; (a \pm c) + (b \pm d)i<br>$$</p>
<p>复数相乘时实部虚部分别相乘：</p>
<p>$$<br>\begin{align}<br>(a+bi) \times (c+di) &amp; &#x3D; a \times (c+di) + bi \times (c+di) \\<br>&amp; &#x3D; ac + adi + bci - bd \\<br>&amp; &#x3D; (ac - bd) + (ad + bc)i<br>\end{align}<br>$$</p>
<p>复数相除时就有点难办了。<br>直觉告诉我们 $\dfrac{a+bi}{c+di}$ 不会好化简。</p>
<p>这里需要引入一个概念：复数的共轭。<br>$a+bi$ 的共轭是 $a-bi$ 。<br>一个复数乘以其共轭最终得到的是一个实数。（ $(a+bi) \times (a-bi) &#x3D; a^2 + b^2$ ）</p>
<p>所以当我们化简 $\dfrac{a+bi}{c+di}$ 的时候，我们只需要上下同乘分母的共轭就可以了：<br>$$<br>\begin{align}<br>\frac{a+bi}{c+di} &amp; &#x3D; \frac{(a+bi)(c-di)}{(c+di)(c-di)} \\<br>&amp; &#x3D; \frac{(ac+bd) + (bc-ad)i}{c^2+d^2} \\<br>&amp; &#x3D; \frac{ac+bd}{c^2+d^2} + \frac{bc-ad}{c^2+d^2} i<br>\end{align}<br>$$</p>
<h3 id="复数在数轴上的表示"><a href="#复数在数轴上的表示" class="headerlink" title="复数在数轴上的表示"></a>复数在数轴上的表示</h3><p>那我们怎么在数轴上表示复数呢？</p>
<p>之前我们说过了，虚数单位 $i$ 找不到一个合适的与其对应的数轴上的点。</p>
<p>那我们到底怎么办呢？</p>
<p>于是有人加了一条垂直于原本数轴的轴，用来表示复数的虚部。</p>
<p>就像这样：</p>
<img src="https://i.loli.net/2021/10/18/L9kKUvWyAhiconp.png" alt="傅里叶6.png" width="60%" />

<p>于是我们举几个例子：</p>
<p><img src="https://i.loli.net/2021/10/19/cgUE58lZkOQJ17G.png" alt="傅里叶7.png"></p>
<p>此时我们关注一下两个虚数的积：</p>
<img src="https://i.loli.net/2021/10/19/RlLhAeVbzxXkHQf.png" alt="傅里叶8.png" width="60%" />

<p>如果我们连接表示复数的点和原点，我们可以看见这三条线的长度分别是 $\sqrt{3^2+4^2}&#x3D;\sqrt{25}&#x3D;5$ ，$\sqrt{5^2+2^2}&#x3D;\sqrt{29}$ 与 $\sqrt{14^2+23^2}&#x3D;\sqrt{725} &#x3D;5\sqrt{29}$ 。<br>凭借大家做几何题的直觉，我们可以看到， $5+2i$ 与 $x$ 轴的夹角与 $3+4i$ 与 $x$ 轴的夹角之和等于 $14+23i$ 与 $x$ 轴的夹角。<br>而且，通过刚才的例子，我们也可以看见 $5+2i$ 与原点的连线的长度与 $3+4i$ 与原点的连线的长度之积等于 $14+23i$ 与原点连线的长度。<br>数学家们为了简便地表示这些东西，发明了两个名词：<strong>幅角</strong>和<strong>模长</strong>。<br>所以，我们可以说，<strong>两个复数相乘时，幅角相加，模长相乘。</strong></p>
<p>证明：</p>
<p>我们设三个点分别为 $A$  ，$B$ 与 $C$ 。</p>
<img src="https://i.loli.net/2021/10/19/bVRTm4gy9dDhWnE.png" alt="傅里叶9.png" width="40%" />

<p>我们分别连接 $AO$ ， $BO$ 与 $CO$ 。</p>
<img src="https://i.loli.net/2021/10/19/TpDc6xyqOth5r8l.png" alt="傅里叶10.png" width="40%" />

<p>因为 $C$ 点代表的是 $(ac-bd)+(ad+bc)i$ ，所以 $AO$ ， $BO$ 与 $CO$ 的长度分别是：</p>
<p>$$<br>\begin{align}<br>AO &amp;&#x3D; \sqrt{a^2 + b^2} \\<br>BO &amp;&#x3D; \sqrt{c^2 + d^2} \\<br>CO &amp;&#x3D; \sqrt{(ac - bd)^2 + (ad+bc)^2}<br>\end{align}<br>$$</p>
<p>我们化简一下 $CO$ 的表达式，可得：</p>
<p>$$<br>\begin{align}<br>CO &amp; &#x3D; \sqrt{(ac-bd)^2+(ad+bc)^2} \\<br>&amp; &#x3D; \sqrt{a^2 c^2 - 2abcd + b^2 d^2 + a^2 d^2 + 2abcd + b^2 c^2} \\<br>&amp; &#x3D; \sqrt{a^2 (c^2 + d^2) + b^2 (c^2 + d^2)} \\<br>&amp; &#x3D; \sqrt{(a^2 + b^2) (c^2 + d^2)} \\<br>&amp; &#x3D; \sqrt{a^2 + b^2} \times \sqrt{c^2 + d^2} \\<br>&amp; &#x3D; AO \times BO<br>\end{align}<br>$$</p>
<p>我们可以得出， $CO&#x3D;AO \times BO$ 这一结论。</p>
<p>我们再连接 $BC$ 与 $AD$ ，$D$ 点代表 $1+0i$ 。</p>
<img src="https://i.loli.net/2021/10/19/81gGbRmnowh5IpK.png" alt="傅里叶11.png" width="40%" />

<p>凭借你做几何题的直觉，你应该知道 $\triangle AOD$ 与 $\triangle COB$ 看上去是相似的。</p>
<p>没错，他们就是相似的。</p>
<p>证明：</p>
<p>我们先算出来 $AD$ 和 $BC$ 的模长：</p>
<p>$$<br>\begin{align}<br>AD &amp; &#x3D; \sqrt{(a-1)^2 + b^2} \\<br>BC &amp; &#x3D; \sqrt{(ac-bd-c)^2 + (ad+bc-d)^2} \\<br>&amp; &#x3D; \sqrt{[(a-1)c-bd]^2 +[(a-1)d + bc]^2} \\<br>&amp; &#x3D; \sqrt{(a-1)^2 c^2 - 2(a-1)bcd + b^2 d^2 + (a-1)^2 d^2 + 2(a-1)bcd + b^2 c^2} \\<br>&amp; &#x3D; \sqrt{(a-1)^2 (c^2 + d^2) + b^2 (c^2 + d^2)} \\<br>&amp; &#x3D; \sqrt{[(a-1)^2 + b^2] (c^2 + d^2)} \\<br>&amp; &#x3D; \sqrt{(a-1)^2 + b^2} \times \sqrt{c^2 + d^2} \\<br>&amp; &#x3D; AD \times BO<br>\end{align}<br>$$</p>
<p>接下来我们证明两三角形相似：</p>
<p>$$<br>\begin{gather}<br>\because<br>CO &#x3D; AO \times BO , DO &#x3D; 1 \\<br>\therefore \frac{CO}{AO} &#x3D; \frac{BO}{DO} \\<br>\because BC &#x3D; AD \times BO\\<br>\therefore \frac{BC}{AD} &#x3D; BO \\<br>\therefore \frac{CO}{AO} &#x3D; \frac{BO}{DO} &#x3D; \frac{BC}{AD} \\<br>\therefore \triangle COB \sim \triangle AOD \\<br>\therefore \angle DOA &#x3D; \angle BOC \\<br>\because \angle DOC &#x3D; \angle DOB + \angle BOC \\<br>\therefore \angle DOC &#x3D; \angle DOB + \angle DOA<br>\end{gather}<br>$$</p>
<p>证毕。</p>
<h2 id="单位根"><a href="#单位根" class="headerlink" title="单位根"></a>单位根</h2><p>现在我们来介绍单位根。</p>
<p>单位根的意义是 $n$ 次方为 1 的复数，也就是 $x^n&#x3D;1$ 的复数解。</p>
<p>如果你学过三角函数的话你应该十分清楚什么是单位圆。<br>而单位圆可以帮我们更好地理解什么是单位根和单位根为什么能够代入之后能实现分治。</p>
<p>我们先画出一个单位圆：</p>
<img src="https://i.loli.net/2021/10/20/Eg1hOysmtHIK7YZ.png" alt="傅里叶12.png" width="60%" />

<p>我们知道， $1^n&#x3D;1$ ，所以单位根的其中一个一定是 $1$ 。</p>
<p>我们连接 $1$ 和 $0$ 。</p>
<img src="https://i.loli.net/2021/10/20/ewkq5Hsl2Xh8iDn.png" alt="傅里叶13.png" width="60%" />

<p>我们在这里举一个 $n&#x3D;4$ 的栗子来帮助我们理解单位根。</p>
<p>首先，我们知道， $(\pm i)^2 &#x3D; -1$ ，而 $-1^2&#x3D;1$ ，<br>所以 $i$ 和 $-i$ 也是 $n&#x3D;4$ 时的两个单位根。<br>当然，因为 $(-1)^2&#x3D;1$ ，所以我们不能丢下-1。</p>
<img src="https://i.loli.net/2021/10/20/ZgXGK4ioqftFAHa.png" alt="傅里叶14.png" width="60%" />

<p>至此，我们就找齐了 $n&#x3D;4$ 时的所有单位根。<br>我们记单位根分别为 $ω^0_4 , ω^1_4 , ω^2_4 , ω^3_4$ 。</p>
<p>但哪个对应哪个呢？</p>
<img src="https://i.loli.net/2021/10/20/pRgxdBbhqrAvweP.png" alt="傅里叶15.png" width="60%" />

<p>当我们观察图像的时候，我们可以发现这四个点与原点的连线可以平分这一个单位圆。<br>每相邻两条线之间的夹角都是 $90^{\circ}$ 。</p>
<p>当我们推广到 $n&#x3D;8$ 的时候。我们可以另外得到 $\frac{1}{\sqrt2}+\frac{1}{\sqrt2}i , \frac{1}{\sqrt2}-\frac{1}{\sqrt2}i , -\frac{1}{\sqrt2}+\frac{1}{\sqrt2}i , -\frac{1}{\sqrt2}-\frac{1}{\sqrt2}i$ 四个单位根。</p>
<p>我们把他们表示在复平面上之后会是这样一个情况：</p>
<img src="https://i.loli.net/2021/10/20/jXxYvVbk6ITR5Fc.png" alt="傅里叶16.png" width="60%" />

<p>我们会发现，新增的这四个单位根所对应的点也在圆上，且所有的这几个点与圆心\原点的连线平分这个单位圆为8份。</p>
<p>所以我们可以这样理解，所有的 $ω_n^{0 \to n-1}$ 与原点的连线可以平分单位圆为 $n$ 份，且每相邻两条线之间的夹角都是 $\frac{2π}{n}$ （即 $\frac{360}{n}^{\circ}$ ）</p>
<p>这样就好编号了：从 $1$ 开始，逆时针编号。</p>
<p>举个栗子：</p>
<p>$ω_8^{0 \to 7}$ 的值分别为 $1 , \frac{1}{\sqrt2} + \frac{1}{\sqrt2}i , i , -\frac{1}{\sqrt2} + \frac{1}{\sqrt2}i , -1 , -\frac{1}{\sqrt2} - \frac{1}{\sqrt2}i , -i , \frac{1}{\sqrt2} - \frac{1}{\sqrt2}$ 。</p>
<p>p.s.:虽然我们只承认 $ω_n^k$ 中的 $0\leq k &lt; n$ 的情况，但是 $k\geq n$ 和 $k&lt;0$ 的情况还是有的，这就跟 $\geq 2π$ （即 $360^{\circ}$ ）和 $&lt;0$ （即 $0^{\circ}$ ）的角一样。</p>
<h3 id="单位根的性质"><a href="#单位根的性质" class="headerlink" title="单位根的性质"></a>单位根的性质</h3><p>单位根有很多性质，这里会列举几个。其中，最后一个是最重要的，也是我们选择代入单位根的原因。</p>
<ol>
<li>$ω^a_n + ω^b_n &#x3D; ω_n^{a+b}$</li>
</ol>
<p>  可以从把单位根类比成切蛋糕的方法去理解。</p>
<ol start="2">
<li>$(ω^1_n)^k &#x3D; ω^k_n$</li>
</ol>
<p>  可以理解成把 $k$ 块蛋糕拼起来。</p>
<ol start="3">
<li>$ω_{λn}^{λk} &#x3D; ω_n^k$</li>
</ol>
<p>  同可以理解成把一块蛋糕平均切成 $\lambda$ 块。</p>
<ol start="4">
<li>$ω^k_{2n} &#x3D; - ω_{2n}^{(k+n)\bmod{n}}$</li>
</ol>
<p>  这是最重要的一条。<br>  这条的证明可以在复平面上清晰的看出。</p>
<img src="https://i.loli.net/2021/10/20/Huv9WglE7MbLTAj.png" alt="傅里叶17.png" width="60%" />

<p>这一条性质是我们选择代入单位根的原因。但为什么呢？</p>
<h1 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h1><h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p>傅里叶把多项式 $f(x)$ 按照次数分成奇偶两部分。（忘了的向前翻再看一遍）</p>
<p>即，<br>$$<br>\begin{align}<br>f(x) &amp;&#x3D; \sum^n_{i&#x3D;0} a_i x^{n-i} \\<br>&amp;&#x3D; \sum_{i&#x3D;0}^{\frac{n}{2}} a_i x^{n-2i} + \sum_{i&#x3D;0}^{\frac{n}{2}} a_{i+1} x^{n-2i-1}<br>\end{align}<br>$$<br>我们称 $\displaystyle \sum_{i&#x3D;0}^{\frac{n}{2}} a_{i+1} x^{n-2i-1}$ 为 $f_o(x)$ ， 称 $\displaystyle \sum_{i&#x3D;0}^{\frac{n}{2}} a_i x^{n-2i}$ 为 $f_e(x)$ 。</p>
<p>此时我们把式子化简一下，可得<br>$$<br>f(x) &#x3D; f_e(x^2) + x f_o(x^2)<br>$$</p>
<p>所以，我们想要计算 $f(x)$ 的话，只需要计算 $f_e(x)$ 与 $f_o(x)$ 即可。<br>当然，我们计算 $f_e(x)$ 与 $f_o(x)$ 的时候，也像刚才我们分解 $f(x)$ 一样，把它们分解掉。<br>最终我们可以达到分治的效果。</p>
<p>而我们不可能对于所有的点都进行实际的代入求值运算，那样会爆精度。</p>
<h2 id="代入求值"><a href="#代入求值" class="headerlink" title="代入求值"></a>代入求值</h2><p>我们刚刚介绍了单位根的性质，所以我们可以代入单位根来简化运算。</p>
<p>怎么简化？</p>
<p>我们尝试过代入几个整数来求值，但是那样子复杂度会爆掉。</p>
<p>然后我们就想到了代入相反数。<br>这样的话，我们只需要求出一半的值，就可以得到另外的所有值了。</p>
<p>我们还可以再快，即进行分治。</p>
<p>但是，分治要求我们每一次分治代入的值都为相反数，这要求了一对相反数的平方仍为相反数。<br>于是我们就找到了单位根。</p>
<p>我们代入 $ω^k_n$ （$0 \leq k &lt; \dfrac{n}{2}$），可得：<br>$$<br>\begin{align}<br>f(ω^k_n) &amp;&#x3D; f_e((ω^k_n)^2) + ω^k_n f_o((ω^k_n)^2) \\<br>&amp;&#x3D; f_e (ω^k_{\frac{n}{2}}) + ω^k_n f_o(ω^k_{\frac{n}{2}})<br>\end{align}<br>$$</p>
<p>此时我们对这个式子进行稍稍的变动，可得：<br>$$<br>\begin{align}<br>f(ω^k_n) &amp;&#x3D; f_e((ω^k_n)^2) + ω^k_n f_o((ω^k_n)^2) \\<br>f(ω_n^{k+\frac{n}{2}}) &amp;&#x3D; f_e((ω_n^{k+\frac{n}{2}})^2) + ω_n^{k+\frac{n}{2}} f_o((ω_n^{k+\frac{n}{2}})^2) \\<br>&amp;&#x3D; f_e (ω_n^{2k+n}) + ω_n^{k+\frac{n}{2}} f_o(ω_n^{2k+n}) \\<br>&amp;&#x3D; f_e (ω_n^{2k}) + ω_n^{k+\frac{n}{2}} f_o(ω_n^{2k}) \\<br>&amp;&#x3D; f_e (ω_{\frac{n}{2}}^k) + ω_n^{k+\frac{n}{2}} f_o(ω_{\frac{n}{2}}^k) \\<br>&amp;&#x3D; f_e (ω_{\frac{n}{2}}^k) - ω^k_n f_o(ω_{\frac{n}{2}}^k) \\<br>\end{align}<br>$$</p>
<p>通过 $\begin{cases} f(ω_n^k)&#x3D;f_e(ω_{\frac{n}{2}}^k)+ω^k_nf_o(ω_{\frac{n}{2}}^k) \\ f(ω_n^{k+\frac{n}{2}})&#x3D;f_e (ω_{\frac{n}{2}}^k) - ω_n^k f_o(ω_{\frac{n}{2}}^k)\end{cases}$ 这两个式子，我们理论上是可以求出所有点值的。因为 $f_e(x)$ 与 $f_o(x)$ 理论上只有 $f(x)$ 次数的一半，只能得到完整地求出 $f(x)$ 所需要的点值的一半。而两个式子分别能求出一半且互不重复，合起来就是我们所需要的所有点值了。</p>
<p>但是当我们遇到某一层的 $f(x)$ 是奇数次的时候，我们应该怎么办呢？</p>
<p>答案是：自己补。</p>
<p>我们可以手动为这个多项式补成2的整数次幂次。当然，是在不影响多项式整体的值得前提下，所以我们选择补0，即我们补上去的所有的 $a_k$ 都是0。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="DFT-1"><a href="#DFT-1" class="headerlink" title="DFT"></a>DFT</h2><h3 id="复数结构体"><a href="#复数结构体" class="headerlink" title="复数结构体"></a>复数结构体</h3><p>为了表示方便，我们使用结构体来表示复数。</p>
<p>我们同时重载一下运算符，以便做复数之间的四则运算。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> str;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Comp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Comp</span>(<span class="type">double</span> xx = <span class="number">0</span>, <span class="type">double</span> yy = <span class="number">0</span>) &#123; x = xx, y = yy; &#125;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    Comp <span class="keyword">operator</span> + (Comp <span class="type">const</span> &amp;B) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Comp</span>(x + B.x, y + B.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Comp <span class="keyword">operator</span> - (Comp <span class="type">const</span> &amp;B) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Comp</span>(x - B.x, y - B.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Comp <span class="keyword">operator</span> * (Comp <span class="type">const</span> &amp;B) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Comp</span>(x * B.x - y * B.y, x * B.y + y * B.x);</span><br><span class="line">    &#125;</span><br><span class="line">    Comp <span class="keyword">operator</span> / (Comp <span class="type">const</span> &amp;B) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> t = B.x * B.x + B.y * B.y;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Comp</span>((x * B.x + y * B.y) / t, (y * B.x - x * B.y) / t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a, b;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(Comp n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(n.x &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; n.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n.x &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        cout &lt;&lt; n.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n.y &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n.x != <span class="number">0</span>)<span class="built_in">putchar</span>(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">        cout &lt;&lt; n.y;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n.x == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; n.y;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)<span class="built_in">putchar</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; a.x &gt;&gt; a.y &gt;&gt; b.x &gt;&gt; b.y;</span><br><span class="line">    Comp c;</span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="built_in">write</span>(a), <span class="built_in">putchar</span>(<span class="string">&#x27;+&#x27;</span>), <span class="built_in">write</span>(b), <span class="built_in">putchar</span>(<span class="string">&#x27;=&#x27;</span>), <span class="built_in">write</span>(c), <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    c = a - b;</span><br><span class="line">    <span class="built_in">write</span>(a), <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), <span class="built_in">write</span>(b), <span class="built_in">putchar</span>(<span class="string">&#x27;=&#x27;</span>), <span class="built_in">write</span>(c), <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    c = a * b;</span><br><span class="line">    <span class="built_in">write</span>(a), <span class="built_in">putchar</span>(<span class="string">&#x27;*&#x27;</span>), <span class="built_in">write</span>(b), <span class="built_in">putchar</span>(<span class="string">&#x27;=&#x27;</span>), <span class="built_in">write</span>(c), <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    c = a / b;</span><br><span class="line">    <span class="built_in">write</span>(a), <span class="built_in">putchar</span>(<span class="string">&#x27;/&#x27;</span>), <span class="built_in">write</span>(b), <span class="built_in">putchar</span>(<span class="string">&#x27;=&#x27;</span>), <span class="built_in">write</span>(c), <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\color[rgb]{1,1,0.0625}{φ}$</p>
<h3 id="预处理单位根"><a href="#预处理单位根" class="headerlink" title="预处理单位根"></a>预处理单位根</h3><p>我们之前应该提到过什么是单位根。但是怎么快速求出我们需要用的所有单位根呢？<br>开根号的方法太慢了，打表又太难。<br>所以我们使用三角函数。<br>没学过三角函数的可以自己先学一下<del>（话说为什么你会先学傅里叶变换？）</del><br>我们首先求出 $ω^1_n$ 。</p>
<p>[anime here]</p>
<p>C++的三角函数采用的是弧度制。而刚才我们已经介绍过什么是弧度了。</p>
<p>所以， $ω^1_n$ 就等于 $\cos(\dfrac{2π}{n})+\sin(\dfrac{2π}{n})i$ 。</p>
<p>把得到的结果依次乘起来就是所有的单位根。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxn 1000500</span></span><br><span class="line"><span class="comment">//用这句话能得到得到精确的π</span></span><br><span class="line"><span class="comment">//但是实际上并没有自己手动打更精确</span></span><br><span class="line"><span class="comment">//比如说下一个代码就是我自己手打的</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CP</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CP</span>(<span class="type">double</span> xx = <span class="number">0</span>, <span class="type">double</span> yy = <span class="number">0</span>) &#123; x = xx, y = yy; &#125;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    CP <span class="keyword">operator</span> + (CP <span class="type">const</span> &amp;B) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CP</span>(x + B.x, y + B.y);</span><br><span class="line">    &#125;</span><br><span class="line">    CP <span class="keyword">operator</span> - (CP <span class="type">const</span> &amp;B) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CP</span>(x - B.x, y - B.y);</span><br><span class="line">    &#125;</span><br><span class="line">    CP <span class="keyword">operator</span> * (CP <span class="type">const</span> &amp;B) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CP</span>(x * B.x - y * B.y, x * B.y + y * B.x);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//除法没用</span></span><br><span class="line">&#125;w[Maxn];</span><br><span class="line"><span class="comment">//w长得是不是很像ω?</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="function">CP <span class="title">sav</span><span class="params">(cos(<span class="number">2</span> * Pi / n), sin(<span class="number">2</span> * Pi / n))</span>, <span class="title">buf</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        w[i] = buf;</span><br><span class="line">        buf = buf * sav;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;w[%d][n]=(%.4lf,%.4lf)\n&quot;</span>, i, w[i].x, w[i].y);</span><br><span class="line">    <span class="comment">//由于精度问题会出现-0.0000的情况,将就看吧</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3Uub3JnL2Jsb2cvY29tbWFuZC1ibG9jay9mZnQteHVlLXhpLWJpLWpp">$\blacktriangleright$<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxn 1350000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Pi = <span class="number">3.1415926535897932394626433832795</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CP</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CP</span>(<span class="type">double</span> xx = <span class="number">0</span>, <span class="type">double</span> yy = <span class="number">0</span>) &#123; x = xx, y = yy; &#125;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    CP <span class="keyword">operator</span> + (CP <span class="type">const</span> &amp;B) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CP</span>(x + B.x, y + B.y);</span><br><span class="line">    &#125;</span><br><span class="line">    CP <span class="keyword">operator</span> - (CP <span class="type">const</span> &amp;B) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CP</span>(x - B.x, y - B.y);</span><br><span class="line">    &#125;</span><br><span class="line">    CP <span class="keyword">operator</span> * (CP <span class="type">const</span> &amp;B) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CP</span>(x * B.x - y * B.y, x * B.y + y * B.x);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//除法这里没用</span></span><br><span class="line">&#125;f[Maxn &lt;&lt; <span class="number">1</span>], sav[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dft</span><span class="params">(CP *f, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">1</span>)<span class="keyword">return</span>;<span class="comment">//边界</span></span><br><span class="line">    <span class="comment">//指针的使用比较巧妙 </span></span><br><span class="line">    CP *fl = f, *fr = f + len / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; len; k++)sav[k] = f[k];</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; len / <span class="number">2</span>; k++)<span class="comment">//分奇偶打乱</span></span><br><span class="line">    &#123;</span><br><span class="line">        fl[k] = sav[k &lt;&lt; <span class="number">1</span>]; fr[k] = sav[k &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dft</span>(fl, len / <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">dft</span>(fr, len / <span class="number">2</span>);<span class="comment">//处理子问题</span></span><br><span class="line">    <span class="comment">//由于每次使用的单位根次数不同(len次单位根),所以要重新求。</span></span><br><span class="line">    <span class="function">CP <span class="title">tG</span><span class="params">(cos(<span class="number">2</span> * Pi / len), sin(<span class="number">2</span> * Pi / len))</span>, <span class="title">buf</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; len / <span class="number">2</span>; k++)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//这里buf = (len次单位根的第k个) </span></span><br><span class="line">        sav[k] = fl[k] + buf * fr[k];<span class="comment">//(1)</span></span><br><span class="line">        sav[k + len / <span class="number">2</span>] = fl[k] - buf * fr[k];<span class="comment">//(2)</span></span><br><span class="line">        <span class="comment">//这两条语句具体见上面的式子</span></span><br><span class="line">        buf = buf * tG;<span class="comment">//得到下一个单位根。</span></span><br><span class="line">    &#125;<span class="built_in">f_or</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; len; k++)f[k] = sav[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;f[i].x);</span><br><span class="line">    <span class="comment">//一开始都是实数,虚部为0</span></span><br><span class="line">    <span class="built_in">f_or</span>(m = <span class="number">1</span>; m &lt; n; m &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//把长度补到2的幂,不必担心高次项的系数,因为默认为0</span></span><br><span class="line">    <span class="built_in">dft</span>(f, m);</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%.4f,%.4f)\n&quot;</span>, f[i].x, f[i].y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3Uub3JnL2Jsb2cvY29tbWFuZC1ibG9jay9mZnQteHVlLXhpLWJpLWpp">$\blacktriangleright$<i class="fa fa-external-link-alt"></i></span></p>
<p>好了，我相信你已经学会了利用DFT把多项式拆成一系列点值了。</p>
<p>但是我们怎么把这些点值还原为多项式呢？</p>
<h1 id="IDFT"><a href="#IDFT" class="headerlink" title="IDFT"></a>IDFT</h1><p>IDFT只需要改变DFT中的一点东西就可以得到。</p>
<p>因为我们代入的时候，得到了一个点值序列，我们在此称其为 $u$ ，而 $\displaystyle u[k]&#x3D;\sum_{i&#x3D;0}^{n-1} (ω^k_n)^i f(i)$ ，所以 $\displaystyle f(i) &#x3D; \frac{\sum\limits_{i&#x3D;0}^{n-1} (ω_n^{-k})^i u[i]}{n}$ 。</p>
<p>具体的证明过程目前请见<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2Jsb2cvY29tbWFuZC1ibG9jay9mZnQteHVlLXhpLWJpLWpp">这里<i class="fa fa-external-link-alt"></i></span> 。这个证明涉及到了单位根反演，可以再写一篇博客，所以我等写到的时候再补全证明。</p>
<p>上代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1350010</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Pi = <span class="number">3.1415926535897932384626433832795</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CP</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CP</span>(<span class="type">double</span> xx = <span class="number">0</span>, <span class="type">double</span> yy = <span class="number">0</span>) &#123; x = xx, y = yy; &#125;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    CP <span class="keyword">operator</span> + (CP <span class="type">const</span> &amp;B) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CP</span>(x + B.x, y + B.y);</span><br><span class="line">    &#125;</span><br><span class="line">    CP <span class="keyword">operator</span> - (CP <span class="type">const</span> &amp;B) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CP</span>(x - B.x, y - B.y);</span><br><span class="line">    &#125;</span><br><span class="line">    CP <span class="keyword">operator</span> * (CP <span class="type">const</span> &amp;B) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CP</span>(x * B.x - y * B.y, x * B.y + y * B.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;f[N &lt;&lt; <span class="number">1</span>], p[N &lt;&lt; <span class="number">1</span>], sav[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> tr[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fft</span><span class="params">(CP *f, <span class="type">bool</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; tr[i])<span class="built_in">swap</span>(f[i], f[tr[i]]);</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> p = <span class="number">2</span>; p &lt;= n; p &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> len = p &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="function">CP <span class="title">tG</span><span class="params">(cos(<span class="number">2</span> * Pi / p), sin(<span class="number">2</span> * Pi / p))</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(!flag)tG.y *= <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">f_or</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k += p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">CP <span class="title">buf</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="built_in">f_or</span>(<span class="type">int</span> l = k; l &lt; k + len; l++)</span><br><span class="line">            &#123;</span><br><span class="line">                CP tt = buf * f[len + l];</span><br><span class="line">                f[len + l] = f[l] - tt;</span><br><span class="line">                f[l] = f[l] + tt;</span><br><span class="line">                buf = buf * tG;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;f[i].x);</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;p[i].x);</span><br><span class="line">    <span class="built_in">f_or</span>(m += n, n = <span class="number">1</span>; n &lt;= m; n &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        tr[i] = (tr[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) ? n &gt;&gt; <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fft</span>(f, <span class="number">1</span>); <span class="built_in">fft</span>(p, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)f[i] = f[i] * p[i];</span><br><span class="line">    <span class="built_in">fft</span>(f, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ( <span class="type">int</span> )(f[i].x / n + <span class="number">0.49</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3Uub3JnL2Jsb2cvY29tbWFuZC1ibG9jay9mZnQteHVlLXhpLWJpLWpp">$\blacktriangleright$<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论（广义）学习笔记</title>
    <url>/notes/game-strategy/</url>
    <content><![CDATA[<p>简介： 博弈论</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>我们先举一个栗子：</p>
<p>假如你和李zen一起玩一个游戏；<br>你们面前都有一个开关，你们都可以选择让这个开关处于断开或闭合两种状态的其中任意一种。<br>而我会根据开关的状态给你们评级：<br>当两个开关都闭合时，你们都得 $C$ ；<br>当两个开关都断开时，你们都得 $B$ ；<br>当两个开关一开一断时，断开的得 $D$ ，闭合的得 $A$ 。<br>十分简单。</p>
<p>你会怎么选呢？</p>
<p>首先我们列一个表格，表示出所有结果：</p>
<p><img src="https://i.loli.net/2021/09/22/PugFZ2BDdAqo5zw.png" alt="博弈1.png"></p>
<p>现在你会做出什么选择呢？</p>
<p>你犹豫了一下，然后闭合了开关。<br>毕竟这样你可以<del>迫害李zen</del>得到更高的评级。<br>但是你的内心深处还是有一个声音：<br>“断开开关吧，毕竟李zen之前被迫害太多次了，他会<del>开始反围剿</del>伤心的”<br>驱使着你断开开关。<br>是不是？</p>
<p>你仍然在犹豫。</p>
<p>那么，如果现在我们规定，本次游戏结果计入今年的期末考试，只有拿到 $C$ 级才能及格，而你又不想挂科，怎么样？</p>
<p>为了更直观一点，我们用 $[-1,2]$ 范围内的整数来代替评级，是不是会更好一些？</p>
<p><img src="https://i.loli.net/2021/09/22/OSmtUF89Hs5covl.png" alt="博弈2.png"></p>
<p>这时候，你就可以进行一下比较：</p>
<p>如果你闭合开关，那么无论李zen干什么，你都可以拿到更高的分数<del>（除非他直接来找你）</del> ：<br>$0&gt;-1,2&gt;1$</p>
<p>此时，如果有两个策略 $α$ 与 $β$ ，无论他人选择什么，我们选 $α$ 得到的结果都严格优于选 $β$ ，那我们就称 $α$ 相对于 $β$ 是一个 <strong>严格优势策略(Strictly dominant strategy)</strong> 。</p>
<p>比如这道题里的“闭合开关”就是个相对于“断开开关”的严格优势策略。</p>
<p>假如你选择了断开开关，而李zen选择闭合开关，你挂科了。<br>这时候你就会得到一条重要的结论：</p>
<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论 1"></a>结论 1</h3><p><strong>永远，永远不要选择劣势策略。</strong><br>这里的 <strong>“严格劣势策略(Strictly dominated strategy)”</strong> 是相对于 <strong>“严格优势策略”</strong> 而说的，指有一个策略，不管别人选择什么，你选它的结果都严格劣于选其他的策略。</p>
<p>懂的都懂。</p>
<hr>
<p>所以说，你们两个人都选择断开开关，都得B，不是很好的吗？</p>
<p>这时候需要引入另一条重要的结论：</p>
<h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论 2"></a>结论 2</h3><p><strong>理性的选择最终一定导致非最优结果。</strong></p>
<p>对于zen来说，不管你怎么选，选择闭合开关总是对他有利的。但你不知道他会选什么，也不可以与它交流，所以你不能与他一起约好了选择断开开关。</p>
<hr>
<p>现在，我们更改一下游戏的结果。</p>
<p>假如你考砸了，你就会受到家长的诘问，因而变得伤心，这一部分也要算在期望收益里；</p>
<p>假如你让李zen考砸了，你就会心生愧疚<del>同时被愤怒的zen反围剿</del>，也会变得伤心，这一部分也要算在期望收益里。</p>
<p>于是，我们的表格变成了：</p>
<p><img src="https://i.loli.net/2021/09/22/16dpGnyJa9uB3vM.png" alt="博弈3.png"></p>
<p>在这种情况下，你就不会有任何优势策略或劣势策略。</p>
<p>这个博弈叫做 <strong>“协和谬误(Coordination problem)”</strong> 。</p>
<p>这个时候你就不知道怎么办了。</p>
<p>你不知道李zen会怎么做，你们两个人也无法交流，因此你就无法做出决定。</p>
<p>这就引出了另外一条很好的结论：</p>
<h3 id="结论-3"><a href="#结论-3" class="headerlink" title="结论 3"></a>结论 3</h3><p><strong>汝欲求之，必先知之。</strong></p>
<p>你在做出决定之前，最好先了解一下你的对手的基本信息。</p>
<p>在这局游戏里，你的对手是李zen。</p>
<p>碰巧，你知道李zen富有爱心，他总会考虑你的感受。如果他闭合了开关但你没有而使得你输了，他会不开心的。</p>
<p>这就导致他之前和鳖玩的时候被邪恶的鳖打到自闭。（之前的不计入期末成绩awa）</p>
<p>你们两个会玩的十分愉快。（你输了他会安慰你awa）</p>
<p>但是如果你跟鳖玩呢？</p>
<p>鳖不会有情感损伤的减益よ。</p>
<p>那么，你的期望收益就变成了这样：</p>
<p><img src="https://i.loli.net/2021/09/22/ElJjYIQzXW8mtdO.png" alt="博弈4.png"></p>
<p>此时，你就需要对你的策略进行一些改变：</p>
<p>因为无论你选择什么，鳖总会闭合开关，因为这相对于他来说是一种优势策略。</p>
<p>所以，你应当闭合开关，使得鳖的收益最小。</p>
<p>这时候，你就学会了一条重要的结论：</p>
<h3 id="结论-4"><a href="#结论-4" class="headerlink" title="结论 4"></a>结论 4</h3><p><strong>站在他人的立场上去分析他们会做出的决策</strong> ，或者， <strong>学会换位思考</strong> 。</p>
<p>现在，你大概就可以与鳖这样的人友好地游玩了，甚至能跟tue、zhua过上几招了。</p>
<p>但是，如果这个游戏的结果与你的期末考试成绩挂钩呢？<br>那么，就连zen也会闭合开关，来防止挂科的。</p>
<p>所以记住：</p>
<h3 id="结论-5"><a href="#结论-5" class="headerlink" title="结论 5"></a>结论 5</h3><p><strong>人是自私的。人都想偷懒。</strong></p>
<p>至此，你就基本上开始接触了博弈论。</p>
<hr>
<p>大家应该都听说过囚徒困境罢。<br>不出意外的话，两个囚徒都会选择供出对方。<br>那么，如何改变这个博弈的结果呢？</p>
<h3 id="如何改变博弈结果"><a href="#如何改变博弈结果" class="headerlink" title="如何改变博弈结果"></a>如何改变博弈结果</h3><p>我们有三种方法：</p>
<p><strong>1. 签订条约，制定规章制度等；</strong><br><strong>2. 多次重复博弈；</strong><br><strong>3. 教育。（如集体主义教育）</strong></p>
<p>不管哪一条，本质上都是改变了参与者的收益或参与者的动机。</p>
<hr>
<h2 id="更深的层次"><a href="#更深的层次" class="headerlink" title="更深的层次"></a>更深的层次</h2><p>我们刚才通过举例子知道了什么是博弈，但我们真的知道什么是博弈吗？</p>
<h3 id="博弈的组成"><a href="#博弈的组成" class="headerlink" title="博弈的组成"></a>博弈的组成</h3><p>一个博弈由三部分组成：</p>
<h4 id="1-参与人-Players"><a href="#1-参与人-Players" class="headerlink" title="1. 参与人(Players)"></a>1. 参与人(Players)</h4><p>在这里，我们使用小写字母 $i$ , $j$ 等来代表参与人。</p>
<h4 id="2-策略-Strategy"><a href="#2-策略-Strategy" class="headerlink" title="2. 策略(Strategy)"></a>2. 策略(Strategy)</h4><p>在这里，我们使用带有下标的小写字母 $s_i$ 来代表参与人 $i$ 的某一个策略。</p>
<p>我们使用带有下标的大写字母 $S_i$ 来代表参与人 $i$ 的所有可能的策略集合。</p>
<p>我们使用小写字母 $s_{-i}$ 来表示除参与人 $i$ 之外的所有参与人的策略。</p>
<h4 id="3-收益-Payoff"><a href="#3-收益-Payoff" class="headerlink" title="3. 收益(Payoff)"></a>3. 收益(Payoff)</h4><p>在这里，我们使用带有下标的大写字母 $U_i (s)$ 来代表参与人 $i$ 在所有参与者使用的策略为 $s$ 时所能得到的收益。（这一段好长啊）</p>
<p>另外的，我们使用小写字母 $s$ 来表示一个博弈。</p>
<p>好了，现在让我们来使用我们刚刚学会的表示方法来表示我们之前学过的东西。</p>
<p>那么，如果策略 $s_i$ 相对于策略 $s_i’$ 是一个严格优势策略的话，那么我们就可以写下</p>
<p>$$<br>\begin{equation}<br>U_i (s_i , s_{-i}) &gt; U_i (s_i’ , s_{-i})<br>\end{equation}<br>$$</p>
<p>类似的，如果策略 $s_i$ 相对于策略 $s_i’$ 是一个严格劣势策略的话，那么我们就可以写下</p>
<p>$$<br>\begin{equation}<br>U_i (s_i , s_{-i}) &lt; U_i (s_i’ , s_{-i})<br>\end{equation}<br>$$</p>
<h3 id="弱优与弱劣"><a href="#弱优与弱劣" class="headerlink" title="弱优与弱劣"></a>弱优与弱劣</h3><p>如果策略 $s_i$ 相对于策略 $s_i’$ 是一个严格优势策略，那么无论他人选择何种策略，那么我们选 $s_i$ 得到的结果都严格优于选 $s_i’$。</p>
<p>但有时候我们并不能总见到这样的策略。</p>
<p>那我们定义一个策略 $s_i$ 为相对于另一个策略 $s_i’$ 为 <strong>弱优策略(Weakly dominant strategy)</strong> ，此时只需要将大于号填上等于即可。<br>就像下面这样：</p>
<p>$$<br>\begin{equation}<br>U_i (s_i , s_{-i}) \leq U_i (s_i’ , s_{-i})<br>\end{equation}<br>$$</p>
<p>类似的， <strong>弱劣策略(Weakly dominated strategy)</strong> 的定义如下：</p>
<p>$$<br>\begin{equation}<br>U_i (s_i , s_{-i}) \geq U_i (s_i’ , s_{-i})<br>\end{equation}<br>$$</p>
<p>所以说，对于刚才你和李zen做的游戏，我们可以用这些表示来替换之前的说法：</p>
<p>（先放图）</p>
<p><img src="https://i.loli.net/2021/09/22/OSmtUF89Hs5covl.png" alt="博弈2.png"></p>
<p>其中，<br>$S_{you} &#x3D; \lbrace 1,0 \rbrace $<br>$S_{zen} &#x3D; \lbrace 1,0 \rbrace $<br>$U_{you} (1,1) &#x3D; 0 $<br>$U_{zen} (1,1) &#x3D; 0 $<br>$U_{you} (1,0) &#x3D; 2 $<br>$U_{zen} (1,0) &#x3D; -1 $<br>$U_{you} (0,1) &#x3D; -1 $<br>$U_{zen} (0,1) &#x3D; 2 $<br>$U_{you} (0,0) &#x3D; 1 $<br>$U_{zen} (0,0) &#x3D; 1 $<br>$U_{zen} (1,s_{-zen}) &gt; U_{zen} (0,s_{-zen}) $<br>$U_{you} (1,s_{-you}) &gt; U_{you} (0,s_{-you}) $</p>
<p>现在你就可以理解刚才我们讲的符号是什么意思了。</p>
<h3 id="迭代剔除劣势策略"><a href="#迭代剔除劣势策略" class="headerlink" title="迭代剔除劣势策略"></a>迭代剔除劣势策略</h3><p>让我们来做一个新的游戏。</p>
<p>你，李zen，鳖，tue，zhua，还有广大四班人民群众一起做一个游戏。每一个人都需要从范围为 $[1,100]$ 的整数里面选一个数。<br>AJ将会统计大家的结果，并进行总结。<br>总结后取平均数的 $\dfrac{2}{3}$ 作为基准数（向上取整）。基准数减去（你的结果与基准数的差）再除以基准数，得到一个百分数。这个百分数再乘以120就是你本次期末的数学成绩。</p>
<p>同时，AJ指定你和李zen为挑战对象。这意味着你如果比不过他，你就得承包他明年的巧克力供应了。</p>
<p>所以，你会选择哪一个数呢？</p>
<ul>
<li>首先，你知道即使大家都选择100，基准数也是 $67\dfrac{1}{3}$ ，所以说选择67以上的数字是不明智的选择。</li>
</ul>
<p>现在你把目光聚集到了 $[1,67]$ 范围内的整数上。</p>
<ul>
<li>其次，即使大家都选择67，那么基准数也将会是 $44$ ，所以选择44以上的数字也是不太明智的选择。</li>
</ul>
<p> 现在你把目光聚集到了 $[1,44]$ 范围内的整数上。</p>
<ul>
<li>然后，即使大家都选择了44，那么基准数也将会是 $28$ ，所以选择28以上的数字也是不很明智的选择。</li>
</ul>
<p>……</p>
<p>最后，这个基准数字将会迭代到1。<br>不断剔除明显看起来劣势的策略，找出来此时新出现的劣势策略并予以剔除，这就叫 <strong>迭代剔除劣势策略(Iterative deletion of dominated strategies)</strong> 。</p>
<h3 id="公共知识与相互知识"><a href="#公共知识与相互知识" class="headerlink" title="公共知识与相互知识"></a>公共知识与相互知识</h3><p>所以1是个明智的选择吗？</p>
<p>其实不是的。</p>
<p>大家都选择1的前提是，同学们都认为自己会选择1，且他人会选择1，且他人知道自己会选择1，且自己知道他人知道自己会选择1，且他人知道自己知道他人知道自己会选择1……</p>
<p>是不是绕起来了？</p>
<p>有一个相似的东西叫做 <strong>猜疑链</strong> 。</p>
<p>长度为2n+1的猜疑链大概是这样的：</p>
<p>你不知道我不知道你不知道我不知道你不知道……我不知道你不知道我不知道你在想什么。</p>
<p>省略的部分就不写出来了。</p>
<p>刚才我们遇见的东西看起来很像猜疑链，只不过“不知道”换成了“知道”。这就叫做 <strong>公共知识(Common knowledge)</strong> 。</p>
<p>但是在这个情况下，同学们们无法和对方沟通，无法知道别人的结果，所以这个东西是不能成立的。</p>
<p>AJ在统计完结果后让挑战对象互相看了对方的答案，但是你不知道李zen看了你的答案，同时李zen也不知道你看了他的答案。</p>
<p>这时候，公共知识的构建就停止在了某一层。这时候，我们就称其为 <strong>相互知识(Mutual knowledge)</strong> 。</p>
<p>是不是很简单？</p>
<h3 id="中位选民定理"><a href="#中位选民定理" class="headerlink" title="中位选民定理"></a>中位选民定理</h3><p>班长轮换时间到！</p>
<p>现在我们有两位班长候选人：bobo与武嘉。</p>
<p>而班级内将会产生十个不同的小团体，每个团体投一票。他们只会投给自己理想中的班长——也就是与自己交集最多的人。</p>
<p>小团体之间互无交集。<br>bobo和武嘉需要将自己定位到某一个小团体内，以计算选票。</p>
<p>现在我们将这些小团体分别命名为 $α,β,γ,δ,ε,ζ,η,θ,ι,κ$ 。</p>
<p>假如bobo选了η，而武嘉选了γ，那么他们两个人分别得到 $5.5$ 票与 $4.5$ 票。bobo会赢。</p>
<p>现在我们来模拟一下所有可能的结果。</p>
<p><img src="https://i.loli.net/2021/09/24/7rGpuJPQ4eTLN6n.png" alt="博弈5.png"></p>
<p>很明显，策略 $α$ 劣势于策略 $β$ ；去除策略 $α$ 后，策略 $β$ 劣势于策略 $γ$ ；去除策略 $β$ 后，策略 $γ$ 劣势于策略 $δ$ ；去除策略 $γ$ 后，策略 $δ$ 劣势于策略 $ε$ 。</p>
<p>同样的，策略 $κ$ 劣势于策略 $ι$ ；去除策略 $κ$ 后，策略 $ι$ 劣势于策略 $θ$ ；去除策略 $ι$ 后，策略 $θ$ 劣势于策略 $η$ ；去除策略 $θ$ 后，策略 $η$ 劣势于策略 $ζ$ 。</p>
<p>而策略 $ε$ 与策略 $ζ$ 没有优劣关系。</p>
<p>所以说，最后bobo和武嘉在进行玩迭代剔除劣势策略后，只能选择融入 $ε$ 和 $ζ$ 两个小团体之一了。</p>
<p>这就是著名的 <strong>中位选民定理(Median Voter Theorem)</strong> 了。</p>
<h3 id="最佳对策与期望收益"><a href="#最佳对策与期望收益" class="headerlink" title="最佳对策与期望收益"></a>最佳对策与期望收益</h3><p>现在让我们玩一个随机的游戏。<br>题面如下：</p>
<p><img src="https://i.loli.net/2021/09/24/ftmEhcYzuSdZkyI.png" alt="博弈6.png"></p>
<p>现在我们可以看到，没有明显的优势策略或劣势策略。</p>
<p>那我们该怎么办呢？</p>
<p>首先，我们可以看到，当李zen选择←时，选↑是我们的最佳对策；当李zen选择→时，选↓是我们的最佳对策。</p>
<p>但是你并不知道zen会选择什么。</p>
<p>你开始用AJ教你的数学知识来对每一个选项的期望收益进行一个模拟。</p>
<p>假设李zen选择←和→的几率是相等的，那么我们的期望收益如下：</p>
<p>$$<br>\begin{align}<br>U_{top} \  vs \  (\frac{1}{2} , \frac{1}{2} ) &amp; &#x3D; 5 \times \frac{1}{2} + 0 \times \frac{1}{2} &#x3D; 2 \frac{1}{2} \\<br>U_{middle} \  vs \  (\frac{1}{2} , \frac{1}{2} ) &amp; &#x3D; 1 \times \frac{1}{2} + 4 \times \frac{1}{2} &#x3D; 2 \frac{1}{2} \\<br>U_{down} \  vs \  (\frac{1}{2} , \frac{1}{2} ) &amp; &#x3D; 4 \times \frac{1}{2} + 2 \times \frac{1}{2} &#x3D; 3<br> \end{align}<br>$$</p>
<p>此时我们可以看到，选择↓是我们的最佳对策（也是最安全的对策），因为 $2 \dfrac{1}{2} &lt; 3 $ 。</p>
<p>但是如果你知道了李zen选择←或→的概率呢？</p>
<p>上图。</p>
<p><img src="https://i.loli.net/2021/09/24/mroUEi69tjgV1Cu.png" alt="博弈7.png"></p>
<p>图中的横轴代表李zen选←的概率，同时选→的概率是（1-选←的概率）。纵轴代表不同选择的期望收益。</p>
<p>所以，我们可以看到，在李zen选择某一策略的概率不同时，我们的最佳对策是不一样的。</p>
<p>在这里，我们可以这样定义 <strong>最佳对策(Best Responce)</strong> :<br>当</p>
<p>$$<br>U_i ( \hat{s_i} ,s_{-i} ) \geq U_i ( s_i’ ,s_{-i} ) \quad (s_i’ \in S_i )<br>$$</p>
<p>或</p>
<p>$$<br>U_i ( \hat{s_i} ,s_{-i} ) &#x3D; max( U_i ( S_i , s_{-i}))<br>$$</p>
<p>或</p>
<p>$$<br>EU_i ( \hat{s_i} ,p ) \geq max( EU_i ( s_i’ , p)) \quad (s_i’ \in S_i )<br>$$</p>
<p>时，我们称 $ \hat{s_i} $ 是策略 $s_{-i} $ 的最佳对策。</p>
<p>其中， $EU_i ( s_i , p ) $ 指的是策略 $s_i$ 在参与人 $i$ 持信念 $p$ 时的期望收益。</p>
<p>同时，我们需要注意一下，对于不同的策略集合 $s_{-i}$ ，其最佳对策的数量可能是不同的，且可能不为一（就是最佳对策不会只有一个）。</p>
<h2 id="纳什均衡"><a href="#纳什均衡" class="headerlink" title="纳什均衡"></a>纳什均衡</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>假设你需要和李zen一起完成一个项目。你将会付出 $s_y$ 个小时的时间，而zen将会付出 $s_z$ 个小时，其中 $s_y , s_z \in [0,10] $ 。</p>
<p>你们的收益为：</p>
<p>$$<br>\begin{align}<br>U_y &amp; &#x3D; 2 ( s_y + s_z + b s_y s_z ) - s_y^2 \\<br>U_z &amp; &#x3D; 2 ( s_y + s_z + b s_y s_z ) - s_z^2<br>\end{align}<br>$$</p>
<p>此时让我们来算一下我们怎么最大化我们的收益。</p>
<p>首先求一下导，把 $s_z$ 当做常数：</p>
<p>$$<br>\begin{align}<br>U_y’ &amp; &#x3D; 2 ( 1 + b s_z ) - 2 s_y \\<br>U_y’’ &amp; &#x3D; -2 &lt; 0<br>\end{align}<br>$$</p>
<p>此时令 $U_y’ &#x3D; 0 $ ，可以求出最佳对策：</p>
<p>$$<br>\begin{align}<br>2 ( 1 + b s_z ) - 2 s_y &amp; &#x3D; 0 \\<br>1 + b s_z &amp; &#x3D; s_y \\<br>s_y &amp; &#x3D; \frac{1}{1-b}<br>\end{align}<br>$$</p>
<p>此时画一下图：</p>
<p><img src="https://i.loli.net/2021/09/25/mwYX56SC4WaQtcT.png" alt="博弈8.png"></p>
<p>此时我们可以看到，两个人的最佳对策函数交于了一点。</p>
<p>在实际情况中，因为你们两个都想偷懒，所以你们会不断剔除掉双方付出过多的策略，最终直到选择那个交点。</p>
<p>这个就叫做 <strong>纳什均衡(Nash Equilibrium)</strong> 。</p>
<p>其定义是：</p>
<p>对于一个已选对策的集合$ \lbrace s_1^* , s_2^* , s_3^* , \dots , s_m^* \rbrace $ ，其纳什均衡是满足下列条件的策略集合：</p>
<p>对于 $ \forall $ 参与人 $i$ 来说，其策略 $ s_i^* $ 是 $ s_{-i}^* $ 的最佳对策。</p>
<p>要实现纳什均衡，我们需要几个动机。</p>
<h4 id="动机-1"><a href="#动机-1" class="headerlink" title="动机 1"></a>动机 1</h4><p><strong>人们永不反悔。</strong></p>
<p>或者说，在所有人都已经选定好每个人的策略了之后，改变自己的策略并不会有额外收益。</p>
<h4 id="动机-2"><a href="#动机-2" class="headerlink" title="动机 2"></a>动机 2</h4><p><strong>纳什均衡可以被看做一种自我实施的信念。</strong></p>
<h4 id="动机-3"><a href="#动机-3" class="headerlink" title="动机 3"></a>动机 3</h4><p>tbc</p>
<h3 id="找出博弈中的纳什均衡"><a href="#找出博弈中的纳什均衡" class="headerlink" title="找出博弈中的纳什均衡"></a>找出博弈中的纳什均衡</h3><p>假设我们现在与李zen玩一个新的游戏，题面如下：</p>
<p><img src="https://i.loli.net/2021/09/26/Qlx73OLrFZEYH9K.png" alt="博弈9.png"></p>
<p>现在，我们用绿色的圆圈和红色的方框来分别表示你和李zen的最佳对策：</p>
<p><img src="https://i.loli.net/2021/09/26/wo6Lc3VPdbTRvsX.png" alt="博弈10.png"></p>
<p>那么，这个博弈里的纳什均衡是什么呢？</p>
<p>我们可以看到，当你选择↓时，zen的最佳对策是选择→； 当李zen选择→时，你的最佳对策是选择↓。</p>
<p>一旦你们两个人中的其中一个选定了之后，另一个人就不会轻易跳出这个循环。</p>
<p>所以说， $(↓,→)$ 就是这场博弈里的纳什均衡。</p>
<p>当然，一场博弈的纳什均衡也可能不只有一个。<br>比如下图：</p>
<p><img src="https://i.loli.net/2021/09/26/NLsOb3oUgT26yM7.png" alt="博弈11.png"></p>
<p>很简单是不是？</p>
<p>这时你们会发现，在这场博弈中，虽然看起来 $(←,↑)$ 明显是纳什均衡 <del>（其实也真的是）</del> ，但是如果你仔细看的话，右下角的那个零零也符合纳什均衡的定义，虽然两个人什么都得不到且傻子也会知道选择有收益的那个策略而不是一点收益都没有的，但是一旦两个人知道对方会选择这个零零，那就不会轻易更改自己的策略，不要忘了<a href="/game_strategy/#%E5%8A%A8%E6%9C%BA-1">动机1</a>、<a href="/game_strategy/#%E5%8A%A8%E6%9C%BA-2">动机2</a>和<a href="/game_strategy/#%E7%BB%93%E8%AE%BA-5">结论5</a>。</p>
<p>这就类似全局最优解和局部最优解。</p>
<h3 id="帕累托优势"><a href="#帕累托优势" class="headerlink" title="帕累托优势"></a>帕累托优势</h3><p>在刚才上面那个博弈中，我们可以清楚的看到，左上的那个纳什均衡的收益是严格大于右下的那个的。</p>
<p>如果我们重复这次博弈。那么最终选择左上的几率会是百分之百。</p>
<p>这就叫做 <strong>帕累托优势(Pareto Dominate)</strong> 。</p>
<hr>
<p>咕了。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数</title>
    <url>/notes/linar-algebra/</url>
    <content><![CDATA[<p>简介：线性代数</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="排列相关"><a href="#排列相关" class="headerlink" title="排列相关"></a>排列相关</h1><h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h2><p>排列指由 $[1,n]$ 范围内的所有整数组成的一个有序数列叫做 $n$ 级排列。</p>
<h2 id="逆序相关"><a href="#逆序相关" class="headerlink" title="逆序相关"></a>逆序相关</h2><h3 id="逆序"><a href="#逆序" class="headerlink" title="逆序"></a>逆序</h3><p><strong>逆序</strong>指大权排在小权后面。</p>
<h3 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h3><p><strong>逆序数</strong>指逆序的总数，用 $N(A_n)$ 来表示，其中括号里的是一个n级排列。</p>
<p>如果 $N(A_n)&#x3D;0$ ，那我们称这个排列为<strong>标准排列</strong>或者<strong>自然排列</strong>，其中所有元素都是按照顺序排列。</p>
<h3 id="奇偶排列"><a href="#奇偶排列" class="headerlink" title="奇偶排列"></a>奇偶排列</h3><p>对于一个n级排列 $A_n$ ，如果 $N(A_n)  \% 2 &#x3D; 1 $ （即逆序数为奇数），那它是一个奇排列；反之（ $N(A_n) \% 2 &#x3D; 0 $ ，逆序数为偶数）则是一个偶排列。</p>
<p>这里有一个比较重要的定理：</p>
<p>$n$ 级排列中，奇排列与偶排列各有 $\dfrac{n!}{2}$ 个。</p>
<h3 id="对换"><a href="#对换" class="headerlink" title="对换"></a>对换</h3><p><strong>对换</strong>即交换两个数的顺序，与我们常用的<code>swap()</code>函数类似。</p>
<p>对换一次之后会使排列的奇偶性<strong>翻转</strong>。</p>
<h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><p>（本部分按照宋浩老师讲课顺序撰写，会出现部分引用）</p>
<p>今天AJ只给同学们留了一道题目作为作业：</p>
<p>解方程。</p>
<p>$$<br>\begin{cases}<br>5x+6y&#x3D;7 \\<br>9x+4y&#x3D;3<br>\end{cases}<br>\tag {2.0.1}<br>$$<br>简单。</p>
<p>学过二元一次方程组的人都能做得出来。</p>
<p>我们首先消掉 $x$ ，把方程组变成这个样子：</p>
<p>$$<br>\begin{cases}<br>9 \times 5x + 9 \times 6y &#x3D; 7 \times 9 \\<br>5 \times 9x + 5 \times 4y &#x3D; 3 \times 5<br>\end{cases}<br>\tag{2.0.2}<br>$$</p>
<p>可得</p>
<p>$$<br>\begin{align}<br>x &amp; &#x3D; \frac{7 \times 4 - 6 \times 3}{5 \times 4 - 6 \times 9} \tag{2.0.3} \\<br>y &amp; &#x3D; \frac{3 \times 5 - 7 \times 9}{5 \times 4 - 6 \times 9} \tag{2.0.4}<br>\end{align}<br>$$</p>
<p>然而班里唯一学过高等数学（现在不是了）的王哥用另一种方法做了出来。</p>
<h2 id="二阶行列式"><a href="#二阶行列式" class="headerlink" title="二阶行列式"></a>二阶行列式</h2><p>$$<br>\begin{align}<br>x &amp; &#x3D; \frac{\begin{vmatrix} 7 &amp; 6 \\ 3 &amp; 4 \end{vmatrix}}{\begin{vmatrix} 5 &amp; 6 \\ 9 &amp; 4 \end{vmatrix}} \tag{2.1.1} \\<br>y &amp; &#x3D; \frac{\begin{vmatrix} 3 &amp; 7 \\ 9 &amp; 5 \end{vmatrix}}{\begin{vmatrix} 5 &amp; 6 \\ 9 &amp; 4 \end{vmatrix}} \tag{2.1.2}<br>\end{align}<br>$$</p>
<p>王哥后来解释道：“这玩意叫做二阶行列式。二阶行列式是这么用的：<br>$$<br>\begin{vmatrix} a &amp; b \\ c &amp; d \end{vmatrix} &#x3D; ad - bc<br>\tag{2.1.3}<br>$$<br>所以最终展开之后是大家得到的答案。”</p>
<p>于是，同学们开始广泛地<del>瞎玩</del>使用二阶行列式。</p>
<h2 id="三阶行列式"><a href="#三阶行列式" class="headerlink" title="三阶行列式"></a>三阶行列式</h2><p>但是tue不满足于二阶行列式。他追问：“有二阶的，是不是还会有三阶的？”</p>
<p>王哥：“是的。但是三阶行列式更加复杂。比如这个：</p>
<p>$$<br>\begin{vmatrix}<br>a &amp; b &amp; c \\<br>d &amp; e &amp; f \\<br>g &amp; h &amp; i<br>\end{vmatrix}<br>&#x3D; aei+bfg+cdh-afh-bdi-ceg<br>\tag{2.2.1}<br>$$</p>
<p>二阶行列式展开后的结果是主对角线上的数字相乘减去次对角线上的数字相乘，十分简单；但是三阶行列式就不一样了。它展开后的结果是这样的：</p>
<p>我们要把这个行列式在它的右边誊写一遍，像这样：</p>
<p>$$<br>\begin{vmatrix}<br>a &amp; b &amp; c \\<br>d &amp; e &amp; f \\<br>g &amp; h &amp; i<br>\end{vmatrix}<br>\begin{vmatrix}<br>a &amp; b &amp; c \\<br>d &amp; e &amp; f \\<br>g &amp; h &amp; i<br>\end{vmatrix}<br>\tag{2.2.2}<br>$$</p>
<p>然后连线：</p>
<p>先连与主对角线平行的三条，不重复的连结所有数字</p>
<p><img src="https://i.loli.net/2021/10/01/ydZtcIBgCxRmSvr.png" alt="线代1.png"></p>
<p>再连与次对角线平行的三条，不重复的连结所有数字</p>
<p><img src="https://i.loli.net/2021/10/01/SMFi3Y2otIxq1Tl.png" alt="线代2.png"></p>
<p>最后把三条蓝色线（与主对角线平行）上的数字分别相乘后求和减去三条绿色线（与次对角线平行）上的数字分别相乘之后的积之和。</p>
<p>就是这样：</p>
<p>$$<br>\begin{vmatrix}<br>a &amp; b &amp; c \\<br>d &amp; e &amp; f \\<br>g &amp; h &amp; i<br>\end{vmatrix}<br>&#x3D; \color{blue}{(aei+bfg+cdh)} - \color{green}{(afh+bdi+ceg)}<br>\tag{2.2.3}<br>$$</p>
<p>这样算起来十分麻烦，还容易算错，所以，现阶段我不建议使用三阶行列式。”</p>
<h2 id="n阶行列式"><a href="#n阶行列式" class="headerlink" title="n阶行列式"></a>n阶行列式</h2><p>$n$ 阶行列式的展开遵循这样的规则：</p>
<ul>
<li>首先列出所有列标的排列组合可能；</li>
<li>然后再分别算出每一个排列的奇偶性；</li>
<li>将每一个列标所对应的排列中的元素相乘，其中保证元素不重复（或者说行标取标准排列）；</li>
<li>最后再将偶排列的和减去奇排列的和。</li>
</ul>
<p>用式子表示大概就是这样：</p>
<p>$$<br>\begin{vmatrix}<br>a_{1,1} &amp; a_{1,2} &amp; a_{1,3} &amp; \dots &amp; a_{1,n} \\<br>a_{2,1} &amp; a_{2,2} &amp; a_{2,3} &amp; \dots &amp; a_{2,n} \\<br>a_{3,1} &amp; a_{3,2} &amp; a_{3,3} &amp; \dots &amp; a_{3,n} \\<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>a_{n,1} &amp; a_{n,2} &amp; a_{n,3} &amp; \dots &amp; a_{n,n}<br>\end{vmatrix}<br>&#x3D;<br>\sum_{j1 , j2 , \dots , jn} (-1)^{N(j1 , j2 , \dots , jn)}<br>a_1 j_1 \ a_2 j_2 \ \dots a_n j_n<br>\tag{2.3.1}</p>
<p>$$</p>
<p>我们通常这样表示：$D (或 Det(a))&#x3D; |a_{i,j}| $ 。</p>
<p>并且，显而易见的，特别地，$|a_{1,1}| &#x3D; a_{1,1}$ 。</p>
<p>然后我们会看见： $\exists |a| \neq |a|$<br>比如：$|-1| \neq |-1|$ 。<br>因为左右两边一个是行列式，另一个是绝对值。<br>这个一定要分清。</p>
<h2 id="特殊形态的行列式"><a href="#特殊形态的行列式" class="headerlink" title="特殊形态的行列式"></a>特殊形态的行列式</h2><p>有一些特殊的行列式，他们具有特殊的结构：</p>
<h3 id="对角形行列式"><a href="#对角形行列式" class="headerlink" title="对角形行列式"></a>对角形行列式</h3><p>形如<br>$$<br>\begin{vmatrix}<br>a_{1,1} &amp; &amp; \\<br>&amp; \ddots &amp; \\<br>&amp; &amp; a_{n,n}<br>\end{vmatrix}<br>\tag{2.4.1}<br>\label{main}<br>$$</p>
<p>的行列式称为对角形行列式。</p>
<p>展开后的结果是： $D_{对角形} &#x3D; \prod\limits_{i&#x3D;1}^n a_{i,i} $ 。</p>
<h3 id="上、下三角行列式"><a href="#上、下三角行列式" class="headerlink" title="上、下三角行列式"></a>上、下三角行列式</h3><p>形如<br>$$<br>\begin{vmatrix}<br>a_{1,1} &amp; a_{1,2} &amp; a_{1,3} &amp; \cdots &amp; a_{1,n} \\<br>&amp; a_{2,2} &amp; a_{2,3} &amp; \cdots &amp; a_{2,n} \\<br>&amp;&amp; a_{3,3} &amp; \cdots &amp; a_{3,n} \\<br>&amp;&amp;&amp; \ddots &amp; \vdots \\<br>&amp;&amp;&amp;&amp; a_{n,n}<br>\end{vmatrix}<br>\tag{2.4.2}<br>$$<br>的行列式称作<strong>上三角行列式</strong>，而形如<br>$$<br>\begin{vmatrix}<br>a_{1,1} &amp;&amp;&amp;&amp; \\<br>a_{2,1} &amp; a_{2,2} &amp;&amp;&amp; \\<br>a_{3,1} &amp; a_{3,2} &amp; a_{3,3} &amp;&amp; \\<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \\<br>a_{n,1} &amp; a_{n,2} &amp; a_{n,3} &amp; \cdots &amp; a_{n,n}<br>\end{vmatrix}<br>\tag{2.4.3}<br>$$<br>的称作<strong>下三角行列式</strong>。</p>
<p>展开后的结果是：$D_{上三角}&#x3D;(-1)^{\frac{n(n-1)}{2}}\prod\limits_{i-1}^n a_{i,i}$ ，$D_{下三角}&#x3D;(-1)^{\frac{n(n-1)}{2}}\prod\limits_{i-1}^n a_{i,i}$</p>
<p>记住：不论是对角形还是上下三角，用的都是<strong>主对角线</strong>。</p>
<h3 id="范德蒙德行列式"><a href="#范德蒙德行列式" class="headerlink" title="范德蒙德行列式"></a>范德蒙德行列式</h3><p>跳转：<a href="/notes/linar-algebra/#%E8%8C%83%E5%BE%B7%E8%92%99%E5%BE%B7(Vandermonde)%E8%A1%8C%E5%88%97%E5%BC%8F">范德蒙德行列式</a></p>
<h3 id="对称行列式"><a href="#对称行列式" class="headerlink" title="对称行列式"></a>对称行列式</h3><p>跳转：<a href="/notes/linar-algebra/#%E5%AF%B9%E7%A7%B0%E8%A1%8C%E5%88%97%E5%BC%8F">对称行列式</a></p>
<h3 id="反对称行列式"><a href="#反对称行列式" class="headerlink" title="反对称行列式"></a>反对称行列式</h3><p>跳转：<a href="/notes/linar-algebra/#%E5%8F%8D%E5%AF%B9%E7%A7%B0%E8%A1%8C%E5%88%97%E5%BC%8F">反对称行列式</a></p>
<h2 id="行列式的性质"><a href="#行列式的性质" class="headerlink" title="行列式的性质"></a>行列式的性质</h2><h3 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h3><p>与矩阵一样，行列式也可以进行转置。</p>
<p>行列式 $D$ 转置之后的行列式，我们称其为 行列式 $D$ 的转置行列式，记作 $D^T$ 或者 $D’$ （少用）。</p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>$(D^T)^T \equiv D$ .</p>
<h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><h4 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h4><p>$D^T&#x3D;D$ .</p>
<p>这里我们要注意：在行列式中，<strong>对行成立的性质，对列也成立。</strong></p>
<h4 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h4><p><strong>两行（列）互换，行列式的值要变号。</strong></p>
<p>推论：<strong>两行（列）相等，</strong>$D &#x3D; 0$ <strong>.</strong></p>
<h4 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h4><p><strong>某一行（列）都乘k，相当于k乘以D。</strong><br>$$<br>\begin{vmatrix}a&amp;b&amp;c\\kd&amp;ke&amp;kf\\g&amp;h&amp;i\end{vmatrix}<br>&#x3D;k<br>\begin{vmatrix}a&amp;b&amp;c\\d&amp;e&amp;f\\g&amp;h&amp;i\end{vmatrix}<br>\tag{2.5.1}<br>$$</p>
<p>推论：<strong>某一行（列）有公因子k，k可以提到外面去。</strong></p>
<h4 id="性质4"><a href="#性质4" class="headerlink" title="性质4"></a>性质4</h4><p><strong>两行（列）对应成比例，行列式的值等于0。</strong></p>
<p>推论：<strong>如果行列式某一行（列）等于0，行列式等于0。</strong></p>
<h4 id="性质5"><a href="#性质5" class="headerlink" title="性质5"></a>性质5</h4><p>$$<br>\begin{vmatrix}<br>a&amp;b&amp;c\\d+d’&amp;e+e’&amp;f+f’\\g&amp;h&amp;i<br>\end{vmatrix}<br>&#x3D;<br>\begin{vmatrix}<br>a&amp;b&amp;c\\d&amp;e&amp;f\\g&amp;h&amp;i<br>\end{vmatrix}<br>+<br>\begin{vmatrix}<br>a&amp;b&amp;c\\d’&amp;e’&amp;f’\\g&amp;h&amp;i<br>\end{vmatrix}<br>\tag{2.5.2}<br>$$</p>
<p><em><strong>注意</strong></em>：这个只针对于<strong>某一行（列）</strong>，其余的行（列）<strong>不变</strong>！</p>
<h4 id="性质6"><a href="#性质6" class="headerlink" title="性质6"></a>性质6</h4><p><strong>某一行（列）乘以一个数，加到另一行（列）上去，行列式的值不变。</strong></p>
<p>好了，现在让我们利用这些性质，将这个行列式变为上三角行列式吧！</p>
<p>$$<br>\begin{align}<br>D&#x3D;{} &amp;<br>\begin{vmatrix}<br>1&amp;2&amp;0&amp;1\\2&amp;3&amp;10&amp;0\\0&amp;3&amp;5&amp;18\\5&amp;10&amp;15&amp;4<br>\end{vmatrix}\\<br>&#x3D;{} &amp;<br>\begin{vmatrix}<br>1&amp;2&amp;0&amp;1\\2+1\times(-2)&amp;3+2\times(-2)&amp;10+0\times(-2)&amp;0+1\times(-2)\\0&amp;3&amp;5&amp;18\\5&amp;10&amp;15&amp;4<br>\end{vmatrix}\\<br>&#x3D;{} &amp;<br>\begin{vmatrix}<br>1&amp;2&amp;0&amp;1\\\color{red}{0}&amp;-1&amp;10&amp;-2\\0&amp;3&amp;5&amp;18\\5+1\times(-5)&amp;10+2\times(-5)&amp;15+0\times(-5)&amp;4+1\times(-5)<br>\end{vmatrix}\\<br>&#x3D;{} &amp;<br>\begin{vmatrix}<br>1&amp;2&amp;0&amp;1\\\color{red}{0}&amp;-1&amp;10&amp;-2\\0+0\times 3&amp;3+(-1)\times 3&amp;5+10\times 3&amp;18+(-2)\times 3\\0&amp;0&amp;15&amp;-1<br>\end{vmatrix}\\<br>&#x3D;{} &amp;<br>\begin{vmatrix}<br>1&amp;2&amp;0&amp;1\\\color{red}{0}&amp;-1&amp;10&amp;-2\\\color{red}{0}&amp;\color{red}{0}&amp;35&amp;12\\0+0\times(-\frac{3}{7})&amp;0+0\times(-\frac{3}{7})&amp;15+35\times(-\frac{3}{7})&amp;-1+12\times(-\frac{3}{7})<br>\end{vmatrix}\\<br>&#x3D;{} &amp;<br>\begin{vmatrix}<br>1&amp;2&amp;0&amp;1\\\color{red}{0}&amp;-1&amp;10&amp;-2\\\color{red}{0}&amp;\color{red}{0}&amp;35&amp;12\\\color{red}{0}&amp;\color{red}{0}&amp;\color{red}{0}&amp;-\frac{43}{7}<br>\end{vmatrix}\\<br>&#x3D;{} &amp; 215<br>\end{align}<br>\tag{2.5.3}<br>$$<br>在解这一些行列式的时候，我们通常用这个顺序来解：</p>
<p><img src="https://i.loli.net/2021/10/02/kM5ZneSjdmqylBI.gif" alt="线代4.gif"></p>
<h2 id="子式与余子式"><a href="#子式与余子式" class="headerlink" title="子式与余子式"></a>子式与余子式</h2><p>我们去掉一个$n$阶行列式$D_{n \times n}$的 $k$ 行与 $k$ 列之后，我们就得到了它的一个 $k$ 阶余子式。</p>
<p>例如这个行列式：<br>$$<br>\begin{vmatrix}<br>a_{1,1} &amp; a_{1,2} &amp; a_{1,3} &amp; a_{1,4} \\<br>a_{2,1} &amp; a_{2,2} &amp; a_{2,3} &amp; a_{2,4} \\<br>a_{3,1} &amp; a_{3,2} &amp; a_{3,3} &amp; a_{3,4} \\<br>a_{4,1} &amp; a_{4,2} &amp; a_{4,3} &amp; a_{4,4}<br>\end{vmatrix}<br>\tag{2.6.1}<br>$$<br>我们取走 $a_{3,2}$ 所在的行与列之后，得到的行列式是这样的：<br>$$<br>\begin{vmatrix}<br>a_{1,1} &amp; a_{1,3} &amp; a_{1,4} \\<br>a_{2,1} &amp; a_{2,3} &amp; a_{2,4} \\<br>a_{4,1} &amp; a_{4,3} &amp; a_{4,4}<br>\end{vmatrix}<br>\tag{2.6.2}<br>$$<br>我们称这样得到的余子式为 $M_{3,2}$ 。</p>
<p>如果我们将 $M_{3,2} \times (-1)^{3+2}$ 的话，我们就得到了原行列式的代数余子式，记作$A_{3,2}$ 。</p>
<h3 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h3><p>$D &#x3D; \sum\limits_{j&#x3D;1}^{n} a_{i,j}A_{i,j}$， 或 $D &#x3D; \sum\limits_{i&#x3D;1}^{n} a_{i,j}A_{i,j}$</p>
<h3 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h3><p>某一行元素与另一行元素的代数余子式乘积之和为0。</p>
<h3 id="子式"><a href="#子式" class="headerlink" title="子式"></a>子式</h3><p>对于一个$n$阶行列式$D_{n \times n}$，我们取其中的$k$行$k$列的交点，可以得到一个$k$阶的行列式。</p>
<p>如：<br>$$<br>\begin{vmatrix}<br>a_{1,1} &amp; a_{1,2} &amp; a_{1,3} &amp; \dots &amp; a_{1,n} \\<br>a_{2,1} &amp; a_{2,2} &amp; a_{2,3} &amp; \dots &amp; a_{2,n} \\<br>a_{3,1} &amp; a_{3,2} &amp; a_{3,3} &amp; \dots &amp; a_{3,n} \\<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>a_{n,1} &amp; a_{n,2} &amp; a_{n,3} &amp; \dots &amp; a_{n,n}<br>\end{vmatrix}<br>\tag{2.6.3}<br>$$<br>这个行列式的一个$k$阶子式可以是<br>$$<br>\begin{vmatrix}<br>a_{i,j} &amp; \cdots &amp; a_{i,j+k} \\<br>\vdots &amp; \ddots &amp; \vdots \\<br>a_{i+k,j} &amp; \cdots &amp; a_{i+k,j+k}<br>\end{vmatrix}<br>\tag{2.6.4}<br>$$</p>
<h2 id="拉普拉斯-Laplace-定理"><a href="#拉普拉斯-Laplace-定理" class="headerlink" title="拉普拉斯(Laplace)定理"></a>拉普拉斯(Laplace)定理</h2><p>取定$k$行，由$k$行元素组成的所有$k$阶子式与代数余子式乘积之和$&#x3D;D$ 。</p>
<p>例：</p>
<p>行列式<br>$$<br>\begin{vmatrix}<br>1&amp;2&amp;0&amp;0&amp;0\\3&amp;4&amp;0&amp;0&amp;0\\1&amp;2&amp;3&amp;4&amp;5\\1&amp;1&amp;1&amp;1&amp;1\\6&amp;6&amp;8&amp;3&amp;1<br>\end{vmatrix}<br>\tag{2.7.1}<br>$$<br>可以被分解为<br>$$<br>\begin{vmatrix}<br>1&amp;2\\3&amp;4<br>\end{vmatrix}<br>+(-1)^{1+2+1+2}\<br>\begin{vmatrix}<br>3&amp;4&amp;5\\1&amp;1&amp;1\\8&amp;3&amp;1<br>\end{vmatrix}<br>\tag{2.7.2}<br>$$<br>，即</p>
<p>$$<br>\begin{vmatrix}<br>1&amp;2&amp;0&amp;0&amp;0\\3&amp;4&amp;0&amp;0&amp;0\\1&amp;2&amp;3&amp;4&amp;5\\1&amp;1&amp;1&amp;1&amp;1\\6&amp;6&amp;8&amp;3&amp;1<br>\end{vmatrix}<br>&#x3D;\begin{vmatrix}<br>1&amp;2\\3&amp;4<br>\end{vmatrix}<br>+(-1)^{1+2+1+2}\<br>\begin{vmatrix}<br>3&amp;4&amp;5\\1&amp;1&amp;1\\8&amp;3&amp;1<br>\end{vmatrix}<br>\tag{2.7.3}<br>$$</p>
<h2 id="行列式的运算"><a href="#行列式的运算" class="headerlink" title="行列式的运算"></a>行列式的运算</h2><h3 id="行列式相乘"><a href="#行列式相乘" class="headerlink" title="行列式相乘"></a>行列式相乘</h3><p>同阶行列式相乘类似矩阵的点乘。</p>
<p>例：<br>$$<br>\begin{gather}<br>\begin{vmatrix}<br>a_{1,1} &amp; a_{1,2} &amp; a_{1,3} \\ a_{2,1} &amp; a_{2,2} &amp; a_{2,3} \\ a_{3,1} &amp; a_{3,2} &amp; a_{3,3}<br>\end{vmatrix}<br>\times<br>\begin{vmatrix}<br>b_{1,1} &amp; b_{1,2} &amp; b_{1,3} \\ b_{2,1} &amp; b_{2,2} &amp; b_{2,3} \\ b_{3,1} &amp; b_{3,2} &amp; b_{3,3}<br>\end{vmatrix}<br>&#x3D; \\ \notag<br>\begin{vmatrix}<br>a_{1,1}b_{1,1}+a_{1,2}b_{2,1}+a_{1,3}b_{3,1} &amp;  a_{1,1}b_{1,2}+a_{1,2}b_{2,2}+a_{1,3}b_{3,2} &amp;<br>a_{1,1}b_{1,3}+a_{1,2}b_{2,3}+a_{1,3}b_{3,3} \\<br>a_{2,1}b_{1,1}+a_{2,2}b_{2,1}+a_{2,3}b_{3,1} &amp;  a_{2,1}b_{1,2}+a_{2,2}b_{2,2}+a_{2,3}b_{3,2} &amp;<br>a_{2,1}b_{1,3}+a_{2,2}b_{2,3}+a_{2,3}b_{3,3} \\<br>a_{3,1}b_{1,1}+a_{3,2}b_{2,1}+a_{3,3}b_{3,1} &amp;  a_{3,1}b_{1,2}+a_{3,2}b_{2,2}+a_{3,3}b_{3,2} &amp;<br>a_{3,1}b_{1,3}+a_{3,2}b_{2,3}+a_{3,3}b_{3,3}<br>\end{vmatrix} \notag<br>\end{gather}<br>\tag{2.8.1}<br>$$</p>
<p>如果行列式不同阶，那么就把高阶的降阶。</p>
<h3 id="加边法"><a href="#加边法" class="headerlink" title="加边法"></a>加边法</h3><p>假如有一个行列式如下：<br>$$<br>\begin{vmatrix}<br>1+a_1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 \\<br>1 &amp; 1+a_2 &amp; 1 &amp; \cdots &amp; 1 \\<br>1 &amp; 1 &amp; 1+a_3 &amp; \cdots &amp; 1 \\<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1+a_n<br>\end{vmatrix}<br>\tag{2.8.2}<br>$$<br>我们在解这个行列式的时候，可以给这个行列式在最左面加一列0，再在最上面加一行1，如下：<br>$$<br>\begin{vmatrix}<br>1 &amp; 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1\\<br>0 &amp; 1+a_1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 \\<br>0 &amp; 1 &amp; 1+a_2 &amp; 1 &amp; \cdots &amp; 1 \\<br>0 &amp; 1 &amp; 1 &amp; 1+a_3 &amp; \cdots &amp; 1 \\<br>\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>0 &amp; 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1+a_n<br>\end{vmatrix}<br>\tag{2.8.3}<br>$$<br>此时，我们再对这个行列式做出进一步的计算：<br>$$<br>&#x3D; \begin{vmatrix}1&amp;1&amp;1&amp;\cdots&amp;1\\-1&amp;a_1&amp;&amp;&amp;\\-1&amp;&amp;a_2&amp;&amp;\\\vdots&amp;&amp;&amp;\ddots&amp;\\-1&amp;&amp;&amp;&amp;a_n\end{vmatrix}<br>\tag{2.8.4}<br>\label{tri}<br>$$<br>$$<br>&#x3D; \begin{vmatrix}x&amp;1&amp;1&amp;\cdots&amp;1\\&amp;a_1&amp;&amp;&amp;\\&amp;&amp;a_2&amp;&amp;\\&amp;&amp;&amp;\ddots&amp;\\&amp;&amp;&amp;&amp;a_n\end{vmatrix}<br>\tag{2.8.5}<br>$$<br>其中，$x&#x3D;1+ \sum\limits_{i&#x3D;1}^{n} \dfrac{1}{a_i}$ 。</p>
<p>注意：<strong>加边的时候不能改变行列式的值！</strong></p>
<p>其中的$\ref{tri}$ 叫做“三叉形行列式”。</p>
<h2 id="特殊行列式-2"><a href="#特殊行列式-2" class="headerlink" title="特殊行列式(2)"></a>特殊行列式(2)</h2><h3 id="范德蒙德-Vandermonde-行列式"><a href="#范德蒙德-Vandermonde-行列式" class="headerlink" title="范德蒙德(Vandermonde)行列式"></a>范德蒙德(Vandermonde)行列式</h3><p>形如<br>$$<br>\begin{vmatrix}<br>1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 \\<br>x_1 &amp; x_2 &amp; x_3 &amp; \cdots &amp; x_n \\<br>x^2_1 &amp; x^2_2 &amp; x^2_3 &amp; \cdots &amp;x^2_n\\<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>x_1^{n-1} &amp; x_2^{n-1} &amp; x_3^{n-1} &amp; \cdots &amp; x_n^{n-1}<br>\end{vmatrix}<br>\tag{2.9.1}<br>$$</p>
<p>的行列式叫做<strong>范德蒙德行列式</strong>。</p>
<p>其结果是这样的：<br>$$<br>\begin{vmatrix} x_1^0 &amp; \cdots &amp; x_n^0 \\ \vdots &amp; \ddots &amp; \vdots \\ x_1^{n-1} &amp; \cdots &amp; x_n^{n-1} \end{vmatrix} &#x3D; \prod_{i&#x3D;j&#x3D;1}^n (x_i-x_j) \tag{2.9.2}<br>$$</p>
<h3 id="对称行列式-1"><a href="#对称行列式-1" class="headerlink" title="对称行列式"></a>对称行列式</h3><p>形如<br>$$<br>\begin{vmatrix}<br>x &amp; a_{1,1} &amp; a_{1,2} &amp; \cdots &amp; a_{1,n} \\<br>a_{1,1} &amp; x &amp; a_{2,2} &amp; \cdots &amp; a_{2,n} \\<br>a_{1,2} &amp; a_{2,2} &amp; x &amp; \cdots &amp; a_{3,n} \\<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>a_{1,n} &amp; a_{2,n} &amp; a_{3,n} &amp; \cdots &amp; x<br>\end{vmatrix}<br>\tag{2.9.3}<br>$$<br>的行列式叫做对称行列式，即$a_{i,j}&#x3D;a_{j,i}$。</p>
<p>对称行列式中：</p>
<ul>
<li>主对角线元素没有要求；</li>
<li>右上、左下位置对应相等。</li>
</ul>
<h3 id="反对称行列式-1"><a href="#反对称行列式-1" class="headerlink" title="反对称行列式"></a>反对称行列式</h3><p>形如<br>$$<br>\begin{vmatrix}<br>0 &amp; a_{1,1} &amp; a_{1,2} &amp; \cdots &amp; a_{1,n} \\<br>-a_{1,1} &amp; 0 &amp; a_{2,2} &amp; \cdots &amp; a_{2,n} \\<br>-a_{1,2} &amp; -a_{2,2} &amp; 0 &amp; \cdots &amp; a_{3,n} \\<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>-a_{1,n} &amp; -a_{2,n} &amp; -a_{3,n} &amp; \cdots &amp; 0<br>\end{vmatrix}<br>\tag{2.9.4}<br>$$<br>的行列式叫做反对称行列式，即$a_{i,j}&#x3D;-a_{j,i}$。</p>
<p>反对称行列式中：</p>
<ul>
<li>主对角线全为0；</li>
<li>右上、左下位置对应成相反数。</li>
</ul>
<p>在奇数阶反对称行列式中，$D&#x3D;0$ ；</p>
<p>证明：<br>$$<br>\begin{gathered}<br>\because<br>\begin{cases}<br>D&#x3D;D^T \\<br>D&#x3D;-D^T<br>\end{cases}<br>\\<br>\therefore D&#x3D;-D \\<br>\therefore 2D&#x3D;0 \\<br>\therefore D&#x3D;0<br>\end{gathered}<br>\tag{2.9.5}<br>$$</p>
<h2 id="克拉默-Cramer-法则"><a href="#克拉默-Cramer-法则" class="headerlink" title="克拉默(Cramer)法则"></a>克拉默(Cramer)法则</h2><p>就像<a href="/notes/linar-algebra/#%E4%BA%8C%E9%98%B6%E8%A1%8C%E5%88%97%E5%BC%8F">这里</a>所说的那样，行列式可以用来解多元一次方程组。</p>
<p>比如下面这个：<br>$$<br>\begin{cases}<br>x_1+x_2+x_3&#x3D;1\\<br>x_1-x_2+5x_3&#x3D;6\\<br>-x_1+x_2+6x_3&#x3D;9<br>\end{cases}<br>$$</p>
<p>其中，<br>$$<br>\begin{cases}<br>x_1&#x3D;\frac{D_1}{D}\\<br>x_2&#x3D;\frac{D_2}{D}\\<br>x_3&#x3D;\frac{D_3}{D}<br>\end{cases}<br>\tag{2.10.1}<br>$$<br>其中，<br>$$<br>\begin{cases}<br>D&#x3D;\begin{vmatrix}1&amp;1&amp;1\\1&amp;-1&amp;5\\-1&amp;1&amp;6\end{vmatrix}\\<br>D_1&#x3D;\begin{vmatrix}1&amp;1&amp;1\\6&amp;-1&amp;5\\9&amp;1&amp;6\end{vmatrix}\\<br>D_2&#x3D;\begin{vmatrix}1&amp;1&amp;1\\1&amp;6&amp;5\\-1&amp;9&amp;6\end{vmatrix}\\<br>D_3&#x3D;\begin{vmatrix}1&amp;1&amp;1\\1&amp;-1&amp;6\\-1&amp;1&amp;9\end{vmatrix}<br>\end{cases}<br>\tag{2.10.2}<br>$$<br>简化一点，就是这样：<br>$$<br>\begin{gather}<br>\begin{cases}<br>a_1x_1+b_1x_2+c_1x_3&#x3D;d_1\\<br>a_2x_1+b_2x_2+c_2x_3&#x3D;d_2\\<br>a_3x_1+b_3x_2+c_3x_3&#x3D;d_3<br>\end{cases}\\<br>\tag{2.10.3}<br>\text{其中，}\\<br>\begin{cases}<br>x_1&#x3D;\frac{D_1}{D}\\<br>x_2&#x3D;\frac{D_2}{D}\\<br>x_3&#x3D;\frac{D_3}{D}<br>\end{cases}\\<br>\tag{2.10.4}<br>\text{其中，}\\<br>\begin{cases}<br>D&#x3D;\begin{vmatrix}a_1&amp;b_1&amp;c_1\\a_2&amp;b_2&amp;c_2\\a_3&amp;b_3&amp;c_3\end{vmatrix}\\<br>D_1&#x3D;\begin{vmatrix}d_1&amp;b_1&amp;c_1\\d_2&amp;b_2&amp;c_2\\d_3&amp;b_3&amp;c_3\end{vmatrix}\\<br>D_2&#x3D;\begin{vmatrix}a_1&amp;d_1&amp;c_1\\a_2&amp;d_2&amp;c_2\\a_3&amp;d_3&amp;c_3\end{vmatrix}\\<br>D_3&#x3D;\begin{vmatrix}a_1&amp;b_1&amp;d_1\\a_2&amp;b_2&amp;d_2\\a_3&amp;b_3&amp;d_3\end{vmatrix}<br>\end{cases}<br>\tag{2.10.5}<br>\end{gather}<br>$$</p>
<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><p>形如<br>$$<br>A &#x3D;<br>\begin{bmatrix}<br>a_{1,1} &amp; a_{1,2} &amp; a_{1,3} &amp; \dots &amp; a_{1,n} \\<br>a_{2,1} &amp; a_{2,2} &amp; a_{2,3} &amp; \dots &amp; a_{2,n} \\<br>a_{3,1} &amp; a_{3,2} &amp; a_{3,3} &amp; \dots &amp; a_{3,n} \\<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>a_{m,1} &amp; a_{m,2} &amp; a_{m,3} &amp; \dots &amp; a_{m,n}<br>\end{bmatrix}<br>\tag{3.0.1}<br>$$</p>
<p>的数据结构，我们称之为大小为 $m \times n$ 的矩阵，可以简记为 $A_{m \times n}$ 。</p>
<p>显而易见，$\begin{bmatrix}n\end{bmatrix}&#x3D;n$。</p>
<h2 id="特殊形态的矩阵"><a href="#特殊形态的矩阵" class="headerlink" title="特殊形态的矩阵"></a>特殊形态的矩阵</h2><h3 id="行矩阵"><a href="#行矩阵" class="headerlink" title="行矩阵"></a>行矩阵</h3><p>只有一行的矩阵。</p>
<p>例：$A_{1 \times 3}&#x3D;\begin{bmatrix}1&amp;1&amp;1\end{bmatrix}$</p>
<h3 id="列矩阵"><a href="#列矩阵" class="headerlink" title="列矩阵"></a>列矩阵</h3><p>只有一列的矩阵。</p>
<p>例：$A_{3 \times 1}&#x3D;\begin{bmatrix}1\\1\\1\end{bmatrix}$</p>
<h3 id="零矩阵"><a href="#零矩阵" class="headerlink" title="零矩阵"></a>零矩阵</h3><p>只有零的矩阵。</p>
<p>例：$A_{2 \times 2}&#x3D;\begin{bmatrix}0&amp;0\\0&amp;0\end{bmatrix}$</p>
<p>零矩阵可以记作$0$。</p>
<h3 id="负矩阵"><a href="#负矩阵" class="headerlink" title="负矩阵"></a>负矩阵</h3><p>假设有一个矩阵$A$，其负矩阵为$-A$ 。</p>
<p>某一个矩阵的负矩阵中的每一个元素都与原矩阵的对应元素互为相反数。</p>
<h3 id="方阵"><a href="#方阵" class="headerlink" title="方阵"></a>方阵</h3><p>行数等于列数的矩阵。</p>
<p>例：$A_{2 \times 2}&#x3D;\begin{bmatrix}1&amp;1\\1&amp;1\end{bmatrix}$</p>
<p>$n$阶矩阵$A_{n \times n}$简便记作$A_n$。</p>
<h3 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h3><p>与单位行列式类似，即主对角线上均为1，其余均为0的矩阵。</p>
<p>例：$A_{n \times n}&#x3D;\begin{bmatrix}1&amp;&amp;\\&amp;\ddots&amp;\\&amp;&amp;1\end{bmatrix}$</p>
<p>单位矩阵可以记作$E$或$I$。</p>
<h2 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h2><p>矩阵有这样几种运算：</p>
<h3 id="矩阵的相等"><a href="#矩阵的相等" class="headerlink" title="矩阵的相等"></a>矩阵的相等</h3><p><del>没想到吧矩阵的相等在我这里也算作一种运算</del></p>
<p>两个矩阵相等的前提是他们是同型矩阵。如：<br>如果$A_{m,n}&#x3D;B_{p,q}$，<br>那么$m&#x3D;p,n&#x3D;q$，且$\forall a_{i,j}&#x3D;b_{i,j}$</p>
<h3 id="加法、减法"><a href="#加法、减法" class="headerlink" title="加法、减法"></a>加法、减法</h3><p>$$<br>\begin{bmatrix}<br>a &amp; b &amp; c \\<br>d &amp; e &amp; f<br>\end{bmatrix}<br>\pm<br>\begin{bmatrix}<br>g &amp; h &amp; i \\<br>j &amp; k &amp; l<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>a \pm g &amp; b \pm h &amp; c \pm i \\<br>d \pm j &amp; e \pm k &amp; f \pm l<br>\end{bmatrix}<br>\tag{3.1.1}<br>$$</p>
<p>矩阵的加法满足交换律和结合律。</p>
<p>注意：只有同型矩阵之间才能加减。</p>
<h3 id="数乘"><a href="#数乘" class="headerlink" title="数乘"></a>数乘</h3><p>$$<br>k \times<br>\begin{bmatrix}<br>a &amp; b &amp; c \\<br>d &amp; e &amp; f<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>ka &amp; kb &amp; kc \\<br>kd &amp; ke &amp; kf<br>\end{bmatrix}<br>\tag{3.2.1}<br>$$</p>
<p>矩阵的数乘满足交换律、结合律和分配律。</p>
<h4 id="矩阵提公因子"><a href="#矩阵提公因子" class="headerlink" title="矩阵提公因子"></a>矩阵提公因子</h4><p>与行列式不同（这一点可以在上面的数乘部分看到），矩阵提公因子的话是整体提取的。如：<br>$$<br>\begin{bmatrix}<br>ka &amp; kb &amp; kc \\<br>kd &amp; ke &amp; kf<br>\end{bmatrix}<br>&#x3D;k\times<br>\begin{bmatrix}<br>a &amp; b &amp; c \\<br>d &amp; e &amp; f<br>\end{bmatrix}<br>\tag{3.2.2}<br>$$</p>
<h3 id="点乘"><a href="#点乘" class="headerlink" title="点乘"></a>点乘</h3><p>如果<br>$$<br>A_{i,n} \times B_{n,j} &#x3D; C_{i,j}<br>\tag{3.3.1}<br>$$<br>的话，那么<br>$$<br>c_{i,j}&#x3D;\sum_{k&#x3D;1}^{n} \  a_{i,k} \times b_{k,j}<br>\tag{3.3.2}<br>$$<br>，其中 $ a_{i,k} \in A , b_{k,j} \in B , c_{i,j} \in C $ 。</p>
<p>矩阵的点乘要求A矩阵的长与B矩阵的宽相等。</p>
<p>例：<br>$$<br>\begin{gather}<br>\begin{bmatrix}<br>a_{1,1} &amp; a_{1,2} &amp; a_{1,3} \\ a_{2,1} &amp; a_{2,2} &amp; a_{2,3} \\ a_{3,1} &amp; a_{3,2} &amp; a_{3,3} \\ a_{4,1} &amp; a_{4,2} &amp; a_{4,3}<br>\end{bmatrix}<br>\times<br>\begin{bmatrix}<br>b_{1,1} &amp; b_{1,2} \\ b_{2,1} &amp; b_{2,2} \\ b_{3,1} &amp; b_{3,2}<br>\end{bmatrix}\\ \notag<br>&#x3D;\\ \notag<br>\begin{bmatrix}<br>a_{1,1}b_{1,1}+a_{1,2}b_{2,1}+a_{1,3}b_{3,1} &amp; a_{2,1}b_{1,1}+a_{2,2}b_{2,1}+a_{2,3}b_{3,1} &amp; a_{3,1}b_{1,1}+a_{3,2}b_{2,1}+a_{3,3}b_{3,1} &amp; a_{4,1}b_{1,1}+a_{4,2}b_{2,1}+a_{4,3}b_{3,1} \\<br>a_{1,1}b_{1,2}+a_{1,2}b_{2,2}+a_{1,3}b_{3,2} &amp;  a_{2,1}b_{1,2}+a_{2,2}b_{2,2}+a_{2,3}b_{3,2} &amp; a_{3,1}b_{1,2}+a_{3,2}b_{2,2}+a_{3,3}b_{3,2} &amp; a_{4,1}b_{1,2}+a_{4,2}b_{2,2}+a_{4,3}b_{3,2}<br>\end{bmatrix} \notag<br>\end{gather}<br>\tag{3.3.3}<br>\label{dt}<br>$$</p>
<p>在点乘中，有许多需要注意的点：</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>1.矩阵的点乘不满足交换律。<br>即，$A \times B$不一定$&#x3D;B \times A$。<br>所以，特别的，在算式$A \times B$中，我们称$A$左乘$B$，同时$B$右乘$A$。<br>如果正好$A \times B&#x3D;B \times A$，那么我们称$A,B$是可交换的。</p>
<p>但是，矩阵的点乘满足结合律和分配律，即：</p>
<p>$(A \times B) \times C&#x3D;A \times (B \times C)$</p>
<p>运用分配率的时候需要注意，矩阵的位置要对应。</p>
<p>$(A+B) \times C &#x3D; A \times C + B \times C $</p>
<p>$C \times (A \times B) &#x3D; C \times A + C \times B$</p>
<p>2.$A \times B&#x3D;0 \ \nRightarrow A&#x3D;0 \ or \ B&#x3D;0$.</p>
<p>3.$if \ A \times B&#x3D;A \times C , A \neq 0 \nRightarrow B&#x3D;C$</p>
<h4 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h4><ol>
<li>$A \times 0 &#x3D; 0$.</li>
<li>$A \times E&#x3D;E \times A&#x3D;A$.</li>
<li>$k(A \times B) &#x3D; (kA) \times B &#x3D; A \times (kB)$</li>
</ol>
<h3 id="转置-1"><a href="#转置-1" class="headerlink" title="转置"></a>转置</h3><p>将矩阵的行和列互相交换之后，就完成了矩阵的转置。<br>如：<br>$$<br>\begin{bmatrix}<br>a &amp; b &amp; c \\<br>d &amp; e &amp; f<br>\end{bmatrix}^T&#x3D;<br>\begin{bmatrix}<br>a &amp; d\\<br>b &amp; e\\<br>c &amp; f<br>\end{bmatrix}<br>\tag{3.4.1}<br>$$</p>
<p>矩阵 $A$ 的转置用符号 $A^T$ 表示。</p>
<h4 id="性质-3"><a href="#性质-3" class="headerlink" title="性质"></a>性质</h4><ol>
<li>$(A^T)^T&#x3D;A$.</li>
<li>$(A+B)^T&#x3D;A^T+B^T$.</li>
<li>$(kA)^T&#x3D;kA^T$.</li>
<li>$(AB)^T&#x3D;B^T \times A^T$.</li>
</ol>
<h3 id="幂运算"><a href="#幂运算" class="headerlink" title="幂运算"></a>幂运算</h3><p>与常数类似，矩阵也有幂运算。</p>
<p>我们定义矩阵$A$的$k$次幂为$A$ $k$次自乘后所得的结果。<br>特别的，我们定义$A^0&#x3D;E$。</p>
<p>矩阵的幂运算与常数的幂运算不是很类似。</p>
<p>矩阵的幂运算不满足这些定律：</p>
<p>$(A \times B)^k \neq A^k \times B^k$</p>
<p>$(A \pm B)^2 \neq A^2 \pm 2A \times B +B^2$</p>
<p>但是，矩阵满足这样一个奇怪的东西：</p>
<p>$(A+E)^2 &#x3D; A^2 + 2A \times E + E^2$</p>
<p>我们推导一下，可以得到这样一个结果：</p>
<p>$$<br>\begin{align}<br>(A+E)^2 &#x3D;{} &amp; (A+E) \times (A+E) \\<br>&#x3D;{} &amp; (A^2 + E \times A) + (A \times E + E^2) \\<br>\end{align}<br>$$<br>$$<br>\because A \times E &#x3D; E \times A &#x3D; A<br>$$<br>$$<br>\begin{align}<br>\therefore<br>(A+E)^2 &#x3D;{} &amp; (A^2 + A \times E) + (A \times E + E^2) \\<br>&#x3D;{} &amp; A^2 + 2A \times E + E^2<br>\end{align}<br>$$</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>P2860 [USACO06JAN] Redundant Paths 题解</title>
    <url>/solutions/solution-p2860/</url>
    <content><![CDATA[<br>
<span id="more"></span>

<div id="problem-card-vis">true</div>
<div id="problem-info-name">Redundant Paths</div>
<div id="problem-info-from">USACO 2006 January Gold</div>
<div id="problem-info-difficulty">提高+ /省选-</div>
<div id="problem-info-color">#3498db</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI4NjA=">Luogu P2860<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzk3Lw==">AcWing 395<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzE3MTg=">BZOJ #1718<i class="fa fa-external-link-alt"></i></span></li></ul></div>

<hr>
<p>题目要求我们给一个无向联通图上加几条边，使得整个图变成一个双联通分量。</p>
<p>我们可以想到的一个思路就是，首先跑一遍 Tarjan 算法，将所有的双连通分量缩成点，这样就可以将整张图缩成一棵树。</p>
<p>这样的话，我们可以瞎搞出来一个结论，如下：</p>
<p>我们统计出来所有的叶子结点，记其数目为 $cnt$，我们最终要加的边数最少就是 $\lceil \dfrac{cnt}{2} \rceil$。</p>
<p>首先我们可以随便连接两个叶子结点，将其变为一个基环树。</p>
<p>我们可以证明，一定有一种连接方法，使得得到的基环树是有偶数条支链的。</p>
<p>如果我们得到的基环树有奇数条支链的话，我们可以进行一些转化：</p>
<p>假设当前有这样一个基环树：<br><del>（不如叫他<ruby>1-乙基-3-(1-甲基)乙基环己烷<rt>1-ethyl-3-(1-methyl)ethylcyclohexane</rt></ruby>）</del></p>
<img src="https://s2.loli.net/2022/06/21/8zeqAH9PdpEoUvC.png" alt="p2860-8.png" width="60%" />

<p>我们可以找到一条边，连接两个端点，而其中一个端点有支链。不妨设这个有支链的点为 $y$，另一个点为 $x$。</p>
<p>我们断开连接 $x$ 与 $y$ 的边，然后找到 $y$ 的一条支链最底端的叶子结点 $z$，最后连接 $x$ 与 $z$，减少了一条支链。</p>
<img src="https://s2.loli.net/2022/06/21/QtFkemasBWDjPMO.png" alt="p2860-1.png" width="60%" />

<p><del>（不如叫他<ruby>1,4-二乙基环辛烷<rt>1,4-diethylcyclohexane</rt></ruby>）</del></p>
<p>这样就可以变成只有偶数条支链了。</p>
<p>对于每一条支链的叶子结点，我们找到一个另外的叶子结点，使得他们的LCA在环上。这样就满足了我们“双联通分量”的要求。不懂的可以自己手画一下。</p>
<p>但是有些时候随机连接的方案不一定能让所有的LCA都在环上，比如这个：</p>
<img src="https://s2.loli.net/2022/06/21/8mlIyAtafpFT5dr.png" alt="p2860-2.png" width="60%" />

<p>这样连接就不可以：</p>
<img src="https://s2.loli.net/2022/06/21/NPgAT2fhJlLb41H.png" alt="p2860-3.png" width="60%" />

<p>这样连接就可以：</p>
<img src="https://s2.loli.net/2022/06/21/DJs9KV6TMCf41wG.png" alt="p2860-4.png" width="60%" />

<p>但是很不幸，上面的那种情况就是出现了。<br>现在我们考虑由其转移到一个可行的方案上面。</p>
<p>因为我们总共有偶数个叶子结点，所以我们最终还是会剩偶数个叶子结点没有配对。</p>
<p>我们可以通过不断对部分节点重新配对来缩小问题规模，直至解决问题。</p>
<p>我们先把不对劲的边断开：</p>
<img src="https://s2.loli.net/2022/06/21/NXe28OcVAY4JDqU.png" alt="p2860-5.png" width="60%" />

<p>然后找到已经配好对了的两个子节点，这里选取8和13；<br>断掉其间的边，然后分别找一个子树上的任意一个点连边；</p>
<img src="https://s2.loli.net/2022/06/21/bsOS24dDWPXuGBa.png" alt="p2860-6.png" width="60%" />

<p>然后我们的问题规模就缩小了2，剩下的点如法炮制即可。<br>如果最终只剩两个点，而且不在同一支链上的话就直接连边即可。</p>
<img src="https://s2.loli.net/2022/06/21/pEJU3FSLcOCKkuG.png" alt="p2860-7.png" width="60%" />

<p>最终我们可以得出，我们最少需要连接的边数是 $\lceil \dfrac{cnt}{2} \rceil$ 条。</p>
<p>然后就可以上代码了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> isBridge[M];</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], cnt;</span><br><span class="line"><span class="type">int</span> sta[N], tt;</span><br><span class="line"><span class="type">int</span> scc[N], sc, sz[N];</span><br><span class="line"><span class="type">int</span> deg[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> from)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    low[p] = dfn[p] = ++cnt;</span><br><span class="line">    sta[++tt] = p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j, i);</span><br><span class="line">            low[p] = <span class="built_in">min</span>(low[p], low[j]);</span><br><span class="line">            <span class="keyword">if</span>(dfn[p] &lt; low[j])</span><br><span class="line">                isBridge[i] = isBridge[i ^ <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i != (from ^ <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            low[p] = <span class="built_in">min</span>(low[p], dfn[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[p] == low[p])</span><br><span class="line">    &#123;</span><br><span class="line">        ++sc;</span><br><span class="line">        <span class="keyword">while</span>(sta[tt] != p)</span><br><span class="line">        &#123;</span><br><span class="line">            scc[sta[tt]] = sc;</span><br><span class="line">            sz[sc]++;</span><br><span class="line">            tt--;</span><br><span class="line">        &#125;</span><br><span class="line">        scc[sta[tt]] = sc;</span><br><span class="line">        sz[sc]++;</span><br><span class="line">        tt--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++)</span><br><span class="line">        <span class="keyword">if</span>(isBridge[i])</span><br><span class="line">            deg[scc[e[i]]]++;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sc; i++)</span><br><span class="line">        <span class="keyword">if</span>(deg[i] == <span class="number">1</span>)cnt++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (cnt + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>图的连通性</tag>
      </tags>
  </entry>
</search>
