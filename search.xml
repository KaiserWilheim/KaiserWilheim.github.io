<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>亚兰字母拼写英语</title>
    <url>/hebrew-english/</url>
    <content><![CDATA[<p>一种使用亚兰字母来拼写英语的方案。<br>（测试博客显示情况用）<br>𗼇𗟲</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<p>首先展示 Note 框，以便使用：</p>
<details class="note "><summary><p>Without Class</p>
</summary>

</details>

<details class="note default"><summary><p>Default</p>
</summary>

</details>

<details class="note primary"><summary><p>Primary</p>
</summary>

</details>

<details class="note info"><summary><p>Info</p>
</summary>

</details>

<details class="note success"><summary><p>Success</p>
</summary>

</details>

<details class="note warning"><summary><p>Warning</p>
</summary>

</details>

<details class="note danger"><summary><p>Danger</p>
</summary>

</details>

<p>然后是 Tabs：</p>
<div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><a href="#test-1"><i class="fa fa-heart"></i>第一页</a></li><li class="tab"><a href="#test-2">Page 2</a></li></ul><div class="tab-content"><div class="tab-pane active" id="test-1"><p>这是第一个 Tab 。</p></div><div class="tab-pane" id="test-2"><p>Tab 语法里面的 <code>&lt;!--</code> 之后和 <code>--&gt;</code> 之前好像可以有空格。</p></div></div></div>

<div class="tabs" id="tabs-套-note"><ul class="nav-tabs"><li class="tab active"><a href="#tabs-套-note-1">无 Class</a></li><li class="tab"><a href="#tabs-套-note-2">default</a></li><li class="tab"><a href="#tabs-套-note-3">primary</a></li><li class="tab"><a href="#tabs-套-note-4">info</a></li><li class="tab"><a href="#tabs-套-note-5">success</a></li><li class="tab"><a href="#tabs-套-note-6">warning</a></li><li class="tab"><a href="#tabs-套-note-7">danger</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tabs-套-note-1"><details class="note "><summary><p>Without Class</p>
</summary>

</details></div><div class="tab-pane" id="tabs-套-note-2"><details class="note default"><summary><p>Default</p>
</summary>

</details></div><div class="tab-pane" id="tabs-套-note-3"><details class="note primary"><summary><p>Primary</p>
</summary>

</details></div><div class="tab-pane" id="tabs-套-note-4"><details class="note info"><summary><p>Info</p>
</summary>

</details></div><div class="tab-pane" id="tabs-套-note-5"><details class="note success"><summary><p>Success</p>
</summary>

</details></div><div class="tab-pane" id="tabs-套-note-6"><details class="note warning"><summary><p>Warning</p>
</summary>

</details></div><div class="tab-pane" id="tabs-套-note-7"><details class="note danger"><summary><p>Danger</p>
</summary>

</details></div></div></div>

<hr>
<h1 id="亚兰字母"><a href="#亚兰字母" class="headerlink" title="亚兰字母"></a>亚兰字母</h1><p>首先是元音。</p>
<p>&#x2F;ʌ&#x2F;-&gt;אֲ  &#x2F;æ&#x2F;-&gt;אֵ  &#x2F;α:&#x2F;-&gt;אַ</p>
<p>&#x2F;i&#x2F;-&gt;י  &#x2F;i:&#x2F;-&gt;יִ</p>
<p>&#x2F;u&#x2F;-&gt;ו  &#x2F;u:&#x2F;-&gt;וִ</p>
<p>&#x2F;e&#x2F;-&gt;אֶ  &#x2F;ə&#x2F;-&gt;ע  &#x2F;ə:&#x2F;-&gt;עִ</p>
<p>&#x2F;ɔ&#x2F;-&gt;אֳ  &#x2F;ɔ:&#x2F;-&gt;אָ</p>
<p>双元音直接组合即可。</p>
<p>&#x2F;ei&#x2F;-&gt;עֹ  &#x2F;ai&#x2F;-&gt;אַֹ  &#x2F;au&#x2F;-&gt;אַו  &#x2F;əu&#x2F;-&gt;עו  &#x2F;uə&#x2F;-&gt;וֶ  &#x2F;iə&#x2F;-&gt;יֶ  &#x2F;eə&#x2F;-&gt;עֶ  &#x2F;ɔi&#x2F;-&gt;אָֹ</p>
<p>然后是辅音。</p>
<p>&#x2F;k&#x2F;-&gt;ק  &#x2F;t&#x2F;-&gt;ט  &#x2F;p&#x2F;-&gt;פּ</p>
<p>&#x2F;g&#x2F;-&gt;ג  &#x2F;d&#x2F;-&gt;ד  &#x2F;b&#x2F;-&gt;בּ</p>
<p>&#x2F;s&#x2F;-&gt;ס  &#x2F;θ&#x2F;-&gt;ת  &#x2F;f&#x2F;-&gt;פ  &#x2F;ʃ&#x2F;-&gt;ש</p>
<p>&#x2F;z&#x2F;-&gt;ז  &#x2F;ð&#x2F;-&gt;דּ  &#x2F;v&#x2F;-&gt;ב  &#x2F;ʒ&#x2F;-&gt;שׁ</p>
<p>&#x2F;tʃ&#x2F;-&gt;טש  &#x2F;tr&#x2F;-&gt;טר  &#x2F;ts&#x2F;-&gt;צ</p>
<p>&#x2F;dʒ&#x2F;-&gt;דשׁ  &#x2F;dr&#x2F;-&gt;דר  &#x2F;dz&#x2F;-&gt;צּ</p>
<p>&#x2F;m&#x2F;-&gt;מ  &#x2F;n&#x2F;-&gt;נ  &#x2F;ŋ&#x2F;-&gt;נּ</p>
<p>&#x2F;h&#x2F;-&gt;ה  &#x2F;l&#x2F;-&gt;ל  &#x2F;r&#x2F;-&gt;ר</p>
<p>最后是半元音。</p>
<p>&#x2F;w&#x2F;-&gt;וּ  &#x2F;j&#x2F;-&gt;יּ</p>
<p>辅音中的כ与ח和元音中的אֻ没有用到，但我准备了适配其他语言的音素：</p>
<p>&#x2F;ç&#x2F;-&gt;כ  &#x2F;x&#x2F;-&gt;כּ  &#x2F;ʀ&#x2F;-&gt;ח  &#x2F;y&#x2F;-&gt;אֻ</p>
<p>还有重音符号：<br>&#x2F;ˈ&#x2F;-&gt;א֫<br>&#x2F;ˌ&#x2F;-&gt;אֽ ?</p>
<p>备注：</p>
<p>没想到tsadee没有办法类似שׁ这样向右上方加点，所以采用了中间加点的方式来使其可以打到电脑上。</p>
<p>示例：</p>
<p>原文：</p>
<p>To be, or not to be- that is the question:<br>Whether ‘tis nobler in the mind to suffer<br>The slings and arrows of outrageous fortune<br>Or to take arms against a sea of troubles,<br>And by opposing end them. To die- to sleep-<br>No more; and by a sleep to say we end<br>The heartache, and the thousand natural shocks<br>That flesh is heir to. ‘Tis a consummation<br>Devoutly to be wish’d. To die- to sleep.</p>
<p>音标：</p>
<p>[tuː] [biː]<strong>,</strong> [ɔː] [nɔt] [tuː] [biː]<strong>-</strong> [ðæt] [ɪz] [ðə] [ˈkwesʧən]<strong>:</strong><br>[ˈweðə] [tɪz] [ˈnəublər] [ɪn] [ðə] [maɪnd] [tuː] [ˈsʌfə]<br>[ðə] [slɪŋz] [ænd] [ˈærəuz] [ɔv] [autˈreɪʤəs] [ˈfɔːʧən]<br>[ɔː] [tuː] [teɪk] [ɑːmz] [əˈgenst] [ə] [siː] [ɔv] [ˈtrʌblz]<strong>,</strong><br>[ænd] [baɪ] [əˈpəuzɪŋ] [end] [ðem]<strong>.</strong> [tuː] [daɪ]<strong>-</strong> [tuː] [sliːp]<strong>-</strong><br>[nəu] [mɔː]<strong>;</strong> [ænd] [baɪ] [ə] [sliːp] [tuː] [seɪ] [wiː] [end]<br>[ðə] [ˈhɑːteɪk]<strong>,</strong> [ænd] [ðə] [ˈθauzənd] [ˈnæʧrəl] [ʃɔks]<br>[ðæt] [fleʃ] [ɪz] [eə] [tuː]<strong>.</strong> [tɪz] [ə] [ˌkɔnsəˈmeɪʃən]<br>[dɪˈvautli] [tuː] [biː] [wɪʃt]<strong>.</strong> [tuː] [daɪ]<strong>-</strong> [tuː] [sliːp]<strong>.</strong></p>
<p>转写：</p>
<p dir="rtl">
טוִ בּיִ, אָ נֳט טוִ בּיִ- דֵּט יז דּע ק֫וֶּסטשען: <br>
וֶּ֫דּע טיז נ֫עובּלער ין דּע מַֹנד טוִ סֲ֫פע <br>
דּע סלינּז אֵנד אֵ֫רעֻז אֳב אַוטר֫עֹדצּעס פָ֫טשען <br>
אָ טוִ טעֹק אַמז ע֫גֶנסט אֶ סיִ אֳב ט֫רֲבּלז, <br>
אֵנּד בַֹּ עפּ֫עֻזיןּ אֶנד דֶּם. טוִ דַֹ- טוִ סליִףּ- <br>
נעו מָ; אֵנד בַֹּ ע סליִפּ טוִ סעֹ וּיִ אֶנד <br>
דּע הַ֫טעֹק, דּע תַ֫וזענד נֵ֫טשרעל שָקס <br>
דֵּט פלֶש יז עֶ טוִ. טיז ע קֳנסעמ֫עֹשען <br>
דיבַ֫וטלי טוִ בּיִ וּישט. טוִ דַֹ- טוִ סליִףּ.
</p>

<p><del>犹太史诗（确信）</del></p>
<h1 id="阿拉伯字母"><a href="#阿拉伯字母" class="headerlink" title="阿拉伯字母"></a>阿拉伯字母</h1><p>既然阿拉伯字母与希伯来字母同根同源，那么……</p>
<p>（tbc）</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>博客索引</title>
    <url>/suoyin/</url>
    <content><![CDATA[<p>文章的索引。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>$\rm{OI}$ 与 $\rm{Ch}$ 的交汇，能迸发出怎样的火花呢？</p>
<p>为了便于<del>我自己及时更新</del>读者们挑选合适的文章，下面有几个符号，可以帮助读者大人们挑选。<del>（我有读者吗？）</del></p>
<ul>
<li>$\color[rgb]{0,0.5,1}{\sharp}$ 代表已经写完了</li>
<li>$\color[rgb]{0.067,0.270588,0.078431}{\natural}$ 表示长期更新</li>
<li>$\color[rgb]{1,0,0}{\flat}$ 表示我这个蒟蒻还没写完</li>
<li><strong>止まれ</strong> 表示我因某种原因暂停更新<del>也就是咕咕咕了</del></li>
<li>$\color[rgb]{0.5,0.4,0.4}{φ}$ 表示我虽然写完了，但是某些地方还需要完善，完善完了会换成 $\color[rgb]{0,0.5,1}{\sharp}$ 标志。</li>
<li>$\color[rgb]{1,1,0.0625}{\aleph}$ 表示我这个蒟蒻觉得我自己写的很好。</li>
</ul>
<p>阅读博客的时候，我们经常会看到一些板子。</p>
<p>如果某一个板子是我自己写的，在它的附近会有一个 $\color[rgb]{1,1,0.0625}{φ}$ 的标志。这些板子保证运行的正确性。大胆褐，不会有事的（指运行结果）。<br>如果某一个板子不是我写的，在它的附近会有一个 $\blacktriangleright$ 指向它的出处。这些板子不保证运行的正确性。使用之前请斟酌。 </p>
<p>最后一次维护：20220826</p>
<h1 id="OI"><a href="#OI" class="headerlink" title="OI"></a>OI</h1><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><p>数学是算法的基石。</p>
<ul>
<li><p><a href="/maths/mathematics">杂项整理</a> $\color[rgb]{0.067,0.270588,0.078431}{\natural}$<br>写不成博客的东西都在这里。</p>
</li>
<li><p><a href="/maths/eular-and-m%C3%B6bius">欧拉与莫比乌斯</a> $\color[rgb]{0,0.5,1}{\sharp}$<br>包含欧拉函数、欧拉定理、莫比乌斯函数与莫比乌斯反演。</p>
</li>
<li><p><a href="/maths/special-numbers">特殊的数</a> $\color[rgb]{1,0,0}{\flat}$<br>包含斯特林数等。</p>
</li>
<li><p><a href="/maths/fourier-transform">傅里叶变换</a> $\color[rgb]{0.5,0.4,0.4}{φ}$<br>包含傅里叶变换和快速傅里叶变换，附带一些复数和单位根的知识。</p>
</li>
<li><p><a href="/maths/lagrange-interpolation">拉格朗日插值</a> $\color[rgb]{0.5,0.4,0.4}{φ}$<br>包括拉格朗日插值。</p>
</li>
<li><p><a href="/maths/matrix/">矩阵</a> $\color[rgb]{0,0.5,1}{\sharp}$<br>矩阵相关运算，以及矩阵在OI中的运用。</p>
</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法是程序的基础。</p>
<ul>
<li><p><a href="/OI/scanning-line">扫描线</a> $\color[rgb]{0,0.5,1}{\sharp}$<br>一种用来求矩形面积并的算法。</p>
</li>
<li><p><a href="/OI/heavy-path-decomposition">树链剖分</a> $\color[rgb]{0,0.5,1}{\sharp}$<br>树剖。</p>
</li>
<li><p><a href="/OI/difference-constraint/">差分约束</a> $\color[rgb]{0,0.5,1}{\sharp}$<br>一种用来解决不等式组求解的算法。</p>
</li>
<li><p><a href="/OI/2-sat">2-SAT</a> $\color[rgb]{0,0.5,1}{\sharp}$<br>rt，2-SAT问题。</p>
</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>啊这……这里该怎么写……</p>
<ul>
<li><p><a href="/OI/tree-array">树状数组</a> $\color[rgb]{0,0.5,1}{\sharp}$<br>如题，树状数组。</p>
</li>
<li><p><a href="/OI/segment-tree">线段树</a> $\color[rgb]{0,0.5,1}{\sharp}$<br>线段树相关内容，包括动态开点线段树、可持久化权值线段树等。</p>
</li>
<li><p><a href="/OI/scapegoat-tree/">替罪羊树</a> $\color[rgb]{0,0.5,1}{\sharp}$<br>一种利用暴力重构维护平衡的平衡树。</p>
</li>
<li><p><a href="/OI/splay/">Splay</a> $\color[rgb]{0,0.5,1}{\sharp}$<br>一种基于旋转的平衡树。</p>
</li>
<li><p><a href="/OI/kd-tree/">K-D Tree</a> $\color[rgb]{0.5,0.4,0.4}{φ}$<br>一种维护高维空间信息的数据结构。</p>
</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串的处理和询问一直是OI中比较重要的内容。</p>
<ul>
<li><p><a href="/OI/kmp/">KMP算法与前缀函数</a> $\color[rgb]{0,0.5,1}{\sharp}$<br>一种用来快速查询模式串在文本串中的出现次数的算法。</p>
</li>
<li><p><a href="/OI/trie-and-AK-avtomat">Trie与AC自动机</a> $\color[rgb]{0,0.5,1}{\sharp}$<br> Trie与AC自动机，同时包括可持久化Trie。</p>
</li>
<li><p><a href="/OI/suffix-avtomat">后缀自动机</a> $\color[rgb]{0,0.5,1}{\sharp}$<br>如题，后缀自动机。</p>
</li>
</ul>
<h2 id="图论相关"><a href="#图论相关" class="headerlink" title="图论相关"></a>图论相关</h2><p>是时候把图论的东西单独拿出来了。</p>
<ul>
<li><p><a href="/OI/flow">网络流</a> $\color[rgb]{0.5,0.4,0.4}{φ}$<br>如题，网络流相关内容。</p>
</li>
<li><p><a href="/OI/bipartie-graph">二分图</a> $\color[rgb]{0.5,0.4,0.4}{φ}$<br>如题，二分图相关内容。</p>
</li>
<li><p><a href="/OI/virtual-tree">虚树</a> $\color[rgb]{0.5,0.4,0.4}{φ}$<br>虚树。</p>
</li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题解还会有没写完的吗？</p>
<p>给自己看的：<br>注意提交地址顺序：<br>Luogu (CF AT) LibreOJ AcWing UOJ BZOJ</p>
<ul>
<li><a href="/solutions/solution-p1084">Luogu P1084</a> [NOIP2012 提高组] 疫情控制</li>
<li><a href="/solutions/solution-p1117">Luogu P1117</a> [NOI2016] 优秀的拆分</li>
<li><a href="/solutions/solution-p1251">Luogu P1251</a> 餐巾计划问题</li>
<li><a href="/solutions/solution-p1486">Luogu P1486</a> [NOI2004] 郁闷的出纳员</li>
<li><a href="/solutions/solution-p1505">Luogu P1505</a> [国家集训队] 旅游</li>
<li><a href="/solutions/solution-p1712">Luogu P1712</a> [NOI2016] 区间</li>
<li><a href="/solutions/solution-p1954">Luogu P1954</a> [NOI2010] 航空管制</li>
<li><a href="/solutions/solution-p1999">Luogu P1999</a> 高维正方体</li>
<li><a href="/solutions/solution-p2042">Luogu P2042</a> [NOI2005] 维护数列</li>
<li><a href="/solutions/solution-p2146">Luogu P2146</a> [NOI2015]软件包管理器</li>
<li><a href="/solutions/solution-p2375">Luogu P2375</a> [NOI2014] 动物园</li>
<li><a href="/solutions/solution-p2414">Luogu P2414</a> [NOI2011] 阿狸的打字机</li>
<li><a href="/solutions/solution-p2469">Luogu P2469</a> [SDOI2010] 星际竞速</li>
<li><a href="/solutions/solution-p2698">Luogu P2698</a> [USACO12MAR] Flowerpot</li>
<li><a href="/solutions/solution-p2824">Luogu P2824</a> [HEOI2016&#x2F;TJOI2016] 排序</li>
<li><a href="/solutions/solution-p2860">Luogu P2860</a> [USACO06JAN] Redundant Paths G</li>
<li><a href="/solutions/solution-p2906">Luogu P2906</a> [USACO08OPEN] Cow Neighborhoods G</li>
<li><a href="/solutions/solution-p3047">Luogu P3047</a> [USACO12FEB] Nearby Cows G</li>
<li><a href="/solutions/solution-p3050">Luogu P3050</a> [USACO12MAR] Large Banner</li>
<li><a href="/solutions/solution-p3174">Luogu P3174</a> [HAOI2009] 毛毛虫</li>
<li><a href="/solutions/solution-p3188">Luogu P3188</a> [HNOI2007] 梦幻岛宝珠</li>
<li><a href="/solutions/solution-p3243">Luogu P3243</a> [HNOI2015] 菜肴制作</li>
<li><a href="/solutions/solution-p3462">Luogu P3462</a> [POI2007] 砝码 ODW</li>
<li><a href="/solutions/solution-p3574">Luogu P3574</a> [POI2014] FAR-FarmCraft</li>
<li><a href="/solutions/solution-p3586">Luogu P3586</a> [POI2015] Logistyka</li>
<li><a href="/solutions/solution-p3589">Luogu P3589</a> [POI2015] Kurs szybkiego czytania</li>
<li><a href="/solutions/solution-p3644">Luogu P3644</a> [APIO2015] 巴邻旁之桥</li>
<li><a href="/solutions/solution-p3645">Luogu P3645</a> [APIO2015] 雅加达的摩天楼</li>
<li><a href="/solutions/solution-p3707">Luogu P3707</a> [SDOI2017] 相关分析</li>
<li><a href="/solutions/solution-p3773">Luogu P3773</a> [CTSC2017] 吉夫特</li>
<li><a href="/solutions/solution-p4135">Luogu P4135</a> 作诗</li>
<li><a href="/solutions/solution-p4336">Luogu P4336</a> [SHOI2016] 黑暗前的幻想乡</li>
<li><a href="/solutions/solution-p4568">Luogu P4568</a> [JLOI2011] 飞行路线</li>
<li><a href="/solutions/solution-p4588">Luogu P4588</a> [TJOI2018] 数学计算</li>
<li><a href="/solutions/solution-p4643">Luogu P4643</a> [国家集训队] 阿狸和桃子的游戏</li>
<li><a href="/solutions/solution-p4654">Luogu P4654</a> [CEOI2017] Mousetrap</li>
<li><a href="/solutions/solution-p5024">Luogu P5024</a> [NOIP2018 提高组] 保卫王国</li>
<li><a href="/solutions/solution-p5290">Luogu P5290</a> [十二省联考 2019] 春节十二响</li>
<li><a href="/solutions/solution-p5752">Luogu P5752</a> [NOI1999] 棋盘分割</li>
<li><a href="/solutions/solution-p5994">Luogu P5994</a> [PA2014] Kuglarz</li>
<li><a href="/solutions/solution-p7619">Luogu P7619</a> [COCI2011-2012#2] RASPORED</li>
<li><a href="/solutions/solution-p8021">Luogu P8021</a> [ONTAK2015] Bajtman i Okrągły Robin</li>
<li><a href="/solutions/solution-p8025">Luogu P8025</a> [ONTAK2015] Związek Harcerstwa Bajtockiego</li>
<li><a href="/solutions/solution-p8161">Luogu P8161</a> [JOI 2022 Final] 自学（自習）</li>
<li><a href="/solutions/solution-p8162">Luogu P8162</a> [JOI 2022 Final] 选举</li>
<li><a href="/solutions/solution-p8251">Luogu P8251</a> [NOI Online 2022 提高组] 丹钓战</li>
<li><a href="/solutions/solution-p8255">Luogu P8255</a> [NOI Online 2022 入门组] 数学游戏</li>
<li><a href="/solutions/solution-p8365">Luogu P8365</a> [LNOI2022] 吃</li>
<li><a href="/solutions/solution-cf456e">Luogu CF456E</a> Cardboard Box</li>
<li><a href="/solutions/solution-cf1041c">Luogu CF1041C</a> Coffee Break</li>
<li><a href="/solutions/solution-cf1288f">Luogu CF1288F</a> Red-Blue Graph</li>
</ul>
<ul>
<li><a href="/solutions/solution-l2759">LibreOJ #2759</a> 蜜袋鼯（フクロモモンガ）</li>
<li><a href="/solutions/solution-l2980">LibreOJ #2980</a> 「THUSCH 2017」 大魔法师</li>
<li><a href="/solutions/solution-l3277">LibreOJ #3277</a> 「JOISC 2020 Day3」 星座 3</li>
</ul>
<ul>
<li><a href="/solutions/solution-se636">S2OJ #636</a> 购物</li>
<li><a href="/solutions/solution-se993">S2OJ #993</a> Merge</li>
<li><a href="/solutions/solution-se1497">S2OJ #1497</a> 树</li>
<li><a href="/solutions/solution-se1498">S2OJ #1498</a> 换乘</li>
<li><a href="/solutions/solution-se1506">S2OJ #1506</a> Antifloyd</li>
</ul>
<h2 id="比赛记录"><a href="#比赛记录" class="headerlink" title="比赛记录"></a>比赛记录</h2><p>校内OJ的模拟赛记录。</p>
<ul>
<li><a href="/contestrecords/2022-wh-8">2022寒假模拟赛8</a> $\color[rgb]{0,0.5,1}{\sharp}$</li>
</ul>
<h1 id="其他学习笔记"><a href="#其他学习笔记" class="headerlink" title="其他学习笔记"></a>其他学习笔记</h1><p>其他东西的学习笔记。</p>
<ul>
<li><p><a href="/notes/game-strategy">博弈论学习笔记</a> <strong>止まれ</strong><br>如题，博弈论学习笔记。<br>咕了。</p>
</li>
<li><p><a href="/notes/linar-algebra">线性代数</a> <strong>止まれ</strong><br>包含行列式和矩阵的运算。<br>同样咕了。</p>
</li>
</ul>
<hr>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMTJrNHkxMTczaQ==">展开</span><br>再见。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>感谢</title>
    <url>/thanks/</url>
    <content><![CDATA[<div id="problem-card-vis">false</div>

<p>感谢 <strong>CloudySky</strong> 和 <strong>宝硕</strong> 的大力支持。</p>
<p>没有他们就没有这个博客。</p>
<p>十分感谢。</p>
<p><img src="https://img.shields.io/github/repo-size/kaiserwilheim/kaiserwilheim.github.io?style=for-the-badge" alt="GitHub repo size"></p>
<!--
祭 陈靖元的爱情
2022.3-2022.6.29
-->
]]></content>
  </entry>
  <entry>
    <title>2-SAT 问题</title>
    <url>/OI/2-sat/</url>
    <content><![CDATA[<p>一种奇怪的问题。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<p>2-SAT问题的名字可以拆成两部分：2和SAT。</p>
<h1 id="SAT？"><a href="#SAT？" class="headerlink" title="SAT？"></a>SAT？</h1><p>SAT是Satisfiability【可满足性】的简称。</p>
<p>解释一下，就是，我们有若干个需要赋值的布尔变量，要求对这些变量进行赋值，使得这些变量的值满足一组布尔方程。</p>
<p>举个例子：</p>
<p>宝硕需要讲解一个题目，他需要就着代码讲题，所以代码需要让每一个人看懂，并尽量满足每一个人的代码习惯。<br>听的人有三个：KaiserWilheim、Johnsonloy、JeffZhao。现在他们提出了一些要求，如下：</p>
<ul>
<li><strong>KaiserWilheim</strong>要求代码满足下列条件之一：<ul>
<li>使用bits库 ($a$)</li>
<li>不使用<code>#define int long long</code> ($\neg b$) </li>
<li>大括号换行 ($c$)</li>
</ul>
</li>
<li><strong>Johnsonloy</strong>要求代码满足下列条件之一：<ul>
<li>使用bits库 ($a$)</li>
<li>使用<code>#define int long long</code> ($b$) </li>
<li>大括号换行 ($c$)</li>
</ul>
</li>
<li><strong>JeffZhao</strong>要求代码满足下列条件之一：<ul>
<li>不使用bits库 ($\neg a$)</li>
<li>不使用<code>#define int long long</code> ($\neg b$) </li>
<li>大括号不换行 ($\neg c$)</li>
</ul>
</li>
</ul>
<p>我们可以将三种条件分别设为 $a$，$b$，$c$，变量前加 $\neg$ 表示对当前要求表示否定。<br>那么上述要求可以变为 $(a \lor \neg b \lor c)\land(a \lor b \lor c)\land(\neg a \lor \neg b \lor \neg c)$。其中 $\lor$ 表示或，$\land$ 表示与。<br>现在我们需要为 $abc$ 三个变量赋值，满足三个人的要求。</p>
<p>怎么处理呢？</p>
<p><strong>暴力</strong>。</p>
<p>因为SAT问题已经被证明为了<strong>NPC（NP完全）</strong>问题，只能暴力做。</p>
<h1 id="2-SAT？"><a href="#2-SAT？" class="headerlink" title="2-SAT？"></a>2-SAT？</h1><p>那么2-SAT又是一种什么东西？<br>为什么我们需要把2-SAT单独拎出来？</p>
<p>2-SAT，就是每一个同学只有两个条件。<br>上面的问题就可以叫做3-SAT。<br>假如说Wilheim和Johnson一致决定将Jeff放在火刑架上使得Jeff放弃了大括号不换行，那么我们的问题就剩下了两个，要求就变为了 $(a \lor \neg b)\land(a \lor b)\land(\neg a \lor \neg b)$。</p>
<p>然后，宝硕就决定按照使用bits库和不使用<code>#define int long long</code>来作为讲题用的代码风格。</p>
<h1 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h1><p>我们怎么求解2-SAT问题呢？</p>
<p>使用强连通分量。</p>
<p>我们将每一个变量拆成两个点，记为 $x$ 与 $\neg x$。</p>
<p>对于每一个同学的要求 $(a \lor b)$，我们尝试将其转化为 $\neg a \to b \land \neg b \to a$。<br>因为我们需要使 $a$ 和 $b$ 中间至少有一个是真，那么我们一旦 $a$ 为假那么 $b$ 就一定为真，反之同理。</p>
<p>那么我们这样建图：</p>
<table>
<thead>
<tr>
<th align="center">式子</th>
<th align="center">建图</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$a \lor b$</td>
<td align="center">$\neg a \to b \land \neg b \to a$</td>
</tr>
<tr>
<td align="center">$\neg a \lor b$</td>
<td align="center">$a \to b \land \neg b \to \neg a$</td>
</tr>
<tr>
<td align="center">$a \lor \neg b$</td>
<td align="center">$\neg a \to \neg b \land b \to a$</td>
</tr>
<tr>
<td align="center">$\neg a \lor \neg b$</td>
<td align="center">$a \to \neg b \land b \to \neg a$</td>
</tr>
</tbody></table>
<p>上面的图就变成了这个样子：</p>
<p><img src="https://s2.loli.net/2022/06/28/ocKCIGR5FxYapAO.png" alt="2sat1.png"></p>
<p>我们可以发现，$a$ 和 $\neg b$ 在同一强连通分量内，同时 $\neg a$ 和 $b$ 也在同一强连通分量内。</p>
<p>在同一强连通分量内就代表着知道了一个数的值之后就可以推出其他所有变量的值，所以我们给同一个强连通分量内的变量取值是相同的。</p>
<p>那么我们就给 $a$ 和 $\neg b$ 都取真，那么就意味着 $a&#x3D;1,b&#x3D;0$。<br>当然我们也可以给 $\neg a$ 和 $b$ 取真，也是一个可行解。</p>
<p>习惯上，我们给缩点后的图排一个拓扑序，当 $x$ 所在强连通分量的拓扑序在 $\neg x$ 所在的强连通分量的拓扑序之后的话我们就给 $x$ 取真。</p>
<p>那么我们什么时候才没有可行解呢？</p>
<p>当且仅当 $x$ 与 $\neg x$ 在同一个强连通分量里面的时候。<br>这样 $x$ 需要同时取真和假两个值，整个方程组就无解了。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>用tarjan来求强联通分量就可以了。</p>
<p>tarjan同时还给缩点后的图排了一下序，就不需要我们再排拓扑序了。</p>
<p>洛谷例题：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQ3ODI=">https://www.luogu.com.cn/problem/P4782</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2000010</span>, M = <span class="number">4000010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], cnt;</span><br><span class="line"><span class="type">int</span> sta[N], tt;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> scc[N], sc, sz[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    low[p] = dfn[p] = ++cnt;</span><br><span class="line">    sta[++tt] = p, vis[p] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            low[p] = <span class="built_in">min</span>(low[p], low[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vis[j])</span><br><span class="line">        &#123;</span><br><span class="line">            low[p] = <span class="built_in">min</span>(low[p], dfn[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[p] == low[p])</span><br><span class="line">    &#123;</span><br><span class="line">        ++sc;</span><br><span class="line">        <span class="keyword">while</span>(sta[tt] != p)</span><br><span class="line">        &#123;</span><br><span class="line">            scc[sta[tt]] = sc;</span><br><span class="line">            sz[sc]++;</span><br><span class="line">            vis[sta[tt]] = <span class="literal">false</span>;</span><br><span class="line">            tt--;</span><br><span class="line">        &#125;</span><br><span class="line">        scc[sta[tt]] = sc;</span><br><span class="line">        sz[sc]++;</span><br><span class="line">        vis[sta[tt]] = <span class="literal">false</span>;</span><br><span class="line">        tt--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x, &amp;a, &amp;y, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(x + !a * n, y + b * n);</span><br><span class="line">        <span class="built_in">add</span>(y + !b * n, x + a * n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])<span class="built_in">tarjan</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(scc[i] == scc[i + n])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;IMPOSSIBLE&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;POSSIBLE&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(scc[i] &lt; scc[i + n])<span class="built_in">printf</span>(<span class="string">&quot;0 &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;1 &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图</title>
    <url>/OI/bipartite-graph/</url>
    <content><![CDATA[<p>二分图相关内容。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="什么是二分图"><a href="#什么是二分图" class="headerlink" title="什么是二分图"></a>什么是二分图</h1><p>二分图是一种特殊的图。</p>
<p>二分图的一个性质是，节点由两个集合组成，且两个集合的内部没有任何一条边。</p>
<p>换而言之，就是我们可以将二分图的两个集合中的所有节点分别染成两种不同的颜色（比如红色与蓝色），可以发现任意一条边都连接着两个不同颜色的点。</p>
<p>我们一般将二分图的两个集合分别放在我们的左边和右边，而边都是横向的。<del>（其实你分别叫这两个集合<font color="#ff0000">华约</font>和<font color="0000ff">北约</font>也没人抗议）</del></p>
<h2 id="我们如何判断一个图是二分图？"><a href="#我们如何判断一个图是二分图？" class="headerlink" title="我们如何判断一个图是二分图？"></a>我们如何判断一个图是二分图？</h2><p>根据二分图的定义，我们可以推断出来一个重要的定理：</p>
<p><strong>二分图没有奇数环。</strong></p>
<p>因为一个二分图的所有边都是横跨两个集合的，每次需要横跨偶数次才能回到起点所在的集合，故二分图没有奇数环。</p>
<p>我们可以利用这个性质对给定的图进行搜索，如果找到了奇数环，那么这个图就一定不是二分图，反之亦然。</p>
<hr>
<p>已知所有二分图相关的问题应该都可以通过转化成为网络流问题来求解，所以在这里我就不对传统的二分图相关算法进行讲解，如匈牙利算法。</p>
<p>二分图有关的问题见下面：</p>
<h1 id="二分图最大匹配"><a href="#二分图最大匹配" class="headerlink" title="二分图最大匹配"></a>二分图最大匹配</h1><h2 id="啥sha是最大匹配？"><a href="#啥sha是最大匹配？" class="headerlink" title="啥shà是最大匹配？"></a><ruby>啥<rt>shà</rt></ruby>是最大匹配？</h2><p>“任意两条边都没有公共端点”的边的集合被称为图的一组匹配。<br>在二分图中，包含变数最多的一组匹配被称为二分图的<strong>最大匹配</strong>。</p>
<p>对于任意一组匹配 $E$ ，属于 $E$ 的边被称为<strong>匹配边</strong>，不属于 $E$ 的边被称为<strong>非匹配边</strong>。匹配边的端点被称为<strong>匹配点</strong>，其他店被称为<strong>非匹配点</strong>。</p>
<h2 id="增广路"><a href="#增广路" class="headerlink" title="增广路"></a>增广路</h2><p>如果在二分图中存在一条连接两个非匹配点的路径 $path$，使得非匹配边与匹配边在 $path$ 上交替出现，那么我们称 $path$ 是 匹配 $E$ 的一条<strong>增广路</strong>，也称交错路。</p>
<p>增广路具有以下性质：</p>
<ol>
<li>长度为奇数。</li>
<li>路径上第奇数条边是非匹配边，第偶数条边是匹配边。</li>
</ol>
<p>利用以上性质，我们尝试将路径上所有边的状态取反，也就是原来的匹配边变成了非匹配边，原来的非匹配边变成了匹配边。<br>经过了这样的一个操作，我们新得到的边集 $E’$ 仍然是一组匹配，且匹配边的数量增加了1。</p>
<p>利用这样的一个操作，我们可以得到一个推论：</p>
<p><strong>二分图的一组匹配 $E$ 是最大匹配，当且仅当图中不存在 $E$ 的增广路。</strong></p>
<p><em>注意</em>：这里的增广路与网络流中的增广路概念不同。</p>
<h2 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h2><p>我们可以使用匈牙利算法，一种利用增广路来求解的算法。其时间复杂度为 $O(nm)$ 。</p>
<p>但是，我们可以使用Dinic来求解。Dinic比匈牙利算法要快（时间复杂度为 $O(m\sqrt{n})$），而且适用范围较匈牙利算法更广。</p>
<p>对于这样的一个问题，我们只需要将所有左边的点<del><font color="$ff0000">华约成员国</font></del>与源点<del><font color="#ff0000">苏联</font></del>连一条容量为1的边，再将所有右边的点<del><font color="#0000ff">北约成员国</font></del>与汇点<del><font color="#0000ff">美国</font></del>连一条容量为1的边。最后，把所有的原图中的边变为一条容量为1的边。</p>
<p>这张图的最大流就是原图的最大匹配数。</p>
<p>以<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzODY=">Luogu P3386 【模板】二分图最大匹配</span>为例。<br>示例代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3386/p3386.cpp"><code>Luogu P3386</code></a></p>
<h2 id="与二分图最大匹配相关的概念"><a href="#与二分图最大匹配相关的概念" class="headerlink" title="与二分图最大匹配相关的概念"></a>与二分图最大匹配相关的概念</h2><h3 id="二分图最大独立集"><a href="#二分图最大独立集" class="headerlink" title="二分图最大独立集"></a>二分图最大独立集</h3><p>从图中选择最多的点，满足两两之间没有边相连。</p>
<p>在二分图中，这个就是去掉最大匹配后的剩余部分。</p>
<h3 id="二分图最小点覆盖"><a href="#二分图最小点覆盖" class="headerlink" title="二分图最小点覆盖"></a>二分图最小点覆盖</h3><p>从图中选择最少的点，满足每条边至少有一个端点被选上。</p>
<p>我们不难发现，点覆盖的补集其实是独立集。</p>
<p>在二分图中，最小点覆盖就是去掉最大独立集后的剩余部分，与最大匹配重合。</p>
<h1 id="二分图最大权匹配"><a href="#二分图最大权匹配" class="headerlink" title="二分图最大权匹配"></a>二分图最大权匹配</h1><p>如果我们给二分图上的边加上边权的话，我们就可以求边权和最大的匹配了。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们可以将其转换为费用流模型，将其按照最大匹配的建图方式建图，并给其中跨集合的边加上一个费用，求这个图的最大费用最大流。</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>差分约束</title>
    <url>/OI/difference-constraint/</url>
    <content><![CDATA[<p>差分约束系统。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<p>2022-03-30发布，<br>2022-06-03再修。</p>
<p>我们经常会遇到一些问题，就是给出一堆未知量，再给出一堆类似“某一个未知量比另一个未知量最多（最少）大（小）多少”的问题，让我们从这一团繁杂的毛钱中拎出一根线头来，以求得这个毛线团的一组可行解。</p>
<p>比如说下面这个东西：</p>
<p>$$<br>\begin{cases}<br>x_1 \geq x_2 - 10 \\<br>x_1 \leq x_3 - 20 \\<br>x_3 \leq x_2 + 10 \\<br>x_4 \leq x_3 - 10 \\<br>x_2 \leq x_4 - 10<br>\end{cases}<br>$$</p>
<p>我们就基本上无从下手。</p>
<p>这时候，我们就需要引入一个新的算法——<strong>差分约束</strong>。</p>
<p>差分约束通过将不等式的问题转化为最短路（或最长路）问题来求解。</p>
<h1 id="最短路？为什么？"><a href="#最短路？为什么？" class="headerlink" title="最短路？为什么？"></a>最短路？为什么？</h1><p>回忆我们学习最短路的时候学到的知识。</p>
<p>假设对于两个点 $a$ 和 $b$，如果其间有一条边长为 $w$ 的有向边 $a \to b$，那么它们的 $dis$ 一定满足 $dis[b] \leq dis[a] + w$。</p>
<p>我们如果将每一个未知量 $x_k$ 与每一个点的 $dis[i]$ 联系起来的话，那么我们就可以得到形如 $x_b \leq x_a + w$ 的一堆不等式。</p>
<p>而我们刚好需要这些不等式。</p>
<p>于是我们就可以将我们手中的不等式组转化为一堆边，并将其放到图里面，建成一个有向图。</p>
<p>最后得出的每一组合法的最短距离，都对应了一组不等式组的解。</p>
<p>我们首先把所有的式子转化为 $x_u \leq x_v + w$ 的形式，再从每一个 $v$ 向 $u$ 建一条边权为 $w$ 的有向边。</p>
<p>这个有向图可以有环，毕竟环是不影响我们的求值环节的。<br>但是它不能有负环。</p>
<p>比如说下面这一组边：</p>
<p>$$<br>\begin{cases}<br>x_2 \leq x_1 + 10 \\<br>x_3 \leq x_2 + 10 \\<br>x_1 \leq x_3 - 30<br>\end{cases}<br>$$</p>
<p>建到图上就是这个样子：</p>
<p><img src="https://s2.loli.net/2022/03/30/d9ltROoBAY178Uy.png" alt="diffcon1.png"></p>
<p>根据原始的不等式组，最终我们会得到 $x_1 \leq x_1 - 10$ 这样一个奇怪的式子，从而导致不等式组无解。</p>
<p>从图上看，这三条边构成了一个负环。</p>
<p>所以说，一个负环最终会导致出现一些奇怪的不等式，最终导致不等式组无解。<br>（当然，如果使用的是最长路的话就是正环）</p>
<p>那我们怎么判负环？（或者说正环）</p>
<p>SPFA！<br>（SPFA信徒狂喜）</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>但是我们光靠这些边实际上是不能得出最终解的。<br>很多情况下，这张图根本不联通。<br>但是这样的图还是可以找到至少一组可行解的。</p>
<p>所以我们还需要建一个超级源点，向每一个点连一条长度为0的边。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>具体情况下，我们不仅有类似 $x_a \leq x_b + w$ 这样的式子，还有其他的一些奇奇怪怪的约束条件。</p>
<p>下面列出了一些常见的约束条件和解决办法：</p>
<table>
<thead>
<tr>
<th>约束条件</th>
<th>解决办法</th>
</tr>
</thead>
<tbody><tr>
<td>$x_a \leq w$</td>
<td>将源点到 $a$ 的边权从0改到 $w$。</td>
</tr>
<tr>
<td>$x_a \geq w$</td>
<td>从 $a$ 向源点连一条长为 $-w$ 的边。</td>
</tr>
<tr>
<td>$x_a &#x3D; x_b + w$</td>
<td>将其拆分为 $x_a \leq x_b + w$ 和 $x_b \leq x_a + (-w)$。</td>
</tr>
<tr>
<td>$x_a + x_b \leq w$</td>
<td>差分约束会寄。请注意一下题目中有没有可以利用的其他特殊性质。</td>
</tr>
</tbody></table>
<p>如果在一个不等式组的约束下（不等式组有解），想求出 $x_i − x_j$ 的最大值呢？<br>首先一定有 $x_i − x_j \leq j$ 到 $i$ 的”最短” 路 $\operatorname{dis}(j,i)$ 。因为我可以先走到 $j$ ，然后走“$j$ 到 $i$ 的”最短路””到 $i$ 。<br>然后我们证明 $x_i − x_j$ 可以取到这个值。<br>这相当于往不等式组中添加一个 $x_i − x_j \geq \operatorname{dis}(j,i)$ ，如果不等式组仍有解，$x_i − x_j$ 就能取到 $\operatorname{dis}(j,i)$ 。<br>这也相当于在图中添加一条边，从 $i$ 到 $j$ ，边权是 $−\operatorname{dis}(j,i)$ 。这样加边一定不会出现负环，因为 $\operatorname{dis}(j,i)$ 是 $j$ 到 $i$ 的最短路，要有负环的话就有别的路径长度 $&lt; \operatorname{dis}(j,i)$ 了。<br>如果要求 $x_i − x_j$ 的最小值，就是求 $x_j − x_i$ 的最大值的相反数，即 $−\operatorname{dis}(i,j)$。<br>“$x_i − x_j$ 的最小值”$\leq$“$x_i − x_j$ 的最大值”，对应了 $−\operatorname{dis}(i,j) \leq \operatorname{dis}(j,i)$ ，也就是 $\operatorname{dis}(i,j) + \operatorname{dis}(j,i) \geq 0$ ，也就对应了图中没有包含 $i,j$ 的负环。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>洛谷<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDU5NjA=">板子题</span></p>
<p>参考代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p5000-p5999/p5960/p5960.cpp"><code>Luogu P5960</code></a></p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>其实差分约束最难的地方不是跑最短路求解的过程，而是如何去建这个图。</p>
<p>这样子的话其实是与网络流有些类似的情况的，有时候我们没有很好的办法来把我们题目中给出的信息来转化成为我们的建图方式。</p>
<p>下面首先会放上两道比较简单的、朴素的题目，没有什么太难理解的地方；然后就会放一些转化题意的例子。</p>
<h2 id="Luogu-P1993-小-K-的农场"><a href="#Luogu-P1993-小-K-的农场" class="headerlink" title="Luogu P1993 小 K 的农场"></a>Luogu P1993 小 K 的农场</h2><p>题目链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDE5OTM=">Luogu</span></p>
<p>接近板子题。</p>
<p>我们可以使用我们刚刚学到的技巧来完成这道题目。</p>
<p>参考代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p1000-p1999/p1993/p1993.cpp"><code>Luogu P1993</code></a></p>
<h2 id="Luogu-P3275-SCOI2011-糖果"><a href="#Luogu-P3275-SCOI2011-糖果" class="headerlink" title="Luogu P3275 [SCOI2011] 糖果"></a>Luogu P3275 [SCOI2011] 糖果</h2><p>题目链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMyNzU=">Luogu</span> || <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE3MS8=">AcWing</span> || <span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yNDM2">LibreOJ</span></p>
<p>我们遇到了新的约束条件：不带取等的不等式。</p>
<p>我们看一下题目的条件：<strong>分糖果</strong>。</p>
<p>由于糖果是一块一块的，我们不能分给小朋友们 $m&#x3D;\dfrac{1}{2}$ 块糖果或 $\lim\limits_{m \to 0} m$ 块糖果，所以我们可以尝试着更改一下约束条件。<br>我们可以将 $x_a &gt; x_b$ 改为 $x_a \geq x_b + 1$。</p>
<p>这样就可以建图了。</p>
<p>（20220714更新）</p>
<p>现在洛谷上面加入了一点Hack数据，会卡掉较慢的SPFA算法，而原题中SPFA是可以过的。（但是数据范围给的是 $10^5$）<br>这道题的本意应该是让我们利用tarjan算法及进行缩点之后再跑差分约束。</p>
<p>我们看看怎么缩点。</p>
<p>我们尝试将所有的环缩成一个点，而这个环内的所有点的值都会相等。<br>那么我们可以确定，环上只含有1、3、5三种类型的边。</p>
<p>（因为你看：我们建出来的图是一个有向图，如果其中边权为 $0$ 的边中形成了环就代表他们权值肯定相等。假如说 $a$，$b$，$c$ 三个点形成了环，那么我们就有如下的方程：</p>
<p>$$<br>\begin{cases}<br>x_b \leq x_a \\<br>x_c \leq x_b \\<br>x_a \leq x_c<br>\end{cases}<br>$$</p>
<p>我们就可以得到三者相等了。）</p>
<p>所以我们先把类型为1、3、5的边建出来跑一个tarjan，然后再建出来剩下的边跑差分约束即可。</p>
<p>参考代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3275/p3275.cpp"><code>Luogu P3275</code></a></p>
<h2 id="AcWing-362-区间"><a href="#AcWing-362-区间" class="headerlink" title="AcWing 362. 区间"></a>AcWing 362. 区间</h2><p>题目链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzY0Lw==">AcWing</span> || <span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8xMDA4Nw==">LibreOJ</span></p>
<p>这一次题目没有直接给出类似于“A大于等于B+C”这样的条件，我们需要自己推出不等式组。</p>
<p>首先我们需要了解我们维护的是一个不可重的集合，那么集合内的每一个数最多只能出现一次。</p>
<p>然后我们需要满足的条件是区间内的数字的个数不小于 $c_i$ 个。</p>
<p>然后我们会发现，我们可以将上述两个条件转化为前缀和数组中的不等关系。</p>
<p>因为我们每一个数只能出现0次或1次，所以我们前缀和数组是严格非降的，且相邻两项之间最多差1。<br>我们如果称前缀和数组为 $s$ 的话，那么上述条件可以转化为 $s_{i-1} \leq s_i$ 和 $s_i \leq s_{i-1} + 1$ 两个不等式。</p>
<p>对于第二个条件，也可以转化成为前缀和数组上的不等关系。<br>如果我们有一个条件是“$[ a,b ]$ 这段区间内的数字不少于 $c$ 个”的话，我们可以将其转化为类似 $s_b \geq s_{a-1} + c$ 这样的不等式。</p>
<p>然后我们就可以愉快地跑SPFA了，最后需要输出的是前缀和数组的最后一位——$s_{50001}$。</p>
<p>参考代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/AcWing/362/ac362.cpp"><code>AcWing 362</code></a></p>
<h2 id="Luogu-P4878-USACO05DEC-Layout-G"><a href="#Luogu-P4878-USACO05DEC-Layout-G" class="headerlink" title="Luogu P4878 [USACO05DEC] Layout G"></a>Luogu P4878 [USACO05DEC] Layout G</h2><p>题目链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQ4Nzg=">Luogu</span> || <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTE3Mi8=">AcWing</span> || <span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8xMDA5MA==">LibreOJ</span></p>
<p>题目保证了奶牛的编号与其在序列中的位置是相对应的，同时两个奶牛之间的距离可以是0，也就是说我们每一个奶牛的坐标一定大于等于其上一只的坐标。</p>
<p>然后还有两种其他的条件，一是两头奶牛之间的距离不大于某个数，二是两头奶牛之间的距离不小于某个数。假设我们这两头奶牛分别是a和b，这个给定的数是c，那么我们对于上面两个条件分别可以得出 $x_b \leq x_a + c$ 和 $x_b \geq x_a + c$ 这两个不等式。</p>
<p>然后就建图跑就可以了。</p>
<p>参考代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p4000-p4999/p4878/p4878.cpp"><code>Luogu P4878</code></a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速求popcount和</title>
    <url>/OI/fast-popcnt-sum/</url>
    <content><![CDATA[<p>一种以 $O(\log n)$ 的时间复杂度快速求 $\sum\limits_{i&#x3D;1}^n \operatorname{popcount}(i)$ 的方法。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h1><p>摆结论：</p>
<p>$$<br>\sum_{i&#x3D;1}^n \operatorname{popcount}(i) &#x3D; \sum_{i&#x3D;1}^{\lceil \log_2(n) \rceil - 1} [(n&gt;&gt;(i-1)) \&amp; 1&#x3D;&#x3D;1] \times (i \times 2^{i-1} + 2^i \times \operatorname{popcount}(n&gt;&gt;i))<br>$$</p>
<p>其中 $[(n&gt;&gt;(i-1)) \&amp; 1&#x3D;&#x3D;1]$ 代表 $n$ 的第 $i$ 位是否为零。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>首先，我们可以想到一种 $O(1)$ 的求 $\sum\limits_{i&#x3D;0}^{2^k-1} \operatorname{popcount}(i)$ 的方法。</p>
<p>这里以 $[0,2^5-1]$ 为例。</p>
<p>我们首先将所有数字列出来：</p>
<p><img src="https://s2.loli.net/2022/06/13/dKYtT86FQsXDpmO.png" alt="fastpopcnt1.png"></p>
<p>然后逐二进制位来看。</p>
<p>最低位的规律是01010101…：</p>
<p><img src="https://s2.loli.net/2022/06/13/vc4nVkg5jTDflNQ.png" alt="fastpopcnt2.png"></p>
<p>第二位的规律是00110011…：</p>
<p><img src="https://s2.loli.net/2022/06/13/ADK2TXtixpzWIUf.png" alt="fastpopcnt3.png"></p>
<p>第三位的规律是00001111…：</p>
<p><img src="https://s2.loli.net/2022/06/13/8ACtzm36Gnfhkde.png" alt="fastpopcnt4.png"></p>
<p>之后的规律也显然：</p>
<p><img src="https://s2.loli.net/2022/06/13/gW4j5p2yVKxAhbk.png" alt="fastpopcnt5.png"><br><img src="https://s2.loli.net/2022/06/13/lFOnc31pAR8aTeG.png" alt="fastpopcnt6.png"></p>
<p>我们可以得到，每一位中都有一半是0，另一半是1。</p>
<p>于是我们就可以得出公式：</p>
<p>$$<br>\sum\limits_{i&#x3D;0}^{2^k-1} \operatorname{popcount}(i) &#x3D; k \times 2^{k-1}<br>$$</p>
<p>然后我们将给定的 $n$ 按照二进制位拆分。</p>
<p>这里以 $(11010110)_2 &#x3D; (214)_{10}$ 为例。 </p>
<p>（下面指的第几位都是从高向低数的）</p>
<p>其第一位是 $1$，所以我们可以向结果累加 $(00000000)_2 \sim (01111111)_2$ 的popcount和，也就是 $0 \times 2^7 + 7 \times 2^6$。</p>
<p>其第二位是 $1$，所以我们可以向结果累加 $(10000000)_2 \sim (10111111)_2$ 的popcount和，也就是 $1 \times 2^6 + 6 \times 2^5$。</p>
<p>其第三位是 $0$，对结果没有贡献。</p>
<p>其第四位是 $1$，所以我们可以向结果累加 $(11000000)_2 \sim (11001111)_2$ 的popcount和，也就是 $2 \times 2^4 + 4 \times 2^3$。</p>
<p>其第五位是 $0$，对结果没有贡献。</p>
<p>其第六位是 $1$，所以我们可以向结果累加 $(11010000)_2 \sim (11010011)_2$ 的popcount和，也就是 $3 \times 2^2 + 2 \times 2^1$。</p>
<p>其第七位是 $1$，所以我们可以向结果累加 $(11010100)_2 \sim (11010101)_2$ 的popcount和，也就是 $4 \times 2^1 + 1 \times 2^0$。</p>
<p>其第八位是 $0$，对结果没有贡献。<br>但其实不管有没有贡献我们都不算他了，因为我们只需要将 $[0,n)$ 这个区间分段即可。</p>
<p>最后再加上 $\operatorname{popcount}((11010110)_2) &#x3D; 5$。</p>
<p>最终结果就是</p>
<p>$$<br>\begin{align}<br>&amp; 0 \times 2^7 + 7 \times 2^6 + 1 \times 2^6 + 6 \times 2^5 + 2 \times 2^4 + 4 \times 2^3 + 3 \times 2^2 + 2 \times 2^1 \\ \notag<br>&amp; + 4 \times 2^1 + 1 \times 2^0 + \operatorname{popcount}((11010110)_2) \\<br>&#x3D;{} &amp; 448 + 256 + 64 + 16 + 9 + 5 \\<br>&#x3D;{} &amp; 798<br>\end{align}<br>$$</p>
<p>因为 $\operatorname{popcount}(0) &#x3D; 0$，所以统计上 $0$ 与不统计上其实没有本质上的区别。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> x = n;</span><br><span class="line"><span class="keyword">while</span>(x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &amp; <span class="number">1</span>)</span><br><span class="line">        tot += (cnt * (<span class="number">1</span> &lt;&lt; (cnt - <span class="number">1</span>))) + (<span class="number">1</span> &lt;&lt; cnt) * __builtin_popcount(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line">tot += __builtin_popcount(n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, tot);</span><br></pre></td></tr></table></figure>












]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>树链剖分</title>
    <url>/OI/heavy-path-decomposition/</url>
    <content><![CDATA[<p>树链剖分。<br>Luogu P3384</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>树链剖分（简称“树剖”，又称“重链剖分”）是一种将一棵树转化为一段连续的区间的方法。<br>这种方法可以将一棵树根据子树大小，也就是所谓的“重儿子”和“轻儿子”，来将一棵树划分成若干条”重链“，并可以保证，在任意一条路径上的连续的链都不超过 $\log_2{n}$ 个。</p>
<p>树剖可以借助一些数据结构（如线段树）来以 $O(\log n)$ 的复杂度维护数上路径的信息，如“修改<strong>树上两点之间的路径上</strong>所有点的值”和“查询<strong>树上两点之间的路径上</strong>节点权值的<strong>和&#x2F;极值&#x2F;其他</strong>(在序列上可以用数据结构维护的、便于合并的信息)”等等。</p>
<p>当然，除了上面那样做，树剖还可以快速地求LCA。</p>
<p>树剖在洛谷上有一道模板题：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzODQ=">Luogu P3384</span><br>一道比较经典的例题：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDIxNDY=">Luogu P2146 [NOI2015] 软件包管理器</span></p>
<h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><p>树剖的思想是，将一棵树按照“重边”来划分称为若干条“重链”。<br>当然，这里的“重链”只是指的一种常用的情况，其他的划分方法比如“长链剖分”等等就不在此赘述了。</p>
<h2 id="重链"><a href="#重链" class="headerlink" title="重链"></a>重链</h2><p>“重链”的定义是若干条首尾衔接的“重边”。<br>那么，如果想要了解“重链”，就需要先了解<strong>重边</strong>。</p>
<h3 id="重边"><a href="#重边" class="headerlink" title="重边"></a>重边</h3><p>“重边”的划分标准是它连接向一个重儿子。<br>这里需要注意的是，它只需要结束于一个重儿子，而无其他限制。<br>那么“重儿子”呢？</p>
<h3 id="重儿子"><a href="#重儿子" class="headerlink" title="重儿子"></a>重儿子</h3><p>“重儿子”是“重子节点”的别称。<br>我们判断一个子节点是否为重子节点的标准是它的子树大小。</p>
<p>对于一个节点的所有儿子，其中子树最大的那个儿子称为“重儿子”，其余的，则相对地称之为“轻儿子”。<br>连接某个节点和其重儿子的边叫做“重边”，而连接其与其轻儿子的边则相应地叫做“轻边”。</p>
<h2 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h2><p>我们首先看一下例子：</p>
<p><img src="https://s2.loli.net/2021/12/29/iVkNYOTprWKF2Lz.png" alt="树剖1.png"></p>
<p>这是一棵树。<br>对于上面的这一棵树，我们可以进行如下的一些标记：<br>我们首先按照深度进行分层：</p>
<p><img src="https://s2.loli.net/2021/12/29/Jgwz7DUojWMBms1.png" alt="树剖2.png"></p>
<p>然后标出子树的大小：</p>
<p><img src="https://s2.loli.net/2021/12/29/4Xcb2qKiFyD6IdM.png" alt="树剖3.png"></p>
<p>然后标出轻儿子、重儿子、轻边和重边：</p>
<p><img src="https://s2.loli.net/2021/12/29/ACztKMokjJgmYx7.png" alt="树剖4.png"></p>
<p>然后标出重链：</p>
<p><img src="https://s2.loli.net/2021/12/29/4nWDzp72RSkBE1l.png" alt="树剖5.png"></p>
<p>最后标出DFS序：</p>
<p><img src="https://s2.loli.net/2021/12/29/bS7Y1wiOglACmkt.png" alt="树剖6.png"></p>
<p>这样就大功告成了。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>树剖的实现是通过两个DFS进行的。</p>
<p>我们这次使用邻接表来存储树的边信息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> w[N], h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个DFS记录了每个节点的父节点(vater)、深度(depth)、子树大小(sz)和重儿子(son)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> vater, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[p] = depth, fa[p] = vater, sz[p] = <span class="number">1</span>;<span class="comment">//初始化节点状态，记录其深度和父节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])<span class="comment">//遍历其所有儿子</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == vater) <span class="keyword">continue</span>;<span class="comment">//防止遍历其父亲</span></span><br><span class="line">        <span class="built_in">dfs1</span>(j, p, depth + <span class="number">1</span>);<span class="comment">//搜索当前儿子</span></span><br><span class="line">        sz[p] += sz[j];<span class="comment">//更新子树大小</span></span><br><span class="line">        <span class="keyword">if</span>(sz[son[p]] &lt; sz[j]) son[p] = j;<span class="comment">//判断是否为重儿子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个DFS记录了每个节点所在重链的链顶节点(top)、dfs序(id)和重新定向的节点权值(nw)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id[p] = ++cnt, nw[cnt] = w[p], top[p] = t;<span class="comment">//初始化节点信息，记录其DFS序</span></span><br><span class="line">    <span class="keyword">if</span>(!son[p]) <span class="keyword">return</span>;<span class="comment">//是否为叶节点</span></span><br><span class="line">    <span class="built_in">dfs2</span>(son[p], t);<span class="comment">//优先搜索在同一条重链上的重儿子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == fa[p] || j == son[p]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(j, j);<span class="comment">//搜索轻儿子，开一条新的重链，链顶为当前轻儿子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>树剖可以在 $O(n) \sim O(\log n)$ 的时间复杂度内求出两个点的LCA。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="板子题"><a href="#板子题" class="headerlink" title="板子题"></a>板子题</h2><p>洛谷上面提供了板子题。<br>题面见<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzODQ=">这里</span>。<br>代码正确性见<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3JlY29yZC82NTkwNzI2Mg==">提交记录</span>。</p>
<p>我们首先照常打出线段树部分（<del>不会的可以看<a href="">这篇博客</a></del>各位读者们一定已经会线段树了罢）；<br>两个DFS也是已经有了的代码（见上面）；<br>然后就有了这篇代码的核心部分。</p>
<p>之后就是对题目要求功能的实现。</p>
<p>题目要求我们这样做：</p>
<blockquote>
<ol>
<li>将树从 x 到 y 结点最短路径上所有节点的值都加上 z。</li>
<li>求树从 x 到 y 结点最短路径上所有节点的值之和。</li>
<li>将以 x 为根节点的子树内所有节点值都加上 z。</li>
<li>求以 x 为根节点的子树内所有节点值之和。</li>
</ol>
</blockquote>
<p>我们分类型进行实现。</p>
<p>对于那些对某一棵子树进行的操作，我们直接调用线段树来进行操作，因为对于任意一棵子树，它里面的所有节点的DFS序就是连续的，也就意味着可以被当成一段区间来进行操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addtree</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">segadd</span>(<span class="number">1</span>, id[p], id[p] + sz[p] - <span class="number">1</span>, k);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sumtree</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">segsum</span>(<span class="number">1</span>, id[p], id[p] + sz[p] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对于路径的操作，我们使用这样一种策略：边走边计算。<br>首先，我们求出这一条最短路，也就是求出它们的最近公共祖先。<br>我们使用这样的思路来寻找他们的LCA：</p>
<p>我们从较深的那一个节点开始不断向上跳重链，直到跳到与较浅的节点同一条重链上为止。此时，深度较浅的那一个就是他们的LCA。</p>
<p>于是我们就可以写出路径加、路径求和的代码了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addpath</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[p] != top[q])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[p]] &lt; dep[top[q]]) <span class="built_in">swap</span>(p, q);</span><br><span class="line">        <span class="built_in">segadd</span>(<span class="number">1</span>, id[top[p]], id[p], k);</span><br><span class="line">        p = fa[top[p]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[p] &lt; dep[q]) <span class="built_in">swap</span>(p, q);</span><br><span class="line">    <span class="built_in">segadd</span>(<span class="number">1</span>, id[q], id[p], k);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sumpath</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[p] != top[q])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[p]] &lt; dep[top[q]]) <span class="built_in">swap</span>(p, q);</span><br><span class="line">        res += <span class="built_in">segsum</span>(<span class="number">1</span>, id[top[p]], id[p]);</span><br><span class="line">        p = fa[top[p]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[p] &lt; dep[q]) <span class="built_in">swap</span>(p, q);</span><br><span class="line">    res += <span class="built_in">segsum</span>(<span class="number">1</span>, id[q], id[p]);</span><br><span class="line">    <span class="keyword">return</span> res % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后放一遍完整代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3384/p3384.cpp"><code>Luogu P3384</code></a></p>
<h2 id="NOI2015-软件包管理器"><a href="#NOI2015-软件包管理器" class="headerlink" title="[NOI2015] 软件包管理器"></a>[NOI2015] 软件包管理器</h2><p>也是一道树剖的经典题目。</p>
<p>我们仔细想一下就可以知道，<code>install</code>操作可以将从当前节点到根节点的所有未安装的软件全部安装，而<code>uninstall</code>会将其子树内的所有软件一并卸载。</p>
<p>然后就是区间推平了。</p>
<p>详细的解释可以看我的<a href="/solutions/solution-p2146/">题解</a>。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>K-D 树</title>
    <url>/OI/kd-tree/</url>
    <content><![CDATA[<p>一种高效处理 $k$ 维空间中的信息的数据结构。</p>
<span id="more"></span>
<p>K-D Tree 全称是叫 K-Dimentional Tree，是一棵二叉树。<br>一般我们用到K-D Tree的时候，这个 $k$ 是等于2的。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>我们就以 $k$ 等于2为例：</p>
<p>假设我们当前有一个二维<del>空间</del>平面，上面有一堆点；</p>
<img src="https://s2.loli.net/2022/06/22/XMeF9ofAaBg1PUQ.png" width="60%">

<p>然后我们需要对这个平面上的12个点建立一棵K-D树。</p>
<h2 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h2><p>建立的过程是这个样子的：</p>
<p>首先我们随便拿一维开始，就拿x这一维了。<br>然后我们找到这个维度中的中位数，在这个点上画一条直线，将平面分成两半：</p>
<img src="https://s2.loli.net/2022/06/22/mhDXF6GO3tsW8Z5.png" width="60%">

<p>然后继续建立，只不过我们为了在每一维都能够有较高的访问效率，这次我们换一维：</p>
<img src="https://s2.loli.net/2022/06/22/a3DnuNJEPzYRHBd.png" width="60%">

<p>然后继续，直到某一个长方形之内没有点了。</p>
<img src="https://s2.loli.net/2022/06/22/p3osUmeyxLtgOCN.png" width="60%">

<p>然后最终我们建立出来的树长这个样子：</p>
<p><img src="https://s2.loli.net/2022/08/18/QwBcK8F5q1IJZS7.png" alt="kd7.png"></p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>K-D树的删除使用惰性删除，利用类似<a href="/OI/scapegoat-tree">替罪羊树</a>的思想，暴力重构即可。</p>
<p>当然，还可以是朝鲜树，因为也是暴力重构。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>假设我们现在要在这里插入一个点 $N&#x3D;(7,3)$。</p>
<img src="https://s2.loli.net/2022/06/22/a9pGS4hXQL75bqZ.png" width="60%">

<p>我们这样来检索：</p>
<p>我们从根节点开始。</p>
<p>首先它在当前节点 $A&#x3D;(6,3)$ 的右边，所以走到右子树；<br>然后它在当前节点 $B&#x3D;(8,5)$ 的下边，所以走到右子树；<br>然后它在当前节点 $J&#x3D;(8,1)$ 的左边，所以走到左子树；</p>
<p>然后我们就发现，当前节点是个空节点。</p>
<p>于是就将 $N$ 加到当前节点上即可。</p>
<p>我们的树就变成了这个样子：</p>
<p><img src="https://s2.loli.net/2022/08/18/Z59VySfXmIgGoLF.png" alt="kd8.png"></p>
<p>不要忘记给点 $N$ 加一条分割线，即使这根本在建树的时候完全体现不出来：</p>
<img src="https://s2.loli.net/2022/06/22/xl3X8ZHzrkDa9Kf.png" width="60%">

<h1 id="维护信息"><a href="#维护信息" class="headerlink" title="维护信息"></a>维护信息</h1><p>K-D Tree可以当做线段树来用，只不过每一个节点都维护的是一个 $k$ 维长方体。</p>
<p>还是刚才这个图，我们将每一个节点维护的矩形的范围定为这样一块：</p>
<img src="https://s2.loli.net/2022/06/22/sA9RILfw3mPFr8X.png" width="60%">

<p>上面就是 $K$ 这个节点维护的矩形范围。</p>
<p>其父节点，$F$，维护的范围如下：</p>
<img src="https://s2.loli.net/2022/06/22/Vwvfgl6sFzpbGHa.png" width="60%">

<p>我们可以看出，K-D Tree 维护的矩形范围十分类似线段树维护的区间范围，某一个节点维护的矩形一定会覆盖其两个子节点维护的矩形，且其两个子节点维护的矩形的并就是这个节点维护的矩形。</p>
<p>所以我们可以对其进行类似线段树上的操作，比如说统计区间和什么的。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>因为KDT是基于替罪羊树的，这里只看与替罪羊树不同的地方。</p>
<h2 id="pushup"><a href="#pushup" class="headerlink" title="pushup"></a>pushup</h2><p>因为维护信息不同，pushup也不一样了。</p>
<p>我们pushup的时候需要将当前节点维护的区间的范围也更新上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].l[<span class="number">0</span>] = tr[p].r[<span class="number">0</span>] = tr[p].p.x[<span class="number">0</span>];</span><br><span class="line">    tr[p].l[<span class="number">1</span>] = tr[p].r[<span class="number">1</span>] = tr[p].p.x[<span class="number">1</span>];</span><br><span class="line">    tr[p].sum = tr[p].p.w;</span><br><span class="line">    tr[p].sz = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].ls)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].l[<span class="number">0</span>] = <span class="built_in">min</span>(tr[p].l[<span class="number">0</span>], tr[tr[p].ls].l[<span class="number">0</span>]);</span><br><span class="line">        tr[p].l[<span class="number">1</span>] = <span class="built_in">min</span>(tr[p].l[<span class="number">1</span>], tr[tr[p].ls].l[<span class="number">1</span>]);</span><br><span class="line">        tr[p].r[<span class="number">0</span>] = <span class="built_in">max</span>(tr[p].r[<span class="number">0</span>], tr[tr[p].ls].r[<span class="number">0</span>]);</span><br><span class="line">        tr[p].r[<span class="number">1</span>] = <span class="built_in">max</span>(tr[p].r[<span class="number">1</span>], tr[tr[p].ls].r[<span class="number">1</span>]);</span><br><span class="line">        tr[p].sum += tr[tr[p].ls].sum;</span><br><span class="line">        tr[p].sz += tr[tr[p].ls].sz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].rs)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].l[<span class="number">0</span>] = <span class="built_in">min</span>(tr[p].l[<span class="number">0</span>], tr[tr[p].rs].l[<span class="number">0</span>]);</span><br><span class="line">        tr[p].l[<span class="number">1</span>] = <span class="built_in">min</span>(tr[p].l[<span class="number">1</span>], tr[tr[p].rs].l[<span class="number">1</span>]);</span><br><span class="line">        tr[p].r[<span class="number">0</span>] = <span class="built_in">max</span>(tr[p].r[<span class="number">0</span>], tr[tr[p].rs].r[<span class="number">0</span>]);</span><br><span class="line">        tr[p].r[<span class="number">1</span>] = <span class="built_in">max</span>(tr[p].r[<span class="number">1</span>], tr[tr[p].rs].r[<span class="number">1</span>]);</span><br><span class="line">        tr[p].sum += tr[tr[p].rs].sum;</span><br><span class="line">        tr[p].sz += tr[tr[p].rs].sz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p>我们重构的时候需要注意，不再是直接取当前区间的mid，而是用<code>nth_element</code>来取出当前区间的中位数。<br>为此，我们还需要分别给两个维度写两个比较函数。<br>更高维的可以尝试使用全局变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp0</span><span class="params">(Point a, Point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x[<span class="number">0</span>] &lt; b.x[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(Point a, Point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x[<span class="number">1</span>] &lt; b.x[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canrbu</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> * <span class="built_in">max</span>(tr[tr[p].ls].sz, tr[tr[p].rs].sz)) &gt;= (alpha * tr[p].sz);</span><br><span class="line">&#125;</span><br><span class="line">Point ldr[N];</span><br><span class="line"><span class="type">int</span> ldc;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbuunf</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">rbuunf</span>(tr[p].ls);</span><br><span class="line">    <span class="keyword">if</span>(tr[p].p.w)</span><br><span class="line">    &#123;</span><br><span class="line">        ldr[++ldc] = tr[p].p;</span><br><span class="line">        rec[++tt] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rbuunf</span>(tr[p].rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rbubld</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> p = <span class="built_in">newnode</span>();</span><br><span class="line">    <span class="built_in">nth_element</span>(ldr + l, ldr + mid, ldr + r + <span class="number">1</span>, k ? cmp1 : cmp0);</span><br><span class="line">    tr[p].p = ldr[mid];</span><br><span class="line">    tr[p].ls = <span class="built_in">rbubld</span>(l, mid - <span class="number">1</span>, k ^ <span class="number">1</span>);</span><br><span class="line">    tr[p].rs = <span class="built_in">rbubld</span>(mid + <span class="number">1</span>, r, k ^ <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbuild</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ldc = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rbuunf</span>(p);</span><br><span class="line">    p = <span class="built_in">rbubld</span>(<span class="number">1</span>, ldc, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>这里是查询的矩形内的权值和。</p>
<p>对于一个矩形来说，我们需要看当前查询区间是否包含这个矩形。<br>如果完全包含的话就直接返回矩形权值和，如果不完全包含的话就需要往下递归了，而如果完全不包含的话就直接返回0即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">inc</span><span class="params">(Point p, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (p.x[<span class="number">0</span>] &gt;= x1) &amp;&amp; (p.x[<span class="number">0</span>] &lt;= x2) &amp;&amp; (p.x[<span class="number">1</span>] &gt;= y1) &amp;&amp; (p.x[<span class="number">1</span>] &lt;= y2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">inc</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (tr[p].l[<span class="number">0</span>] &gt;= x1) &amp;&amp; (tr[p].r[<span class="number">0</span>] &lt;= x2) &amp;&amp; (tr[p].l[<span class="number">1</span>] &gt;= y1) &amp;&amp; (tr[p].r[<span class="number">1</span>] &lt;= y2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">exc</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (tr[p].l[<span class="number">0</span>] &gt; x2) || (tr[p].r[<span class="number">0</span>] &lt; x1) || (tr[p].l[<span class="number">1</span>] &gt; y2) || (tr[p].r[<span class="number">1</span>] &lt; y1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">exc</span>(p, x1, y1, x2, y2))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">inc</span>(p, x1, y1, x2, y2))<span class="keyword">return</span> tr[p].sum;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">inc</span>(tr[p].p, x1, y1, x2, y2))res += tr[p].p.w;</span><br><span class="line">    res += <span class="built_in">query</span>(tr[p].ls, x1, y1, x2, y2);</span><br><span class="line">    res += <span class="built_in">query</span>(tr[p].rs, x1, y1, x2, y2);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="全部加起来"><a href="#全部加起来" class="headerlink" title="全部加起来"></a>全部加起来</h2><p>参考代码：</p>
<details class="note success"><summary><p>参考代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x[<span class="number">2</span>], w;</span><br><span class="line">    <span class="built_in">Point</span>() &#123;&#125;;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> _x, <span class="type">int</span> _y, <span class="type">int</span> _w)</span><br><span class="line">    &#123;</span><br><span class="line">        x[<span class="number">0</span>] = _x, x[<span class="number">1</span>] = _y, w = _w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> Point &amp;a, <span class="type">const</span> Point &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> (a.x[<span class="number">0</span>] == b.x[<span class="number">0</span>]) &amp;&amp; (a.x[<span class="number">1</span>] == b.x[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> alpha = <span class="number">0.75</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">KDT</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ls, rs;</span><br><span class="line">    <span class="type">int</span> l[<span class="number">2</span>], r[<span class="number">2</span>];<span class="comment">//[l,u],[r,d]</span></span><br><span class="line">    <span class="type">int</span> sum, sz;</span><br><span class="line">    Point p;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="type">int</span> rt, idx = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> rec[N], tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tt)<span class="keyword">return</span> rec[tt--];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ++idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].l[<span class="number">0</span>] = tr[p].r[<span class="number">0</span>] = tr[p].p.x[<span class="number">0</span>];</span><br><span class="line">    tr[p].l[<span class="number">1</span>] = tr[p].r[<span class="number">1</span>] = tr[p].p.x[<span class="number">1</span>];</span><br><span class="line">    tr[p].sum = tr[p].p.w;</span><br><span class="line">    tr[p].sz = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].ls)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].l[<span class="number">0</span>] = <span class="built_in">min</span>(tr[p].l[<span class="number">0</span>], tr[tr[p].ls].l[<span class="number">0</span>]);</span><br><span class="line">        tr[p].l[<span class="number">1</span>] = <span class="built_in">min</span>(tr[p].l[<span class="number">1</span>], tr[tr[p].ls].l[<span class="number">1</span>]);</span><br><span class="line">        tr[p].r[<span class="number">0</span>] = <span class="built_in">max</span>(tr[p].r[<span class="number">0</span>], tr[tr[p].ls].r[<span class="number">0</span>]);</span><br><span class="line">        tr[p].r[<span class="number">1</span>] = <span class="built_in">max</span>(tr[p].r[<span class="number">1</span>], tr[tr[p].ls].r[<span class="number">1</span>]);</span><br><span class="line">        tr[p].sum += tr[tr[p].ls].sum;</span><br><span class="line">        tr[p].sz += tr[tr[p].ls].sz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].rs)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].l[<span class="number">0</span>] = <span class="built_in">min</span>(tr[p].l[<span class="number">0</span>], tr[tr[p].rs].l[<span class="number">0</span>]);</span><br><span class="line">        tr[p].l[<span class="number">1</span>] = <span class="built_in">min</span>(tr[p].l[<span class="number">1</span>], tr[tr[p].rs].l[<span class="number">1</span>]);</span><br><span class="line">        tr[p].r[<span class="number">0</span>] = <span class="built_in">max</span>(tr[p].r[<span class="number">0</span>], tr[tr[p].rs].r[<span class="number">0</span>]);</span><br><span class="line">        tr[p].r[<span class="number">1</span>] = <span class="built_in">max</span>(tr[p].r[<span class="number">1</span>], tr[tr[p].rs].r[<span class="number">1</span>]);</span><br><span class="line">        tr[p].sum += tr[tr[p].rs].sum;</span><br><span class="line">        tr[p].sz += tr[tr[p].rs].sz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp0</span><span class="params">(Point a, Point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x[<span class="number">0</span>] &lt; b.x[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(Point a, Point b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x[<span class="number">1</span>] &lt; b.x[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canrbu</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> * <span class="built_in">max</span>(tr[tr[p].ls].sz, tr[tr[p].rs].sz)) &gt;= (alpha * tr[p].sz);</span><br><span class="line">&#125;</span><br><span class="line">Point ldr[N];</span><br><span class="line"><span class="type">int</span> ldc;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbuunf</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">rbuunf</span>(tr[p].ls);</span><br><span class="line">    <span class="keyword">if</span>(tr[p].p.w)</span><br><span class="line">    &#123;</span><br><span class="line">        ldr[++ldc] = tr[p].p;</span><br><span class="line">        rec[++tt] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rbuunf</span>(tr[p].rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rbubld</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> p = <span class="built_in">newnode</span>();</span><br><span class="line">    <span class="built_in">nth_element</span>(ldr + l, ldr + mid, ldr + r + <span class="number">1</span>, k ? cmp1 : cmp0);</span><br><span class="line">    tr[p].p = ldr[mid];</span><br><span class="line">    tr[p].ls = <span class="built_in">rbubld</span>(l, mid - <span class="number">1</span>, k ^ <span class="number">1</span>);</span><br><span class="line">    tr[p].rs = <span class="built_in">rbubld</span>(mid + <span class="number">1</span>, r, k ^ <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbuild</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ldc = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rbuunf</span>(p);</span><br><span class="line">    p = <span class="built_in">rbubld</span>(<span class="number">1</span>, ldc, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;p, Point v, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="built_in">newnode</span>();</span><br><span class="line">        tr[p].ls = tr[p].rs = <span class="number">0</span>;</span><br><span class="line">        tr[p].p = v;</span><br><span class="line">        <span class="built_in">pushup</span>(p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(v.x[k] &lt;= tr[p].p.x[k])<span class="built_in">insert</span>(tr[p].ls, v, k ^ <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">insert</span>(tr[p].rs, v, k ^ <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">canrbu</span>(p))<span class="built_in">rbuild</span>(p, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">inc</span><span class="params">(Point p, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (p.x[<span class="number">0</span>] &gt;= x1) &amp;&amp; (p.x[<span class="number">0</span>] &lt;= x2) &amp;&amp; (p.x[<span class="number">1</span>] &gt;= y1) &amp;&amp; (p.x[<span class="number">1</span>] &lt;= y2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">inc</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (tr[p].l[<span class="number">0</span>] &gt;= x1) &amp;&amp; (tr[p].r[<span class="number">0</span>] &lt;= x2) &amp;&amp; (tr[p].l[<span class="number">1</span>] &gt;= y1) &amp;&amp; (tr[p].r[<span class="number">1</span>] &lt;= y2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">exc</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (tr[p].l[<span class="number">0</span>] &gt; x2) || (tr[p].r[<span class="number">0</span>] &lt; x1) || (tr[p].l[<span class="number">1</span>] &gt; y2) || (tr[p].r[<span class="number">1</span>] &lt; y1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">exc</span>(p, x1, y1, x2, y2))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">inc</span>(p, x1, y1, x2, y2))<span class="keyword">return</span> tr[p].sum;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">inc</span>(tr[p].p, x1, y1, x2, y2))res += tr[p].p.w;</span><br><span class="line">    res += <span class="built_in">query</span>(tr[p].ls, x1, y1, x2, y2);</span><br><span class="line">    res += <span class="built_in">query</span>(tr[p].rs, x1, y1, x2, y2);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> lastans = <span class="number">0</span>, op;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op), op != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x, y, w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;w);</span><br><span class="line">            x ^= lastans, y ^= lastans, w ^= lastans;</span><br><span class="line">            <span class="built_in">insert</span>(rt, <span class="built_in">Point</span>(x, y, w), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">            x1 ^= lastans, y1 ^= lastans, x2 ^= lastans, y2 ^= lastans;</span><br><span class="line">            lastans = <span class="built_in">query</span>(rt, x1, y1, x2, y2);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lastans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="洛谷-P4148-简单题"><a href="#洛谷-P4148-简单题" class="headerlink" title="洛谷 P4148 简单题"></a>洛谷 P4148 简单题</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQxNDg=">题目链接</span></p>
<p>上面放的代码就是该题的代码。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP 算法与前缀函数</title>
    <url>/OI/kmp/</url>
    <content><![CDATA[<p>KMP算法与前缀函数。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>KMP算法，全称为 Knuth-Morris-Pratt 算法，是由 Knuth, Morris 和 Pratt 这三个人创造的算法，可以在 $O(n+m)$ 的时间内使用 $O(n)$ 的空间完成如下的任务：</p>
<blockquote>
<p>给定一个字符串 $S$ 和一个模式串 $T$，求出 $S$ 在 $T$ 中所有出现的位置。</p>
</blockquote>
<p>其中 $|S| &#x3D; n$，$|T| &#x3D; m$。</p>
<p>KMP算法主要依赖的是 “Next函数” 这个东西。</p>
<h1 id="Next函数"><a href="#Next函数" class="headerlink" title="Next函数"></a>Next函数</h1><p>Next函数，有时候也被称作 “前缀函数”，是KMP算法的核心部分。<br>我们以一个数组 $\pi$ 来表示它。</p>
<p>其旨在求得任意一个前缀的border长度。</p>
<h2 id="什么是border？"><a href="#什么是border？" class="headerlink" title="什么是border？"></a>什么是border？</h2><p>border指的是一个字符串内，真前缀和真后缀相等的那一部分。<br>这样的真前缀和真后缀可能有很多种，我们需要找的是最长的那一组。</p>
<p>真前缀和真后缀说的是前缀和后缀中除去字符串本身之后剩下的部分。</p>
<h2 id="如何求得border？"><a href="#如何求得border？" class="headerlink" title="如何求得border？"></a>如何求得border？</h2><h3 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h3><p>我们显然可以暴力扫，最终的复杂度是 $O(n^3)$ 的。</p>
<p>懒得写了，直接搬了OI-Wiki的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefix_function</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = ( <span class="type">int</span> )s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pi</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, j) == s.<span class="built_in">substr</span>(i - j + <span class="number">1</span>, j))</span><br><span class="line">            &#123;</span><br><span class="line">                pi[i] = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prefix_function</span>(<span class="params">s</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    pi = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[<span class="number">0</span> : j] == s[i - j + <span class="number">1</span> : i + <span class="number">1</span>]:</span><br><span class="line">                pi[i] = j</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> pi</span><br></pre></td></tr></table></figure>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>我们会发现，相邻的两个函数值最多会增加1。</p>
<p>也就是说，当我们移动到下一个位置时，Next函数的值要么增加一，要么维持不变，要么减少。</p>
<p>此时改进的算法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefix_function</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = ( <span class="type">int</span> )s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pi</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = pi[i - <span class="number">1</span>] + <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)  <span class="comment">// improved: j=i =&gt; j=pi[i-1]+1</span></span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, j) == s.<span class="built_in">substr</span>(i - j + <span class="number">1</span>, j))</span><br><span class="line">            &#123;</span><br><span class="line">                pi[i] = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prefix_function</span>(<span class="params">s</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    pi = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(pi[i - <span class="number">1</span>] + <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[<span class="number">0</span> : j] == s[i - j + <span class="number">1</span> : i + <span class="number">1</span>]:</span><br><span class="line">                pi[i] = j</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> pi</span><br></pre></td></tr></table></figure>

<p>此时，我们每一个前缀最多需要比对 $O(n)$ 级别的字符串，总复杂度降到了 $O(n^2)$。</p>
<h3 id="继续优化"><a href="#继续优化" class="headerlink" title="继续优化"></a>继续优化</h3><p>刚才我们只考虑到了 $s[i+1] &#x3D; s[\pi[i]]$ 的情况，即函数值增加1。<br>那么对于其他的情况呢？</p>
<p>我们考虑 $s[i+1] \neq s[\pi[i]]$。<br>在我们之前的想法里面，我们就需要枚举出来可能的border长度，并与实际情况进行比较。</p>
<p>我们尝试避免这些无谓的比较。</p>
<p>我们尝试找到一个前缀，在保证其与后缀相等的前提下，使得我们当前匹配的进度最大地保留下来。</p>
<p>观察一下我们想要找到的东西：</p>
<img src="/pics/kmp1.png" width="50%" />

<p>我们想要找到两个字符串 $s[0 \to j-1]$ 和 $s[i-j+1 \to i]$，他们完全相等，同时也分别是 $s[0 \to i]$ 的一个前缀和一个后缀。</p>
<p>我们发现，这两个字符串是完全包含在 $s[0 \to \pi[i]-1]$ 和 $s[i-\pi[i]+1 \to i]$ 这两个完全相等的字符串内的。</p>
<p>所以，我们就可以将其转化成为寻找字符串 $s[0 \to \pi[i]-1]$ 的border。</p>
<p>所以说，我们需要找的就是 $s[0 \to \pi[\pi[i]]-1]$ 和 $s[i-\pi[\pi[i]]+1 \to i]$。</p>
<p>然后我们尝试将 $s_{i+1}$ 纳入我们当前找到的border里面。</p>
<p>如果匹配，那就向前移动；<br>如果失配，那就继续寻找当前长度的border，直到最后到达0。</p>
<p>此时改进的算法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefix_function</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = ( <span class="type">int</span> )s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pi</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = pi[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) j = pi[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i] == s[j]) j++;</span><br><span class="line">        pi[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python Version</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prefix_function</span>(<span class="params">s</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    pi = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        j = pi[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> s[i] != s[j]:</span><br><span class="line">            j = pi[j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        pi[i] = j</span><br><span class="line">    <span class="keyword">return</span> pi</span><br></pre></td></tr></table></figure>

<p>同时我们还可以发现，我们进行优化过的算法是一个在线算法。</p>
<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><p>现在终于来到了KMP算法的本体部分。</p>
<p>我们考虑根据题目给定的 $S$ 和 $T$ 两个字符串，拼接成一个新的字符串 $S+ \# +T$ ，其中 $\#$ 代表在 $S$ 和 $T$ 中都没有出现过的分隔符。</p>
<p>我们考虑计算新字符串 $T$ 部分的Next函数。</p>
<p>因为对于 $T$ 部分的每一个位置，其位置所对应的前缀绝对包含 $S$ 和分隔符的。<br>所以，其Next函数长度绝对不会超过 $n$。（即 $|S|$）</p>
<p>同时，我们保证了只会比对 $T$ 部分的字串，因为分隔符的出现使得包含其的后缀无法与同样长度的前缀匹配，因为这个字符不在 $S$ 或 $T$ 中出现过，而假如前缀中也包含了它，也会因为位置不一样而无法匹配。</p>
<p>所以说，如果在某一个位置 $i$ 有 $\pi[i] &#x3D; n$ 成立，那么 $S$ 就会在 $T$ 的 $i-2n$ 处出现。</p>
<p>洛谷例题：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzNzU=">https://www.luogu.com.cn/problem/P3375</span></p>
<p>示例代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3375/p3375.cpp"><code>Luogu P3375</code></a></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="求一个字符串的周期"><a href="#求一个字符串的周期" class="headerlink" title="求一个字符串的周期"></a>求一个字符串的周期</h2><p>我们考虑利用border的性质。</p>
<p>如果一个字符串 $s$ 有长度为 $r$ 的border，那么 $|s| - r$ 一定是 $s$ 的周期，其长度我们这里记作 $p$。</p>
<p>就像这样：</p>
<img src="/pics/kmp2.svg" alt="kmp2.svg" width="50%" />

<p>从这里我们可以得出 $s[0 \to 1]&#x3D;s[2 \to 3]&#x3D;s[4 \to 5]&#x3D;s[6 \to 7]$，从而得出 $r-|s|&#x3D;2$ 为 $s$ 的周期。</p>
<p>同时，如果这个周期的长度 $p$ 可以被 $|s|$ 整除的话，那么长度为 $p$ 的前缀就是 $s$ 的最小循环元。</p>
<p>AcWing例题：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTQzLw==">https://www.acwing.com/problem/content/143/</span></p>
<p>参考代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/AcWing/141/ac141.cpp"><code>AcWing 141</code></a></p>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>扫描线</title>
    <url>/OI/scanning-line/</url>
    <content><![CDATA[<p>一种便携的用来求矩形面积并的算法。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><p>顾名思义，扫描线就是要模拟一根线，扫过整个图形。至于方向什么的自己根据喜好，这里选用从左往右的方式。</p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="朴素做法"><a href="#朴素做法" class="headerlink" title="朴素做法"></a>朴素做法</h2><p>首先我们看一下这个例子：</p>
<img src="https://i.loli.net/2021/11/12/ykmlLC6RpHTZbUf.png" alt="扫描线1.png" width="60%" />

<p>我们有三个矩形，分别用红、蓝、绿三色标注了出来。<br>他们相交的面积用其他的颜色标了出来。</p>
<p>我们所得到的信息只有矩形的左下端点和右上端点的坐标。也就是我们标红的这几个点：</p>
<img src="https://i.loli.net/2021/11/12/Naw9ZzMXnA6Jt7d.png" alt="扫描线2.png" width="60%" />

<p>然后我们可以画出一根线来，扫过这个多边形的所有面积。<br>这根线从最左边的边开始，每遇到一条边，就停下来计算之前扫到的面积，即为距上一条边的距离与扫描线落在图形上的长度之积，再加到之前的和上面。<br>用动画来做就是这样的：</p>
<img src="https://s2.loli.net/2021/12/29/zsg32tJnWbykfBo.gif" alt="扫描线3.gif" width="60%" />

<p>但是这样做有一处需要注意的地方： <strong>我们怎么才能知道每一次遇到一条边之后扫描线落在图像上的长度是多少</strong> ？<br>如果我们每一次都去枚举、去找，我们程序的时间复杂度就达不到我们的要求了。<br>这就是扫描线算法的精髓之处。</p>
<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>我们把 $y$ 轴上的一段区间按照每一个存在的矩形的边的高度值分一下块：</p>
<img src="https://i.loli.net/2021/11/12/pkELge24OblfDxI.png" alt="扫描线4.png" width="60%" />

<p>我们只需要计算每一段所对应的在 $x$ 轴上的长度就行了。</p>
<p>我们可以使用线段树这一强大的数据结构来帮助我们更快地进行区间修改。</p>
<img src="https://i.loli.net/2021/11/12/W3OLxhVenapUIfH.png" alt="扫描线5.png" width="60%" />

<h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><p>我们在遇到某个矩形的一条边的时候，我们需要看一下这两个东西：</p>
<ol>
<li>它的长度；</li>
<li>他是起始边还是终止边。</li>
</ol>
<p>如果是起始边的话，我们把他这条边所包含的所有区块都打上一个标记；如果是终止边的话，我们就把之前起始边打上的标记去掉。这样，只要有标记就是存在，不管有多少个；没有标记就是没有被覆盖，忽略不计。<br>所以，我们的线段树节点需要存储这个区段被标记的次数。同时，我们还需要存储基本的线段树信息，还有它的长度。<br>同时，我们用来存储矩形边的位置我们也需要改一下，使之能够存储这条边的上端点和下端点，还要标记这条边是起始边还是终止边。<br>最终我们使用动画模拟一下就是这个样子的：</p>
<img src="https://s2.loli.net/2021/12/29/UEmq4XVFOWL56eo.gif" alt="扫描线6.gif" width="60%" />

<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>洛谷板子题：Luogu P5490 【模板】 扫描线：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDU0OTA=">https://www.luogu.com.cn/problem/P5490</span></p>
<p>示例代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p5000-p5999/p5490/p5490.cpp"><code>Luogu P5490</code></a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>替罪羊树</title>
    <url>/OI/scapegoat-tree/</url>
    <content><![CDATA[<p>替罪羊树。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<p>替罪羊树是一种平衡树。</p>
<h1 id="热身"><a href="#热身" class="headerlink" title="热身"></a>热身</h1><p>平衡树一般都是一个二叉搜索树，其满足中序遍历得到的序列就是我们需要维护的原序列。</p>
<p>当然，二叉搜索树可以不平衡，这样就可以构造一个特殊的数据使之退化成为一条链。</p>
<p>那我们怎么定义一棵二叉搜索树“不平衡”呢？</p>
<p>这里需要引入一个概念：平衡指数 $\alpha$。</p>
<p>一棵二叉搜索树的平衡常数等于其子节点大小与其大小的比值。<br>这里取的是最大值。</p>
<p>平衡常数 $\alpha$ 的取值是 $\alpha \in [ 0.5 , 1 ]$。<br>其两个边界代表了两个极端情况：</p>
<p>当 $\alpha &#x3D; 1$ 时，我们不管怎样建造搜索树都会被认为是平衡的，因为其子节点的子树大小永远不可能超过其本身的子树大小。</p>
<p>当 $\alpha &#x3D; 0.5$ 时，我们每一个节点的子节点的子树大小必须恰好是其本身的子树大小的一半。<br>AVL树就在尽力维持这样的平衡，这就导致其代码十分冗长，没有能在OI上有太多实际的应用。<br>在<span class="exturl" data-url="aHR0cHM6Ly93d3cuY3MudXNmY2EuZWR1L35nYWxsZXMvdmlzdWFsaXphdGlvbi9BVkx0cmVlLmh0bWw=">这里</span>有一个AVL树的可视化。</p>
<p>红黑树比较特殊，通过放宽一些过于严苛的要求，其追求的是 $\alpha &#x3D; \frac{2}{3}$，同时降低了常数和代码长度。<br>在<span class="exturl" data-url="aHR0cHM6Ly93d3cuY3MudXNmY2EuZWR1L35nYWxsZXMvdmlzdWFsaXphdGlvbi9SZWRCbGFjay5odG1s">这里</span>有一个红黑树的可视化。</p>
<p>其他的平衡树都是通过一些思想来维持 $\alpha$ 的尽量低。</p>
<p>基于<span class="exturl" data-url="aHR0cHM6Ly9yaXRlbWUuc2l0ZS9ibG9nLzIwMTYtNC02L3NjYXBlZ29hdC5odG1s">这里</span>的数据，我们可以大概得知不同平衡树的 $\alpha$ 大小：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">平均</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Splay</td>
<td align="center">0.758</td>
<td align="center">0.588</td>
<td align="center">0.582</td>
<td align="center">0.612</td>
<td align="center">0.759</td>
<td align="center">0.659</td>
</tr>
<tr>
<td align="center">Treap</td>
<td align="center">0.766</td>
<td align="center">0.578</td>
<td align="center">0.601</td>
<td align="center">0.587</td>
<td align="center">0.781</td>
<td align="center">0.662</td>
</tr>
<tr>
<td align="center">FHQ-Treap</td>
<td align="center">0.914</td>
<td align="center">0.860</td>
<td align="center">0.613</td>
<td align="center">0.678</td>
<td align="center">0.803</td>
<td align="center">0.773</td>
</tr>
</tbody></table>
<p>可见，一般的平衡树都能将 $\alpha$ 维持到 0.6 到 0.8 范围内。</p>
<h2 id="替罪羊树"><a href="#替罪羊树" class="headerlink" title="替罪羊树"></a>替罪羊树</h2><p>替罪羊树最大的特点就是暴力。</p>
<p>怎么暴力呢？</p>
<p>替罪羊树会将不平衡的子树进行重构来保证其平衡。<br>而其判断子树平衡与否就是根据刚才讲的平衡因数 $\alpha$，只不过这里是人为设定的，称之为平衡常数。</p>
<h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><h2 id="暴力重构"><a href="#暴力重构" class="headerlink" title="暴力重构"></a>暴力重构</h2><p>替罪羊树之所以能够平衡，是在于其重构时不是瞎重构，而是将被重构的子树重构为一棵<strong>完全二叉树</strong>。</p>
<p>当然我们都知道这样费时又费力，更何况还是暴力重构的。</p>
<p>所以我们认为设定的平衡常数 $\alpha$ 在此时就起到了决定性的作用。<br>当其值合适的时候，我们就可以将所有的时间复杂度均摊到一个 $O(\log n)$ 的水平。</p>
<p>具体如何暴力重构就不用太多赘述了，我们可以使用简单的方法来保证线性建树，然后将新建的树接过来即可。</p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>替罪羊树的查询与其他二叉搜索树一样，并且因为其没有对树进行修改，还不会导致产生重构操作，所以最终时间复杂度为 $O(\log n)$。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>替罪羊树的插入操作与其他的二叉搜索树差不多。只不过因为其导致了树形态的改变，我们在插入完回溯的过程中还需要判断一下是否需要重构。</p>
<p>当然，还会有一条链上多棵子树不平衡的情况。<br>我们可以将最大的子树重构，但是这样在实际写代码的时候会略显复杂。<br>如果你真的很懒的话，只需要在回溯的时候找到第一棵不平衡的树重构即可，并且据说这个样子对于时间复杂度的影响不会很大。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>替罪羊树使用惰性删除，只需要将对应节点上代表节点内数据数量的标记自减一即可。</p>
<p>对于一个节点内数据数量为0的点，我们会忽略对其的任何操作，并在下一次重构时将其丢弃掉，除非再有插入操作将其插入回去。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>替罪羊树的一个节点内需要存储很多信息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Scapegoat</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ls, rs;</span><br><span class="line">    <span class="type">int</span> w, wn;</span><br><span class="line">    <span class="type">int</span> s, sz, sd;</span><br><span class="line">&#125;tr[N];</span><br></pre></td></tr></table></figure>

<p>解释一下：</p>
<ul>
<li><code>ls</code>&amp;<code>rs</code>：左右儿子。</li>
<li><code>w</code>：节点权值。</li>
<li><code>wn</code>：节点内数据数量。</li>
<li><code>s</code>：子树内节点个数。</li>
<li><code>sz</code>：子树内数据个数。</li>
<li><code>sd</code>：子树内不计删除节点的节点个数。</li>
</ul>
<p>我们这样来（重新）计算当前节点的子树大小：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].s = tr[tr[p].ls].s + tr[tr[p].rs].s + <span class="number">1</span>;</span><br><span class="line">    tr[p].sz = tr[tr[p].ls].sz + tr[tr[p].rs].sz + tr[p].wn;</span><br><span class="line">    tr[p].sd = tr[tr[p].ls].sd + tr[tr[p].rs].sd + (tr[p].wn != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p>我们重构分两种情况：一是子树不平衡了，即左右子树之一的大小占其本身子树大小的比例超过 $\alpha$；二是被删除的节点太多了，这样也会影响效率。</p>
<p>首先我们需要判断是否需要重构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canrbu</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tr[p].wn)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(alpha * tr[p].s &lt;= <span class="built_in">double</span>(<span class="built_in">max</span>(tr[tr[p].ls].s, tr[tr[p].rs].s)))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">double</span>(tr[p].sd) &lt;= alpha * tr[p].s)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="comment">//can rebuild</span></span><br></pre></td></tr></table></figure>

<p>一句话版：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canrbu</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tr[k].wn &amp;&amp; (alpha * tr[k].s &lt;= ( <span class="type">double</span> )<span class="built_in">max</span>(tr[tr[k].ls].s, tr[tr[k].rs].s) ||</span><br><span class="line">        ( <span class="type">double</span> )tr[k].sd &lt;= alpha * tr[k].s);</span><br><span class="line">&#125;<span class="comment">//can rebuild</span></span><br></pre></td></tr></table></figure>

<p>然后就是重构的具体操作：</p>
<p>首先我们将需要重构的子树经中序遍历展开之后存入数组中，然后将新得到的数组二分建树。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbuunf</span><span class="params">(<span class="type">int</span> &amp;ldc, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">rbuunf</span>(ldc, tr[p].ls);</span><br><span class="line">    <span class="keyword">if</span>(tr[p].wn)ldr[++ldc] = p;</span><br><span class="line">    <span class="built_in">rbuunf</span>(ldc, tr[p].rs);</span><br><span class="line">&#125;<span class="comment">//rebuild-unfold</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rbubld</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    tr[ldr[mid]].ls = <span class="built_in">rbubld</span>(l, mid);</span><br><span class="line">    tr[ldr[mid]].rs = <span class="built_in">rbubld</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">calc</span>(ldr[mid]);</span><br><span class="line">    <span class="keyword">return</span> ldr[mid];</span><br><span class="line">&#125;<span class="comment">//rebuild-build</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbuild</span><span class="params">(<span class="type">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ldc = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rbuunf</span>(ldc, p);</span><br><span class="line">    p = <span class="built_in">rbubld</span>(<span class="number">1</span>, ldc);</span><br><span class="line">&#125;<span class="comment">//rebuild</span></span><br></pre></td></tr></table></figure>

<h2 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h2><p>插入时，我们需要找到对应节点并 <code>tr[p].wn++</code>。如果没有节点就新建一个，回溯时需要判断是否能够重构，如果可以的话就重构。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">    &#123;</span><br><span class="line">        p = ++cnt;</span><br><span class="line">        <span class="keyword">if</span>(!rt)rt = <span class="number">1</span>;</span><br><span class="line">        tr[p].w = k;</span><br><span class="line">        tr[p].ls = tr[p].rs = <span class="number">0</span>;</span><br><span class="line">        tr[p].wn = tr[p].s = tr[p].sz = tr[p].sd = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[p].w == k)tr[p].wn++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].w &lt; k)<span class="built_in">insert</span>(tr[p].rs, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">insert</span>(tr[p].ls, k);</span><br><span class="line">        <span class="built_in">calc</span>(p);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">canrbu</span>(p))<span class="built_in">rbuild</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><p>替罪羊树使用惰性删除，找到对应节点之后只需要 <code>tr[p].wn--</code> 即可。当然，回溯时候遇到可以重构的节点时要重构。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">loschn</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].w == k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[p].wn)tr[p].wn--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[p].w &lt; k)<span class="built_in">loschn</span>(tr[p].rs, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">loschn</span>(tr[p].ls, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">calc</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">canrbu</span>(p))<span class="built_in">rbuild</span>(p);</span><br><span class="line">&#125;<span class="comment">//löschen，delete是关键字就不用了</span></span><br></pre></td></tr></table></figure>

<h1 id="查询函数"><a href="#查询函数" class="headerlink" title="查询函数"></a>查询函数</h1><p>然后就是一些其他的函数，都是在二分查找树上进行查找操作的。</p>
<h2 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound"></a><code>upper_bound</code></h2><p>与原来upper_bound的用途一样，返回第一个大于其权值的位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">uprbnd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].w == k &amp;&amp; tr[p].wn)</span><br><span class="line">        <span class="keyword">return</span> tr[tr[p].ls].sz + tr[p].wn + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].w &gt; k)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">uprbnd</span>(tr[p].ls, k);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> tr[tr[p].ls].sz + tr[p].wn + <span class="built_in">uprbnd</span>(tr[p].rs, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个其反义函数，相当于是对当前序列反转之后的结果进行upper_bound，返回的是第一个小于其权值的位置。</p>
<p>查询某一个数字的排名的时候可以使用 <code>uprgtr(rt,k)+1</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">uprgtr</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].w == k &amp;&amp; tr[p].wn)</span><br><span class="line">        <span class="keyword">return</span> tr[tr[p].ls].sz;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].w &lt; k)</span><br><span class="line">        <span class="keyword">return</span> tr[tr[p].ls].sz + tr[p].wn + <span class="built_in">uprgtr</span>(tr[p].rs, k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">uprgtr</span>(tr[p].ls, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="getk"><a href="#getk" class="headerlink" title="getk"></a><code>getk</code></h2><p>getk函数返回的是当前排名上的数字。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getk</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[tr[p].ls].sz &lt; k &amp;&amp; k &lt;= tr[tr[p].ls].sz + tr[p].wn)</span><br><span class="line">        <span class="keyword">return</span> tr[p].w;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[tr[p].ls].sz + tr[p].wn &lt; k)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getk</span>(tr[p].rs, k - tr[tr[p].ls].sz - tr[p].wn);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getk</span>(tr[p].ls, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="前驱与后继"><a href="#前驱与后继" class="headerlink" title="前驱与后继"></a>前驱与后继</h2><p>将上面两个函数结合起来就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">precsr</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getk</span>(p, <span class="built_in">uprgtr</span>(p, k));</span><br><span class="line">&#125;<span class="comment">//precursor</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">succsr</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getk</span>(p, <span class="built_in">uprbnd</span>(p, k));</span><br><span class="line">&#125;<span class="comment">//successor</span></span><br></pre></td></tr></table></figure>

<details class="note success"><summary><p>封装好的结构体</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> alpha = <span class="number">0.75</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Scapegoat</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ls[N], rs[N];</span><br><span class="line">    <span class="type">int</span> w[N], wn[N];</span><br><span class="line">    <span class="type">int</span> s[N], sz[N], sd[N];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt, rt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        s[p] = s[ls[p]] + s[rs[p]] + <span class="number">1</span>;</span><br><span class="line">        sz[p] = sz[ls[p]] + sz[rs[p]] + wn[p];</span><br><span class="line">        sd[p] = sd[ls[p]] + sd[rs[p]] + (wn[p] != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canrbu</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> wn[p] &amp;&amp; (alpha * s[p] &lt;= <span class="built_in">double</span>(<span class="built_in">max</span>(s[ls[p]], s[rs[p]])) || <span class="built_in">double</span>(sd[p] &lt;= alpha * s[p]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ldr[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rbuunf</span><span class="params">(<span class="type">int</span> &amp;ldc, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p)<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">rbuunf</span>(ldc, ls[p]);</span><br><span class="line">        <span class="keyword">if</span>(wn[p])ldr[ldc++] = p;</span><br><span class="line">        <span class="built_in">rbuunf</span>(ldc, rs[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rbubld</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        ls[ldr[mid]] = <span class="built_in">rbubld</span>(l, mid);</span><br><span class="line">        rs[ldr[mid]] = <span class="built_in">rbubld</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">calc</span>(ldr[mid]);</span><br><span class="line">        <span class="keyword">return</span> ldr[mid];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rbuild</span><span class="params">(<span class="type">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ldc = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rbuunf</span>(ldc, p);</span><br><span class="line">        p = <span class="built_in">rbubld</span>(<span class="number">0</span>, ldc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p)</span><br><span class="line">        &#123;</span><br><span class="line">            p = ++cnt;</span><br><span class="line">            <span class="keyword">if</span>(!rt)rt = <span class="number">1</span>;</span><br><span class="line">            w[p] = k;</span><br><span class="line">            ls[p] = rs[p] = <span class="number">0</span>;</span><br><span class="line">            wn[p] = s[p] = sz[p] = sd[p] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(w[p] == k)wn[p]++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(w[p] &lt; k)<span class="built_in">insert</span>(rs[p], k);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">insert</span>(ls[p], k);</span><br><span class="line">            <span class="built_in">calc</span>(p);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">canrbu</span>(p))<span class="built_in">rbuild</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loschn</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(w[p] == k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(wn[p])wn[p]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(w[p] &lt; k)<span class="built_in">loschn</span>(rs[p], k);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">loschn</span>(ls[p], k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">calc</span>(p);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">canrbu</span>(p))<span class="built_in">rbuild</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uprbnd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(w[p] == k &amp;&amp; wn[p])</span><br><span class="line">            <span class="keyword">return</span> sz[ls[p]] + wn[p] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(w[p] &gt; k)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">uprbnd</span>(ls[p], k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> sz[ls[p]] + wn[p] + <span class="built_in">uprbnd</span>(rs[p], k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uprgtr</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(w[p] == k &amp;&amp; wn[p])</span><br><span class="line">            <span class="keyword">return</span> sz[ls[p]];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(w[p] &lt; k)</span><br><span class="line">            <span class="keyword">return</span> sz[ls[p]] + wn[p] + <span class="built_in">uprgtr</span>(rs[p], k);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">uprgtr</span>(ls[p], k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getk</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sz[ls[p]] &lt; k &amp;&amp; k &lt;= sz[ls[p]] + wn[p])</span><br><span class="line">            <span class="keyword">return</span> w[p];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sz[ls[p]] + wn[p] &lt; k)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getk</span>(rs[p], k - sz[ls[p]] - wn[p]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getk</span>(ls[p], k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">precrs</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getk</span>(p, <span class="built_in">uprgtr</span>(p, k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">succsr</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getk</span>(p, <span class="built_in">uprbnd</span>(p, k));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tr;</span><br></pre></td></tr></table></figure>
</details>

<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>洛谷上的<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzNjk=">板子</span>：</p>
<p>示例代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3369/p3369_scapegoat.cpp"><code>Luogu P3369-scapegoat</code></a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>Splay</title>
    <url>/OI/splay/</url>
    <content><![CDATA[<p>Splay.</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>
（2022年5月24日重构）

<p>Splay是一种很好地维护一棵二叉搜索树的方法。<br>如果不知道什么是二叉搜索树，请看<span class="exturl" data-url="aHR0cHM6Ly9vaS13aWtpLm9yZy9kcy9ic3Qv">此页面</span>。</p>
<h1 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h1><p>Splay的基本思想是，通过一系列的旋转操作，维持整棵二叉搜索树的平衡。</p>
<p>首先，我们假设我们需要维护的结构体是这个样子的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s[<span class="number">2</span>], fa;</span><br><span class="line">    <span class="type">int</span> v, w;</span><br><span class="line">    <span class="type">int</span> sz;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> _v, <span class="type">int</span> _fa)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        v = _v, fa = _fa;</span><br><span class="line">        sz = w = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tr[N];</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li><code>s[2]</code>：左右子树。</li>
<li><code>fa</code>：父亲。</li>
<li><code>v</code>：节点权值。</li>
<li><code>w</code>：节点大小。</li>
<li><code>sz</code>：节点及其子树大小。</li>
</ul>
<p>还有一些其他的东西就一一列举了，比如懒标记等等。</p>
<h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>Splay之所以能够维持其平衡，依赖的就是这样的简单旋转操作。</p>
<h3 id="左旋与右旋"><a href="#左旋与右旋" class="headerlink" title="左旋与右旋"></a>左旋与右旋</h3><p>对于这样一个图：</p>
<img src="https://s2.loli.net/2022/01/07/i8JVbaGELdNQOAx.png" alt="splay1.png" width="40%" />

<p>其中x节点有两个子树，A与B；x节点的父亲y节点还有一棵子树C；z节点是y节点的父亲。<br>我们将x节点旋转（这里x节点是其父亲y节点的左儿子，所以我们会将其右旋），结果是这个样子的：</p>
<img src="https://s2.loli.net/2022/01/07/hlkn8QXvHYgCtyr.png" alt="splay2.png" width="40%" />

<p>当然，如果我们把x旋转回去的话，那就是左旋操作了。</p>
<p>总体来看是这个样子：</p>
<img src="https://s2.loli.net/2022/05/24/WQhxLqiVDOIzrmc.png" alt="splay3.png" width="80%" />

<p>在进行旋转操作时，我们需要保持其中序遍历序列不变。</p>
<p>在刚刚的右旋操作中，我们来分析一下我们需要改变的边：</p>
<img src="https://s2.loli.net/2022/03/23/uqVYj9LzJvDKZMn.png" alt="splay4.png" width="40%" />

<p>就是这三条标红的边。</p>
<p>那么对于这三条边，我们分别进行重构操作。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> k = tr[y].s[<span class="number">1</span>] == x;<span class="comment">//x是y的哪个儿子</span></span><br><span class="line">tr[z].s[tr[z].s[<span class="number">1</span>] == y] = x, tr[x].fa = z;<span class="comment">//重构z-x边</span></span><br><span class="line">tr[y].s[k] = tr[x].s[k ^ <span class="number">1</span>], tr[tr[x].s[k ^ <span class="number">1</span>]].fa = y;<span class="comment">//重构y-B边</span></span><br><span class="line">tr[x].s[k ^ <span class="number">1</span>] = y, tr[y].fa = x;<span class="comment">//重构x-y边</span></span><br></pre></td></tr></table></figure>

<p>旋转完成之后，因为我们改变了树的结构，所以我们需要重新计算x和y的大小，有时候还有需要维护的其他信息。<br>注意这里需要先维护较低的y，再维护较高的x。</p>
<p>所以总的函数是这个样子的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].sz = tr[p].w;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].s[<span class="number">0</span>])tr[p].sz += tr[tr[p].s[<span class="number">0</span>]].sz;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].s[<span class="number">1</span>])tr[p].sz += tr[tr[p].s[<span class="number">1</span>]].sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> y = tr[x].fa, z = tr[y].fa;</span><br><span class="line">    <span class="type">int</span> k = tr[y].s[<span class="number">1</span>] == x;</span><br><span class="line">    tr[z].s[tr[z].s[<span class="number">1</span>] == y] = x, tr[x].fa = z;</span><br><span class="line">    tr[y].s[k] = tr[x].s[k ^ <span class="number">1</span>], tr[tr[x].s[k ^ <span class="number">1</span>]].fa = y;</span><br><span class="line">    tr[x].s[k ^ <span class="number">1</span>] = y, tr[y].fa = x;</span><br><span class="line">    <span class="built_in">pushup</span>(y), <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a>核心函数</h2><p>我们在向splay中插入一个数之后，会强制将其旋转到根。<br>而在刚才的示例中，我们看到了，我们将x右旋之后，x就向上走了一点。<br>而经过不断的旋转，我们就可以让x节点走到根。</p>
<p>当然，我们也不是随便瞎转，因为旋转操作也是需要复杂度的。<br>而我们的最后目标是使之均摊之后达到尽量小的复杂度。<br>引用闫学灿的一句话：</p>
<blockquote>
<p>“如果我们瞎转的话，就达不到$O(\log n)$的复杂度了。”</p>
</blockquote>
<p>所以我们要根据x所处的位置来制定不同的旋转方案。</p>
<p>首先，我们对于x可能出现的几种情况分析一下：</p>
<ol start="0">
<li><p>x就是目标节点。<br>那么就不用转了。</p>
</li>
<li><p>x是目标节点的子节点。<br>那我们直接转一下x就可以了。</p>
</li>
</ol>
<p>对于x的父亲也不是目标节点的情况，我们也分两种情况讨论。</p>
<ol start="2">
<li><p>x的父亲也不是目标节点，且x与其父亲的所在子树类型相同。<br>可以理解为x，x的父亲和x的父亲的父亲三个节点在一条直线上。<br>这样的话，我们就先旋转x的父节点，再旋转x。</p>
</li>
<li><p>x的父亲也不是目标节点，且x与其父亲的所在子树类型不同。<br>可以理解为x，x的父亲和x的父亲的父亲三个节点的连线是一条折线。<br>这样的话，我们旋转两次x。</p>
</li>
</ol>
<p>这样不断判断，直到x到达目标节点。</p>
<p>同时我们需要注意，因为我们根节点是随着我们的不断旋转而不断变化的，所以我们需要即使更新根节点的信息。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(tr[x].fa != k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = tr[x].fa, z = tr[y].fa;</span><br><span class="line">        <span class="keyword">if</span>(z != k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((tr[y].s[<span class="number">1</span>] == x) ^ (tr[z].s[<span class="number">1</span>] == y))</span><br><span class="line">                <span class="built_in">rotate</span>(x);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">rotate</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!k) rt = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h1><p>我们假设我们需要维护的是一棵可重序列的二叉搜索树。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>Splay的插入操作是比较复杂的。<br>假设我们需要向树中插入一个元素 $k$，那么我们分下列几种情况讨论：</p>
<ul>
<li>如果树是空的，那就直接插入根节点。</li>
<li>如果当前节点的权值等于 $k$，那就增加当前节点的大小，并更新其与其父亲的信息。</li>
<li>否则就按照二叉搜索树的性质继续向下面的节点查找。</li>
</ul>
<p>最后不要忘记将节点旋转到根。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[++idx].<span class="built_in">init</span>(k, <span class="number">0</span>);</span><br><span class="line">        rt = idx;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> p = rt, fa = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[p].v == k)</span><br><span class="line">        &#123;</span><br><span class="line">            tr[p].w++;</span><br><span class="line">            <span class="built_in">pushup</span>(p), <span class="built_in">pushup</span>(fa);</span><br><span class="line">            <span class="built_in">splay</span>(p, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fa = p;</span><br><span class="line">        p = tr[p].s[tr[p].v &lt; k];</span><br><span class="line">        <span class="keyword">if</span>(!p)</span><br><span class="line">        &#123;</span><br><span class="line">            tr[++idx].<span class="built_in">init</span>(k, fa);</span><br><span class="line">            tr[fa].s[tr[fa].v &lt; k] = idx;</span><br><span class="line">            <span class="built_in">pushup</span>(fa);</span><br><span class="line">            <span class="built_in">splay</span>(idx, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>Splay不使用惰性删除，其删除操作也是比较复杂的。<br>假设我们想要删除节点 $x$。</p>
<p>首先，我们将 $x$ 旋转到根。</p>
<p>然后我们分类讨论：</p>
<ul>
<li>如果 $x$ 的大小不为1，那就减少其大小。</li>
<li>否则直接合并其两棵子树。</li>
</ul>
<p>合并两棵树的操作很简单。如果我们假设需要合并的两棵树 $x$ 和 $y$ 中，$x$ 的最大值大于 $y$ 的话，只需要将的 $x$ 的最大值旋转到根，同时将 $y$ 设置为其根节点的右子树即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">loschn</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">get_rk</span>(k);</span><br><span class="line">    <span class="keyword">if</span>(tr[rt].w &gt; <span class="number">1</span>)<span class="comment">//节点内部包含多个相同元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[rt].w--;</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!tr[rt].s[<span class="number">0</span>] &amp;&amp; !tr[rt].s[<span class="number">1</span>])<span class="comment">//全树上下只剩这一个点了！</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[rt].<span class="built_in">clear</span>();</span><br><span class="line">        rt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!tr[rt].s[<span class="number">0</span>])<span class="comment">//没有左子树，这个点是整棵树最小的点了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p = rt;</span><br><span class="line">        rt = tr[rt].s[<span class="number">1</span>];</span><br><span class="line">        tr[rt].fa = <span class="number">0</span>;</span><br><span class="line">        tr[p].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!tr[rt].s[<span class="number">1</span>])<span class="comment">//没有右子树，这个点是整棵树最大的点了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p = rt;</span><br><span class="line">        rt = tr[rt].s[<span class="number">0</span>];</span><br><span class="line">        tr[rt].fa = <span class="number">0</span>;</span><br><span class="line">        tr[p].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一般情况</span></span><br><span class="line">    <span class="type">int</span> p = rt, x = <span class="built_in">precrs</span>();</span><br><span class="line">    tr[tr[p].s[<span class="number">1</span>]].fa = x;</span><br><span class="line">    tr[x].s[<span class="number">1</span>] = tr[p].s[<span class="number">1</span>];</span><br><span class="line">    tr[p].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查询k的排名"><a href="#查询k的排名" class="headerlink" title="查询k的排名"></a>查询k的排名</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_rk</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, p = rt;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &lt; tr[p].v)<span class="comment">//在左子树中</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = tr[p].s[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[p].s[<span class="number">0</span>])res += tr[tr[p].s[<span class="number">0</span>]].sz;</span><br><span class="line">            <span class="keyword">if</span>(k == tr[p].v)<span class="comment">//就是这个点了！</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">splay</span>(p, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//搜索右子树</span></span><br><span class="line">            res += tr[p].w;</span><br><span class="line">            p = tr[p].s[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查询排名为k的数"><a href="#查询排名为k的数" class="headerlink" title="查询排名为k的数"></a>查询排名为k的数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_k</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = rt;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[tr[p].s[<span class="number">0</span>]].sz &gt;= k)<span class="comment">//在左子树中</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = tr[p].s[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            k -= tr[p].w;</span><br><span class="line">            <span class="keyword">if</span>(tr[p].s[<span class="number">0</span>])k -= tr[tr[p].s[<span class="number">0</span>]].sz;</span><br><span class="line">            <span class="keyword">if</span>(k &lt;= <span class="number">0</span>)<span class="comment">//就是这个点了！</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">splay</span>(p, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> tr[p].v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//搜索右子树</span></span><br><span class="line">            p = tr[p].s[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查询k的前驱或后继"><a href="#查询k的前驱或后继" class="headerlink" title="查询k的前驱或后继"></a>查询k的前驱或后继</h2><p>前驱定义为小于这个数的最大数，后继定义为大于这个数的最小数。</p>
<p>我们的思路是，先将其插入进去，这样它就会到根节点；然后查询其左子树内的最大值或右子树内的最小值即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">precsr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = tr[rt].s[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">while</span>(tr[p].s[<span class="number">1</span>])p = tr[p].s[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">splay</span>(p, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">succsr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = tr[rt].s[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">while</span>(tr[p].s[<span class="number">0</span>])p = tr[p].s[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">splay</span>(p, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="维护可重有序序列"><a href="#维护可重有序序列" class="headerlink" title="维护可重有序序列"></a>维护可重有序序列</h2><p>洛谷<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzNjk=">板子题</span>，要求我们支持维护一个有序序列，并支持上面讲的六种操作。</p>
<p>示例代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3369/p3369_splay.cpp"><code>Luogu P3369-splay</code></a></p>
<h2 id="维护不可重序列，支持区间翻转"><a href="#维护不可重序列，支持区间翻转" class="headerlink" title="维护不可重序列，支持区间翻转"></a>维护不可重序列，支持区间翻转</h2><p>给个洛谷<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzOTE=">板子题</span>的代码:</p>
<p>它这里面要求区间翻转，那么我们在进行每一次旋转操作时，我们首先将左边界的前驱旋转至根节点，接着再把右边界的后继旋转至根节点的下面，此时右边界的后继的左子树就是我们所要翻转的区间了。<br>我们顺便增加一个<code>flag</code>标记，用来标记翻转次数。</p>
<p>示例代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3391/p3391.cpp"><code>Luogu P3391</code></a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>后缀自动机</title>
    <url>/OI/suffix-avtomat/</url>
    <content><![CDATA[<p>后缀自动机(SAM)。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>后缀自动机，是一个能够解决许多字符串相关问题的，十分强力的数据结构。<br>其存储的是一个字符串的所有子串。<br>不要被博客的链接迷惑了，后缀自动机是 <strong>S</strong>uffix <strong>A</strong>uto<strong>m</strong>aton 。<br>（博客标题来自俄语 Суффиксный автомат -&gt; Suffiksneyy avtomat）</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ol>
<li>后缀自动机是一个DAG。其中的节点叫做<strong>状态</strong>，边叫做<strong>转移</strong>。</li>
<li>图中包含一个初始节点 $t_0$ ，任何节点都可以由之经过一系列的转移到达。</li>
<li>每一个转移都标有一个字母，且从某一个节点出发的每一个转移都是不同的。</li>
<li>自动机存在多个终止状态。如果我们从初始状态 $t_0$ 出发，最终转移到了一个终止状态，则路径上的所有转移连接起来一定是字符串 $s$ 的一个后缀。 $s$ 的每个后缀均可用一条从 $t_0$ 到某个终止状态的路径构成。</li>
<li>在所有满足上述条件的自动机中，后缀自动机的结点数是最少的。</li>
</ol>
<h1 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h1><p>一个字符串的后缀自动机包含关于这个字符串子串的所有信息。<br>更准确地来说，对于任意从初始节点 $t_0$ 开始的路径，我们将其转移边上的字符拿下来按顺序排列，都可以得到原字符串的一个子串。<br>这里需要注意：一条路径对应一个子串，但是一个子串不一定只对应一条路径。</p>
<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><h2 id="结束位置-endpos-及其等价类"><a href="#结束位置-endpos-及其等价类" class="headerlink" title="结束位置 endpos 及其等价类"></a>结束位置 <code>endpos</code> 及其等价类</h2><p>对于字符串 $s$ 的一个子串 $t$ ，我们记其在字符串 $s$ 中的所有结束位置为 $\operatorname{endpos}(t)$ 。例如对于字符串 $aabbabd$ ，我们有 $\operatorname{endpos}(ab)&#x3D;\{ 2,4 \} $。<br>两个子串 $t_1$ 与 $t_2$ 的endpos集合可能相等。这样，所有字符串 $s$ 的非空子串都可以根据其endpos集合分为若干<strong>等价类</strong>。<br>后缀自动机中的每个状态都会对应一个等价类。</p>
<p>基于endpos，我们可以得到一系列重要结论：</p>
<blockquote>
<p><strong>引理1</strong>： 考虑两个非空子串 $u$ 与 $v$ （仍然假设 $|u| \leq |v|$ ）。两者的endpos满足这样的一个关系：<br>$$<br>\begin{cases}<br>\operatorname{endpos}(v) \subseteq \operatorname{endpos}(u) &amp; \text{if } u \text{ is a suffix of } v\\<br>\operatorname{endpos}(v) \cap \operatorname{endpos}(u) &#x3D; \varnothing &amp; \text{otherwise}<br>\end{cases}<br>$$</p>
</blockquote>
<p>证明：如果 $\operatorname{endpos}(u) \cap \operatorname{endpos}(v) \neq \varnothing$ ，那么结合我们刚刚证明完的引理1，我们可以知道 $u$ 是 $v$ 的一个后缀。既然 $u$ 是 $v$ 的一个后缀了，那么对于所有 $v$ 出现的地方， $u$ 也会出现，即 $\operatorname{endpos}(u) \subseteq \operatorname{endpos}(v)$ 。而如果 $u$ 的长度小于 $v$ 且 $u$ 还不是 $v$ 的后缀，那么 $v$ 出现的地方 $u$ 一定不会出现，即 $\operatorname{endpos}(u) \cap \operatorname{endpos}(v) &#x3D; \varnothing$ 。</p>
<blockquote>
<p><strong>引理2</strong>: 对于任意一个endpos等价类（或者一个状态），其包含的子串集合是最长子串的连续后缀。</p>
</blockquote>
<p>证明：我们考虑等价类中两个子串：最长的，记为 $u$ ；最短的，记为 $v$ 。如果 $u&#x3D;v$ 那么显然不用证明。如果不是，那么对于长度在区间 $[|u|,|v|]$ 内的子串，必定存在子串有 $v$ 为后缀且同时为 $u$ 的后缀。</p>
<h2 id="后缀链接-link"><a href="#后缀链接-link" class="headerlink" title="后缀链接 link"></a>后缀链接 <code>link</code></h2><p>根据引理3，我们可以知道对于任意状态，其中包含的字串都是其中最长子串的一段连续后缀。这段连续后缀不一定可以覆盖 $[ 1,|\text{最长子串}| ]$ 这一整个区间，但一定是连续的。<br>我们可以将其看做是不断将最长子串的首个字符删去得到子串的一个过程。</p>
<p>而当我们不断删去，直到删去最短子串的首个字符的时候，我们会发现我们已经离开了这个状态。<br>我们可以根据这样一个走向创建一系列的新边。<br>这些新边就被称为link边，也叫做后缀链接。<br>有些地方也叫fa&#x2F;father边。 </p>
<blockquote>
<p><strong>引理4</strong>： 所有后缀链接构成一棵根节点为 $t_0$ 的树。</p>
</blockquote>
<p>证明：根据后缀链接的定义及引理3，我们可以看出，当前状态的后缀链接到达的是严格更短的字符串。而沿着后缀链接走，最后总能到达代表着空字符串的 $t_0$ 。</p>
<p>我们将后缀链接与endpos关联一下。<br>根据引理2，我们可以得出，两个endpos等价类不是互相包含，就是互不相交。根据这个包含关系，我们可以列出一棵endpos等价类的树。<br>对应在后缀自动机上就是对状态建树。</p>
<blockquote>
<p><strong>引理5</strong>： 通过 $\operatorname{endpos}$ 集合构造的树（每个子节点的子集都包含在父节点的子集中）与通过后缀链接构造的树相同。</p>
</blockquote>
<p>证明：是树的证明上面有了，我们看一下对于两者相同的证明。<br>考虑任意非 $t_0$ 的状态 $u$ 及其后缀链接 $\operatorname{link}(u)$ 。根据引理2和后缀链接的定义，我们可以知道 $\operatorname{endpos}(u) \varsubsetneqq \operatorname{endpos}(\operatorname{link}(u))$ 。这样，我们在建树的时候，就会在 $u$ 与 $\operatorname{link}(u)$ 之间连一条边。</p>
<h1 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h1><p>下面是对字符串 $aabbabcd$ 构建后缀自动机得到的结果。<br>其中，蓝色(#1453AD)的边代表的是转移，绿色(#14AD53)的边代表的是后缀链接。<br>蓝色(#1453AD)的点代表状态，紫色(#AD1453)的点代表终止状态。</p>
<p><img src="/pics/SAM.svg" alt="SAM"></p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>构建后缀自动机的算法是个<strong>在线</strong>算法。我们逐个加入字符串中的每个字符，并在每一步中相应地维护刚刚得到的后缀自动机。<br>为了保证线性的空间复杂度，我们只保存<code>len</code>与<code>link</code>的值。终止状态的值可以在构建完自动机之后求出。</p>
<p>在最开始，整个后缀自动机只会包含一个节点： $t_0$ ，编号为0。我们指定<code>len[0] = 0</code>，<code>link[0] = -1</code>。这里的$-1$表示的是一个虚拟的状态。<br>然后我们就可以向后缀自动机内添加字符了。</p>
<p>我们向后缀自动机内添加一个字符 $c$ 的算法流程如下：</p>
<p>我们令<code>last</code>为先前对应整个字符串的状态（一开始我们设<code>last = 0</code>）。</p>
<p>创建一个新的状态<code>cur</code>，并使<code>len[cur] = len[last] + 1</code>。</p>
<p>从状态<code>last</code>开始，不断遍历后缀链接。<br>如果还没有到字符 $c$ 的转移，我们就添加一个指向<code>cur</code>的转移。<br>如果在某个点已经存在到字符 $c$ 的转移，我们就停下来，并将这个状态记为<code>p</code>。<br>如果没有找到这样的状态<code>p</code>，我们最终会到达虚拟状态$-1$，这时我们使<code>link[cur] = 0</code>并退出。</p>
<p>如果我们找到了一个状态<code>p</code>，其可以通过字符 $c$ 转移，我们将这样转移到的状态标记为<code>q</code>。<br>现在我们考虑我们找到的<code>q</code>是否满足<code>len[p] + 1 = len[q]</code>这个条件。</p>
<p>如果满足，那么我们就只需要使<code>link[cur] = q</code>并退出。</p>
<p>如果不满足，那么情况就会变得复杂。<br>我们需要复制一个状态<code>q</code>，标记为<code>nq</code>。<code>nq</code>将会获得<code>q</code>除了<code>len</code>以外的所有信息。我们将<code>len[nq]</code>赋值为<code>len[p] + 1</code>。之后，我们使<code>link[cur] = link[q] = nq</code>。<br>之后，使用后缀链接从<code>p</code>往回走，并把沿途所有指向<code>q</code>的转移重定向至<code>nq</code>。</p>
<p>最后，我们将<code>last</code>的值更新为<code>cur</code>。</p>
<h3 id="寻找终止状态"><a href="#寻找终止状态" class="headerlink" title="寻找终止状态"></a>寻找终止状态</h3><p>如果我们还想要知道哪些状态是终止状态而那些不是，我们可以在构建完 $s$ 对应的后缀自动机之后再进行寻找。</p>
<p>我们从刚才最后一步得到的<code>last</code>处开始遍历后缀链接，直到最终到达初始节点。<br>我们将沿途的所有状态都标记为终止状态，因为他们存储着原字符串 $s$ 的至少一个后缀。</p>
<h3 id="类比"><a href="#类比" class="headerlink" title="类比"></a>类比</h3><p>在课上听到了一个将后缀Trie和SAM进行类比的点子。<br>其核心思想就是通过压缩后缀Trie，使得其变成SAM的样子。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM4MDQ=">洛谷板子题</span>代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3804/p3804.cpp"><code>Luogu P3804</code></a></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>见<span class="exturl" data-url="aHR0cHM6Ly9vaS13aWtpLm9yZy9zdHJpbmcvc2FtLyNfMTM=">OIwiki</span>。</p>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>字符串</tag>
        <tag>自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/OI/tree-array/</url>
    <content><![CDATA[<p>简介： 树状数组</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><p>一种神奇的数据结构。</p>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>当我们想要对一个数组进行单点加时，我们可以选择使用普通数组，时间复杂度是 $O(1)$；<br>当我们想要对一个数组进行区间求和时，我们可以选择使用前缀和数组，时间复杂度也是 $O(1)$；</p>
<p>但是，前缀和数组在进行单点加时，时间复杂度是 $O(n)$ ；<br>而普通数组在进行区间求和时，时间复杂度也是 $O(n)$ ；</p>
<p>我们能不能设计出一个数据结构，让我们在进行这两个操作时牺牲某一个操作的时间复杂度，而减少了另一个操作的时间复杂度呢？</p>
<p>于是，树状数组就应运而生。</p>
<h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h2><p>树状数组的存储原理是这个样子的：</p>
<p>我们称原数组为 $a[i]$ ，我们正常所输入的数据就存储在这里。</p>
<p>在原数组 $a[i]$ 的基础上，我们创建一个新的数组 $c[i]$ 。<br>数组 $c[i]$ 是以这个规则存储信息的：</p>
<p>我们先列出所有的数组下标：</p>
<p><img src="https://i.loli.net/2021/10/14/w8Q9VlYpkiRZOuK.png" alt="树状数组1.png"></p>
<p>接下来我们开始考虑数字的 $lowbit$ 。</p>
<p>所有奇数的 $lowbit$ 都是1。<br>我们在第一层标记上 $lowbit$ 为1的所有数字：</p>
<p><img src="https://i.loli.net/2021/10/14/etBbyiMgNhHA2zQ.png" alt="树状数组2.png"></p>
<p>接下来，我们依次标上数字的 $lowbit$ ：</p>
<p><img src="https://i.loli.net/2021/10/14/7J41bdLejGiP9wF.png" alt="树状数组3.png"></p>
<p><img src="https://i.loli.net/2021/10/14/vCznWK9uGPhIwO8.png" alt="树状数组4.png"></p>
<p><img src="https://i.loli.net/2021/10/14/j1TmJIP9xBknas5.png" alt="树状数组5.png"></p>
<p>最后，我们再进行一下延长，每一个块向左延长至长度为 $2^{lowbit(i)}$ 。</p>
<p><img src="https://i.loli.net/2021/10/14/PAUqE1a8D6CGh3d.png" alt="树状数组6.png"></p>
<p>我们对块进行一下标号：</p>
<p><img src="https://i.loli.net/2021/10/14/r8mtGfDANz2XWHv.png" alt="树状数组7.png"></p>
<p>这些绿色的块里面存储的是其下方所有数字的和。</p>
<p>当然，我们进行值的更新的时候，不可能一个一个加起来再更新，这样复杂度又回到了原先的样子。</p>
<p>我们更新时遵循的是这样一个路线：</p>
<p><img src="https://i.loli.net/2021/10/14/JWnIe5SftkZjpL7.png" alt="树状数组8.png"></p>
<p>因为每一个数有 $\log (n)$ 位，所以最终两个操作的时间复杂度都是 $O(\log n)$ 。</p>
<h2 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h2><div class="tabs" id="model"><ul class="nav-tabs"><li class="tab active"><a href="#model-1">Luogu板子题1</a></li><li class="tab"><a href="#model-2">Luogu板子题2</a></li></ul><div class="tab-content"><div class="tab-pane active" id="model-1"><p>Luogu P3374 【模板】 树状数组1：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzNzQ=">https://www.luogu.com.cn/problem/P3374</span></p>
<p>示例代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3374/p3374.cpp"><code>Luogu P3374</code></a></p></div><div class="tab-pane" id="model-2"><p>Luogu P3368 【模板】 树状数组2：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzNjg=">https://www.luogu.com.cn/problem/P3368</span></p>
<div class="note info"><p>思路：维护差分序列，而不是原序列。</p>
</div>

<p>示例代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3368/p3368.cpp"><code>Luogu P3368</code></a></p></div></div></div>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie 与 AC自动机</title>
    <url>/OI/trie-and-AK-avtomat/</url>
    <content><![CDATA[<p>Trie树（字典树）与AC自动机。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h1><p>Trie树，又称字典树，是一种数据结构。</p>
<p>Trie树可以存储大量不同的字符串，同时支持对其以 $O(|S|)$ 的复杂度进行查询。</p>
<p>首先我们可以放一张图上来：</p>
<p><img src="https://s2.loli.net/2022/04/06/DjtOJRCaSzxwZAB.png" alt="trie1.png"></p>
<p>这就是我们向Trie中顺序插入了aa,aba,ba,bbc,bca,caba,cba,cc八个字符串之后的结果。</p>
<p>我们可以发现，Trie使用边来代表字母，而用点来表示字符串。<br>某一个点表示的字符串就是从根节点到该节点的路径上的字母顺序排列组合而成的字符串。<br>比如说17号节点就代表着cba这一个字符串。</p>
<p><img src="https://s2.loli.net/2022/04/06/udZE5v41asjfBYh.png" alt="trie2.png"></p>
<p>每一个点虽说都代表着一个字符串，但是这个字符串不一定被插入过。我们将实际上有的字符串进行了标红。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>我们将每一个节点存储到一个结构体里面：</p>
<div class="tabs" id="struct"><ul class="nav-tabs"><li class="tab active"><a href="#struct-1">数组</a></li><li class="tab"><a href="#struct-2">指针</a></li></ul><div class="tab-content"><div class="tab-pane active" id="struct-1"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">trie</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">&#125;tr[N];</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="struct-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">trie</span></span><br><span class="line">&#123;</span><br><span class="line">    trie *s[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">&#125;tr[N];</span><br></pre></td></tr></table></figure></div></div></div>

<p>这里 <code>s</code> 数组的大小是根据字符集的大小来定的，一般情况下是小写字母集，所以这里填的是26。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>具体思想就是，如果当前节点的下一位所对应的儿子非空就跳到对应的儿子，是空的那就新建一个儿子。</p>
<div class="tabs" id="insert"><ul class="nav-tabs"><li class="tab active"><a href="#insert-1">数组</a></li><li class="tab"><a href="#insert-2">指针</a></li></ul><div class="tab-content"><div class="tab-pane active" id="insert-1"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[u].s[s[i] - <span class="string">&#x27;a&#x27;</span>] != <span class="number">0</span>)u = tr[u].s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tr[u].s[s[i] - <span class="string">&#x27;a&#x27;</span>] = ++idx;</span><br><span class="line">            u = idx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tr[u].cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="insert-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *u = &amp;tr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>] != <span class="number">0</span>)u = u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>] = &amp;tr[++idx];</span><br><span class="line">            u = u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    u-&gt;cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除这个操作使用的范围不是很广。具体思想就是将对应我们想要删除的字符串的点的<code>cnt</code>值减去1即可。</p>
<div class="tabs" id="loeschen"><ul class="nav-tabs"><li class="tab active"><a href="#loeschen-1">数组</a></li><li class="tab"><a href="#loeschen-2">指针</a></li></ul><div class="tab-content"><div class="tab-pane active" id="loeschen-1"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">loeschen</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">        u = tr[u].s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    tr[u].cnt--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="loeschen-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">loeschen</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *u = &amp;tr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">        u = u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    u-&gt;cnt--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>查询操作的思想就是，不断从根节点沿着字符串跳，直到调到空节点或者跳完整个字符串为止。</p>
<div class="tabs" id="chq"><ul class="nav-tabs"><li class="tab active"><a href="#chq-1">数组</a></li><li class="tab"><a href="#chq-2">指针</a></li></ul><div class="tab-content"><div class="tab-pane active" id="chq-1"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">chq</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[u].s[s[i] - <span class="string">&#x27;a&#x27;</span>] != <span class="number">0</span>)u = tr[u].s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tr[u].cnt &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="chq-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">chq</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *u = &amp;tr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>] != <span class="number">0</span>)u = u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u-&gt;cnt &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="全部加起来"><a href="#全部加起来" class="headerlink" title="全部加起来"></a>全部加起来</h3><div class="tabs" id="all"><ul class="nav-tabs"><li class="tab active"><a href="#all-1">数组</a></li><li class="tab"><a href="#all-2">指针</a></li></ul><div class="tab-content"><div class="tab-pane active" id="all-1"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">trie</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[u].s[s[i] - <span class="string">&#x27;a&#x27;</span>] != <span class="number">0</span>)u = tr[u].s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tr[u].s[s[i] - <span class="string">&#x27;a&#x27;</span>] = ++idx;</span><br><span class="line">            u = idx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tr[u].cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loeschen</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">        u = tr[u].s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    tr[u].cnt--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">chq</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[u].s[s[i] - <span class="string">&#x27;a&#x27;</span>] != <span class="number">0</span>)u = tr[u].s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tr[u].cnt &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="all-2"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">trie</span></span><br><span class="line">&#123;</span><br><span class="line">    trie *s[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *u = &amp;tr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>] != <span class="number">0</span>)u = u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>] = &amp;tr[++idx];</span><br><span class="line">            u = u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    u-&gt;cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loeschen</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *u = &amp;tr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">        u = u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    u-&gt;cnt--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">chq</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *u = &amp;tr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>] != <span class="number">0</span>)u = u-&gt;s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u-&gt;cnt &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>Luogu P2580：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI1ODA=">https://www.luogu.com.cn/problem/P2580</span></p>
<p>参考代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p2000-p2999/p2580/p2580.cpp"><code>Luogu P2580</code></a></p>
<h2 id="01-Trie"><a href="#01-Trie" class="headerlink" title="01-Trie"></a>01-Trie</h2><p>01-Trie是Trie的一种变体。其字符集不是一般见到的Trie的小写字符集，而是 $\lbrace 0,1 \rbrace$。</p>
<p>由于01-Trie的字符集仅限于0和1，所以它被人们用来处理一些与位运算有关的东西，比如说异或和或者集合内数字两两异或的极值什么的。</p>
<h3 id="异或极值"><a href="#异或极值" class="headerlink" title="异或极值"></a>异或极值</h3><p>我们假定我们需要维护这样一个操作：<br>给出一个集合 $A$，再给出一个数 $k$，我们需要在集合内找到一个数 $a_i$，使之与 $k$ 的异或值最大（或最小）。</p>
<p>因为异或操作就是将两个数按照二进制逐位进行比对，相同为0，不同为1，所以我们就可以将上文提到的那个集合 $A$ 内的所有数根据二进制位分解之后再插入Trie中。</p>
<p>然后我们就像查找字符串一样，将 $k$ 进行二进制分解后得到的01串放进去匹配。<br>如果我们需要的是异或最小值的话，就按照正常查找字符串的方式跳。<br>如果我们需要的是异或最大值的话，就让每一次跳儿子的时候跳到与当前位置不同的儿子。</p>
<p>我们还需要注意一点，就是我们需要保证这棵Trie的深度与数据范围的最大二进制位数一致。</p>
<p>由于我们是从高位到低位建的，而高位远比低位重要，所以我们就可以大胆贪心，能跳就跳，不能跳就跳到相反的那个儿子上。而且我们保证了Trie的高度是一定的，这就保证了我们一定可以跳到底。</p>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQ1NTE=">Luogu P4551 最长异或路径</span></p>
<p>参考代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p4000-p4999/p4551/p4551.cpp"><code>Luogu P4551</code></a></p>
<h2 id="可持久化Trie"><a href="#可持久化Trie" class="headerlink" title="可持久化Trie"></a>可持久化Trie</h2><p>有的时候题目要求我们能够随时访问某个历史版本，或甚至回溯到某个历史版本并对其进行修改。</p>
<p>暴力的做法是每一次都开一个新的Trie。</p>
<p>这时候，我们就可以将Trie持久化以完成这些题目的要求。</p>
<p>之前我们每一次插入的时候都是从根节点开始的，添加的字符串也是一条从根节点开始的路径，所以我们每一次插入只需要增加新的一整条路径，并把这条路径与上一个版本中未被更新的部分连接上即可。</p>
<h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h4><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjU4Lw==">AcWing 256. 最大异或和</span></p>
<p>参考代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/AcWing/256/ac256.cpp"><code>AcWing 256</code></a></p>
<h1 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h1><p>这个AC自动机啊，他是 Aho-Corasick Automaton，不是什么Automation。</p>
<p>（博客的标题来自于俄语 Ахо-Корасик автомат -&gt; Aho-Korasik avtomat）</p>
<p>AC自动机就像是Trie和KMP的结合。<br>AC自动机基于的是Trie，同时其匹配字符串时的行为与KMP有异曲同工之妙。</p>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><h3 id="改造-Trie"><a href="#改造-Trie" class="headerlink" title="改造 Trie"></a>改造 Trie</h3><p>这是一个简单的Trie结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">trie</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">&#125;tr[N];</span><br></pre></td></tr></table></figure>

<p>对于KMP算法，我们是根据前缀函数来对字符串匹配进行优化的。<br>而对于Trie呢？</p>
<h3 id="fail指针"><a href="#fail指针" class="headerlink" title="fail指针"></a>fail指针</h3><p>我们考虑使用前缀函数的原因：</p>
<blockquote>
<p>我们需要找到一个前缀，在保证其与某个后缀相等的前提下，使得当前匹配的进度最大地保留下来。</p>
</blockquote>
<p>把同样的思想挪到Trie树上，我们需要找的就是：</p>
<blockquote>
<p>我们需要找到一个节点，其代表的字符串是当前节点代表的字符串的最长后缀。</p>
</blockquote>
<p>于是，我们就可以根据这样的情况来构建fail指针。</p>
<p>举个例子：</p>
<p>如下图，是依次向Trie树中添加he,his,him,her,hers,they,them,their,theirs,she的结果：</p>
<p><img src="https://s2.loli.net/2022/04/07/2QdAr9Jchl4tunG.png" alt="AC1-1.png"></p>
<p>然后我们开始依次构建fail指针。</p>
<p>我们利用BFS来帮助我们构建fail指针。</p>
<p>考虑一个已经构建了fail指针的节点 $u$，其对应字符 $c$ 的儿子 $s[u][c]$ 的fail指针的构建遵循下列原则：</p>
<ol>
<li>如果 $s[fail[u]][c]$ 存在，则让 $s[u][c]$ 的fail指针指向 $s[fail[u]][c]$。这样相当于是在 $u$ 和 $fail[u]$ 后面加一个字符 $c$，分别对应 $s[u][c]$ 和 $s[fail[u]][c]$。</li>
<li>如果 $s[fail[u]][c]$ 不存在，那么我们就递归寻找 $s[fail[fail[u]]][c]$，并重复上面的判断过程，直到跳到根节点。</li>
<li>如果真的什么都没有了，那就让 $s[u][c]$ 的fail指针指向根节点。</li>
</ol>
<p>下图中用不同的颜色来区分不同状态的边、点：</p>
<p>#FF9955 代表在队列中，等待构建fail指针的点；<br>#FFCC00 代表正在构建fail指针的点；<br>#AAD400 代表已经构建完fail指针的点；</p>
<p>#FF0000 代表正在构建的fail指针；<br>#FFDD55 代表已经构建完成的fail指针。</p>
<p><img src="/pics/AC2.gif" alt="AC2.gif"></p>
<p>最终效果图：</p>
<p><img src="https://s2.loli.net/2022/04/08/up7tvA28h9R3E5a.png" alt="AC2-38.png"></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct trie</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int s[26];</span></span><br><span class="line"><span class="comment">    int cnt;</span></span><br><span class="line"><span class="comment">    int fail;</span></span><br><span class="line"><span class="comment">&#125;tr[N];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_fail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(tr[<span class="number">0</span>].s[i])q.<span class="built_in">push</span>(tr[u].s[i]);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[u].s[i])</span><br><span class="line">            &#123;</span><br><span class="line">                tr[tr[u].s[i]].fail = tr[tr[u].fail].s[i];</span><br><span class="line">                q.<span class="built_in">push</span>(tr[u].s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tr[u].s[i] = tr[tr[u].fail].s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码可能与我们刚才的叙述有部分出入，原因是这份代码做了些许优化。<br>事实证明这些优化虽然会修改Trie的结构，使之由树变为图，但是对我们存储的信息是有利无害的。</p>
<p>我们首先将根节点的所有儿子入队。<br>如果我们第一步将根节点入队的话，会导致根节点的所有子节点的fail指针指向自己，而不是指向根节点。</p>
<p>然后是遍历在队列中的节点。<br>对于其非空的儿子，我们照常构建fail指针。由于当前节点的fail指针已经构建完毕，且沿着fail指针形成的通往根节点的链上的所有节点都已经构建完毕了，所以我们直接指向当前节点的fail指针指向的节点的所对应的儿子。如果有这个儿子的话就指向他，如果没有的话就相当于是指向根节点。</p>
<p>然后我们将当前节点的部分空儿子指向当前节点的fail指针指向的节点的对应儿子上。<br>原因就是，反正也是失配了，与其花时间判失配跳fail指针再访问，不如直接访问我们想要它到的节点。<br>所以我们在匹配的时候一直走（结构体意义上的）树边，直到整个跑完就可以了。</p>
<p>照这样建完fail指针之后，我们会将原先的Trie树变为一张“Trie图”。</p>
<p>由于边太多太密，我就不画了。可能会补上一张CSAcademy的图。<br>（太糊了，感觉会不久后撤下，就先存本地了）</p>
<p><img src="/pics/AC3.png"></p>
<p>（这是原数据）</p>
<p><img src="/pics/AC4.png"></p>
<p>（这是图）</p>
<h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><p>匹配的思路是这个样子的：</p>
<ol>
<li>沿着Trie图的边跳，直到遍历完整个字符串为止。<br> 由于我们在之前已经将Trie树改造为了Trie图，且fail指针已经在某种意义上失去了其作为失配指针的意义，所以我们只需要跳Trie图内的边即可。</li>
<li>每走到一个节点，就沿着当前节点的fail指针累加答案。<br> 由于fail边跳到的是当前字符串在Trie内存在的最长后缀，且如果当前的模式串出现在了文本串内的话，其子串也会出现在文本串内，所以我们可以沿着fail指针一路遍历当前模式串的所有后缀。</li>
</ol>
<p>这里有一份对于多模式串匹配，且允许模式串多次被统计的，用来统计所有模式串的总出现次数的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u = tr[u].s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = u; j &gt; <span class="number">0</span>; j = tr[j].fail)</span><br><span class="line">            res += tr[j].cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>res</code>是所有模式串的总出现次数。</p>
<h2 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM4MDg=">P3808 【模板】 AC 自动机（简单版）</span></p>
<p>参考代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3808/p3808.cpp"><code>Luogu P3808</code></a></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM3OTY=">P3796 【模板】 AC 自动机（加强版)</span></p>
<p>参考代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3796/p3796.cpp"><code>Luogu P3796</code></a></p>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>字符串</tag>
        <tag>自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>虚树</title>
    <url>/OI/virtual-tree/</url>
    <content><![CDATA[<p>虚树。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<p>虚树，顾名思义，是一棵树。</p>
<p>有时候题目给的树太大了，同时每一次处理询问的时候总会有大量的不可避免的冗余信息需要处理，这时候就需要我们对当前的树建立一棵虚树来选择性地忽略掉一些不重要的信息，进而减小了时间复杂度。</p>
<p>一般需要建立虚树的题目会在树上选择出几个关键点进行询问，而不关心其它的信息。同时我们还可以注意到，关键点的个数一般是与树的大小是同阶的（即在同一个数量级内）。这指的是，假如我们每一次询问的关键点个数是 $k_i$ 个，一共有 $m$ 次询问，那么 $\log_{10} (\sum k_i) &#x3D; \log_{10} n$。</p>
<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>比如说这道题：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI0OTU=">Luogu P2495</span> [SDOI2011] 消耗战</p>
<p>这一道题需要我们找到使所有关键点都不与根节点连接的割边方案，并且需要使这个割边方案中边的权值和最小。</p>
<p>对于这个问题，我们有一套经典的DP方案：</p>
<p>设 $dp[u]$ 表示使编号为 $u$ 的点不与其子树中任意一个关键点联通的最小代价。</p>
<p>设 $w(i,j)$ 表示连接 $i$ 与 $j$ 的边的权值。</p>
<p>那么我们可以枚举 $u$ 的儿子 $v$：</p>
<ul>
<li>若 $v$ 不是关键点，那么 $dp[u]&#x3D;dp[u]+\min(dp[v],w(u,v))$；</li>
<li>若 $v$ 是关键点，那么 $dp[u]&#x3D;dp[u]+w(u,v)$。</li>
</ul>
<p>单次DP的时间复杂度是 $O(n)$ 的。因为题目给出了 $m$ 次询问，并且每一次询问时关键点的信息还会改变，所以我们每一次询问的时候必须得重新DP一遍，这让我们总体的时间复杂度成为了 $O(nm)$。</p>
<p>然后看题目要求：</p>
<blockquote>
<p>对于 $100\%$ 的数据，$2\leq n \leq 2.5\times 10^5, 1\leq m\leq 5\times 10^5, \sum k_i \leq 5\times 10^5$。</p>
</blockquote>
<p>我们一眼就可以看出来以 $O(nm)$ 的复杂度是绝对过不去的。</p>
<p>经试验验证(LibreOJ)，以下面的代码可以跑出来50分的好成绩：<span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcy8xNDc2ODM0">提交寄录</span></p>
<h1 id="虚树"><a href="#虚树" class="headerlink" title="虚树"></a>虚树</h1><p>我们重新来看一遍DP的过程。</p>
<p>我们在枚举某一个节点的所有儿子的时候，假设这个节点 $u$ 下面的子树内没有一个关键点，那么这个DP的过程就是冗余的。</p>
<p>既然我们不需要 $u$ 及其子树的信息了，那么它也就没有了继续存在于图内的必要了。</p>
<p>而如果 $u$ 下面的子树内有关键点，那么他也不一定能留下。</p>
<p>鉴于我们只关心关键点之间的连通性，我们关心的只有两类点：一是关键点，二是可能是两个关键点的LCA的点。<br>前者的数量是给定的，而后者只会在树分叉的地方出现，数量不会大于关键点的个数。</p>
<p>我们就可以对这两种点建立一棵新的树，而树上的边权就是我们关心的信息——在这道题内就是两端点在原树上的路径中的最小边权。</p>
<p>然后我们就可以对着明显缩水了的树进行DP了。</p>
<p>如果我们使用正确的求LCA算法的话（比如 $O(\log n)$ 的树剖），我们的时间复杂度就是 $O(\log \sum k_i)$ 了。</p>
<p>而由于 $\sum k_i$ 与 $n$ 同阶，所以我们可以近似的将我们的时间复杂度看为 $O(n \log n)$。</p>
<h1 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h1><p>既然有了思想，我们就可以着手建立虚树了。</p>
<p>我们当然不可能逐个枚举关键点的LCA并加进去来建立，这样的复杂度仍然是 $O(k^2)$ 级别的，我们无法接受。</p>
<p>我们需要尝试将这个算法优化，至少优化到 $O(k)$ 级别（不算LCA的 $O(\log n)$），这样我们才能够通过上面的数据范围。</p>
<p>自己手模一下，可以发现LCA只会在树分叉的地方出现，所以我们只需要维护树分叉的地方就可以了。</p>
<p>那怎么维护呢？</p>
<p>我们可以尝试维护极右链。</p>
<p>对于这样的一棵树：</p>
<img src="https://s2.loli.net/2022/06/06/MWQe1lCIjOadpfs.png" alt="vt1.png" width="50%" />

<p>现在它的极右链是这块红色的链：</p>
<img src="https://s2.loli.net/2022/06/06/8hxmdLiXeOlfGtQ.png" alt="vt2.png" width="50%" />

<p>那么假设我们最后的点是这个红色点，美剧导的下一个点是这个蓝色的点：</p>
<img src="https://s2.loli.net/2022/06/06/oEYqybwUDK7VZGg.png" alt="vt3.png" width="50%" />

<p>蓝色的点向上到根节点的路径有与之前已经建好了的树重合的部分，也有之前没有出现过的部分（蓝色的链）。</p>
<p>我们把这个点加入树中的同时，还需要加入它与之前的极右链中的交点，即其与上一个关键点的LCA。</p>
<p>然后，最新的极右链就是这个：</p>
<img src="https://s2.loli.net/2022/06/06/VsBZlrqPUDuJweT.png" alt="vt4.png" width="50%" />

<p>为了保证不会损坏虚树的结构，首先我们将所有的关键点按照DFS序来排序，保证逐个遍历的时候不会有新的关键点出现在当前极右链的左边。</p>
<p>然后我们使用栈来维护遍历的顺序，就像我们DFS时的系统栈一样，记录下之前遍历的点。</p>
<p>下面的代码里面的注释就是对该步骤的解释：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v.<span class="built_in">init</span>();<span class="comment">//清空链式前向星</span></span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + k, cmp);<span class="comment">//将关键点按照DFS序排序</span></span><br><span class="line">    sta[tt = <span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//1号节点入栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> g = <span class="built_in">lca</span>(a[i], sta[tt]);</span><br><span class="line">        <span class="comment">//拎出来当前节点与栈顶节点在原树上的LCA</span></span><br><span class="line">        <span class="keyword">if</span>(g != sta[tt])</span><br><span class="line">        &#123;<span class="comment">//如果LCA不是栈顶的节点，就意味着当前节点不在当前节点所维护的链上</span></span><br><span class="line">            <span class="keyword">while</span>(id[g] &lt; id[sta[tt - <span class="number">1</span>]])</span><br><span class="line">            &#123;<span class="comment">//当次大节点的DFS序大于LCA的DFS序</span></span><br><span class="line">                <span class="type">int</span> p = sta[tt - <span class="number">1</span>], q = sta[tt--];</span><br><span class="line">                ll d = <span class="built_in">minpath</span>(p, q);</span><br><span class="line">                v.<span class="built_in">add</span>(p, q, d);</span><br><span class="line">                v.<span class="built_in">add</span>(q, p, d);</span><br><span class="line">                <span class="comment">//那就说明栈顶节点不需要再维护了</span></span><br><span class="line">                <span class="comment">//连边，弹栈</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(id[g] &gt; id[sta[tt - <span class="number">1</span>]])</span><br><span class="line">            &#123;<span class="comment">//如果LCA不是次大节点</span></span><br><span class="line">                ll d = <span class="built_in">minpath</span>(g, sta[tt]);</span><br><span class="line">                v.<span class="built_in">add</span>(g, sta[tt], d);</span><br><span class="line">                v.<span class="built_in">add</span>(sta[tt], g, d);</span><br><span class="line">                tt--;</span><br><span class="line">                sta[++tt] = g;</span><br><span class="line">                <span class="comment">//那就说明LCA从来没有在栈内出现过</span></span><br><span class="line">                <span class="comment">//与栈顶元素连边并弹出之</span></span><br><span class="line">                <span class="comment">//然后就入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;<span class="comment">//否则LCA就是次大节点</span></span><br><span class="line">                <span class="type">int</span> p = sta[tt - <span class="number">1</span>], q = sta[tt--];</span><br><span class="line">                ll d = <span class="built_in">minpath</span>(p, q);</span><br><span class="line">                v.<span class="built_in">add</span>(p, q, d);</span><br><span class="line">                v.<span class="built_in">add</span>(q, p, d);</span><br><span class="line">                <span class="comment">//直接连边弹栈即可，不用入栈了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sta[++tt] = a[i];<span class="comment">//当前节点入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(tt &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;<span class="comment">//将剩下的最后一条极右链连接起来</span></span><br><span class="line">        <span class="type">int</span> p = sta[tt - <span class="number">1</span>], q = sta[tt];</span><br><span class="line">        ll d = <span class="built_in">minpath</span>(p, q);</span><br><span class="line">        v.<span class="built_in">add</span>(p, q, d);</span><br><span class="line">        v.<span class="built_in">add</span>(q, p, d);</span><br><span class="line">        tt--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以愉快地在虚树上进行dp了，方法与之前一样。</p>
<p>现在我们的复杂度大大减小，就可以拿到——80分的好成绩！<span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcy8xNDc2NjAy">提交寄录</span></p>
<p>然后我们就不理解了。</p>
<p>我的理论复杂度也是对的，应该没有什么问题。</p>
<p>我们回忆一下我们代码的实现：</p>
<p>我们在每一次建立虚树之前，都把整个链式前向星都清空了一遍。</p>
<p>这时我们可以再懒一点，我们可以不需要清空链式前向星，只需要将每一个入栈的节点在入栈的时候清空该节点的表头即可。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">void build()</span><br><span class="line">&#123;</span><br><span class="line"><span class="deletion">-   v.init();</span></span><br><span class="line"><span class="addition">+   v.idx = 0;</span></span><br><span class="line">    sort(a + 1, a + 1 + k, cmp);</span><br><span class="line">    sta[tt = 1] = 1;</span><br><span class="line"><span class="addition">+   v.h[1] = -1;</span></span><br><span class="line">    for(int i = 1; i &lt;= k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int g = lca(a[i], sta[tt]);</span><br><span class="line">        if(g != sta[tt])</span><br><span class="line">        &#123;</span><br><span class="line">            while(id[g] &lt; id[sta[tt - 1]])</span><br><span class="line">            &#123;</span><br><span class="line">                int p = sta[tt - 1], q = sta[tt--];</span><br><span class="line">                ll d = minpath(p, q);</span><br><span class="line">                v.add(p, q, d);</span><br><span class="line">                v.add(q, p, d);</span><br><span class="line">            &#125;</span><br><span class="line">            if(id[g] &gt; id[sta[tt - 1]])</span><br><span class="line">            &#123;</span><br><span class="line">                ll d = minpath(g, sta[tt]);</span><br><span class="line"><span class="addition">+               v.h[g] = -1;</span></span><br><span class="line">                v.add(g, sta[tt], d);</span><br><span class="line">                v.add(sta[tt], g, d);</span><br><span class="line">                tt--;</span><br><span class="line">                sta[++tt] = g;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                int p = sta[tt - 1], q = sta[tt--];</span><br><span class="line">                ll d = minpath(p, q);</span><br><span class="line">                v.add(p, q, d);</span><br><span class="line">                v.add(q, p, d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="addition">+       v.h[a[i]] = -1;</span></span><br><span class="line">        sta[++tt] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    while(tt &gt; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        int p = sta[tt - 1], q = sta[tt--];</span><br><span class="line">        ll d = minpath(p, q);</span><br><span class="line">        v.add(p, q, d);</span><br><span class="line">        v.add(q, p, d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩下的节点我们就不需要管了，因为我们甚至没有访问他们的机会。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="Luogu-P2495-SDOI2011-消耗战"><a href="#Luogu-P2495-SDOI2011-消耗战" class="headerlink" title="Luogu P2495 [SDOI2011] 消耗战"></a>Luogu P2495 [SDOI2011] 消耗战</h2><p>题面在这里：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI0OTU=">https://www.luogu.com.cn/problem/P2495</span></p>
<p>上面已经讲了做法了，就是一个树形DP。</p>
<p>代码见这里：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p2000-p2999/p2495/p2495.cpp"><code>Luogu P2495</code></a></p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数</title>
    <url>/notes/linar-algebra/</url>
    <content><![CDATA[<p>线性代数。</p>
<span id="more"></span>

<p>2022年7月暑假推倒重写。</p>
<div id="problem-card-vis">false</div>

<hr>
<h1 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h1><p>线性代数基本上可以说是基于向量的。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>向量可以被描述成一条有向线段。</p>
<p>决定一个向量的两个量是其长度和其方向。<br>这就意味着，在保证其长度和方向不变的情况下，我们可以将其随意地平移而不改变其本身。</p>
<p>我们用一个有序数列来描述一个向量。</p>
<p>比如说下面的这个向量，我们就可以用 $\begin{bmatrix}2\\1\end{bmatrix}$ 来表示。</p>
<p>[pic here]</p>
<p>这个 $2$ 和 $1$ 分别代表的是，这个向量可以被表示为 $2 {\color[RGB]{125,180,100}\hat{\imath}} + 1 {\color[RGB]{255,100,80}\hat{\jmath}}$。<br>这样，每一个向量都可以与一个有序数列一一对应了。</p>
<h2 id="向量的运算"><a href="#向量的运算" class="headerlink" title="向量的运算"></a>向量的运算</h2><p>这里先介绍两种重要的向量运算：加法和数乘。</p>
<p>我们这里首先以二维向量做例子。</p>
<h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><p>向量加法，就是高中课本里面的向量加法，可以用平行四边形法则的那个。</p>
<p>其满足交换律和结合律，所以我们可以将两个向量拆开来看。</p>
<p>对于两个向量 $\vec{a}$ 和 $\vec{b}$，我们将其表示为 $\begin{bmatrix}{\color[RGB]{125,180,100}x_a}\\{\color[RGB]{255,110,80}y_a}\end{bmatrix}$ 和 $\begin{bmatrix}{\color[RGB]{125,180,100}x_b}\\{\color[RGB]{255,110,80}y_b}\end{bmatrix}$。<br>那么如果令 $\vec{c} &#x3D; \vec{a} + \vec{b}$ 的话，$\vec{c}$ 就可以表示为 $\begin{bmatrix}{\color[RGB]{125,180,100}x_a}\\{\color[RGB]{255,110,80}y_a}\end{bmatrix} + \begin{bmatrix}{\color[RGB]{125,180,100}x_b}\\{\color[RGB]{255,110,80}y_b}\end{bmatrix}$。<br>将两式拆分的话，可以得到 $\vec{c} &#x3D; ({\color[RGB]{125,180,100}x_a \hat{\imath}} + {\color[RGB]{255,110,80}y_a \hat{\jmath}}) + ({\color[RGB]{125,180,100}x_b \hat{\imath}} + {\color[RGB]{255,110,80}y_b \hat{\jmath}})$，合并同类项可得 $\vec{c} &#x3D; \begin{bmatrix}{\color[RGB]{125,180,100}x_a+x_b}\\{\color[RGB]{255,110,80}y_a+y_b}\end{bmatrix}$。</p>
<p>[pic here]</p>
<h3 id="数乘"><a href="#数乘" class="headerlink" title="数乘"></a>数乘</h3><p>向量的数乘可以看作是对这个向量进行缩放。</p>
<p>还是对于向量 $\begin{bmatrix}2\\1\end{bmatrix}$，我们让他乘以一个数 $\lambda$，就相当于是将其缩放了 $\lambda$ 倍，最终得到的向量是 $\begin{bmatrix}2\lambda\\\lambda\end{bmatrix}$。</p>
<p>推广到一般情况下，对于一个向量 $\begin{bmatrix}{\color[RGB]{125,180,100}x}\\{\color[RGB]{255,110,80}y}\end{bmatrix}$，我们将其乘以 $\lambda$，得到的向量是 $\begin{bmatrix}{\color[RGB]{125,180,100}\lambda x}\\{\color[RGB]{255,110,80}\lambda y}\end{bmatrix}$。</p>
<p>[pic here]</p>
<h2 id="基底，张成空间与线性相关"><a href="#基底，张成空间与线性相关" class="headerlink" title="基底，张成空间与线性相关"></a>基底，张成空间与线性相关</h2><h3 id="基底"><a href="#基底" class="headerlink" title="基底"></a>基底</h3><p>我们刚才提到的东西里面有两个没有解释，是 $\color[RGB]{125,180,100}\hat{\imath}$ 和 $\color[RGB]{255,100,80}\hat{\jmath}$。<br>$\color[RGB]{125,180,100}\hat{\imath}$ 长度为1，方向沿 $x$ 轴；$\color[RGB]{255,100,80}\hat{\jmath}$ 长度为1，方向沿 $y$ 轴。</p>
<p>[pic here]</p>
<p>我们在数学书上面可以看到，这两个向量叫做 $x$ 轴和 $y$ 轴上的单位向量。<br>根据刚才的例子可以看出，我们可以使用这两个向量组成二维平面内的所有向量，也就是说，所有的向量都可以表示为 $a{\color[RGB]{125,180,100}\hat{\imath}} + b{\color[RGB]{255,100,80}\hat{\jmath}}$ 的形式。</p>
<p>我们就称这样的一组向量为这个二维平面的一组<strong>基底</strong>。</p>
<p>当前这个二维平面的基底不止有这一种，只要我们选定的一组向量可以<strong>张成</strong>这个二维平面的话，这组向量也可以算是一组基底。</p>
<h3 id="张成空间"><a href="#张成空间" class="headerlink" title="张成空间"></a>张成空间</h3><p>“张成”这个术语其实很简单。</p>
<p>我们随便考虑两个向量，比如说 $\color[RGB]{210,100,110}\vec{u} &#x3D; \begin{bmatrix}2\\1\end{bmatrix}$ 和 $\color[RGB]{80,150,220}\vec{v} &#x3D; \begin{bmatrix}3\\-1\end{bmatrix}$。</p>
<p>[pic here]</p>
<p>对于二维平面中的任意一个向量，如果我们都能将其写成 $a{\color[RGB]{210,100,110}\vec{u}} + b{\color[RGB]{80,150,220}\vec{v}}$ 的形式的话，我们就可以说 $\color[RGB]{210,100,110}\vec{u}$ 和 $\color[RGB]{80,150,220}\vec{v}$ 所张成的空间就是当前我们这个二维平面，$\color[RGB]{210,100,110}\vec{u}$ 和 $\color[RGB]{80,150,220}\vec{v}$ 就是当前二维平面的一组基底。<br>我们称这个让一个向量等于 $a{\color[RGB]{210,100,110}\vec{u}} + b{\color[RGB]{80,150,220}\vec{v}}$ 的组成向量的方式为<strong>“线性组合”</strong>或者<strong>“线性表出”</strong>。也就是说，由$\color[RGB]{210,100,110}\vec{u}$ 和 $\color[RGB]{80,150,220}\vec{v}$ 所张成的空间中的所有向量都是 $\color[RGB]{210,100,110}\vec{u}$ 和 $\color[RGB]{80,150,220}\vec{v}$ 的线性组合，或可以由 $\color[RGB]{210,100,110}\vec{u}$ 和 $\color[RGB]{80,150,220}\vec{v}$ 线性表出。</p>
<p>二维平面的一组基底最少需要两个向量。<br>但这两个向量可不是随便两个就可以的。</p>
<p>假如说选中的两个向量共线的话，这两个向量所能线性组合而成的向量就（相对）少多了。这些向量只会存在在这两个向量所在的直线上。那么，这两个向量所张成的空间就是这一条直线。</p>
<p>为什么两个共线的向量就不行了呢？</p>
<p>因为他们<strong>线性相关</strong>。</p>
<h3 id="线性相关"><a href="#线性相关" class="headerlink" title="线性相关"></a>线性相关</h3><p>我们定义一组向量 ${\bf{A}}:\{ \vec{a_1},\vec{a_2},\vec{a_3},\cdots,\vec{a_m} \}$ 线性相关，当且仅当存在一组不全为 $0$ 的数 $k_1,k_2,k_3,\cdots,k_m$，使得:</p>
<center>$k_1\vec{a_1} + k_2\vec{a_2} + k_3\vec{a_3} + \cdots + k_m\vec{a_m} = \vec{0}$</center>

<p>换句话说，这一组向量里面有至少一个向量可以被组内其他向量线性表出。</p>
<p>在我们刚才举的第一个例子中，两个向量不能被对方线性表出，我们就称其为<strong>线性无关</strong>的。<br>而在第二个例子中，两个共线的向量可以被对方线性表出，我们就称其为<strong>线性相关</strong>的。</p>
<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><p>矩阵可以看作是一系列向量的组合。</p>
<p>一般我们在学矩阵的时候，我们首先认识到的是矩阵的代数意义。<br>这样不是很直观，且死记硬背的成分较多。</p>
<p>这里我们通过矩阵与线性变换的结合，可以将矩阵的几何意义表示出来。<br>这样就较为直观，并且可能可以加深对某些操作的理解。</p>
<h2 id="矩阵与线性变换"><a href="#矩阵与线性变换" class="headerlink" title="矩阵与线性变换"></a>矩阵与线性变换</h2><p>何为<strong>线性变换</strong>？</p>
<p>我们仍然以二维平面为例。</p>
<p>对于这样一个平面直角坐标系，我们可以搞出来一个映射，使得这个二维平面内的每一个点都可以映射到二维平面内的一个点。<br>将点转化成为向量，我们的这个映射就相当于是对于一个向量的函数，其输入值和输出值的类型都是二维向量。</p>
<p>这就称为一个<strong>变换</strong>。</p>
<p>而<strong>线性</strong>代表的就是，我们需要保证，在原先平面内的每一条直线，在变换后的平面内其仍然为一条直线；同时原点位置不变。</p>
<p>在上面这两条要求的约束下，我们就可以利用基底来对变换进行定量的描述了。</p>
<p>我们仍然利用 $\color[RGB]{125,180,100}\hat{\imath}$ 和 $\color[RGB]{255,100,80}\hat{\jmath}$ 来说明。</p>
<p>我们对一个平面直角坐标系进行线性变换的同时，其基底 $\color[RGB]{125,180,100}\hat{\imath}$ 和 $\color[RGB]{255,100,80}\hat{\jmath}$ 同时也会发生变化。</p>
<p>[pic here]</p>
<p>基于这两个新的基底，我们按照原来的数量关系构建出来的向量和直接拿向量去变换得到的结果是吻合的。</p>
<p>[pic here]</p>
<p>基于上面这个结论，我们就可以用 $\color[RGB]{125,180,100}\hat{\imath}$ 和 $\color[RGB]{255,100,80}\hat{\jmath}$ 经过变换后的位置来描述这个变换了。</p>
<p>假设我们变换之后的 $\color[RGB]{125,180,100}\hat{\imath}$ 和 $\color[RGB]{255,100,80}\hat{\jmath}$ 分别为 $\color[RGB]{125,180,100}\begin{bmatrix}2\\1\end{bmatrix}$ 和 $\color[RGB]{255,100,80}\begin{bmatrix}1\\3\end{bmatrix}$。<br>我们将两个向量写到一块：$\begin{bmatrix}{\color[RGB]{125,180,100}2}&amp;{\color[RGB]{255,100,80}1}\\{\color[RGB]{125,180,100}1}&amp;{\color[RGB]{255,100,80}3}\end{bmatrix}$。</p>
<p>假设我们要对向量 $\begin{bmatrix}-1\\2\end{bmatrix}$ 做这个变换的话，其变换后可以看作是 $-1{\color[RGB]{125,180,100}\begin{bmatrix}2\\1\end{bmatrix}} + 2{\color[RGB]{255,100,80}\begin{bmatrix}1\\3\end{bmatrix}}$，也就是 $\begin{bmatrix}0\\5\end{bmatrix}$。</p>
<h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>（这里有一个矩阵乘法的<span class="exturl" data-url="aHR0cDovL21hdHJpeG11bHRpcGxpY2F0aW9uLnh5ei8=">可视化工具</span>）</p>
<p>将上面的东西推广到一般，可以得到下面的式子：</p>
<center>$\begin{bmatrix}{\color[RGB]{125,180,100}a}&{\color[RGB]{255,100,80}b}\\{\color[RGB]{125,180,100}c}&{\color[RGB]{255,100,80}d}\end{bmatrix} \begin{bmatrix}e\\f\end{bmatrix} = \begin{bmatrix}{\color[RGB]{125,180,100}a}e+{\color[RGB]{255,100,80}b}f\\{\color[RGB]{125,180,100}c}e+{\color[RGB]{255,100,80}d}f\end{bmatrix}$</center>

<p><del>根据矩阵乘法的定义</del>，我们可以知道这样就相当于是给一个向量左乘了一个方阵。<del>（其实上面写的就是）</del></p>
<p>对于一次做多种变换，比如说对于向量 $\vec{v}&#x3D;\begin{bmatrix}-1\\2\end{bmatrix}$，我们先做一个 ${\bf{U}}_1&#x3D;\begin{bmatrix}{\color[RGB]{125,180,100}2}&amp;{\color[RGB]{255,100,80}1}\\{\color[RGB]{125,180,100}1}&amp;{\color[RGB]{255,100,80}3}\end{bmatrix}$，再做一个 ${\bf{U}}_2&#x3D;\begin{bmatrix}{\color[RGB]{125,180,100}2}&amp;{\color[RGB]{255,100,80}1}\\{\color[RGB]{125,180,100}0}&amp;{\color[RGB]{255,100,80}1}\end{bmatrix}$。<br>根据上面的式子，我们可以推出来结果是这个：$\begin{bmatrix}{\color[RGB]{125,180,100}2}&amp;{\color[RGB]{255,100,80}1}\\{\color[RGB]{125,180,100}0}&amp;{\color[RGB]{255,100,80}1}\end{bmatrix} \begin{bmatrix}{\color[RGB]{125,180,100}2}&amp;{\color[RGB]{255,100,80}1}\\{\color[RGB]{125,180,100}1}&amp;{\color[RGB]{255,100,80}3}\end{bmatrix} \begin{bmatrix}-1\\2\end{bmatrix}$。</p>
<p>按照我们上面的描述，我们的运算顺序是这个样子的：${\bf{U}}_2({\bf{U}}_1\vec{v})$。<br>如果我们将 ${\bf{U}}_2{\bf{U}}_1$ 合并成为一个矩阵的话，结果是</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉和莫比乌斯</title>
    <url>/maths/eular-and-m%C3%B6bius/</url>
    <content><![CDATA[<p>简介：欧拉定理，欧拉函数和莫比乌斯函数</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<p>初稿写于2021-10-10，<br>再修改于2022-02-07</p>
<p><strong>Achtung: 本文章使用p来代指“任意质数”，请勿混淆。</strong></p>
<p>首先让我们膜拜一下莱昂哈德·欧拉(Leonhard Euler):</p>
<p><img src="/pics/eular.jpg" alt="eular"></p>
<h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><p>欧拉函数 $φ(n)$ 的概念是在 $[0,n-1]$ 范围内有多少个整数与 $n$ 互质。</p>
<p>其中，我们规定 $φ(1)&#x3D;1$，</p>
<p>且不难发现，$φ(p)&#x3D;p-1$。</p>
<h2 id="欧拉函数的一些性质"><a href="#欧拉函数的一些性质" class="headerlink" title="欧拉函数的一些性质"></a>欧拉函数的一些性质</h2><h3 id="欧拉函数是积性函数"><a href="#欧拉函数是积性函数" class="headerlink" title="欧拉函数是积性函数"></a>欧拉函数是积性函数</h3><p>即 $φ(mn) &#x3D; φ(m) φ(n)$</p>
<p>并且当 $n \bmod{2} \equiv 1$ 时，$φ(2n) &#x3D; φ(n)$，</p>
<p>而当 $n \bmod{2} \equiv 0$（即 $2|n$)时，$φ(2n) &#x3D; 2 φ(n)$</p>
<h3 id="displaystyle-sum-m-n-n-m-x3D-n-frac-φ-n-2"><a href="#displaystyle-sum-m-n-n-m-x3D-n-frac-φ-n-2" class="headerlink" title="$\displaystyle \sum_{m|n}^{n} m &#x3D; n \frac{φ(n)}{2}$"></a>$\displaystyle \sum_{m|n}^{n} m &#x3D; n \frac{φ(n)}{2}$</h3><p>$$<br>\sum_{m|n}^{n} m &#x3D; n \frac{φ(n)}{2}<br>$$</p>
<p>易证。</p>
<h3 id="displaystyle-sum-d-n-φ-d-x3D-n"><a href="#displaystyle-sum-d-n-φ-d-x3D-n" class="headerlink" title="$\displaystyle \sum_{d|n} φ(d) &#x3D; n$"></a>$\displaystyle \sum_{d|n} φ(d) &#x3D; n$</h3><p>$$<br>\sum_{d|n} φ(d) &#x3D; n<br>$$</p>
<p>我们利用莫比乌斯反演的相关知识可以得出。</p>
<p>或者我们这样考虑：<br>如果 $\gcd(k,n) &#x3D; d$ ，那么 $\gcd(\frac{k}{d} , \frac{n}{d}) &#x3D; 1 (k &lt; n)$ 。<br>我们如果设 $f(x)$ 为满足 $\gcd(k,n) &#x3D; x$ 的数的个数，那么 $n &#x3D; \sum_{i-1}^n f(i)$ 。<br>根据上面的证明，我们可以发现， $f(x) &#x3D; φ(\frac{n}{x})$ ，从而得到 $n &#x3D; \sum_{d|n} φ(\frac{n}{d})$ 。注意此时我们的约数 $d$ 和 $\frac{n}{d}$ 具有对称性，所以上面的式子可以化为 $n &#x3D; \sum_{d|n} φ(d)$ 。</p>
<h3 id="displaystyle-φ-p-k-x3D-p-k-p-k-1"><a href="#displaystyle-φ-p-k-x3D-p-k-p-k-1" class="headerlink" title="$\displaystyle φ(p^k) &#x3D; p^k - p^{k-1}$"></a>$\displaystyle φ(p^k) &#x3D; p^k - p^{k-1}$</h3><p>若 $n &#x3D; p^k$ ，那么 $φ(n) &#x3D; p^k - p^{k-1}$ 。</p>
<p>由定义可知。<br>因为有 $n \perp p^k \iff p \not \mid n$ 。在 ${ 0,1,p,\cdots ,p^k-1 }$ 中， $p$ 的倍数是 ${ 0,p,2p,\cdots ,p^k-p }$ ，共有 $p^{k-1}$ 个。</p>
<h3 id="displaystyle-φ-prod-i-x3D-1-s-p-i-k-i-x3D-prod-i-x3D-1-s-p-i-k-i-1-·-p-i-1"><a href="#displaystyle-φ-prod-i-x3D-1-s-p-i-k-i-x3D-prod-i-x3D-1-s-p-i-k-i-1-·-p-i-1" class="headerlink" title="$\displaystyle φ(\prod_{i&#x3D;1}^s p_i^{k_i}) &#x3D; \prod_{i&#x3D;1}^s p_i^{k_i - 1} · (p_i - 1)$"></a>$\displaystyle φ(\prod_{i&#x3D;1}^s p_i^{k_i}) &#x3D; \prod_{i&#x3D;1}^s p_i^{k_i - 1} · (p_i - 1)$</h3><p>由唯一分解定理，设 $n &#x3D; \prod_{i&#x3D;1}^s p_i^{k_i}$ ，则有 $φ(n) &#x3D; \prod_{i&#x3D;1}^s \frac{p_i - 1}{p_i}$。</p>
<p>证明：</p>
<p>$$<br>\begin{align}<br>φ(n) &amp;&#x3D; \prod_{i&#x3D;1}^s φ(p_i^{k_i}) \\<br>&amp;&#x3D; \prod_{i&#x3D;1}^s p_i^{k_i} - p_i^{k_i - 1} \\<br>&amp;&#x3D; \prod_{i&#x3D;1}^s (p_i - 1) \times p_i^{k_i - 1} \\<br>&amp;&#x3D; \prod_{i&#x3D;1}^s (1 - \frac{1}{p_i}) p_i^{k_i} \\<br>&amp;&#x3D; n \prod_{i&#x3D;1}^s (1 - \frac{1}{p_i})<br>\end{align}<br>$$</p>
<h2 id="计算欧拉函数的值"><a href="#计算欧拉函数的值" class="headerlink" title="计算欧拉函数的值"></a>计算欧拉函数的值</h2><h3 id="单点求值"><a href="#单点求值" class="headerlink" title="单点求值"></a>单点求值</h3><p>我们不难发现，当 $m$ 是一个质数的整数幂 $p^k$ 时，我们有<br>$$<br>φ(p^k)&#x3D;p^k-p^{k-1}<br>$$<br>;<br>如果 $m&gt;1$ 不是一个质数的整数幂，那我们可以把 $m$ 拆分成 $m&#x3D;m_1 m_2$ ，其中 $m_1 \perp m_2$。这样这个数就可以在剩余系里表示为 $(n \bmod m_1 , n \bmod m_2)$ 。如果你不知道什么是剩余系，可以看我的博客：（咕了）。</p>
<p>根据<br>$$<br>k \perp m 且 k \perp n \iff k \perp mn<br>$$<br>和<br>$$<br>\gcd(m,n) &#x3D; \gcd(n \bmod m,m)<br>$$<br>可得<br>$$<br>n \perp m \iff n \bmod m_1 \perp m_1 且 n \bmod m_2 \perp m_2<br>$$<br>，由此，我们可以推得<br>$$<br>φ(m)&#x3D;φ(m_1)φ(m_2),m_1 \perp m_2<br>$$<br>所以，欧拉函数是一个积性函数。</p>
<p>欧拉函数的通项公式是<br>$$<br>φ(m)&#x3D;\prod_{p|m} (p^{m_p}-p^{m_p-1})&#x3D;m \prod_{p|m}(1-\frac{1}{p})<br>$$</p>
<p>上代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">euler_phi</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">int</span>(<span class="built_in">sqrt</span>(n + <span class="number">0.5</span>));</span><br><span class="line">    <span class="type">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>) ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果将代码改为下面的形式可以优化一些：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">euler_phi</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>) ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="区间筛"><a href="#区间筛" class="headerlink" title="区间筛"></a>区间筛</h3><p>而我们可以使用筛法来求连续区间的欧拉函数值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> phi[N], prime[N / <span class="number">100</span>];</span><br><span class="line"><span class="type">bool</span> visit[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getphi</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visit[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime[prime[<span class="number">0</span>] + <span class="number">1</span>] = i;</span><br><span class="line">            prime[<span class="number">0</span>]++;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= prime[<span class="number">0</span>] &amp;&amp; i * prime[j] &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            visit[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i % prime[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                phi[i * prime[j]] = phi[i] * (prime[j] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有OI Wiki上提供的代码：</p>
<details class="note default"><summary><p>from OI Wiki</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(is_prime, <span class="number">1</span>, <span class="built_in">sizeof</span>(is_prime));</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    is_prime[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">5000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(is_prime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= <span class="number">5000000</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            is_prime[i * prime[j]] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j])</span><br><span class="line">                phi[i * prime[j]] = phi[i] * phi[prime[j]];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                phi[i * prime[j]] = phi[i] * prime[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>复杂度均为线性。</p>
<h1 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h1><p>我们先看一下费马小定理。</p>
<h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p>众所周知，费马小定理是：<br>$$<br>a^{p-1} \equiv 1 \pmod{p},a \perp p<br>$$<br>还有另一种形式，是这样的：<br>$$<br>\forall a \in \mathbb{N} ,a^p \equiv a \pmod{p}<br>$$<br>。</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>我们首先取一个不为 $p$ 倍数的数 $a$ 。<br>构造一个序列： $A &#x3D; \lbrace 1,2,3, \cdots , p - 1 \rbrace$ ，这个序列拥有这样的一个性质：<br>$$<br>\prod_{i&#x3D;1}^n A_i \equiv \prod_{i&#x3D;1}^n (A_i \times a) \pmod{p}<br>$$</p>
<p>证明：<br>$$<br>\because (A_i,p) &#x3D; 1 , (A_i \times a,p) &#x3D; 1<br>$$<br>又因为每一个 $A_i \times a \pmod{p}$ 都是独一无二的，且 $A_i \times a \pmod{p} &lt; p$ ，得证（每一个 $A_i \times a$ 都对应了一个 $A_i$）。<br>设 $f &#x3D; (p-1)!$，则<br>$$<br>\begin{align}<br>f &amp;\equiv (a \times A_1)(a \times A_2)(a \times A_3) \cdots (a \times A_{p-1}) \pmod{p} \\<br>a^{p-1} · f &amp;\equiv f \pmod{p} \\<br>a^{p-1} &amp;\equiv 1 \pmod{p}<br>\end{align}<br>$$<br>证毕。</p>
<p>或者也可以使用归纳法证明：</p>
<p>显然 $1^p \equiv 1 \pmod{p}$。那么假设 $a^p \equiv a \pmod{p}$ 成立，那么通过二项式定理有<br>$$<br>(a+1)^p &#x3D; a^p + C_p^1 a^{p-1} + C_p^2 a^{p-2} + \cdots + C_p^{p-1} a + 1<br>$$<br>因为 $C_p^k &#x3D; \frac{p!}{(n-k)!k!}$ 对于 $k \in [ 1,p-1 ]$ 成立，在模 $p$ 意义下 $C_p^1 \equiv C_p^2 \equiv \cdots \equiv C_p^{p-1} \equiv 0 \pmod{p}$，那么 $(a+1)^p \equiv a^p + 1 \pmod{p}$，将 $a^p \equiv a \pmod{p}$ 代入得 $(a+1)^p \equiv a+1 \pmod{p}$。<br>证毕。</p>
<h2 id="欧拉定理-1"><a href="#欧拉定理-1" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>欧拉定理的内容如下：</p>
<p>若 $\gcd(a,m) &#x3D; 1$，则 $a^{φ(m)} \equiv 1 \pmod{m}$。</p>
<h3 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h3><p>欧拉定理的证明过程与费马小定理的证明过程十分相似。<br>我们同样首先构造一个与 $m$ 互质的序列，再进行操作。</p>
<p>设 $r_1,r_2, \cdots ,r_{φ(m)}$ 为模 $m$ 意义下的一个简化剩余系，则 $ar_1,ar_2, \cdots ,ar_{φ(m)}$ 同样也为模 $m$ 意义下的一个简化剩余系。所以，$\prod_{i&#x3D;1}^{φ(m)} r_i \equiv \prod_{i&#x3D;1}^{φ(m)} ar_i \equiv a^{φ(m)} \prod_{i&#x3D;1}^{φ(m)} r_i \pmod{m}$，约去 $\prod_{i&#x3D;1}^{φ(m)} r_i$ 后可得 $a^{φ(m)} \equiv 1 \pmod{m}$。<br>证毕。</p>
<p>当 $m&#x3D;p$ 时，由于 $φ(m) &#x3D; m-1$，将之代入可得费马小定理。</p>
<h2 id="扩展欧拉定理"><a href="#扩展欧拉定理" class="headerlink" title="扩展欧拉定理"></a>扩展欧拉定理</h2><p>扩展欧拉定理是这个样子的：</p>
<p>$$<br>a^b \equiv \begin{cases}a^{b \ \bmod \ φ(m)}, &amp; \gcd(a,m) &#x3D; 1,\\a^b, &amp; \gcd(a,m) \neq 1, b &lt; φ(m),\\a^{(b \ \bmod \ φ(m))+φ(m)}, &amp; \gcd(a,m) \neq 1,b \geq φ(m). \end{cases} \pmod{m}<br>$$</p>
<p>证明见<span class="exturl" data-url="aHR0cHM6Ly9vaS13aWtpLm9yZy9tYXRoL251bWJlci10aGVvcnkvZmVybWF0LyNfNg==">OI Wiki</span></p>
<h1 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>我们把一个数字分解质因数为 $n&#x3D;p_1^{c_1}p_2^{c_2} \cdots p_k^{c_k}$，则<br>$$<br>μ(n)&#x3D;<br>\begin{cases}<br>1 &amp; n&#x3D;1 \\<br>0 &amp; \forall i \in [1,k] , c_i &gt; 1 \\<br>(-1)^k &amp; \forall i \in [1,k] , c_i &#x3D; 1<br>\end{cases}<br>$$</p>
<p>解释一下：</p>
<ol>
<li>当 $n&#x3D;1$ 时， $μ(n)&#x3D;1$；</li>
<li>当 $n \neq 1$ 时：<ol>
<li>当存在 $i\in [1,k]$，使得 $c_i &gt; 1$ 时，$μ(n)&#x3D;0$，也就是说只要某个质因子出现的次数超过一次，$μ(n)$ 就等于 $0$；</li>
<li>当任意 $i\in[1,k]$，都有 $c_i&#x3D;1$ 时，$μ(n)&#x3D;(-1)^k$，也就是说每个质因子都仅仅只出现过一次时，$μ(n)$ 等于 $-1$ 的 $k$ 次幂，此处 $k$ 指的便是仅仅只出现过一次的质因子的总个数。</li>
</ol>
</li>
</ol>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>莫比乌斯函数不仅是积性函数，还有如下性质：<br>$$<br>\sum_{d|m} μ(d) &#x3D; [m&#x3D;&#x3D;1]<br>$$<br>其中 $[m&#x3D;&#x3D;1]$ 代表 <code>m==1?1:0</code> 。</p>
<h2 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a>证明</h2><p>设<br>$$<br>n&#x3D;\prod_{i&#x3D;1}^k{p_i}^{c_i},n’&#x3D;\prod_{i&#x3D;1}^k p_i<br>$$<br>那么<br>$$<br>\sum_{d\mid n}μ(d)&#x3D;\sum_{d\mid n’}μ(d)&#x3D;\sum_{i&#x3D;0}^k C_k^i·(-1)^i&#x3D;(1+(-1))^k<br>$$</p>
<h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><p>如果两个的函数 $f(n)$ 与 $g(n)$ 满足<br>$$<br>f(n) &#x3D; \sum_{d|n} g(d)<br>$$<br>则<br>$$<br>g(n) &#x3D; \sum_{d|n} μ(d) f(\frac{n}{d})<br>$$</p>
<h3 id="证明-3"><a href="#证明-3" class="headerlink" title="证明"></a>证明</h3><details class="note info"><summary><p>摘自《混凝土数学》</p>
</summary>
<h4 id="充分性"><a href="#充分性" class="headerlink" title="充分性"></a>充分性</h4><p>$$<br>\begin{align}<br>f(n) &amp;&#x3D; \sum_{d|n} g (d)\\<br>&amp;&#x3D; \sum_{d|n} g (\frac{n}{d})<br>\end{align}<br>$$</p>
<p>$$<br>\sum_{d|n} μ(d) f(\frac{n}{d}) &#x3D; \sum_{d|n} μ(d) \sum_{d_1|\frac{n}{d}} g(d_1)<br>$$</p>
<p>$$<br>\begin{align}<br>\sum_{d|n} \sum_{d_1|\frac{n}{d}} μ(d) g (d_1) &amp;&#x3D; \sum_{d_1|n} g(d_1) \sum_{d|\frac{n}{d_1}} μ(d) \\<br>&amp;&#x3D; g(n)<br>\end{align}<br>$$</p>
<p>考虑到<br>$$<br>\sum_{d|\frac{n}{d_1}} μ(d) &#x3D;<br>\begin{cases}<br>1 &amp; d_1 &#x3D; n \\<br>0 &amp; d_1 &lt; n<br>\end{cases}<br>$$<br>因此<br>$$<br>\begin{align}<br>g(n) &amp;&#x3D; \sum_{d|n} μ(d) f(\frac{n}{d}) \\<br>&amp;&#x3D; \sum_{d|n} μ(\frac{n}{d}) f(d)<br>\end{align}<br>$$</p>
<h4 id="必要性"><a href="#必要性" class="headerlink" title="必要性"></a>必要性</h4><p>$$<br>\begin{align}<br>g(n) &amp;&#x3D; \sum_{d|n} μ(d) f(\frac{n}{d}) \\<br>&amp;&#x3D; \sum_{d|n} μ(\frac{n}{d}) f(d)<br>\end{align}<br>$$</p>
<p>$$<br>\begin{align}<br>\sum_{d|n} g(d) &amp;&#x3D; \sum_{d|n}g(\frac{n}{d}) \\<br>&amp;&#x3D; \sum_{d|n} \sum_{d_1|\frac{n}{d}} μ(\frac{n}{d d_1})f(d_1) \\<br>&amp;&#x3D; \sum_{d d_1|n} μ(\frac{n}{d d_1}) f(d_1) \\<br>&amp;&#x3D; \sum_{d_1|n} f(d_1) \sum_{d|\frac{n}{d}} μ(\frac{n}{d d_1}) \\<br>&amp;&#x3D; f(n)<br>\end{align}<br>$$</p>
<p>考虑到</p>
<p>$$<br>\begin{align}<br>\sum_{d|\frac{n}{d_1}} μ(\frac{n}{d d_1}) &amp;&#x3D; \sum_{d|\frac{n}{d_1}} μ(d) \\<br>&amp;&#x3D; \begin{cases} 1 &amp; d_1 &#x3D; n \\ 0 &amp; d_1 &lt; n \end{cases}<br>\end{align}<br>$$</p>
<p>因此</p>
<p>$$<br>\begin{align}<br>f(n) &amp;&#x3D; \sum_{d|n} g(d) \\<br>&amp;&#x3D; \sum_{d|n} g(\frac{n}{d})<br>\end{align}<br>$$</p>

</details>

<h2 id="求莫比乌斯函数的值"><a href="#求莫比乌斯函数的值" class="headerlink" title="求莫比乌斯函数的值"></a>求莫比乌斯函数的值</h2><h3 id="单点求值-1"><a href="#单点求值-1" class="headerlink" title="单点求值"></a>单点求值</h3><p>自己算。</p>
<h3 id="区间筛法"><a href="#区间筛法" class="headerlink" title="区间筛法"></a>区间筛法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getMu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flg[i]) p[++tot] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * p[j] &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            flg[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % p[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mu[i * p[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i * p[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="莫比乌斯变换"><a href="#莫比乌斯变换" class="headerlink" title="莫比乌斯变换"></a>莫比乌斯变换</h2><p>设 $f(n)$，$g(n)$ 为两个数论函数。<br>如果有 $f(n) &#x3D; \sum_{d|n} g(d)$ 那么有：</p>
<p>形式1： $g(n) &#x3D; \sum_{d|n} μ(d) f(\frac{n}{d})$。</p>
<p>这种形式下，函数 $f(n)$ 被称为函数 $g(n)$ 的莫比乌斯变换，反之则称之为其的莫比乌斯逆变换（反演）。</p>
<p>形式2： $g(n) &#x3D; \sum_{d|n} μ(\frac{d}{n}) f(d)$。</p>
<p>据说这种形式更常考一点。</p>
<h3 id="证明-4"><a href="#证明-4" class="headerlink" title="证明"></a>证明</h3><ul>
<li>方法一：对原式做数论变换。</li>
</ul>
<p>$$<br>\begin{align}<br>&amp; \sum_{d\mid n}μ(d)f(\frac{n}{d}) \\<br>&#x3D;&amp; \sum_{d\mid n}μ(d)\sum_{k\mid \frac{n}{d}}g(k) \\<br>&#x3D;&amp; \sum_{k\mid n}g(k)\sum_{d\mid \frac{n}{k}}μ(d) \\<br>&#x3D;&amp; g(n)<br>\end{align}<br>$$</p>
<p>用 $\displaystyle\sum_{d\mid n}g(d)$ 来替换 $f(\dfrac{n}{d})$，再变换求和顺序。最后一步变换的依据：$\displaystyle\sum_{d\mid n}μ(d)&#x3D;[n&#x3D;1]$，因此在 $\dfrac{n}{k}&#x3D;1$ 时第二个和式的值才为 $1$。此时 $n&#x3D;k$，故原式等价于 $\displaystyle\sum_{k\mid n}[n&#x3D;k]\cdot g(k)&#x3D;g(n)$</p>
<ul>
<li>方法二：运用卷积。</li>
</ul>
<p>原问题为：已知 $f&#x3D;g * 1$，证明 $g&#x3D;f * μ$</p>
<p>易知如下转化：$f * μ&#x3D;g * 1 * μ\implies f * μ&#x3D;g$（其中 $1 * μ&#x3D;ε$）。</p>
<p>对于第二种形式：</p>
<p>类似上面的方法一，我们考虑逆推这个式子。</p>
<p>$$<br>\begin{align}<br>&amp; \sum_{n|d}{μ(\frac{d}{n})f(d)} \\<br>&#x3D;&amp; \sum_{k&#x3D;1}^{+\infty}{μ(k)f(kn)} \\<br>&#x3D;&amp; \sum_{k&#x3D;1}^{+\infty}{μ(k)\sum_{kn|d}{g(d)}} \\<br>&#x3D;&amp; \sum_{n|d}{g(d)\sum_{k|\frac{d}{n}}{μ(k)}} \\<br>&#x3D;&amp; \sum_{n|d}{g(d)ε(\frac{d}{n})} \\<br>&#x3D;&amp; g(n)<br>\end{align}<br>$$</p>
<p>我们把 $d$ 表示为 $kn$ 的形式，然后把 $f$ 的原定义代入式子。</p>
<p>发现枚举 $k$ 再枚举 $kn$ 的倍数可以转换为直接枚举 $n$ 的倍数再求出 $k$，发现后面那一块其实就是 $ε$, 整个式子只有在 $d&#x3D;n$ 的时候才能取到值。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>《混凝土数学》<br>OI Wiki</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>拉格朗日插值</title>
    <url>/maths/lagrange-interpolation/</url>
    <content><![CDATA[<p>拉格朗日插值。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<p>在学完函数以后，AJ想让我们求出一个函数，使得其带入自然数时生成的序列时给定的，并让武嘉给出了一个数列。</p>
<p>崇尚<ruby>野獣<rt>やじゅう</rt></ruby><ruby>先輩<rt>せんぱい</rt></ruby>的武嘉给出了这样的一个序列：</p>
<p>$$<br>1,3,5,7,9,114514<br>$$</p>
<p>光看前五项貌似可以构建出 $f(x)&#x3D;2x-1$ 来糊过去，但是第6项就不好办了。</p>
<p>王哥说：“这都不会，快用<strong>拉格朗日插值</strong>！”<br>(P.S.: 其实我们班里初三的时候真的有讲拉插)</p>
<hr>
<p>引入完毕。</p>
<p>拉格朗日插值法可以很快地将一系列的点值转化为一个经过所有给定点值的函数（或者称多项式）。</p>
<p>拉格朗日给出的方法是这样的：</p>
<p>首先我们给出两个二次多项式，分别称之为 $f(x)$ 与 $g(x)$。<br>两者的系数分别为 $a_f,b_f,c_f$ 与 $a_g,b_g,c_g$。</p>
<p>假设有一个函数 $h(x)$ ，它等于 $f(x)+g(x)$，那么</p>
<p>$$<br>\begin{align}<br>h(x) &amp;&#x3D; f(x)+g(x) \\<br>&amp;&#x3D; a_fx^2+b_fx+c_f + a_gx^2+b_gx+c_g \\<br>&amp;&#x3D; (a_f+a_g)x^2 + (b_f+b_g)x + (c_f+c_g)<br>\end{align}<br>$$</p>
<p>$h(x)$ 的每一项系数竟然是 $f(x)$ 与 $g(x)$ 该项系数之和。</p>
<p>我们再来看代入数值之后的结果。</p>
<p>我们不难看出，对于每一个 $x$ ，其对应的函数值 $f(x)$，$g(x)$ 与 $h(x)$ 满足 $h(x)&#x3D;f(x)+g(x)$。</p>
<p>然后拉格朗日就想，对于每一个点值，我们分别构造一个函数，使得其刚好经过当前点值代表的点，而其他点值处均为 $0$。<br>我们最后将所有的函数加起来，就得到了完美经过每个点值的函数了。</p>
<p>而每一个函数又怎么求呢？</p>
<p>我们先想个简单一点的，让这个函数在当前 $x$ 处为 $1$，其他 $x$ 处都为 $0$。</p>
<p>首先，我们为了表示这些点值且与自由元 $x$ 区分，设其分别为 $(X_i,Y_i)$，总共有 $n$ 个，当前函数为 $F_k(x)$，代表着第 $k$ 个点值。</p>
<p>那么，我们让函数为 $\displaystyle \prod_{i&#x3D;1,i \neq k}^n (x - X_i)$，这样可以使除当前点之外的数都是 $0$。</p>
<p>然后，我们将整个函数除以代入 $X_k$ 时的值，使 $F_k(X_k)&#x3D;1$。<br>那么整个函数就变为了 $\displaystyle \prod_{i&#x3D;1,i \neq k}^n \frac{x - X_i}{X_k - X_i}$。</p>
<p>最后再乘上 $Y_k$，就可以得出我们当前的函数：$\displaystyle F_k(x) &#x3D; Y_k \prod_{i&#x3D;1,i \neq k}^n \frac{x - X_i}{X_k - X_i}$</p>
<p>再把所有的东西加起来，得到</p>
<p>$$<br>G(x) &#x3D; \sum_{k&#x3D;1}^n \bigg( Y_k \prod_{i&#x3D;1,i \neq k}^n \frac{x - X_i}{X_k -X_i} \bigg)<br>$$</p>
<hr>
<p>或者说，我们对于每一个点值列一个方程，将所有的系数作为未知量来求解。</p>
<p>对于一个 $n$ 次多项式，我们一共有 $n+1$ 个系数。我们设这些系数分别为 $a_0,a_1,a_2,a_3,\cdots ,a_n$。</p>
<p>我们如果有一个点值 $(x,y)$，那么我们就可以根据其列出一个方程：</p>
<p>$$<br>a_0 + a_1 x + a_2 x^2 + a_3 x^3 + \cdots + a_n x^n &#x3D; y<br>$$</p>
<p>首先，众所周知，我们需要不少于 $n$ 个方程才能求出 $n$ 个未知数。<br>其次，我们利用克拉默法则来接方程式的时候，也需要形成行列式才能解出来值。</p>
<p>所以说，我们给定 $n+1$ 个点值，能唯一地确定一个 $n$ 次多项式。</p>
<hr>
<p>所以，我们如果用拉格朗日插值法来计算AJ的课后作业的话，得到的式子就是这个样子的：</p>
<p>$$<br>\begin{align}<br>G(x) &amp;&#x3D; 1·\frac{(x-2)(x-3)(x-4)(x-5)(x-6)}{(1-2)(1-3)(1-4)(1-5)(1-6)}<br>\\ &amp;+ 3·\frac{(x-1)(x-3)(x-4)(x-5)(x-6)}{(2-1)(2-3)(2-4)(2-5)(2-6)}<br>\\ &amp;+ 5·\frac{(x-1)(x-2)(x-4)(x-5)(x-6)}{(3-1)(3-2)(3-4)(3-5)(3-6)}<br>\\ &amp;+ 7·\frac{(x-1)(x-2)(x-3)(x-5)(x-6)}{(4-1)(4-2)(4-3)(4-5)(4-6)}<br>\\ &amp;+ 9·\frac{(x-1)(x-2)(x-3)(x-4)(x-6)}{(5-1)(5-2)(5-3)(5-4)(5-6)}<br>\\ &amp;+ 114514·\frac{(x-1)(x-2)(x-3)(x-4)(x-5)}{(6-1)(6-2)(6-3)(6-4)(6-5)} \\<br>&amp;&#x3D; \frac{114503}{120} x^5 - \frac{114503}{8} x^4 + \frac{1946551}{24} x^3 - \frac{1717545}{8} x^2 + \frac{15687031}{60} x - 114504<br>\end{align}<br>$$</p>
<p>这里有一个 $O(n^2)$ 求出最后得出的多项式的系数的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5050</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll t = mod - <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t &amp; <span class="number">1</span>)ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll x[N], y[N], c[N], fs[N], g[N], f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;x[i], &amp;y[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span>(i != j)</span><br><span class="line">                c[i] = c[i] * (x[i] - x[j]) % mod;</span><br><span class="line">        c[i] = <span class="built_in">qpow</span>(c[i]) * y[i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    fs[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = n; j; j--)</span><br><span class="line">            fs[j] = (fs[j - <span class="number">1</span>] + fs[j] * (mod - x[i])) % mod;</span><br><span class="line">        fs[<span class="number">0</span>] = fs[<span class="number">0</span>] * (mod - x[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll buf = <span class="built_in">qpow</span>(mod - x[i]);</span><br><span class="line">        g[<span class="number">0</span>] = fs[<span class="number">0</span>] * buf % mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            g[j] = (fs[j] - g[j - <span class="number">1</span>]) * buf % mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            f[j] = (f[j] + c[i] * g[j]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, (f[i] + mod) % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3Uub3JnL2Jsb2cvY29tbWFuZC1ibG9jay96b25nLWxhLWNoYS1kYW8ta3VhaS1zdS1jaGEtemhpLXFpdS16aGk=">$\blacktriangleright$</span></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数学杂项整理</title>
    <url>/maths/mathematics/</url>
    <content><![CDATA[<p>这里是一个数学杂项（也就是太短暂时写不成博客）的整理。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h1><p>参见 <strong>陈卓裕质数三大公理</strong> (<span class="exturl" data-url="aHR0cHM6Ly9rYW1vbWUubW9lL2luZGV4LnBocC8yMDIxLzA5LzI2L3RoZXlfY2hhbmdlZF9tYXRoLw==">Link is here</span>) 。</p>
<p>在 $[1,n]$范围内，质数个数的数量级是 $\dfrac{n}{\log n}$ 的，</p>
<p>即， $\pi(n) \sim O(\dfrac{n}{\log n})$</p>
<p>（此处的$\log$指的是$\ln$）</p>
<h1 id="组合计数"><a href="#组合计数" class="headerlink" title="组合计数"></a>组合计数</h1><h2 id="排列数"><a href="#排列数" class="headerlink" title="排列数"></a>排列数</h2><p>排列数，通常用 $A$ (Arrangement)来表示。<br>公式为：</p>
<p>$$<br>\begin{equation}<br>A^n_m &#x3D; \frac{n!}{(n-m)!}<br>\end{equation}<br>$$</p>
<p>还有以下递推式：</p>
<p>$$<br>A_n^m &#x3D; m \times A_{n-1}^{m-1} + A_{n-1}^m<br>$$</p>
<h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><p>组合数，通常用 $C$ (Conbination)来表示。</p>
<p>常见的表示方法有$\binom{m}{n}$ 和 $C^n_m$ 两种。</p>
<p>我这里用的是后者。<br>（据说这个是苏联写法，已经在机房里面成为梗了）</p>
<p>公式为：</p>
<p>$$<br>\begin{equation}<br>C^n_m &#x3D; \frac{A^n_m}{A^n_n} &#x3D; \frac{n!}{(n-m)!m!}<br>\end{equation}<br>$$</p>
<p>还有以下递推式：</p>
<p>$$<br>C_n^m &#x3D; C_{n-1}^{m-1} + C_{n-1}^m<br>$$</p>
<h3 id="快速计算组合数"><a href="#快速计算组合数" class="headerlink" title="快速计算组合数"></a>快速计算组合数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m &gt; n || m &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[n] * ifac[m] % mod * ifac[n - m] % mod;</span><br><span class="line">&#125;<span class="comment">//组合数</span></span><br></pre></td></tr></table></figure>

<h3 id="常见组合恒等式"><a href="#常见组合恒等式" class="headerlink" title="常见组合恒等式"></a>常见组合恒等式</h3><ul>
<li>$\displaystyle C_n^m &#x3D; C_n^{n-m}$</li>
</ul>
<p>因为</p>
<p>$$<br>C_n^m &#x3D; \frac{n!}{(n-m)!m!} &#x3D; \frac{n!}{(n-(n-m))!(n-m)!} &#x3D; C_n^{n-m}<br>$$</p>
<ul>
<li>$\displaystyle m \times C_n^m &#x3D; n \times C_{n-1}^{m-1}$</li>
</ul>
<p>因为</p>
<p>$$<br>m \times C_n^m &#x3D; \frac{n!}{(n-m)!(m-1)!} &#x3D; n \times \frac{(n-1)!}{(n-m)!(m-1)!} &#x3D; n \times C_{n-1}^{m-1}<br>$$</p>
<ul>
<li>$\displaystyle \sum_{i&#x3D;0}^n C_n^i &#x3D; 2^n$</li>
</ul>
<p>就类似于考虑每一个物品到底是选还是不选。</p>
<ul>
<li>$\displaystyle C_n^0 + C_n^2 + \cdots &#x3D; C_n^1 + C_n^3 + \cdots &#x3D; 2^{n-1} (n \geq 1)$</li>
</ul>
<p>跟上面的那个差不多。</p>
<ul>
<li>$\displaystyle \sum_{i&#x3D;0}^n (-1)^i C_n^i &#x3D; C_n^0 - C_n^1 + C_n^2 - C_n^3 + \cdots &#x3D; [ n&#x3D;&#x3D;0 ]$</li>
</ul>
<p>上面那个的衍生。</p>
<ul>
<li>$\displaystyle \sum_{i&#x3D;0}^k C_n^i \times C_m^{k-i} &#x3D; C_{n+m}^k$</li>
</ul>
<p>考虑将 $n+m$ 的一堆物品分为一堆 $n$ 的和一堆 $m$ 的，分别从两堆里面取。<br>然后分别考虑从两堆里面各挑出来几个物品。</p>
<ul>
<li>$\displaystyle \sum_{i&#x3D;0}^n (C_n^i)^2 &#x3D; C_{2n}^n$</li>
</ul>
<p>上面的那个的特殊化。<br>因为 $C_n^i &#x3D; C_n^{n-i}$，所以我们可以将其替换为这样的形式。</p>
<h1 id="上升幂与下降幂"><a href="#上升幂与下降幂" class="headerlink" title="上升幂与下降幂"></a>上升幂与下降幂</h1><h2 id="上升幂"><a href="#上升幂" class="headerlink" title="上升幂"></a>上升幂</h2><p>$$<br>x^{\bar{k}} &#x3D; \prod_{i&#x3D;i}^k (x+i-1)<br>$$</p>
<h2 id="下降幂"><a href="#下降幂" class="headerlink" title="下降幂"></a>下降幂</h2><p>$$<br>x^{\underline{k}} &#x3D; \prod_{i&#x3D;1}^k (x-i+1)<br>$$</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵</title>
    <url>/maths/matrix/</url>
    <content><![CDATA[<p>矩阵与矩阵相关运算。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<p>在数学中，矩阵是一种很重要的表现形式；在OI中，矩阵也是一种很重要的数据结构。<br>矩阵通常可以用在线性齐次递推式的加速上，比如说加速斐波那契数列的递推过程。<br>矩阵还可以让多个数据关联起来，并简便地进行区间维护。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>为了更好地区分矩阵与其他量，我们这里将代表矩阵的符号进行了特殊处理，就像这个样子：</p>
<p>$A \to \mathbf{A}$</p>
<h2 id="矩阵是什么"><a href="#矩阵是什么" class="headerlink" title="矩阵是什么"></a>矩阵是什么</h2><p>由 $n \times m$ 个元素组成的，形如<br>$$<br>\mathbf{A} &#x3D;<br>\begin{bmatrix}<br>a_{1,1} &amp; a_{1,2} &amp; a_{1,3} &amp; \dots &amp; a_{1,m} \\<br>a_{2,1} &amp; a_{2,2} &amp; a_{2,3} &amp; \dots &amp; a_{2,m} \\<br>a_{3,1} &amp; a_{3,2} &amp; a_{3,3} &amp; \dots &amp; a_{3,m} \\<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>a_{n,1} &amp; a_{n,2} &amp; a_{n,3} &amp; \dots &amp; a_{n,m}<br>\end{bmatrix}<br>$$<br>的 $n$ 行 $m$ 列的数表，我们称之为大小为 $n \times m$ 的矩阵，可以简记为 $\mathbf{A_{\mathcal{n \times m}}}$ 。</p>
<h2 id="特殊的矩阵"><a href="#特殊的矩阵" class="headerlink" title="特殊的矩阵"></a>特殊的矩阵</h2><p>特殊的矩阵由很多种，比如单位矩阵、上三角矩阵等等。</p>
<h3 id="行矩阵与列矩阵"><a href="#行矩阵与列矩阵" class="headerlink" title="行矩阵与列矩阵"></a>行矩阵与列矩阵</h3><p>行矩阵就是只有一行的矩阵，列矩阵就是只有一列的矩阵。</p>
<h3 id="零矩阵"><a href="#零矩阵" class="headerlink" title="零矩阵"></a>零矩阵</h3><p>元素全为 $0$ 的矩阵。<br>零矩阵简记为 $\mathbf{0}$。</p>
<h3 id="负矩阵"><a href="#负矩阵" class="headerlink" title="负矩阵"></a>负矩阵</h3><p>对于一个矩阵 $\mathbf{A}$ 的负矩阵 $-\mathbf{A}$，其中每个元素都与矩阵 $\mathbf{A}$ 内相同位置的元素互为相反数。</p>
<h3 id="方阵"><a href="#方阵" class="headerlink" title="方阵"></a>方阵</h3><p>方阵指的就是正方形的矩阵，其行数与列数相等。<br>此时，其行数（或列数，反正他们相等）就可以被称作该矩阵的阶。</p>
<p>简单来说，一个 $n$ 阶方阵 $\mathbf{A_{\mathcal{n}}}$ 其实就是相当于一个 $n \times n$ 的矩阵 $\mathbf{A_{\mathcal{n \times n}}}$。</p>
<h3 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h3><p>单位矩阵就是指，在主对角线上的元素都是 $1$，其余元素都为 $0$ 的矩阵。<br>主对角线就是指 $(1,1)$ 到 $(n,n)$。这也说明单位矩阵都是正方形的。</p>
<p>单位矩阵简记为 $\mathbf{I}$。</p>
<p>单位矩阵也有其相应的阶，比如1到4阶的单位矩阵分别是这个样子的：$\mathbf{I_{\mathrm{1}}}&#x3D;\begin{bmatrix}1\end{bmatrix}$，$\mathbf{I_{\mathrm{2}}}&#x3D;\begin{bmatrix}1&amp;\\&amp;1\end{bmatrix}$，$\mathbf{I_{\mathrm{3}}}&#x3D;\begin{bmatrix}1&amp;&amp;\\&amp;1&amp;\\&amp;&amp;1\end{bmatrix}$，$\mathbf{I_{\mathrm{4}}}&#x3D;\begin{bmatrix}1&amp;&amp;&amp;\\&amp;1&amp;&amp;\\&amp;&amp;1&amp;\\&amp;&amp;&amp;1\end{bmatrix}$。</p>
<p>形象一点，就是这样：<br>（为 $0$ 的元素太多时一般将其省略）</p>
<p>$$<br>\mathbf{I} &#x3D;<br>\begin{bmatrix}<br>1&amp; &amp; &amp; \\<br> &amp;1&amp; &amp; \\<br> &amp; &amp; \ddots &amp; \\<br> &amp; &amp; &amp;1<br>\end{bmatrix}<br>$$</p>
<p>单位矩阵的一个很重要的性质就是，任何矩阵乘以单位矩阵的结果还是其本身，即 $\mathbf{AI} &#x3D; \mathbf{IA} &#x3D; \mathbf{A}$。</p>
<p>有时候还可能将单位矩阵称为 $\mathbf{E}$，但是很少见，我目前还没有见过。</p>
<h2 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h2><p>矩阵可以进行四则运算，但是与正常的数字还是有所不同。</p>
<h3 id="加减"><a href="#加减" class="headerlink" title="加减"></a>加减</h3><p>矩阵的加减要求两个矩阵必须行数列数均相同才可以进行。</p>
<p>加减的时候，每一对位置相同的元素相加或者相减。</p>
<p>形象一点就是这个样子：</p>
<p>$$<br>\mathbf{A} \pm \mathbf{B}<br>&#x3D;<br>\begin{bmatrix}<br>a &amp; b &amp; c \\<br>d &amp; e &amp; f<br>\end{bmatrix}<br>\pm<br>\begin{bmatrix}<br>g &amp; h &amp; i \\<br>j &amp; k &amp; l<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>a \pm g &amp; b \pm h &amp; c \pm i \\<br>d \pm j &amp; e \pm k &amp; f \pm l<br>\end{bmatrix}<br>$$</p>
<p>矩阵的加法满足交换律和结合律。</p>
<h3 id="数乘"><a href="#数乘" class="headerlink" title="数乘"></a>数乘</h3><p>就是一个矩阵乘以一个数。</p>
<p>乘起来的时候，矩阵内的每一个元素都要乘以这个数。</p>
<p>形象一点就是这样：</p>
<p>$$<br>λ\mathbf{A}<br>&#x3D;<br>λ \times<br>\begin{bmatrix}<br>a &amp; b &amp; c \\<br>d &amp; e &amp; f<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>λa &amp; λb &amp; λc \\<br>λd &amp; λe &amp; λf<br>\end{bmatrix}<br>$$</p>
<p>矩阵的数乘满足交换律、结合律和分配律。</p>
<p>如果将刚才这个过程反过来的话，就叫做矩阵提公因子。</p>
<h3 id="点乘"><a href="#点乘" class="headerlink" title="点乘"></a>点乘</h3><p>点乘是矩阵运算中很重要的一部分。</p>
<p>点乘又叫做矩阵乘法，（基本上）是OI中矩阵的精髓。</p>
<p>矩阵乘法不满足交换律，是因为其需要满足左侧矩阵的列数与右侧矩阵的行数相等。</p>
<p>形象一点，就是 $\mathbf{A_{\mathcal{n \times p}}} \times \mathbf{B_{\mathcal{p \times m}}} &#x3D; \mathbf{C_{\mathcal{n \times m}}}$。</p>
<p>具体操作的时候是这个样子的：</p>
<p>我们以 $\mathbf{A_{\mathrm{3 \times 3}}} \times \mathbf{B_{\mathrm{3 \times 2}}}$ 为例。</p>
<p>$$<br>\begin{align}<br>&amp; \mathbf{A_{\mathrm{3 \times 3}}} \times \mathbf{B_{\mathrm{3 \times 2}}} \\<br>&#x3D;{} &amp;<br>\begin{bmatrix}<br>a_{1,1} &amp; a_{1,2} &amp; a_{1,3} \\ a_{2,1} &amp; a_{2,2} &amp; a_{2,3} \\ a_{3,1} &amp; a_{3,2} &amp; a_{3,3}<br>\end{bmatrix}<br>\times<br>\begin{bmatrix}<br>b_{1,1} &amp; b_{1,2} \\ b_{2,1} &amp; b_{2,2} \\ b_{3,1} &amp; b_{3,2}<br>\end{bmatrix}\\<br>&#x3D;{} &amp;<br>\begin{bmatrix}<br>a_{1,1}b_{1,1}+a_{1,2}b_{2,1}+a_{1,3}b_{3,1} &amp; a_{2,1}b_{1,1}+a_{2,2}b_{2,1}+a_{2,3}b_{3,1} &amp; a_{3,1}b_{1,1}+a_{3,2}b_{2,1}+a_{3,3}b_{3,1} \\<br>a_{1,1}b_{1,2}+a_{1,2}b_{2,2}+a_{1,3}b_{3,2} &amp; a_{2,1}b_{1,2}+a_{2,2}b_{2,2}+a_{2,3}b_{3,2} &amp; a_{3,1}b_{1,2}+a_{3,2}b_{2,2}+a_{3,3}b_{3,2}<br>\end{bmatrix}<br>\end{align}<br>$$</p>
<p>除了交换律以外，矩阵乘法只满足结合律和左、右分配律。</p>
<h3 id="幂"><a href="#幂" class="headerlink" title="幂"></a>幂</h3><p>矩阵的幂运算与正常的幂运算一样，都是自乘多少次，但是由于矩阵乘法的特殊性质，我们只能给方阵求幂。</p>
<p>$\mathbf{A^{\mathcal{k}}} &#x3D; \underbrace{\mathbf{AAAA \cdots AA}}_{\text{k of}}$</p>
<p>根据这种性质，我们可以像对数字一样进行快速幂，逻辑与之前一样。</p>
<h3 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h3><p>转置就是将一个矩阵顺时针旋转90度。</p>
<p>例：<br>$$<br>\begin{bmatrix}<br>1&amp;1&amp;4\\5&amp;1&amp;4<br>\end{bmatrix}^T<br>&#x3D;<br>\begin{bmatrix}<br>5&amp;1\\1&amp;1\\4&amp;4<br>\end{bmatrix}<br>$$</p>
<p>我们使用 $\mathbf{A}^T$ 来表示矩阵 $\mathbf{A}$ 的转置。</p>
<p>转置满足以下法则：<br>$$<br>\begin{align}<br>(\mathbf{A}^T)^T &amp;&#x3D; \mathbf{A} \\<br>(\lambda \mathbf{A})^T &amp;&#x3D; \lambda \mathbf{A}^T \\<br>(\mathbf{AB})^T &amp;&#x3D; \mathbf{B}^T \mathbf{A}^T<br>\end{align}<br>$$</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我们可以使用一个二维数组来存储矩阵。</p>
<p>就像这个样子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> a[N][N];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定义一个初始化函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Matrix</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">Matrix</span>(<span class="type">int</span> n, <span class="type">int</span> m) : <span class="built_in">n</span>(n), <span class="built_in">m</span>(m) &#123; <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a)) &#125;;</span><br></pre></td></tr></table></figure>

<p>重载一下运算符：</p>
<p>加：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> Matrix <span class="keyword">operator</span> + (<span class="type">const</span> Matrix &amp;lhs, <span class="type">const</span> Matrix &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">res</span><span class="params">(lhs.n, lhs.m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lhs.n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lhs.m; j++)</span><br><span class="line">            res.a[i][j] = lhs.a[i][j] + rhs.a[i][j];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乘：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> Matrix <span class="keyword">operator</span> * (<span class="type">const</span> Matrix &amp;lhs, <span class="type">const</span> Matrix &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">res</span><span class="params">(lhs.n, rhs.m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lhs.n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= rhs.m; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= lhs.m; k++)</span><br><span class="line">                res.a[i][j] += lhs.a[i][k] * rhs.a[k][j];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乘方（快速幂）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> Matrix <span class="keyword">operator</span> ^ (Matrix rhs, <span class="type">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">res</span><span class="params">(rhs.n, rhs.n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= rhs.n; i++)res.a[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) res = res * rhs;</span><br><span class="line">        rhs = rhs * rhs;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再继续加一些其他的重载运算符之后就是这个样子：</p>
<details class="note default"><summary><p>矩阵结构体</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> a[N][N];</span><br><span class="line">    <span class="built_in">Matrix</span>() &#123;&#125;;</span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="type">int</span> n, <span class="type">int</span> m) : <span class="built_in">n</span>(n), <span class="built_in">m</span>(m) &#123; <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a)) &#125;;</span><br><span class="line">    <span class="keyword">friend</span> Matrix <span class="keyword">operator</span> + (<span class="type">const</span> Matrix &amp;lhs, <span class="type">const</span> Matrix &amp;rhs)</span><br><span class="line">    &#123;<span class="comment">//加</span></span><br><span class="line">        <span class="function">Matrix <span class="title">res</span><span class="params">(lhs.n, lhs.m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lhs.n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lhs.m; j++)</span><br><span class="line">                res.a[i][j] = lhs.a[i][j] + rhs.a[i][j];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Matrix <span class="keyword">operator</span> - (<span class="type">const</span> Matrix &amp;lhs, <span class="type">const</span> Matrix &amp;rhs)</span><br><span class="line">    &#123;<span class="comment">//减</span></span><br><span class="line">        <span class="function">Matrix <span class="title">res</span><span class="params">(lhs.n, lhs.m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lhs.n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lhs.m; j++)</span><br><span class="line">                res.a[i][j] = lhs.a[i][j] - rhs.a[i][j];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> -() <span class="type">const</span></span><br><span class="line">    &#123;<span class="comment">//取反</span></span><br><span class="line">        <span class="function">Matrix <span class="title">res</span><span class="params">(n, m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">                res.a[i][j] = -a[i][j];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Matrix <span class="keyword">operator</span> * (<span class="type">const</span> Matrix &amp;lhs, <span class="type">const</span> Matrix &amp;rhs)</span><br><span class="line">    &#123;<span class="comment">//点乘</span></span><br><span class="line">        <span class="function">Matrix <span class="title">res</span><span class="params">(lhs.n, rhs.m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lhs.n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= rhs.m; j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= lhs.m; k++)</span><br><span class="line">                    res.a[i][j] += lhs.a[i][k] * rhs.a[k][j];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Matrix <span class="keyword">operator</span> * (<span class="type">const</span> Matrix &amp;lhs, <span class="type">int</span> k)</span><br><span class="line">    &#123;<span class="comment">//数乘</span></span><br><span class="line">        <span class="function">Matrix <span class="title">res</span><span class="params">(lhs.n, lhs.m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lhs.n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lhs.m; j++)</span><br><span class="line">                res.a[i][j] = lhs.a[i][j] * k;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Matrix <span class="keyword">operator</span> ^ (Matrix lhs, <span class="type">int</span> n)</span><br><span class="line">    &#123;<span class="comment">//快速幂</span></span><br><span class="line">        <span class="function">Matrix <span class="title">res</span><span class="params">(lhs.n, lhs.n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lhs.n; i++)res.a[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n &amp; <span class="number">1</span>) res = res * lhs;</span><br><span class="line">            lhs = lhs * lhs;</span><br><span class="line">            x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>

<p>但其实更常见的是这样子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> a[N][N];</span><br><span class="line">    <span class="built_in">Matrix</span>() &#123;&#125;;</span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="type">int</span> n, <span class="type">int</span> m) : <span class="built_in">n</span>(n), <span class="built_in">m</span>(m) &#123; <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a)) &#125;;</span><br><span class="line">    <span class="keyword">friend</span> Matrix <span class="keyword">operator</span> + (<span class="type">const</span> Matrix &amp;lhs, <span class="type">const</span> Matrix &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">res</span><span class="params">(lhs.n, lhs.m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lhs.n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lhs.m; j++)</span><br><span class="line">                res.a[i][j] = lhs.a[i][j] + rhs.a[i][j];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Matrix <span class="keyword">operator</span> * (<span class="type">const</span> Matrix &amp;lhs, <span class="type">const</span> Matrix &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">res</span><span class="params">(lhs.n, rhs.m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lhs.n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= rhs.m; j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= lhs.m; k++)</span><br><span class="line">                    res.a[i][j] += lhs.a[i][k] * rhs.a[k][j];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Matrix <span class="keyword">operator</span> ^ (Matrix lhs, <span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">res</span><span class="params">(lhs.n, lhs.n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lhs.n; i++)res.a[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n &amp; <span class="number">1</span>) res = res * lhs;</span><br><span class="line">            lhs = lhs * lhs;</span><br><span class="line">            x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="矩阵加速递推"><a href="#矩阵加速递推" class="headerlink" title="矩阵加速递推"></a>矩阵加速递推</h2><p>就以矩阵加速斐波那契数列递推为例吧。</p>
<p>我们将第 $n$ 项斐波那契数简写为 $F_n$。</p>
<p>我们知道 $F_n &#x3D; F_{n-1} + F_{n-2}$，我们就考虑把斐波那契数列的相邻两项放在一个行（或者列，根据个人习惯）矩阵里面，就像这个样子：$\begin{bmatrix}F_i&amp;F_{i-1}\end{bmatrix}$。</p>
<p>我们需要把 $\begin{bmatrix}F_i&amp;F_{i-1}\end{bmatrix}$ 变成 $\begin{bmatrix}F_{i-1}+F_i&amp;F_i\end{bmatrix}$，同时需要用到矩阵乘法。</p>
<p>因为<br>$$<br>\begin{bmatrix}<br>a &amp; b<br>\end{bmatrix}<br>\times<br>\begin{bmatrix}<br>x &amp; y\\<br>z &amp; w<br>\end{bmatrix}<br>&#x3D;<br>\begin{bmatrix}<br>ax+bz &amp; ay+bw<br>\end{bmatrix}<br>$$</p>
<p>所以我们如果想让 $\begin{bmatrix}a&amp;b\end{bmatrix}$ 变成 $\begin{bmatrix}a+b&amp;a\end{bmatrix}$ 的话，我们就需要将其乘以 $\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}$。</p>
<p>然后就是矩阵快速幂了。<br>因为我们一开始的 $\begin{bmatrix}1&amp;1\end{bmatrix}$ 是 $\begin{bmatrix}F_2&amp;F_1\end{bmatrix}$，所以我们只需要将其乘以 $\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}^{n-2}$ 即可得到 $F_n$。</p>
<h3 id="如何构建转移矩阵"><a href="#如何构建转移矩阵" class="headerlink" title="如何构建转移矩阵"></a>如何构建转移矩阵</h3><p>我们考虑我们是如何从一个状态转移到下一个状态的。</p>
<p>对于一个函数 $f(x)$，我们假定它具有这样的转移式子：</p>
<p>$$<br>f(x) &#x3D; f(x-1) + 2f(x-2) + 2^x + 2<br>$$</p>
<p>我们的状态矩阵就是这个样子的：$\begin{bmatrix}f(x)&amp;f(x-1)&amp;2^x&amp;1\end{bmatrix}$。</p>
<p>然后我们考虑我们如何从 $\begin{bmatrix}f(x-1)&amp;f(x-2)&amp;2^{x-1}&amp;1\end{bmatrix}$ 变为 $\begin{bmatrix}f(x)&amp;f(x-1)&amp;2^x&amp;1\end{bmatrix}$</p>
<p>我们将 $\begin{bmatrix}f(x)&amp;f(x-1)&amp;2^x&amp;1\end{bmatrix}$ 展开，得</p>
<p>$$<br>\begin{align}<br>f(x) &amp;&#x3D; f(x-1) \times 1 + f(x-2) \times 2 + 2^{x-1} \times 2 + 1 \times 2 \\<br>f(x-1) &amp;&#x3D; f(x-1) \times 1 + f(x-2) \times 0 + 2^{x-1} \times 0 + 1 \times 0 \\<br>2^x &amp;&#x3D; f(x-1) \times 0 + f(x-2) \times 0 + 2^{x-1} \times 2 + 1 \times 0 \\<br>1 &amp;&#x3D; f(x-1) \times 0 + f(x-2) \times 0 + 2^{x-1} \times 0 + 1 \times 1<br>\end{align}<br>$$</p>
<p>然后我们就可以得到我们的转移矩阵了：</p>
<p>$$<br>\begin{bmatrix}<br>1&amp;1&amp;0&amp;0\\<br>2&amp;0&amp;0&amp;0\\<br>2&amp;0&amp;2&amp;0\\<br>2&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>$$</p>
<h2 id="矩阵辅助维护信息"><a href="#矩阵辅助维护信息" class="headerlink" title="矩阵辅助维护信息"></a>矩阵辅助维护信息</h2><p>这种一般就是对于那种同时需要维护多种信息，还需要支持一大堆复杂的操作，但是推式子的时候不会超过一次的那种题，就比如说这一个：</p>
<p><a href="/solutions/solution-l2980/">THUSC 大魔法师</a></p>
<p>我们可以发现其操作（$A_i &#x3D; A_i + k$，$B_i &#x3D; B_i \times k$，$C_i &#x3D; k$）均未出现两个未知量相乘的情况，即可判定其可以利用矩阵乘法来维护。</p>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>特殊的数</title>
    <url>/maths/special-numbers/</url>
    <content><![CDATA[<p>简介： 卡特兰数，斯特林数，欧拉数，调和级数</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="卡特兰数-Catalan-Numbers"><a href="#卡特兰数-Catalan-Numbers" class="headerlink" title="卡特兰数(Catalan Numbers)"></a>卡特兰数(Catalan Numbers)</h1><p>卡特兰数 (<del>Català</del>Catalan Numbers) 十分常用，序列的开头是 $1,1,2,5,14,42,\cdots$。</p>
<p>卡特兰数的主要应用是再括号序列上面，很多题目都可以转化成为括号序列的问题，就比如下面这个：</p>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>有关卡特兰数的例题有很多，其中最经典的是<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwNDQ=">下面这个</span>：</p>
<p>我们有 $n$ 个元素和一个栈。这 $n$ 各元素是 $[1,n]$ 的所有整数，并且以升序排列。</p>
<p>现在我们将所有的元素放入栈中，并最终让所有元素都出栈。栈的<code>pop()</code>和<code>push()</code>的顺序由你自己来决定，问有多少种可能的出栈顺序。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>我们显然可以看出，我们不能对着一个空的栈疯狂<code>pop()</code>，也不能对着一个空的进栈序列疯狂<code>push()</code>。<br>所以，每一个<code>pop()</code>操作必定对应着之前的一个<code>pop()</code>操作，且所有<code>pop()</code>操作的次数与<code>push()</code>操作的次数相等。</p>
<p>我们尝试将<code>push()</code>和<code>pop()</code>抽象为前缀和的形式。<br>我们可以将<code>push()</code>转化为<code>+1</code>，<code>pop()</code>转化为<code>-1</code>。<br>那么，我们的要求就是：</p>
<p>该序列的每一个前缀和必定大于等于0，且整个序列的和必定为0。</p>
<p>这就需要我们使用卡特兰数。</p>
<h2 id="求值"><a href="#求值" class="headerlink" title="求值"></a>求值</h2><p>我们这里使用 $C_n$ 来代表第 $n$ 项卡特兰数。</p>
<p>我们通常使用的都是单个的卡特兰数（除非有多组测试数据），所以这里首先给出了通项公式。</p>
<p>卡特兰数的通项公式是这个样子的：</p>
<p>$$<br>C_n&#x3D;\frac{C_{2n}^n}{n+1}<br>$$</p>
<p>如果需要生成卡特兰数数列，那么我们可以进行递推：</p>
<p>首先，$C_0&#x3D;C_1&#x3D;1$，这两个我们先自己手动输入进去。<br>之后我们可以根据这个递推公式来计算：</p>
<p>$$<br>C_n &#x3D; C_{n-1} \frac{4n-2}{n+1}<br>$$</p>
<p>我们需要注意，在 $n \in [ 0,16 ] $ 的时候可以只开<code>int</code>；在 $n \in [ 17,35 ] $ 的时候就需要开<code>long long</code>了；而当 $n \geq 36$ 的时候就只能使用高精度或者用 Python 来求了。</p>
<p>递推代码示例：</p>
<p>Python：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ans = <span class="number">1</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;项数：&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1:&quot;</span> + <span class="built_in">str</span>(ans))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">    ans = ans * (<span class="number">4</span> * i - <span class="number">2</span>) // (i + <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(i) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(ans))</span><br></pre></td></tr></table></figure>

<p>例题 <span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwNDQ=">Luogu P1044</span> 代码示例：</p>
<p>Python：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ans = <span class="number">1</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">    ans = ans * (<span class="number">4</span> * i - <span class="number">2</span>) // (i + <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(ans))</span><br></pre></td></tr></table></figure>

<p>C++：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        ans = ans * (<span class="number">4</span> * i - <span class="number">2</span>) / (i + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="斯特林数-Stirling-Numbers"><a href="#斯特林数-Stirling-Numbers" class="headerlink" title="斯特林数(Stirling Numbers)"></a>斯特林数(Stirling Numbers)</h1><p>斯特林数 (Stirling Numbers) 分为第一类斯特林数和第二类斯特林数。</p>
<p>我们使用 $S_1(n,k)$ 来表示第一类斯特林数，使用 $S_2(n,k)$ 来表示第二类斯特林数。<br>通常的表达方式是这样的：<br>使用 $\begin{bmatrix} n \\ k \end{bmatrix}$ 来表示第一类斯特林数，使用 $\begin{Bmatrix} n \\ k \end{Bmatrix}$ 来表示第二类斯特林数。<br>但是因为这个样子在 $ \LaTeX $ 里面并不好打，所以我就索性换了个表达方式，以便我能够打出来。</p>
<h2 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h2><p>第二类斯特林数比第一类更加常用（其实是所有这些数里除了组合数外最常用的），所以我们先介绍第二类斯特林数。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>第二类斯特林数 $S_2(n,k)$ $(n \geq k)$ 表示讲一个有 $n$ 件互不相同的物品的集合划分为 $k$ 个非空子集的方法数。</p>
<p>例：</p>
<p>$S_2(4,2)$ 有下列几种情况：</p>
<p>$$<br>\begin{align}<br>\{ 1 , 2 , 3 \} &amp; \cup \{ 4 \} \\<br>\{ 1 , 2 , 4 \} &amp; \cup \{ 3 \} \\<br>\{ 1 , 3 , 4 \} &amp; \cup \{ 2 \} \\<br>\{ 2 , 3 , 4 \} &amp; \cup \{ 1 \} \\<br>\{ 1 , 2 \} &amp; \cup \{ 3 , 4 \} \\<br>\{ 1 , 3 \} &amp; \cup \{ 2 , 4 \} \\<br>\{ 1 , 4 \} &amp; \cup \{ 2 , 3 \}<br>\end{align}<br>$$</p>
<p>所以 $S_2(4,2)&#x3D;7$ 。</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol>
<li><p>显而易见的，$S_2(n,1)&#x3D;1$ ，$S_2(n,n)&#x3D;1$ 。</p>
</li>
<li><p>特别的，我们规定 $S_2(0,0)&#x3D;1$ ，$S_2(n,0)&#x3D;0$ 。</p>
</li>
</ol>
<h3 id="求值-1"><a href="#求值-1" class="headerlink" title="求值"></a>求值</h3><p>我们从较小的 $k$ 来入手。</p>
<p>当 $k \leq 1$ 时 比较好办，我们可以通过上面两个显而易见的性质推出来。</p>
<p>而当 $k&#x3D;2$ 时，我们可以这样想：<br>一个物品不是放在一个篮子里面就是放在另一个篮子里面，所以 $n$ 个物品一共有 $n^2$ 中不同的划分方式。<br>而因为两个篮子不区分，且有着非空的要求，所以最终的划分方式就只有 $2^{n-1}-1$ 种了。<br>所以，</p>
<p>$$<br>S_2(n,k) &#x3D; 2^{n-1}-1 \quad (n&gt;0)<br>$$</p>
<p>或者使用更难打出来但更眼熟的方式：</p>
<p>$$<br>\begin{Bmatrix}<br>n \\ 2<br>\end{Bmatrix}<br>&#x3D; 2^{n-1}-1<br>$$</p>
<p>再来看 $k&gt;2$ 的情况。</p>
<p>我们仍然对每一个物品进行分析，只不过我们这次是倒序分析的。</p>
<p>对于最后的一个物品，我们可以将其单独分成一堆，也可以将其放入之前的 $n-1$ 个物品组成的 $k$ 堆中的一堆中。</p>
<p>对于前一个选择，我们有 $S_2(n-1,k-1)$ 中排列的方法；而对于后一种，我们有 $S_2(n-1,k)$ 中方法，最后还需乘以我们可以做出的选择数 $k$。</p>
<h4 id="递推式"><a href="#递推式" class="headerlink" title="递推式"></a>递推式</h4><p>所以总结一一下，我们有以下递推式：</p>
<p>$$<br>S_2(n,k) &#x3D; k · S_2(n-1,k) + S_2(n-1,k-1)<br>$$</p>
<p>或者使用更难打出来但更眼熟的表达方式：</p>
<p>$$<br>\begin{Bmatrix}<br>n \\ k<br>\end{Bmatrix}<br>&#x3D;<br>k<br>\begin{Bmatrix}<br>n-1 \\ k<br>\end{Bmatrix}<br>+<br>\begin{Bmatrix}<br>n-1 \\ k-1<br>\end{Bmatrix}<br>$$</p>
<h4 id="通项式"><a href="#通项式" class="headerlink" title="通项式"></a>通项式</h4><p>还有一种直接求的通项公式，是这个样子的：</p>
<p>$$<br>S_2(n,m)&#x3D;\sum_{i&#x3D;0}^m \frac{(-1)^{m-i} i^n}{i! (m-i)!}<br>$$</p>
<h2 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>第一类斯特林数 $S_1(n,k) (n \geq k)$ 也是一种描述将 $n$ 个互不相同的物品划分为 $k$ 个不同的轮换的方案。</p>
<p>所谓轮换，就是指像项链一样的环形排列，可以类比成把所有的元素像珠子一样穿到项链上。</p>
<p>比如说一个轮换 $[A,B,C,D]$，它有4种异构体：</p>
<p>$$<br>[A,B,C,D]&#x3D;[B,C,D,A]&#x3D;[C,D,A,B]&#x3D;[D,A,B,C]<br>$$</p>
<p>所以说对于 $S_1(4,2)$，有下列几种情况：</p>
<p>$$<br>\begin{align}<br>[ 1,2,3 ] [ 4 ] \quad [ 1,3,2 ] [ 4 ] \\<br>[ 1,2,4 ] [ 3 ] \quad [ 1,4,2 ] [ 3 ] \\<br>[ 1,3,4 ] [ 2 ] \quad [ 1,4,3 ] [ 2 ] \\<br>[ 2,3,4 ] [ 1 ] \quad [ 2,4,3 ] [ 1 ]<br>\end{align}<br>$$<br>$$<br>[ 1,2 ] [ 3,4 ] \quad<br>[ 1,3 ] [ 2,4 ] \quad<br>[ 1,4 ] [ 2,3 ]<br>$$</p>
<p>一共11种。</p>
<p>所以， $S_1(4,2)&#x3D;11$。</p>
<p>我们不难看出，$S_1(n,k) \geq S_2(n,k)$。</p>
<h3 id="求值-2"><a href="#求值-2" class="headerlink" title="求值"></a>求值</h3><p>我们仍然从较小的 $k$ 开始。</p>
<p>当 $k&#x3D;1$ 时，我们对于每一个空位考虑。第 $i$ 个空位可以随意选择 $n-i+1$ 个物品，总体就是 $\displaystyle \prod_{i&#x3D;1}^n (n-i+1)$，显而易见是 $(n-1)!$。<br>所以：</p>
<p>$$<br>S_1(n,1)&#x3D;(n-1)!<br>$$</p>
<p>当所有的轮换都至多含两个物品的时候，我们就会发现，此时的轮换与子集是等价的。<br>这种情况只能在 $k&#x3D;n-1$ 的时候成立，也就是说，<br>$$<br>\begin{align}<br>S_1(n,n) &amp;&#x3D; S_2(n,n) &#x3D; 1 \\<br>S_1(n,n-1) &amp;&#x3D; S_2(n,n-1) &#x3D; C^2_n<br>\end{align}<br>$$</p>
<h4 id="递推式-1"><a href="#递推式-1" class="headerlink" title="递推式"></a>递推式</h4><p>我们考虑一般的情况。</p>
<p>还是类似之前考虑 $S_2$ 时的方法，我们还是考虑最后一个元素。</p>
<p>对于这个元素，我们可以将其单独成堆，也可以将其放在之前的任意一个轮换里面。</p>
<p>显然，对于前者，我们有 $S_1(n-1,k-1)$ 种方案；对于后者，我们有 $S_1(n-1,k)$ 种方案，而这个物品有 $n-1$ 种放置的位置（指插在任意一个元素的后面），所以总共是这样的式子：</p>
<p>$$<br>S_1(n,k) &#x3D; (n-1) · S_1(n-1,k) + S_1(n-1,k-1)<br>$$</p>
<p>或者使用更难打出来但更眼熟的表达方式：</p>
<p>$$<br>\begin{bmatrix}<br>n \\ k<br>\end{bmatrix}<br>&#x3D;<br>(n-1)<br>\begin{bmatrix}<br>n-1 \\ k<br>\end{bmatrix}<br>+<br>\begin{bmatrix}<br>n-1 \\ k-1<br>\end{bmatrix}<br>$$</p>
<p>第一类斯特林数没有实用的通项公式。</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1041C Coffee Break 题解</title>
    <url>/solutions/solution-cf1041c/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">Coffee Break</div>
<div id="problem-info-from">Codeforces Round #509 (Div. 2)</div>
<div id="problem-info-difficulty">提高+ /省选-</div>
<div id="problem-info-color">#3498db</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0YxMDQxQw==">Luogu CF1041C</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9wcm9ibGVtc2V0L3Byb2JsZW0vMTA0MS9D">CF 1041 C</span></li></ul></div>

<hr>
<p>题目大概说的就是，给定 $n$ 个数和一个 $k$，让我们把这 $n$ 个数划分到尽量少的集合中去。每一个集合需要满足一个条件，就是其中任意两个数的差必须大于 $k$。</p>
<p>我们可以贪心地每一次取出当前集合内的最小值，并不断查找最小可以选取的值并选取之，直到无法再选取新值为止。</p>
<p>查找最小可以选取的值可以使用<code>lower_bound()</code>，那我们需要一个数据结构，支持快速查询当前最小值。<br>因为数据保证不会有重复的数，我们可以使用<code>set&lt;int&gt;</code>来进行存储。</p>
<p>总复杂度 $O(n \log n)$。</p>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll m, k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line">    ll v;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="built_in">Data</span>(ll _v, <span class="type">int</span> _id) &#123; <span class="keyword">this</span>-&gt;v = _v, <span class="keyword">this</span>-&gt;id = _id; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Data &amp;a)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> v &lt; a.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;Data&gt;s;</span><br><span class="line"><span class="type">int</span> pos[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld%lld&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;x);</span><br><span class="line">        s.<span class="built_in">emplace</span>(x, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> now = s.<span class="built_in">begin</span>()-&gt;v, cnt = <span class="number">1</span>;</span><br><span class="line">    pos[s.<span class="built_in">begin</span>()-&gt;id] = <span class="number">1</span>;</span><br><span class="line">    s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Data <span class="title">x</span><span class="params">(now + k + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        set&lt;Data&gt;::iterator it = s.<span class="built_in">lower_bound</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(it != s.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            pos[it-&gt;id] = cnt;</span><br><span class="line">            now = it-&gt;v;</span><br><span class="line">            s.<span class="built_in">erase</span>(it);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++cnt;</span><br><span class="line">        it = s.<span class="built_in">begin</span>();</span><br><span class="line">        pos[it-&gt;id] = cnt;</span><br><span class="line">        now = it-&gt;v;</span><br><span class="line">        s.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pos[i]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>贪心</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1288F Red-Blue Graph 题解</title>
    <url>/solutions/solution-cf1288f/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">Red-Blue Graph</div>
<div id="problem-info-from">Educational Codeforces Round 80</div>
<div id="problem-info-difficulty">NOI / NOI+ / CTSC</div>
<div id="problem-info-color">#0e1d69</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0YxMjg4Rg==">Luogu CF1288F</span></li><li><span class="exturl" data-url="aHR0cDovL2NvZGVmb3JjZXMuY29tL3Byb2JsZW1zZXQvcHJvYmxlbS8xMjg4L0Y=">CF 1288 F</span></li></ul></div>

<hr>
<p>不知道怎么就有思路了（</p>
<p>首先看数据范围，$1 \leq n,m \leq 200$，应该是给网络流的复杂度。</p>
<p>对于一个红色的点，我们将其连接着的边中颜色不同的边一对对地消除了之后还剩一些红边，对于蓝点这样消除之后还剩一些蓝边。<br>那么红点应该对于红边有贡献，蓝点应该对于蓝边有贡献。</p>
<p>把这个绑定到流上面，就可以认为红点有流出，蓝点有流入，而没有颜色的点既可以流出也可以流入。而红边从左往右，蓝边从右往左，没有染色的边不走，所以既不往左也不往右。<br>我们需要保证这个“不少于”，那么二分图的点连向源（汇）点的边就有了下界，需要使用有源汇上下界最小费用可行流。<br>其实现思路与有源汇上下界可行流是一样的，同时也需要将bfs函数改为spfa来实现费用流。</p>
<hr>
<p>具体实现的时候，我们将每一个原图中的边拆成两条边，一条红，一条蓝，容量为 $[0,1]$。<br>对于每一个点，如果其是红色点，那么连接源点，容量为 $[1,\infty]$；如果其是蓝色点，那么连接汇点，容量为 $[1,\infty]$；如果其没有颜色，那么其既连接源点，又连接汇点，容量都是 $[0,\infty]$。</p>
<p>然后就直接跑就可以了。</p>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = <span class="number">200010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> m, n1, n2;</span><br><span class="line"><span class="type">int</span> S, T, s, t;</span><br><span class="line"><span class="type">int</span> R, B;</span><br><span class="line"><span class="type">int</span> h[N], e[M], f[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> A[N], tot;</span><br><span class="line"><span class="type">int</span> q[N], d[N], pre[N], incf[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A[a] -= l, A[b] += l;</span><br><span class="line">    e[idx] = b, f[idx] = r - l, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">    e[idx] = a, f[idx] = <span class="number">0</span>, w[idx] = -c, ne[idx] = h[b], h[b] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">memset</span>(incf, <span class="number">0</span>, <span class="built_in">sizeof</span>(incf));</span><br><span class="line">    q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, incf[S] = INF;</span><br><span class="line">    <span class="keyword">while</span>(hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh == N) hh = <span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i];</span><br><span class="line">            <span class="keyword">if</span>(f[i] &amp;&amp; d[v] &gt; d[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[v] = d[t] + w[i];</span><br><span class="line">                pre[v] = i;</span><br><span class="line">                incf[v] = <span class="built_in">min</span>(f[i], incf[t]);</span><br><span class="line">                <span class="keyword">if</span>(!st[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++] = v;</span><br><span class="line">                    <span class="keyword">if</span>(tt == N) tt = <span class="number">0</span>;</span><br><span class="line">                    st[v] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> incf[T] &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EK</span><span class="params">(<span class="type">int</span> &amp;flow, <span class="type">int</span> &amp;cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    flow = cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = incf[T];</span><br><span class="line">        flow += t, cost += t * d[T];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = T; i != S; i = e[pre[i] ^ <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            f[pre[i]] -= t;</span><br><span class="line">            f[pre[i] ^ <span class="number">1</span>] += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>, &amp;n1, &amp;n2, &amp;m, &amp;R, &amp;B);</span><br><span class="line">    s = <span class="number">0</span>, t = n1 + n2 + <span class="number">1</span>;</span><br><span class="line">    S = n1 + n2 + <span class="number">2</span>, T = n1 + n2 + <span class="number">3</span>;</span><br><span class="line">    string lc, rc;</span><br><span class="line">    cin &gt;&gt; lc &gt;&gt; rc;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b + n1, <span class="number">0</span>, <span class="number">1</span>, R);</span><br><span class="line">        <span class="built_in">add</span>(b + n1, a, <span class="number">0</span>, <span class="number">1</span>, B);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lc[i - <span class="number">1</span>] == <span class="string">&#x27;R&#x27;</span>)<span class="built_in">add</span>(s, i, <span class="number">1</span>, INF, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(lc[i - <span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span>)<span class="built_in">add</span>(i, t, <span class="number">1</span>, INF, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(lc[i - <span class="number">1</span>] == <span class="string">&#x27;U&#x27;</span>)<span class="built_in">add</span>(s, i, <span class="number">0</span>, INF, <span class="number">0</span>), <span class="built_in">add</span>(i, t, <span class="number">0</span>, INF, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(rc[i - <span class="number">1</span>] == <span class="string">&#x27;R&#x27;</span>)<span class="built_in">add</span>(i + n1, t, <span class="number">1</span>, INF, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(rc[i - <span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span>)<span class="built_in">add</span>(s, i + n1, <span class="number">1</span>, INF, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(rc[i - <span class="number">1</span>] == <span class="string">&#x27;U&#x27;</span>)<span class="built_in">add</span>(s, i + n1, <span class="number">0</span>, INF, <span class="number">0</span>), <span class="built_in">add</span>(i + n1, t, <span class="number">0</span>, INF, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add</span>(t, s, <span class="number">0</span>, INF, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = s; i &lt;= t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt; <span class="number">0</span>)tot += A[i], <span class="built_in">add</span>(S, i, <span class="number">0</span>, A[i], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(A[i] &lt; <span class="number">0</span>)<span class="built_in">add</span>(i, T, <span class="number">0</span>, -A[i], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> flow, cost;</span><br><span class="line">    <span class="built_in">EK</span>(flow, cost);</span><br><span class="line">    <span class="keyword">if</span>(flow != tot)<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cost);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m * <span class="number">4</span>; i += <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!f[i])<span class="built_in">putchar</span>(<span class="string">&#x27;R&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!f[i + <span class="number">2</span>])<span class="built_in">putchar</span>(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">&#x27;U&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>CF436E Cardboard Box 题解</title>
    <url>/solutions/solution-cf436e/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">Cardboard Box</div>
<div id="problem-info-from">Zepto Code Rush 2014</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vQ0Y0MzZF">Luogu CF436E</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9wcm9ibGVtc2V0L3Byb2JsZW0vNDM2L0U=">CF 436 E</span></li></ul></div>

<hr>
<p>题目说，我们可以花费 $a_i$ 的代价拿到1分，或者可以花费 $b_i$ 的代价拿到两分。我们需要求出得到 $k$ 分的代价和方案。</p>
<p>一眼反悔贪心问题，但是做法却不是那么显然。</p>
<p>一个根据之前反悔贪心能得出的做法就是，把 $a_i$ 扔进一个小根堆里面，然后选中了一个 $a_i$ 之后就将其所对应的 $b_i - a_i$ 扔进小根堆里面，取 $k$ 次堆顶。</p>
<p>但是有一种情况就是，有可能你取 $b_j$ 更优，但是 $a_j$ 没能取到导致 $b_j$ 也取不到。</p>
<p>我们就可以分开考虑，将所有的 $a_i$ 加入一个小根堆，之后将所有的 $b_i - a_i$ 加入另一个小根堆，再拿一个数组记录下哪些已经被选中了，然后每一次取的时候权衡一下到底是取 $a_i$ 最好还是取 $b_i$ 最好。</p>
<p>每一次决策的时候都需要将已经选过了的全部清掉，防止选到重复的。</p>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>, M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> st[N];</span><br><span class="line">ll a[M];</span><br><span class="line"><span class="type">bool</span> vis[M];</span><br><span class="line">ll sum;</span><br><span class="line">priority_queue&lt;pair&lt;ll, <span class="type">int</span>&gt; &gt;q, t;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dump</span><span class="params">(priority_queue&lt;pair&lt;ll, <span class="type">int</span>&gt; &gt; &amp;q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; vis[q.<span class="built_in">top</span>().second])q.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;a[i], &amp;a[i + n]);</span><br><span class="line">        a[i + n] -= a[i];</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-a[i], i));</span><br><span class="line">        t.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-a[i] - a[i + n], i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dump</span>(q), <span class="built_in">dump</span>(t);</span><br><span class="line">        <span class="type">int</span> i = q.<span class="built_in">top</span>().second;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">dump</span>(q);</span><br><span class="line">        <span class="keyword">if</span>(m &amp;&amp; !t.<span class="built_in">empty</span>() &amp;&amp; a[i] - q.<span class="built_in">top</span>().first &gt;= -t.<span class="built_in">top</span>().first)</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-a[i], i));</span><br><span class="line">            i = t.<span class="built_in">top</span>().second;</span><br><span class="line">            t.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; n)q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-a[i + n], i + n));</span><br><span class="line">        sum += a[i];</span><br><span class="line">        st[i % n]++;</span><br><span class="line">        vis[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, st[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>反悔贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>LibreOJ #2759 蜜袋鼯（フクロモモンガ） 题解</title>
    <url>/solutions/solution-l2759/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name"><ruby>蜜袋鼯<rt>フクロモモンガ</rt></ruby></div>
<div id="problem-info-from">JOI 2014 Final T4</div>
<div id="problem-info-difficulty">none</div>
<div id="problem-info-color">#0e1d69</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yNzU5">LibreOJ L2759</span></li></ul></div>

<hr>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>首先我们考虑一下我们的策略。</p>
<p>无论给出何种方案，我们都需要遵守一个原则：非必要不爬升，且爬升时只爬升至足够飞过去的高度即可。</p>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>对于前半句，我们这样分析：</p>
<p>我们假设可以突破高度只能大于等于0的限制。</p>
<p>那我们就可以持续进行飞行操作，直到到达终点再向上爬到树顶。</p>
<p>也就是说，我们将我们的操作从一系列的“飞跃-爬升”操作变成了一串连续的飞跃操作和一个爬升操作。</p>
<p>显然，只要我们选择的路径一定，我们最后爬升的路程一定是一定的。<br>我们不妨设其为 $h$ 。</p>
<p>如果我们在这种情况下，选择在中间进行一次爬升操作，假设我们爬升的高度为 $h’$ 。<br>那么，我们到达最后的高度就是$H_N - h + h’$。</p>
<p>然而，我们总共还是爬升了 $h-h’+h’&#x3D;h$ 的高度，总共爬升操作所用的时间也是不变的。</p>
<p>更何况我们还会遇到到一棵树正上方时高度大于树高的时候，这时候我们就只能降低高度，而在最后多的时间来爬升刚才降低的那一段距离。<br>这会导致如果我们瞎爬升的话，结果会劣于非必要不爬升的结果。</p>
<p>那么对于后半句，我们这样分析：</p>
<p>假设一种极限情况，一路上的树一棵比一棵矮，且每一次从树顶开始飞行都会飞跃目标树。<br>那么如果我们选择爬升的高度太多，就会导致爬升高度的浪费。</p>
<p>我们完全可以选择一种极端的情况，那么就是让我们的高度保持为0即可。<br>我们在每次飞跃一条边（假设其为 $(u,v)$ ）时，我们如果之前已经保持了高度为0的话，我们就只需爬升 $w_{(u,v)}$ 的高度即可，即到达 $v$ 点时高度仍然为零。而如果我们仍有高度$x$的话，我们就爬升 <code>(x-w[(u,v)]&gt;=0)?0:(w[(u,v)]-x)</code> 即可。<br>如果按照这样操作的话，我们只会在达到高度为0之前的时候才可能下降高度以适配较低的树高，最终得到的就是最优的结果。</p>
<hr>
<p>之后对每一条边进行分析。</p>
<p>对于每一条边 $(u,v)$ ，会有以下四种情况：</p>
<ol>
<li>到达点正上方时的高度大于树高。<br>需要先向下爬到高度为 $h_v + w_{(u,v)}$ 的点才能从该边飞过，可以证明这是最优选择。</li>
<li>在飞行途中不得不落地。<br>我们无论如何都无法通过这一条边，只能在向有向图中加边时忽略这一条边。</li>
<li>不向上爬无法正常飞到下一个点。<br>根据上面的证明，我们只需向上爬升至高度 $w_{(u,v)}$ ，保证尽量靠近地面。</li>
<li>可以正常飞到下一个点。<br>直接飞跃即可。</li>
</ol>
<p>这样这个问题就变成了一个最短路问题。<br>而对于最短路的寻找，我们采用dijkstra算法。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">300005</span>;</span><br><span class="line"><span class="type">int</span> h[N], ne[M &lt;&lt; <span class="number">1</span>], e[M &lt;&lt; <span class="number">1</span>], w[M &lt;&lt; <span class="number">1</span>], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> val[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">ll sum[N];</span><br><span class="line"><span class="type">int</span> H[N];</span><br><span class="line"><span class="type">bool</span> mark[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    ll v;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node &amp;A)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> v &gt; A.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> at)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)sum[i] = <span class="number">1e18</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123; <span class="number">0</span>,<span class="number">1</span> &#125;);</span><br><span class="line">    H[<span class="number">1</span>] = at;</span><br><span class="line">    sum[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    ll v;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        node now = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(mark[now.id])<span class="keyword">continue</span>;</span><br><span class="line">        mark[now.id] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> nh = H[now.id];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[now.id]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nh - w[i] &gt; val[e[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                v = sum[now.id] + nh - w[i] - val[e[i]] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(sum[e[i]] &gt; v)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum[e[i]] = v;</span><br><span class="line">                    H[e[i]] = val[e[i]];</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123; sum[e[i]],e[i] &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nh - w[i] &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                v = sum[now.id] + w[i] - nh + w[i];</span><br><span class="line">                <span class="keyword">if</span>(sum[e[i]] &gt; v)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum[e[i]] = v;</span><br><span class="line">                    H[e[i]] = <span class="number">0</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123; sum[e[i]],e[i] &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(sum[e[i]] &gt; sum[now.id] + w[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    sum[e[i]] = sum[now.id] + w[i];</span><br><span class="line">                    H[e[i]] = nh - w[i];</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123; sum[e[i]],e[i] &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="type">int</span> at;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;at);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;val[i]);</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">if</span>(val[a] &gt;= c)<span class="built_in">add</span>(a, b, c);</span><br><span class="line">        <span class="keyword">if</span>(val[b] &gt;= c)<span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>(at);</span><br><span class="line">    <span class="keyword">if</span>(sum[n] == <span class="number">1e18</span>)<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, sum[n] + val[n] - H[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>LibreOJ #2980 [THUSCH 2017] 大魔法师 题解</title>
    <url>/solutions/solution-l2980/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">大魔法师</div>
<div id="problem-info-from">THUSCH 2017</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDc0NTM=">Luogu P7453</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yOTgw">LibreOJ L2980</span></li></ul></div>

<hr>
<p>首先看题：</p>
<p>题目要求我们在 $[ 1,n ]$ 的区间上维护三个值 $A_i,B_i,C_i$，要求支持查询区间和和下面六中操作：</p>
<ol>
<li>区间内 $A_i &#x3D; A_i + B_i$；</li>
<li>区间内 $B_i &#x3D; B_i + C_i$；</li>
<li>区间内 $C_i &#x3D; C_i + A_i$；</li>
<li>区间内 $A_i &#x3D; A_i + k$（$k$ 给定）；</li>
<li>区间内 $B_i &#x3D; B_i \times k$（$k$ 给定）；</li>
<li>区间内 $C_i &#x3D; k$（$k$ 给定）。</li>
</ol>
<p>显然这道题需要使用线段树来维护区间操作。<br>但是我们不能给每一个操作附上一个懒标记，最后懒标记下放的时候还不得麻烦死。</p>
<p>我们可以尝试一下转化一下我们的操作。</p>
<p>我们可以发现，我们所有的操作不会出现跨位置的操作，也不会出现高于一次的操作（例如 $C_i &#x3D; C_i \times B_i$ 什么的）<br>这样我们就可以使用矩阵来维护这三种信息。</p>
<p>如果我们将 $A_i,B_i,C_i$ 三个数值化作一个矩阵的话，那么这个矩阵 $\begin{bmatrix} A_i &amp; B_i &amp; C_i \end{bmatrix}$ 所对应的单位矩阵是这个样子的：$\begin{bmatrix}1&amp;&amp;\\&amp;1&amp;\\&amp;&amp;1\end{bmatrix}$。</p>
<p>而 $\begin{bmatrix} A_i &amp; B_i &amp; C_i \end{bmatrix}$ 想要变成 $\begin{bmatrix} A_i+B_i &amp; B_i &amp; C_i \end{bmatrix}$ 的话可以让它乘以一个 $\begin{bmatrix}1&amp;&amp;\\1&amp;1&amp;\\&amp;&amp;1\end{bmatrix}$。$(2,1)$ 处多出来的那个1就代表着给结果行矩阵的第<strong>1</strong>个位置加上<strong>1</strong>个原先的行矩阵矩阵第<strong>2</strong>个位置的值，也就相当于是给结果的 $A_i$ 加上了一个 $B_i$。</p>
<p>同理，第二个操作乘以的是一个 $\begin{bmatrix}1&amp;&amp;\\&amp;1&amp;\\&amp;1&amp;1\end{bmatrix}$，第三个操作乘以的是一个 $\begin{bmatrix}1&amp;&amp;1\\&amp;1&amp;\\&amp;&amp;1\end{bmatrix}$。</p>
<p>然后就是可恶的第四个操作。我们需要给 $A_i$ 加上一个 $k$，但是我们无法从刚才的方法里面推出来一个类似的方法。</p>
<p>于是我们可以考虑将我们维护的矩阵由 $\begin{bmatrix} A_i &amp; B_i &amp; C_i \end{bmatrix}$ 变为 $\begin{bmatrix} A_i &amp; B_i &amp; C_i &amp; 1 \end{bmatrix}$。<br>这样我们就只需要乘以一个 $\begin{bmatrix}1&amp;&amp;&amp;\\&amp;1&amp;&amp;\\&amp;&amp;1&amp;\\k&amp;&amp;&amp;1\end{bmatrix}$ 即可。</p>
<p>为了适配我们新的需要维护的矩阵，前面三个就变成了 $\begin{bmatrix}1&amp;&amp;&amp;\\1&amp;1&amp;&amp;\\&amp;&amp;1&amp;\\&amp;&amp;&amp;1\end{bmatrix}$，$\begin{bmatrix}1&amp;&amp;&amp;\\&amp;1&amp;&amp;\\&amp;1&amp;1&amp;\\&amp;&amp;&amp;1\end{bmatrix}$ 和 $\begin{bmatrix}1&amp;&amp;1&amp;\\&amp;1&amp;&amp;\\&amp;&amp;1&amp;\\&amp;&amp;&amp;1\end{bmatrix}$。</p>
<p>第五个操作的思路也很简单，只需要乘以一个 $\begin{bmatrix}1&amp;&amp;&amp;\\&amp;k&amp;&amp;\\&amp;&amp;1&amp;\\&amp;&amp;&amp;1\end{bmatrix}$ 即可。</p>
<p>第六个操作有点难，我们可以先把 $C_i$ 变成0，通过乘以一个 $\begin{bmatrix}1&amp;&amp;&amp;\\&amp;1&amp;&amp;\\&amp;&amp;&amp;\\&amp;&amp;&amp;1\end{bmatrix}$，然后再乘以一个 $\begin{bmatrix}1&amp;&amp;&amp;\\&amp;1&amp;&amp;\\&amp;&amp;1&amp;\\&amp;&amp;k&amp;1\end{bmatrix}$，就可以给 $C_i$ 赋成 $k$ 了。<br>最终效果跟直接乘以 $\begin{bmatrix}1&amp;&amp;&amp;\\&amp;1&amp;&amp;\\&amp;&amp;&amp;\\&amp;&amp;k&amp;1\end{bmatrix}$ 效果一样。</p>
<p>于是我们的线段树只需要维护一个区间乘和区间求和即可。</p>
<p>矩阵结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    ll a[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">Matrix</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="type">int</span> _n, <span class="type">int</span> _m) :<span class="built_in">n</span>(_n), <span class="built_in">m</span>(_m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> + (<span class="type">const</span> Matrix &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">res</span><span class="params">(n, m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">                res.a[i][j] = (a[i][j] + rhs.a[i][j]) % p;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> * (<span class="type">const</span> Matrix &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">res</span><span class="params">(n, rhs.m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= rhs.m; j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= m; k++)</span><br><span class="line">                    res.a[i][j] = (res.a[i][j] + a[i][k] * rhs.a[k][j]) % p;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>总代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">250010</span>;</span><br><span class="line"><span class="type">const</span> ll p = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    ll a[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">Matrix</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="type">int</span> _n, <span class="type">int</span> _m) :<span class="built_in">n</span>(_n), <span class="built_in">m</span>(_m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> + (<span class="type">const</span> Matrix &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">res</span><span class="params">(n, m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">                res.a[i][j] = (a[i][j] + rhs.a[i][j]) % p;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> * (<span class="type">const</span> Matrix &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">res</span><span class="params">(n, rhs.m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= rhs.m; j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= m; k++)</span><br><span class="line">                    res.a[i][j] = (res.a[i][j] + a[i][k] * rhs.a[k][j]) % p;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Matrix num[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    Matrix sum, tag;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">Matrix base1, base2, base3, base4, base5, base6;</span><br><span class="line">Matrix base;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[p], &amp;left = tr[p &lt;&lt; <span class="number">1</span>], &amp;rght = tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    left.sum = left.sum * root.tag;</span><br><span class="line">    rght.sum = rght.sum * root.tag;</span><br><span class="line">    left.tag = left.tag * root.tag;</span><br><span class="line">    rght.tag = rght.tag * root.tag;</span><br><span class="line">    root.tag = base;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].l = l, tr[p].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum = num[l];</span><br><span class="line">        tr[p].tag = base;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    tr[p].sum = tr[p &lt;&lt; <span class="number">1</span>].sum + tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">    tr[p].tag = base;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">segadd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, Matrix k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].tag = tr[p].tag * k;</span><br><span class="line">        tr[p].sum = tr[p].sum * k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)<span class="built_in">segadd</span>(p &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)<span class="built_in">segadd</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">    tr[p].sum = tr[p &lt;&lt; <span class="number">1</span>].sum + tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">segsum</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)<span class="keyword">return</span> tr[p].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="function">Matrix <span class="title">res</span><span class="params">(<span class="number">4</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res = res + <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)res = res + <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    base = <span class="built_in">Matrix</span>(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">        base.a[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    base1:| base2:| base3:</span></span><br><span class="line"><span class="comment">    1 0 0 | 1 0 0 | 1 0 1</span></span><br><span class="line"><span class="comment">    1 1 0 | 0 1 0 | 0 1 0</span></span><br><span class="line"><span class="comment">    0 0 1 | 0 1 1 | 0 0 1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    base1 = base;</span><br><span class="line">    base1.a[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    base2 = base;</span><br><span class="line">    base2.a[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    base3 = base;</span><br><span class="line">    base3.a[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    base4:  | base5:  | base6:</span></span><br><span class="line"><span class="comment">    1 0 0 0 | 1 0 0 0 | 1 0 0 0</span></span><br><span class="line"><span class="comment">    0 1 0 0 | 0 v 0 0 | 0 1 0 0</span></span><br><span class="line"><span class="comment">    0 0 1 0 | 0 0 1 0 | 0 0 0 0</span></span><br><span class="line"><span class="comment">    v 0 0 1 | 0 0 0 1 | 0 0 v 1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    base4 = base;</span><br><span class="line">    base5 = base;</span><br><span class="line">    base6 = base;</span><br><span class="line">    base6.a[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        num[i] = <span class="built_in">Matrix</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;num[i].a[<span class="number">1</span>][<span class="number">1</span>], &amp;num[i].a[<span class="number">1</span>][<span class="number">2</span>], &amp;num[i].a[<span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">        num[i].a[<span class="number">1</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op, l, r, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">segadd</span>(<span class="number">1</span>, l, r, base1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">segadd</span>(<span class="number">1</span>, l, r, base2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">segadd</span>(<span class="number">1</span>, l, r, base3);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v);</span><br><span class="line">            base4.a[<span class="number">4</span>][<span class="number">1</span>] = v;</span><br><span class="line">            <span class="built_in">segadd</span>(<span class="number">1</span>, l, r, base4);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v);</span><br><span class="line">            base5.a[<span class="number">2</span>][<span class="number">2</span>] = v;</span><br><span class="line">            <span class="built_in">segadd</span>(<span class="number">1</span>, l, r, base5);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v);</span><br><span class="line">            base6.a[<span class="number">4</span>][<span class="number">3</span>] = v;</span><br><span class="line">            <span class="built_in">segadd</span>(<span class="number">1</span>, l, r, base6);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">7</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Matrix res = <span class="built_in">segsum</span>(<span class="number">1</span>, l, r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld %lld\n&quot;</span>, res.a[<span class="number">1</span>][<span class="number">1</span>], res.a[<span class="number">1</span>][<span class="number">2</span>], res.a[<span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>LibreOJ #3277 [JOISC 2020 Day3] 星座 3 题解</title>
    <url>/solutions/solution-l3277/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">星座 3</div>
<div id="problem-info-from">JOISC 2020 Day3 T1</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDcyMTk=">Luogu P7219</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8zMjc3">LibreOJ L3277</span></li><li><span class="exturl" data-url="aHR0cHM6Ly91b2ouYWMvcHJvYmxlbS81MDc=">UOJ #507</span></li></ul></div>

<hr>
<p>对于这道题来说，我们有两种做法。</p>
<p>首先我们可以确定一点，就是他给我们的建筑是一定到底的，那么肯定不是让我们从左往右枚举的。</p>
<p>这里就以样例来举个例子：</p>
<p><img src="https://s2.loli.net/2022/07/02/sKMGZFDTyJHa9Pi.png" alt="l3277-1.png"></p>
<p>我们首先看最上面的这一行。</p>
<p><img src="https://s2.loli.net/2022/07/02/tFgcno53CvVMzaB.png" alt="l3277-2.png"></p>
<p>当我们碰到了最高的那个建筑的时候，我们当前这个区间就被分成了两份。</p>
<p><img src="https://s2.loli.net/2022/07/02/MKT9iOy5pWHLzef.png" alt="l3277-3.png"></p>
<p>随着我们不断向下，我们的区间也在不断细分，直到最后全是建筑。</p>
<p>然后我们就可以以此建立一棵笛卡尔树了。<br>其中我们的根节点是最上面的那一行再往上的那一片空白区域，我们可以保证其一定是一个完整的区间。</p>
<p>对于每一个区间，我们需要先处理一下，使其只剩一颗星星。<br>这样可以大大简化我们的冲突判断，减少了对时间的需求。</p>
<p>其次，我们需要对两个（或多个）区间进行合并，就好似对这个区间进行DP，让每一个区间中的那一颗星星选或不选，然后如果选的话就考虑其下面与其冲突的星星，这样这个区间的子树的所有星星都需要删去。<br>这样一直合并到最上面的区间之后就得到了我们要的结果。</p>
<p>我们可以使用树链剖分来维护上面的信息。<br>不过下面有个更优的做法，就不放代码了。</p>
<p>我们可以贪心一下。</p>
<p>首先我们将所有房屋和星星按照纵坐标从小到大排个序。<br>然后我们搞一个并查集，使用并查集维护每一个点可以到达的最大范围。<br>最后我们建立一棵树状数组，用来存储每一个横坐标中把所有星星清空的代价之和。这一棵树是随着枚举纵坐标不断更新的。</p>
<p>之后我们从下往上处理信息。</p>
<p>对于每一个纵坐标，我们假设已经处理出来所有纵坐标小于其的答案。<br>我们在树状数组上面查找当前纵坐标所对应的值 $S$，与消除这一颗星星所需要的代价 $C$ 比较一下。</p>
<ul>
<li>如果 $S \geq C$，那就意味着我们加入这颗星星并不会使答案更优，因为靠上的星星可能会冲突的概率更大一些，况且保留其权值又不如保留其下面的星星的权值之和更优。所以我们的答案直接加上 $C$ 即可。</li>
<li>如果 $S &lt; C$，那我们就不能确定保留这一颗星星是否更优了。我们先暂且给答案加上 $S$，然后将当前星星能够到达的横坐标上的每一个值加上 $C-S$。这样我们在继续枚举的时候如果发现留着当前点仍然不优，那么我们就向答案里面又加入了 $C-S$，相当于是向答案中加入了 $C$，而把 $S$ 拎了出来。</li>
</ul>
<p>前者的正确性很显然，后者则可以这样想：<br>我们已经在递推的时候的每一步都是当前纵坐标的最优解，而我们保留 $C$ 相当与就是舍弃了这个最优解。<br>当我们再想把 $C$ 删去而保留 $S$ 的时候，选取的 $S$ 仍然是那个区间的最优解，就不需要继续考虑更深的点了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dsu</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p[N];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x)p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;L, R;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line">ll tr[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, ll c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">        tr[i] += c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">        res += tr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">ll ans;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;st[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;h[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    L.p[n + <span class="number">1</span>] = R.p[n + <span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L.p[i] = R.p[i] = i;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        h[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;c);</span><br><span class="line">        st[y].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(x, c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; s : st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            ll S = <span class="built_in">sum</span>(s.first);</span><br><span class="line">            <span class="keyword">if</span> (S &gt; s.second)ans += s.second;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans += S;</span><br><span class="line">                <span class="built_in">add</span>(L.<span class="built_in">find</span>(s.first) + <span class="number">1</span>, s.second - S);</span><br><span class="line">                <span class="built_in">add</span>(R.<span class="built_in">find</span>(s.first), S - s.second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : h[i])</span><br><span class="line">        &#123;</span><br><span class="line">            L.p[j] = j - <span class="number">1</span>;</span><br><span class="line">            R.p[j] = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>贪心</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>P1084 [NOIP2012 提高组] 疫情控制 题解</title>
    <url>/solutions/solution-p1084/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">疫情控制</div>
<div id="problem-info-from">NOIP 2012 提高组</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwODQ=">Luogu P1084</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yNjA3">LibreOJ L2607</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzU5Lw==">AcWing 357</span></li></ul></div>

<hr>
<p>题目要求我们求出一个最小的时间，使得每一个叶子节点到根节点的路径上都有驻军。<br>同时根节点本身不能驻军。</p>
<h1 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h1><p>我们考虑一个极端情况，那就是我们将所有的军队分散在根节点的所有子节点中，这样就可以使得每一个叶子结点到根节点的路径上都有驻军。<br>（如果军队数量少于根节点的子节点数量的话直接无解）<br>假设我们对于这种方案取了一个时间花费最小的，我们可以看出当时间大于其的时候肯定是有解的，而时间小于其的则不一定有解，那么我们就可以二分答案了。</p>
<p>左端点肯定是0，右端点我们设成所有边的权值和。</p>
<p>然后就是判定是否能够控制疫情了。</p>
<h1 id="判定"><a href="#判定" class="headerlink" title="判定"></a>判定</h1><p>我们选用上面说的方案，也就是说将所有的军队尽量部署在根节点的所有子节点中。<br>当然，如果某一个子节点没有能被驻军，但是其到其子树中的所有叶子结点的路径上都有驻军也可以。</p>
<h2 id="移动并初步部署"><a href="#移动并初步部署" class="headerlink" title="移动并初步部署"></a>移动并初步部署</h2><p>那我们每一个军队都贪心地尽量往上走，直到到达根节点的子节点为止。<br>为了节省时间，我们使用倍增优化一下移动。</p>
<figure class="highlight cpp"><figcaption><span>倍增优化</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fa[N][<span class="number">32</span>];</span><br><span class="line">ll dis[N][<span class="number">32</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getFa</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//DFS求出父亲节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i] == fa[p][<span class="number">0</span>])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        fa[j][<span class="number">0</span>] = p;</span><br><span class="line">        dis[j][<span class="number">0</span>] = w[i];</span><br><span class="line">        <span class="built_in">getFa</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initFa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//倍增预处理</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p = <span class="number">1</span>; p &lt;= n; p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fa[p][i] = fa[fa[p][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">            dis[p][i] = dis[p][i - <span class="number">1</span>] + dis[fa[p][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>移动</span></figcaption><table><tr><td class="code"><pre><span class="line">vector&lt;pair&lt;ll, <span class="type">int</span>&gt; &gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = mil[i];</span><br><span class="line">    ll cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = t; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[x][j] &gt; <span class="number">1</span> &amp;&amp; cnt + dis[x][j] &lt;= lim)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt += dis[x][j];</span><br><span class="line">            x = fa[x][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fa[x][<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; cnt + dis[x][<span class="number">0</span>] &lt;= lim)</span><br><span class="line">        q.<span class="built_in">emplace_back</span>(lim - cnt - dis[x][<span class="number">0</span>], x);<span class="comment">//存储闲置军队</span></span><br><span class="line">    <span class="keyword">else</span> scr[x] = <span class="literal">true</span>;<span class="comment">//打上驻扎标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移动完后，一些军队是已经再也不能向上走了，只能在此地驻扎，而另一些军队是已经走到了根节点的子节点，还有时间可以走。我们称处于后者的状态的军队为“闲置”的军队。<br>我们将这些军队存储起来，供以后使用。</p>
<h2 id="进一步部署"><a href="#进一步部署" class="headerlink" title="进一步部署"></a>进一步部署</h2><p>我们从根节点的每一个子节点开始进行DFS，看一看其子树内是否有叶子结点到根节点的路径上没有驻军。<br>如果有的话，那么该节点就需要被驻军。</p>
<figure class="highlight cpp"><figcaption><span>DFS</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> scr[N], need[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isScrd</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> isLeaf = <span class="literal">true</span>;<span class="comment">//是否为叶子结点</span></span><br><span class="line">    <span class="keyword">if</span>(scr[p])<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//节点本身被驻军</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i] == fa[p][<span class="number">0</span>])<span class="keyword">continue</span>;</span><br><span class="line">        isLeaf = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isScrd</span>(e[i]))<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//有一个叶子结点没有被驻军</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isLeaf)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//为叶子结点且本身未驻军</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//不是叶子结点且子树内没有未被驻军的叶子结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每一个有闲置军队且需要驻军的子节点，我们选取剩余时间最小的那个军队让其驻扎。<br>剩下的军队中，我们选出来一些军队让其继续闲置。<br>这些军队需要满足一个条件，就是可以从当前节点走到根节点再走回来，否则我们不如让其直接驻扎在当前节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> u = q.<span class="built_in">begin</span>(); u != q.<span class="built_in">end</span>(); u++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(need[u-&gt;second] &amp;&amp; u-&gt;first &lt; dis[u-&gt;second][<span class="number">0</span>] * <span class="number">2</span>)need[u-&gt;second] = <span class="literal">false</span>;<span class="comment">//驻扎</span></span><br><span class="line">    <span class="keyword">else</span> rmtm.<span class="built_in">push_back</span>(u-&gt;first);<span class="comment">//继续闲置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="再部署"><a href="#再部署" class="headerlink" title="再部署"></a>再部署</h2><p>现在我们需要处理的节点只剩下那些没有被驻军且需要驻军的子节点了。<br>我们这时候可以不管哪个军队驻扎在那里了，只需要将其剩余时间与需要被驻扎的点与根节点的距离比较即可。</p>
<p>我们使用两个小根堆来存储这些信息，每一次取出堆顶比较并在适当时间弹出即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;ll&gt;rmtm;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = h[<span class="number">1</span>]; ~i; i = ne[i])</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isScrd</span>(e[i]))</span><br><span class="line">        need[e[i]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> u = q.<span class="built_in">begin</span>(); u != q.<span class="built_in">end</span>(); u++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(need[u-&gt;second] &amp;&amp; u-&gt;first &lt; dis[u-&gt;second][<span class="number">0</span>] * <span class="number">2</span>)need[u-&gt;second] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> rmtm.<span class="built_in">push_back</span>(u-&gt;first);</span><br><span class="line">&#125;<span class="comment">//书接上文</span></span><br><span class="line">vector&lt;ll&gt;tbd;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = h[<span class="number">1</span>]; ~i; i = ne[i])</span><br><span class="line">    <span class="keyword">if</span>(need[e[i]])tbd.<span class="built_in">push_back</span>(dis[e[i]][<span class="number">0</span>]);<span class="comment">//压入需要驻军的节点</span></span><br><span class="line"><span class="keyword">if</span>(rmtm.<span class="built_in">size</span>() &lt; tbd.<span class="built_in">size</span>())<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//军队数量不够直接返回不可行</span></span><br><span class="line"><span class="built_in">sort</span>(rmtm.<span class="built_in">begin</span>(), rmtm.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">sort</span>(tbd.<span class="built_in">begin</span>(), tbd.<span class="built_in">end</span>());<span class="comment">//因为不需要随时取出栈顶比较，所以直接采用vector+sort()</span></span><br><span class="line">vector&lt;ll&gt;::iterator i = tbd.<span class="built_in">begin</span>(), j = rmtm.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(i != tbd.<span class="built_in">end</span>() &amp;&amp; j != rmtm.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(*i &lt;= *j)i++, j++;<span class="comment">//当前栈顶军队可以到达栈顶节点</span></span><br><span class="line">    <span class="keyword">else</span> j++;<span class="comment">//栈顶军队不能到达任意一个节点，直接弃用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i == tbd.<span class="built_in">end</span>())<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//全部节点都驻上军了</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>至此，判断时间上限是否合法的部分就结束了。</p>
<h1 id="全都加起来"><a href="#全都加起来" class="headerlink" title="全都加起来"></a>全都加起来</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>, M = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m, t;</span><br><span class="line"><span class="type">int</span> mil[N];</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">32</span>];</span><br><span class="line">ll dis[N][<span class="number">32</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getFa</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i] == fa[p][<span class="number">0</span>])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        fa[j][<span class="number">0</span>] = p;</span><br><span class="line">        dis[j][<span class="number">0</span>] = w[i];</span><br><span class="line">        <span class="built_in">getFa</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initFa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p = <span class="number">1</span>; p &lt;= n; p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fa[p][i] = fa[fa[p][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">            dis[p][i] = dis[p][i - <span class="number">1</span>] + dis[fa[p][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> scr[N], need[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isScrd</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> isLeaf = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(scr[p])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i] == fa[p][<span class="number">0</span>])<span class="keyword">continue</span>;</span><br><span class="line">        isLeaf = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isScrd</span>(e[i]))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isLeaf)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">chq</span><span class="params">(ll lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(scr, <span class="number">0</span>, <span class="built_in">sizeof</span>(scr));</span><br><span class="line">    <span class="built_in">memset</span>(need, <span class="number">0</span>, <span class="built_in">sizeof</span>(need));</span><br><span class="line">    vector&lt;pair&lt;ll, <span class="type">int</span>&gt; &gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = mil[i];</span><br><span class="line">        ll cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = t; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fa[x][j] &gt; <span class="number">1</span> &amp;&amp; cnt + dis[x][j] &lt;= lim)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt += dis[x][j];</span><br><span class="line">                x = fa[x][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fa[x][<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; cnt + dis[x][<span class="number">0</span>] &lt;= lim)</span><br><span class="line">            q.<span class="built_in">emplace_back</span>(lim - cnt - dis[x][<span class="number">0</span>], x);</span><br><span class="line">        <span class="keyword">else</span> scr[x] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q.<span class="built_in">begin</span>(), q.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;ll&gt;rmtm;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[<span class="number">1</span>]; ~i; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isScrd</span>(e[i]))</span><br><span class="line">            need[e[i]] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> u = q.<span class="built_in">begin</span>(); u != q.<span class="built_in">end</span>(); u++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(need[u-&gt;second] &amp;&amp; u-&gt;first &lt; dis[u-&gt;second][<span class="number">0</span>] * <span class="number">2</span>)need[u-&gt;second] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> rmtm.<span class="built_in">push_back</span>(u-&gt;first);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;ll&gt;tbd;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[<span class="number">1</span>]; ~i; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span>(need[e[i]])tbd.<span class="built_in">push_back</span>(dis[e[i]][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(rmtm.<span class="built_in">size</span>() &lt; tbd.<span class="built_in">size</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">sort</span>(rmtm.<span class="built_in">begin</span>(), rmtm.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(tbd.<span class="built_in">begin</span>(), tbd.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;ll&gt;::iterator i = tbd.<span class="built_in">begin</span>(), j = rmtm.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(i != tbd.<span class="built_in">end</span>() &amp;&amp; j != rmtm.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*i &lt;= *j)i++, j++;</span><br><span class="line">        <span class="keyword">else</span> j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == tbd.<span class="built_in">end</span>())<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    t = <span class="built_in">log2</span>(n) + <span class="number">1</span>;</span><br><span class="line">    ll l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        <span class="built_in">add</span>(u, v, w), <span class="built_in">add</span>(v, u, w);</span><br><span class="line">        r += w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getFa</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">initFa</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;mil[i]);</span><br><span class="line">    <span class="type">bool</span> isValid = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">chq</span>(mid))</span><br><span class="line">        &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">            isValid = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//printf(&quot;[%lld %lld]\n&quot;, l, r);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!isValid)<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>P1117 [NOI2016] 优秀的拆分 题解</title>
    <url>/solutions/solution-p1117/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">优秀的拆分</div>
<div id="problem-info-from">NOI 2016</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDExMTc=">Luogu P1117</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yMDgz">LibreOJ L2083</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAwOC8=">AcWing 1006</span></li><li><span class="exturl" data-url="aHR0cHM6Ly91b2ouYWMvcHJvYmxlbS8yMTk=">UOJ #219</span></li></ul></div>

<hr>
<div class="note warning"><p>本文图片出了一些大病，不建议点击放大。</p>
</div>

<p>据说暴力用哈希扫可以拿到95分。</p>
<p>这一道题的思路是这个样子的：</p>
<p>我们首先准备两个数组<code>a[]</code>和<code>b[]</code>，分别表示以 $i$ 结尾的形似AA的字串个数和以 $i$ 开头的形似AA的字串的个数，最终答案其实就是 $\displaystyle \sum_{i&#x3D;1}^n a[i] \times b[i+1]$。</p>
<p>然后考虑如何求出这两个数组。</p>
<p>对于每一个位置，我们尝试枚举一个 $len$，然后求出当前位置 $i$ 与 $i+len$ 位置处的 <code>lcp</code> 与 <code>lcs</code> 。</p>
<p>当两者长度加起来不小于 $len$ 的时候，就意味着我们可以找到至少一个长度为 $2len$ 的AA串。</p>
<p>为什么呢？</p>
<p>我们考虑从两个位置的 <code>lcs</code> 的开头处开始，分别向后截取出一段长度为 $len$ 的串。</p>
<p>如果这个串被两者的 <code>lcs</code> 和两者的 <code>lcp</code> 拼起来组成的一个字串覆盖，那么我们就可以把这两个串拼起来，形成一个长度为 $2len$ 的AA串。<br>就像这样：</p>
<img src="https://s2.loli.net/2022/03/22/mo9Hg7zp3YlCWjf.png" alt="p1117-1.png" width="60%" />

<p>当两者长度加起来不够 $len$ 时，我们截出来的两端字串就不保证一样。<br>不，应该是保证不一样，要不然两者的 <code>lcp</code> 还可以更长一点。<br>这样就拼不出来一个长度为 $2len$ 的AA串了。</p>
<img src="https://s2.loli.net/2022/03/22/1Yo3UAOuptlvKz5.png" alt="p1117-2.png" width="60%" />

<p>如果两者甚至有重合，那么我们就可以挑出来多个字串。我们这些会累积到后面。</p>
<img src="https://s2.loli.net/2022/03/22/EdSZAXvpG17hPYF.gif" alt="p1117-3.gif" width="60%" />

<p>就是这样。</p>
<p>简单来说，我们需要做的就是：</p>
<ol>
<li>枚举 $len$；这个操作的复杂度是 $O(n \log n)$</li>
<li>求 <code>lcp</code> 与 <code>lcs</code>；使用后缀数组即可。</li>
<li>区间加；差分即可。</li>
</ol>
<p>上代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1001000</span>;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line">ll a[N], b[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SuffixArray</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> S[N]; <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> cnt[N], sa[N], rk[N], height[N];</span><br><span class="line">    <span class="type">int</span> st[N][<span class="number">25</span>], lg2[N];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> id, x, y;</span><br><span class="line">    &#125;aa[N], bb[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">buildsa</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n = <span class="built_in">strlen</span>(S + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        <span class="built_in">memset</span>(height, <span class="number">0</span>, <span class="built_in">sizeof</span>(height));</span><br><span class="line">        <span class="built_in">memset</span>(sa, <span class="number">0</span>, <span class="built_in">sizeof</span>(sa));</span><br><span class="line">        <span class="built_in">memset</span>(rk, <span class="number">0</span>, <span class="built_in">sizeof</span>(rk));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) aa[i] = bb[i] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cnt[S[i]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">256</span>; i++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) rk[i] = cnt[S[i]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> L = <span class="number">1</span>; L &lt; n; L *= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) aa[i] = &#123; i,rk[i],rk[i + L] &#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cnt[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cnt[aa[i].y]++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--) bb[cnt[aa[i].y]--] = aa[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cnt[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cnt[aa[i].x]++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--) aa[cnt[bb[i].x]--] = bb[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                <span class="keyword">if</span>((aa[i].x == aa[i - <span class="number">1</span>].x) &amp;&amp; (aa[i].y == aa[i - <span class="number">1</span>].y))</span><br><span class="line">                    rk[aa[i].id] = rk[aa[i - <span class="number">1</span>].id];</span><br><span class="line">                <span class="keyword">else</span> rk[aa[i].id] = rk[aa[i - <span class="number">1</span>].id] + <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sa[rk[i]] = i; <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k) k--;</span><br><span class="line">            <span class="type">int</span> j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span>((i + k &lt;= n) &amp;&amp; (j + k &lt;= n) &amp;&amp; (S[i + k] == S[j + k])) k++;</span><br><span class="line">            height[rk[i]] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">buildst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lg2[<span class="number">0</span>] = <span class="number">-1</span>; <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++) lg2[i] = lg2[i / <span class="number">2</span>] + <span class="number">1</span>; lg2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) st[i][<span class="number">0</span>] = height[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++)</span><br><span class="line">                st[i][j] = <span class="built_in">min</span>(st[i][j - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Lcp</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        l = rk[l], r = rk[r];</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r) <span class="built_in">swap</span>(l, r); l++;</span><br><span class="line">        <span class="type">int</span> k = lg2[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(st[l][k], st[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;SA[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, SA[<span class="number">0</span>].S + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">strlen</span>(SA[<span class="number">0</span>].S + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = b[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            SA[<span class="number">1</span>].S[i] = SA[<span class="number">0</span>].S[n - i + <span class="number">1</span>];</span><br><span class="line">        SA[<span class="number">0</span>].<span class="built_in">buildsa</span>(), SA[<span class="number">1</span>].<span class="built_in">buildsa</span>();</span><br><span class="line">        SA[<span class="number">0</span>].<span class="built_in">buildst</span>(), SA[<span class="number">1</span>].<span class="built_in">buildst</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> Len = <span class="number">1</span>; Len &lt;= n / <span class="number">2</span>; Len++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = Len; i &lt;= n; i += Len)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> l = i, r = i + Len;</span><br><span class="line">                <span class="type">int</span> L = n - (r - <span class="number">1</span>) + <span class="number">1</span>, R = n - (l - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> lcp = SA[<span class="number">0</span>].<span class="built_in">Lcp</span>(l, r); lcp = <span class="built_in">min</span>(lcp, Len);</span><br><span class="line">                <span class="type">int</span> lcs = SA[<span class="number">1</span>].<span class="built_in">Lcp</span>(L, R); lcs = <span class="built_in">min</span>(lcs, Len - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(lcp + lcs &gt;= Len)</span><br><span class="line">                &#123;</span><br><span class="line">                    b[i - lcs]++, b[i - lcs + (lcp + lcs - Len + <span class="number">1</span>)]--;</span><br><span class="line">                    a[r + lcp - (lcp + lcs - Len + <span class="number">1</span>)]++, a[r + lcp]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] += a[i - <span class="number">1</span>], b[i] += b[i - <span class="number">1</span>];</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) ans += a[i] * b[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>P1251 餐巾计划问题 题解</title>
    <url>/solutions/solution-p1251/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">餐巾计划问题</div>
<div id="problem-info-from">网络流24题</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEyNTE=">Luogu P1251</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC82MDA4">LibreOJ L6008</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjE4Ni8=">AcWing 2184</span></li></ul></div>

<hr>
<p>题目要求我们安排餐巾的清洗分配。</p>
<p>可能是戴森球计划搭产线搭多了吧，这道题我一开始就把餐巾从一个地方到另一个地方（如从餐厅到快洗部）想成了一道流。</p>
<p>我们就可以把餐厅向快洗部和慢洗部连边。</p>
<p>但是呢，我们还需要处理快洗部和慢洗部需要的时间问题，还有处理所有的延时送洗的操作。</p>
<p>我们于是就考虑将每天的餐厅拆成不同的点。<br>当然，每天的快洗部和慢洗部也需要拆成不同的点。</p>
<p>这样就可以保证我们可以让餐巾进行时间穿梭了，而不再是只局限于一天之内。</p>
<p>还有，我们需要将餐巾进行最大化利用来省钱，毕竟每多存在一块餐巾，就多需要花费我们 $p$ 分钱。</p>
<p>我们考虑将拆分后的餐厅继续拆分，拆成一个输入和一个输出。输入代表今天餐厅的餐巾到底是从哪里运过来的，而输出就代表今天使用的餐巾的最终去处。</p>
<p>这时候，我们就已经需要了 $4n$ 个点了（不包括源点和汇点），其中餐厅输入，餐厅输出，快洗部和慢洗部各 $n$ 个点。</p>
<p>但是我们考虑简化一下。</p>
<p>我们考虑省去快洗部和慢洗部，可以看做自己内部员工洗干净了。<br>这样，我们可以直接连接某一天的输出和另一天的输入了。</p>
<p>最后开始连边。</p>
<ol>
<li>源点与餐厅输出连一条容量为当天用量，费用为0的边；</li>
<li>汇点与餐厅输入连一条容量为当天用量，费用为0的边；</li>
<li>餐厅输出与下一日的餐厅输出连一条容量为无限，费用为0的边。</li>
<li>源点与餐厅输入连一条容量为无限，费用为 $p$ 的边；</li>
<li>餐厅输出与 $n$ 天后的餐厅输入连一条容量为无限，费用为 $s$ 的边，代表快洗部；</li>
<li>餐厅输出与 $m$ 天后的餐厅输入连一条容量为无限，费用为 $f$ 的边，代表慢洗部。</li>
</ol>
<p>然后跑一个最小费用最大流即可，最终的费用就是答案。</p>
<p>上代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5010</span>, M = <span class="number">100010</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">int</span> p, x, xp, y, yp;</span><br><span class="line"><span class="type">int</span> need[N];</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="type">int</span> h[N], e[M], f[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> q[N], d[N], pre[N], incf[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a]; h[a] = idx++;</span><br><span class="line">    e[idx] = a, f[idx] = <span class="number">0</span>, w[idx] = -d, ne[idx] = h[b], h[b] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="built_in">memset</span>(incf, <span class="number">0</span>, <span class="keyword">sizeof</span> incf);</span><br><span class="line">    q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, incf[S] = INF;</span><br><span class="line">    <span class="keyword">while</span>(hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh == N) hh = <span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ver = e[i];</span><br><span class="line">            <span class="keyword">if</span>(f[i] &amp;&amp; d[ver] &gt; d[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[ver] = d[t] + w[i];</span><br><span class="line">                pre[ver] = i;</span><br><span class="line">                incf[ver] = <span class="built_in">min</span>(f[i], incf[t]);</span><br><span class="line">                <span class="keyword">if</span>(!st[ver])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++] = ver;</span><br><span class="line">                    <span class="keyword">if</span>(tt == N) tt = <span class="number">0</span>;</span><br><span class="line">                    st[ver] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incf[T] &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">EK</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = incf[T];</span><br><span class="line">        cost += t * d[T];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = T; i != S; i = e[pre[i] ^ <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            f[pre[i]] -= t;</span><br><span class="line">            f[pre[i] ^ <span class="number">1</span>] += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    S = <span class="number">0</span>, T = n * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;need[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld%lld&quot;</span>, &amp;p, &amp;x, &amp;xp, &amp;y, &amp;yp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> r = need[i];</span><br><span class="line">        <span class="built_in">add</span>(S, i, r, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">add</span>(n + i, T, r, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">add</span>(S, n + i, INF, p);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; n) <span class="built_in">add</span>(i, i + <span class="number">1</span>, INF, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(i + x &lt;= n) <span class="built_in">add</span>(i, n + i + x, INF, xp);</span><br><span class="line">        <span class="keyword">if</span>(i + y &lt;= n) <span class="built_in">add</span>(i, n + i + y, INF, yp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">EK</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>P1486 [NOI2004] 郁闷的出纳员 题解</title>
    <url>/solutions/solution-p1486/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">郁闷的出纳员</div>
<div id="problem-info-from">NOI 2004</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDE0ODY=">Luogu P1486</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8xMDE0NQ==">LibreOJ L10145</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvOTUwLw==">AcWing 950</span></li></ul></div>

<hr>
<p>这道题要求我们完成两个操作：插入和查询。</p>
<p>我们最多分别有 $10^5$ 次插入和 $10^5$ 次查询。<br>而在通常是方法中，查询和插入的复杂度都是很高的，尤其是查询前还需要进行一次排序。</p>
<p>所以我们需要降低复杂度。</p>
<p>正好，平衡树可以帮助我们减轻这个负担。</p>
<p>我们尝试使用平衡树来维护一个有序的序列，以避免任何不必要的排序操作，城区排序需要的复杂度。</p>
<p>FHQ的无旋Treap可以过，具体实现见<span class="exturl" data-url="aHR0cHM6Ly9vaS5iYW9zaHVvLnJlbi9sdW9ndS1wMTQ4Ni8=">这篇博客</span>；STL貌似也能水过，具体实现见<span class="exturl" data-url="aHR0cHM6Ly9vaS5iYW9zaHVvLnJlbi9sdW9ndS1wMTQ4Ni8=">这篇博客</span>；而我们这里采用的是Splay。</p>
<p>对于插入，我们就像平常插入一样，不断递归直到可以插入为止。<br>同时注意：如果这个员工还没有来就发现自己的工资不足工资下界，那么他就不会来了。我们直接忽略即可。</p>
<p>对于修改工资，我们存储一个 $\Delta$ 以方便随时加减工资。<br>假设某个员工的工资是 $k$ ，那么我们存到平衡树里面的数据是 $k - \Delta$。<br>$\Delta$ 初始为0，我们每次加工资或减工资只需要对 $\Delta$ 进行更改就可以了。</p>
<p>同时我们还需要注意离职的员工。每一次减工资的时候，我们都需要看一下有哪些员工需要离职。<br>方法很简单：查找工资下界对应的节点——旋上来——清空子树。</p>
<p>对于查找，我们只需要在平衡树的节点上面维护一个 $size$，到时候直接查找就行了。<br>查找的思路是这个样子的：<br>我们使用一个参数 $k$，从根节点开始搜索。<br>当当前的左子树的 $size \geq k$ 时，证明我们的目标节点在左子树里面，我们递归搜索左子树。<br>如果当前的左子树的 $size + 1 &#x3D; k$ 时，证明我们的目标节点就是我们当前搜索到的节点，直接<code>return</code>。<br>其他情况就是证明我们的目标节点在右子树里面，我们把当前的 $k$ 减去左子树的 $size$，再减去代表当前节点的 $1$，然后带着新的 $k$ 去递归搜索右子树。</p>
<p>上代码：</p>
<div class="note warning"><p>注意：我这里使用了非ASCII字符<code>Δ</code>做变量名，这种情况下只能在C++20的情况下通过编译，请根据需要修改变量名。</p>
</div>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n, m, Δ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s[<span class="number">2</span>], p, v;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> _v, <span class="type">int</span> _p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        v = _v, p = _p;</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> root, idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[x].size = tr[tr[x].s[<span class="number">0</span>]].size + tr[tr[x].s[<span class="number">1</span>]].size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> y = tr[x].p, z = tr[y].p;</span><br><span class="line">    <span class="type">int</span> k = tr[y].s[<span class="number">1</span>] == x;</span><br><span class="line">    tr[z].s[tr[z].s[<span class="number">1</span>] == y] = x, tr[x].p = z;</span><br><span class="line">    tr[y].s[k] = tr[x].s[k ^ <span class="number">1</span>], tr[tr[x].s[k ^ <span class="number">1</span>]].p = y;</span><br><span class="line">    tr[x].s[k ^ <span class="number">1</span>] = y, tr[y].p = x;</span><br><span class="line">    <span class="built_in">pushup</span>(y), <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(tr[x].p != k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = tr[x].p, z = tr[y].p;</span><br><span class="line">        <span class="keyword">if</span>(z != k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((tr[y].s[<span class="number">1</span>] == x) ^ (tr[z].s[<span class="number">1</span>] == y))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">rotate</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">rotate</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!k) root = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = root, p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(u) p = u, u = tr[u].s[v &gt; tr[u].v];</span><br><span class="line">    u = ++idx;</span><br><span class="line">    <span class="keyword">if</span>(p) tr[p].s[v &gt; tr[p].v] = u;</span><br><span class="line">    tr[u].<span class="built_in">init</span>(v, p);</span><br><span class="line">    <span class="built_in">splay</span>(u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = root, res;</span><br><span class="line">    <span class="keyword">while</span>(u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[u].v &gt;= v)</span><br><span class="line">        &#123;</span><br><span class="line">            res = u;</span><br><span class="line">            u = tr[u].s[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            u = tr[u].s[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_k</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[tr[u].s[<span class="number">0</span>]].size &gt;= k)</span><br><span class="line">        &#123;</span><br><span class="line">            u = tr[u].s[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tr[tr[u].s[<span class="number">0</span>]].size + <span class="number">1</span> == k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> tr[u].v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            k -= tr[tr[u].s[<span class="number">0</span>]].size + <span class="number">1</span>;</span><br><span class="line">            u = tr[u].s[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="type">int</span> L = <span class="built_in">insert</span>(-INF), R = <span class="built_in">insert</span>(INF);</span><br><span class="line">    <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, &amp;op, &amp;k);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k &gt;= m)</span><br><span class="line">            &#123;</span><br><span class="line">                k -= Δ;</span><br><span class="line">                <span class="built_in">insert</span>(k);</span><br><span class="line">                tot++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Δ += k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Δ -= k;</span><br><span class="line">            R = <span class="built_in">get</span>(m - Δ);</span><br><span class="line">            <span class="built_in">splay</span>(R, <span class="number">0</span>), <span class="built_in">splay</span>(L, R);</span><br><span class="line">            tr[L].s[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">pushup</span>(L), <span class="built_in">pushup</span>(R);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[root].size - <span class="number">2</span> &lt; k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">get_k</span>(tr[root].size - k) + Δ);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tot - (tr[root].size - <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>P1505 [国家集训队] 旅游 题解</title>
    <url>/solutions/solution-p1505/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">旅游</div>
<div id="problem-info-from">国家集训队</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDE1MDU=">Luogu P1505</span></li></ul></div>

<hr>
<p>题目给定一棵 n 个节点的树，边带权，编号 $0 \sim n-1$，需要我们支持五种操作：</p>
<ul>
<li><code>C i w</code> 将输入的第 $i$ 条边权值改为 $w$</li>
<li><code>N u v</code> 将 $u,v$ 节点之间的边权都变为相反数</li>
<li><code>SUM u v</code> 询问 $u,v$ 节点之间边权和</li>
<li><code>MAX u v</code> 询问 $u,v$ 节点之间边权最大值</li>
<li><code>MIN u v</code> 询问 $u,v$ 节点之间边权最小值</li>
</ul>
<p>我们可以使用树剖来解决这个问题。</p>
<p>但是树剖作用的是点权，而我们可以使用边权转点权的方法来解决。</p>
<p>我们将边权转入其下方的节点里面，在访问的时候忽略掉最顶端的节点即可。</p>
<p>还有区间取反。</p>
<p>我们考虑使用一个懒标记来异或维护一下，当我们需要访问的时候就让min和max取反并互换即可。</p>
<p>上代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> cnt, h[N], e[N &lt;&lt; <span class="number">1</span>], ne[N &lt;&lt; <span class="number">1</span>], val[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> idx, fa[N], son[N], top[N], dep[N], dfn[N], sz[N], tmp[N], w[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum, max, min, tag;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">3</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;id[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[++cnt] = h[x]; e[cnt] = y; val[cnt] = w; h[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[x] = dep[f] + <span class="number">1</span>; fa[x] = f; sz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[x]; i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i];</span><br><span class="line">        <span class="keyword">if</span>(v == f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v, x);</span><br><span class="line">        tmp[v] = val[i];</span><br><span class="line">        sz[x] += sz[v];</span><br><span class="line">        <span class="keyword">if</span>(sz[son[x]] &lt; sz[v]) son[x] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> topf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x] = ++idx; w[idx] = tmp[x]; top[x] = topf;</span><br><span class="line">    <span class="keyword">if</span>(son[x]) <span class="built_in">dfs2</span>(son[x], topf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[x]; i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i];</span><br><span class="line">        <span class="keyword">if</span>(v == fa[x] || v == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].sum = tr[p &lt;&lt; <span class="number">1</span>].sum + tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">    tr[p].max = <span class="built_in">max</span>(tr[p &lt;&lt; <span class="number">1</span>].max, tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].max);</span><br><span class="line">    tr[p].min = <span class="built_in">min</span>(tr[p &lt;&lt; <span class="number">1</span>].min, tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].min);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[p], &amp;left = tr[p &lt;&lt; <span class="number">1</span>], &amp;rght = tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    left.tag ^= <span class="number">1</span>; rght.tag ^= <span class="number">1</span>;</span><br><span class="line">    left.sum = -left.sum; rght.sum = -rght.sum;</span><br><span class="line">    left.max = -left.max; rght.max = -rght.max;</span><br><span class="line">    left.min = -left.min; rght.min = -rght.min;</span><br><span class="line">    <span class="built_in">swap</span>(left.max, left.min);</span><br><span class="line">    <span class="built_in">swap</span>(rght.max, rght.min);</span><br><span class="line">    root.tag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].l = l, tr[p].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum = tr[p].max = tr[p].min = w[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((tr[p].l == q) &amp;&amp; (tr[p].r == q))</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum = tr[p].max = tr[p].min = k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].tag) <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(q &lt;= mid) <span class="built_in">change</span>(p &lt;&lt; <span class="number">1</span>, q, k);</span><br><span class="line">    <span class="keyword">if</span>(q &gt; mid)  <span class="built_in">change</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, q, k);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">segrev</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((l &lt;= tr[p].l) &amp;&amp; (r &gt;= tr[p].r))</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].tag ^= <span class="number">1</span>;</span><br><span class="line">        tr[p].sum = -tr[p].sum;</span><br><span class="line">        tr[p].max = -tr[p].max;</span><br><span class="line">        tr[p].min = -tr[p].min;</span><br><span class="line">        <span class="built_in">swap</span>(tr[p].max, tr[p].min);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].tag) <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">segrev</span>(p &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)  <span class="built_in">segrev</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">segsum</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((l &lt;= tr[p].l) &amp;&amp; (r &gt;= tr[p].r))<span class="keyword">return</span> tr[p].sum;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].tag)<span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res += <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)res += <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">segmax</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((l &lt;= tr[p].l) &amp;&amp; (r &gt;= tr[p].r))<span class="keyword">return</span> tr[p].max;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">-2147483647</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].tag)<span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res = <span class="built_in">max</span>(res, <span class="built_in">segmax</span>(p &lt;&lt; <span class="number">1</span>, l, r));</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)res = <span class="built_in">max</span>(res, <span class="built_in">segmax</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">segmin</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((l &lt;= tr[p].l) &amp;&amp; (r &gt;= tr[p].r))<span class="keyword">return</span> tr[p].min;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">2147483647</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].tag)<span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res = <span class="built_in">min</span>(res, <span class="built_in">segmin</span>(p &lt;&lt; <span class="number">1</span>, l, r));</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)res = <span class="built_in">min</span>(res, <span class="built_in">segmin</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">revpath</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="built_in">segrev</span>(<span class="number">1</span>, dfn[top[x]], dfn[x]);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &gt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">if</span>(x != y) <span class="built_in">segrev</span>(<span class="number">1</span>, dfn[x] + <span class="number">1</span>, dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">sumpath</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        res += <span class="built_in">segsum</span>(<span class="number">1</span>, dfn[top[x]], dfn[x]);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &gt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">if</span>(x != y) res += <span class="built_in">segsum</span>(<span class="number">1</span>, dfn[x] + <span class="number">1</span>, dfn[y]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">maxpath</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">-2147483647</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">segmax</span>(<span class="number">1</span>, dfn[top[x]], dfn[x]));</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &gt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">if</span>(x != y) res = <span class="built_in">max</span>(res, <span class="built_in">segmax</span>(<span class="number">1</span>, dfn[x] + <span class="number">1</span>, dfn[y]));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">minpath</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">2147483647</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        res = <span class="built_in">min</span>(res, <span class="built_in">segmin</span>(<span class="number">1</span>, dfn[top[x]], dfn[x]));</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &gt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">if</span>(x != y) res = <span class="built_in">min</span>(res, <span class="built_in">segmin</span>(<span class="number">1</span>, dfn[x] + <span class="number">1</span>, dfn[y]));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(++a, ++b, c);</span><br><span class="line">        <span class="built_in">add</span>(b, a, c);</span><br><span class="line">        id[i].x = a;</span><br><span class="line">        id[i].y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> s[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%lld%lld&quot;</span>, s, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> target;</span><br><span class="line">            <span class="keyword">if</span>(dep[id[a].x] &gt; dep[id[a].y]) target = id[a].x;</span><br><span class="line">            <span class="keyword">else</span> target = id[a].y;</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>, dfn[target], b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;N&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">revpath</span>(++a, ++b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">sumpath</span>(++a, ++b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;M&#x27;</span> &amp;&amp; s[<span class="number">1</span>] == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">maxpath</span>(++a, ++b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;M&#x27;</span> &amp;&amp; s[<span class="number">1</span>] == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">minpath</span>(++a, ++b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>P1712 [NOI2016] 区间 题解</title>
    <url>/solutions/solution-p1712/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">区间</div>
<div id="problem-info-from">NOI 2016</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDE3MTI=">Luogu P1712</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yMDg2">LibreOJ L2086</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAxMS8=">AcWing 1009</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzQ2NTM=">BZOJ #4653</span></li></ul></div>

<hr>
<p>既然题目没有规定覆盖的顺序，且想让我们最小化选定的区间长度的极差，那我们不妨就先按照区间长度排一个序。</p>
<p>这一道题中的区间长度计算方式是 $l_i - r_i$，但是无伤大雅，毕竟我们按照比较常见的方式计算之后的结果会将1约掉，使得最后的结果没有差别。</p>
<p>之后，我们考虑一下如何枚举答案，最朴素的做法就是利用尺取法来不断判断现在选出的区间是否满足了要求，满足了就更新一下答案。<br>更新完答案之后，我们将左端点右移到不满足条件了就可以了。</p>
<p>最后我们考虑区间覆盖的时候如何快速判断是否符合要求，答案是线段树维护区间最大值。<br>当然，我们这里值域太大了，需要进行一发离散化。</p>
<p>于是我们就顺利地解决了这个问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> max, tag;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].max = <span class="built_in">max</span>(tr[p &lt;&lt; <span class="number">1</span>].max, tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].tag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;root = tr[p], &amp;left = tr[p &lt;&lt; <span class="number">1</span>], &amp;rght = tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">        left.tag += root.tag;</span><br><span class="line">        left.max += root.tag;</span><br><span class="line">        rght.tag += root.tag;</span><br><span class="line">        rght.max += root.tag;</span><br><span class="line">        root.tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].l = l, tr[p].r = r;</span><br><span class="line">    tr[p].max = tr[p].tag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">segadd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].max += k;</span><br><span class="line">        tr[p].tag += k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)<span class="built_in">segadd</span>(p &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)<span class="built_in">segadd</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">query</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> query &amp;a)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> len &lt; a.len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="type">int</span> x[N &lt;&lt; <span class="number">1</span>], idx;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;dic;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a[i].l, &amp;a[i].r);</span><br><span class="line">        a[i].len = a[i].r - a[i].l;</span><br><span class="line">        x[i * <span class="number">2</span> - <span class="number">2</span>] = a[i].l, x[i * <span class="number">2</span> - <span class="number">1</span>] = a[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(x, x + <span class="number">2</span> * n);</span><br><span class="line">    idx = <span class="built_in">unique</span>(x, x + <span class="number">2</span> * n) - x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++)</span><br><span class="line">        dic.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(x[i], i + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, idx);</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = dic[a[i].l], r = dic[a[i].r];</span><br><span class="line">        <span class="built_in">segadd</span>(<span class="number">1</span>, l, r, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(tr[<span class="number">1</span>].max &gt;= m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(tr[<span class="number">1</span>].max &gt;= m &amp;&amp; hh &lt;= n)</span><br><span class="line">            &#123;</span><br><span class="line">                hh++;</span><br><span class="line">                <span class="type">int</span> hl = dic[a[hh].l], hr = dic[a[hh].r];</span><br><span class="line">                <span class="built_in">segadd</span>(<span class="number">1</span>, hl, hr, <span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, a[i].len - a[hh].len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">0x3f3f3f3f</span>)<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P1954 [NOI2010] 航空管制 题解</title>
    <url>/solutions/solution-p1954/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">航空管制</div>
<div id="problem-info-from">NOI 2010</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDE5NTQ=">Luogu P1954</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8zNzYw">LibreOJ L3760</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvOTgxLw==">AcWing 979</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzIwMDg=">BZOJ #2008</span></li></ul></div>

<hr>
<p>本题的思路与<a href="/solutions/solution-p3243">[HNOI2015] 菜肴制作</a>很像。<br>同样是将约束条件当成单向边建反图之后跑拓扑排序，但是这里还需要考虑最晚起飞时间的限制。<br>因为我们是倒序枚举的时间，所以最晚起飞时间可以转化为最早起飞时间。<br>我们可以拿一个桶来存储下每一个最晚起飞时间对应的飞机集合，当我们枚举到这个时间之后，将所有的飞机放入堆里。<br>当然，因为要求的是可行解，所以这里的堆可以换成队列。</p>
<p>对于最早可能的起飞序号，我们可以对每一个飞机做一遍拓扑排序。<br>这一次做拓扑排序的时候，我们需要让当前选定的这个飞机尽量在队尾，也就是尽量晚出队。<br>具体实现方式就是在每一次插入新的队尾的时候，看一看能否将当前这个飞机（也就是队尾的前一个元素）与队尾交换位置。</p>
<p>题目保证有解了，就不需要判定无解的情况了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>, M = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> deg[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans[N], tot;</span><br><span class="line"><span class="type">int</span> tmp[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> q[N];</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">1</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tmp[i] = deg[i] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = n; t; t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[t].<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j : v[t])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!(--tmp[j]))</span><br><span class="line">                &#123;</span><br><span class="line">                    q[++tt] = j;</span><br><span class="line">                    <span class="keyword">if</span>(hh &lt; tt &amp;&amp; q[tt - <span class="number">1</span>] == u)<span class="built_in">swap</span>(q[tt], q[tt - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> p = q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(p == u)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, t);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(--tmp[e[i]]))</span><br><span class="line">            &#123;</span><br><span class="line">                q[++tt] = e[i];</span><br><span class="line">                <span class="keyword">if</span>(hh &lt; tt &amp;&amp; q[tt - <span class="number">1</span>] == u)<span class="built_in">swap</span>(q[tt], q[tt - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        v[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        deg[u]++;</span><br><span class="line">        <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tmp[i] = deg[i] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = n; t; t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[t].<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j : v[t])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[j]--;</span><br><span class="line">                <span class="keyword">if</span>(!tmp[j])q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        ans[t] = u;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">            <span class="keyword">if</span>(!(--tmp[e[i]]))q.<span class="built_in">push</span>(e[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">solve</span>(i);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>贪心</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P1999 高维正方体 题解</title>
    <url>/solutions/solution-p1999/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">高维正方体</div>
<div id="problem-info-from">none</div>
<div id="problem-info-difficulty">提高+ /省选-</div>
<div id="problem-info-color">#3498db</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDE5OTk=">Luogu P1999</span></li></ul></div>

<hr>
<p>一道考试题，写一下当时的思路。</p>
<p>首先我们进行一个列表：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">1</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">8</td>
<td align="center">12</td>
<td align="center">6</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>首先我们可以发现一个规律，就是 $n$ 位立方体所拥有的的点的个数是 $2^n$，所拥有的 $n-1$ 维立方体的个数是 $2n$。</p>
<p>然后就没有发现规律。</p>
<p>于是我就尝试再举出一个例子，看看能不能找出规律。</p>
<p><img src="https://img.catium.top:10000/upload/757281.png"></p>
<p>这是一个超立方体的展开图。</p>
<p>数了一下，发现这个玩意有8个正方体，24个面，32个边，16个顶点。</p>
<p>现在我们可以扩充一下这个表了：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">1</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">8</td>
<td align="center">12</td>
<td align="center">6</td>
<td align="center">1</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">16</td>
<td align="center">32</td>
<td align="center">24</td>
<td align="center">8</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>貌似还是没有什么规律。</p>
<p>尝试搞出来超立方体的面数与正方体的面数的关系。<br>发现其每一个面都会由两个正方体共享，于是就是 $\frac{6 \times 8}{2}$。<br>由此往后面推，每一个边都会由三个正方体共享，于是就是 $\frac{12 \times 8}{3} $。而正方体中的每一条边都会由两个面共享，所以12就等于 $\frac{4 \times 6}{2}$。</p>
<p>定义一个 $f_{n,m}$，代表 $n$ 维立方体拥有的 $m$ 维正方体数量。</p>
<p>于是 $f_{4,1} &#x3D; f_{3,1} \times \frac{2 \times 4}{3} &#x3D; f_{2,1} \times \frac{2 \times 3}{2} \times \frac{2 \times 4}{3}$。<br>而 $f_{n,n-1} &#x3D; 2n$。</p>
<p>于是我们就得到了一个关于 $f_{n,m}$ 的公式：</p>
<p>$$<br>f_{n,m} &#x3D; \frac{n!}{(n-m)!m!} \times 2^{n-m-1} \times 2(m+1)<br>$$</p>
<p>于是我们像预处理组合数一样预处理出来阶乘和阶乘的逆元就可以了。</p>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll fac[<span class="number">100010</span>], inv[<span class="number">100010</span>];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>)res = (res * a) % mod;</span><br><span class="line">        a = (a * a) % mod;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1ll</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m == n - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ll res = (<span class="number">2</span> * n) % mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">qpow</span>(<span class="number">2</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ll res = (fac[n] * inv[m + <span class="number">1</span>]) % mod * inv[n - m] % mod;</span><br><span class="line">        res = (res * <span class="built_in">qpow</span>(<span class="number">2</span>, n - m - <span class="number">1</span>)) % mod;</span><br><span class="line">        res = (res * <span class="built_in">f</span>(m + <span class="number">1</span>, m)) % mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    inv[<span class="number">0</span>] = <span class="number">1</span>; inv[<span class="number">100000</span>] = <span class="built_in">qpow</span>(fac[<span class="number">100000</span>], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">99999</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        inv[i] = <span class="number">1</span> * inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">if</span>(n &lt; m)<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">f</span>(n, m));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>P2042 [NOI2005] 维护数列 题解</title>
    <url>/solutions/solution-p2042/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">维护数列</div>
<div id="problem-info-from">NOI 2005</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDIwNDI=">Luogu P2042</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvOTU3Lw==">AcWing 955</span></li></ul></div>

<hr>
<p>题目要求我们维护一个数列，支持下面六种操作：</p>
<ol>
<li>插入：在当前数列的第 $posi$ 个数字后面插入 $c_1,c_2,\cdots,c_tot$ 共计 $tot$ 个数字；</li>
<li>删除：从当前数列的第 $posi$ 个数字开始连续删除 $tot$ 个数字；</li>
<li>推平：从当前数列的第 $posi$ 个数字开始的连续 $tot$ 个数字改为 $c$；</li>
<li>翻转：将区间 $[ posi,posi+tot-1 ]$ 翻转；</li>
<li>求和：求出区间 $[ posi,posi+tot-1 ]$ 内所有数字的和；</li>
<li>求最大子序列和：求出当前数列中最大的一段子序列并输出其序列和。</li>
</ol>
<p>看见区间翻转我就想到了平衡树。</p>
<p>幸好上面需要我们支持的操作都是可以利用平衡树来维护的。</p>
<p>我们在维护区间翻转的时候就用到了懒标记的思想，这里我们也可以使用懒标记。</p>
<p>我们的结构体长的是这个样子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s[<span class="number">2</span>], p, v;</span><br><span class="line">    <span class="type">int</span> rev, same;</span><br><span class="line">    <span class="type">int</span> sz, sum, ms, ls, rs;</span><br><span class="line">&#125;tr[N];</span><br></pre></td></tr></table></figure>

<p>其中分别维护的是：</p>
<ul>
<li><code>s[2]</code>：左右儿子；</li>
<li><code>p</code>：父亲；</li>
<li><code>v</code>：当前节点的值；</li>
<li><code>rev</code>：翻转懒标记；</li>
<li><code>same</code>：推平懒标记；</li>
<li><code>sz</code>：子树大小；</li>
<li><code>sum</code>：区间和；</li>
<li><code>ms</code>：区间最大子序列和；</li>
<li><code>ls</code>：区间最大前缀和；</li>
<li><code>rs</code>：区间最大后缀和。</li>
</ul>
<p>我们初始化的时候这样初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> _v, <span class="type">int</span> _p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s[<span class="number">0</span>] = s[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    p = _p, v = _v;</span><br><span class="line">    rev = same = <span class="number">0</span>;</span><br><span class="line">    sz = <span class="number">1</span>;</span><br><span class="line">    sum = ms = v;</span><br><span class="line">    ls = rs = <span class="built_in">max</span>(v, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是区间合并：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;u = tr[x], &amp;l = tr[u.s[<span class="number">0</span>]], &amp;r = tr[u.s[<span class="number">1</span>]];</span><br><span class="line">    u.sz = l.sz + r.sz + <span class="number">1</span>;</span><br><span class="line">    u.sum = l.sum + r.sum + u.v;</span><br><span class="line">    u.ls = <span class="built_in">max</span>(l.ls, l.sum + u.v + r.ls);</span><br><span class="line">    u.rs = <span class="built_in">max</span>(r.rs, r.sum + u.v + l.rs);</span><br><span class="line">    u.ms = <span class="built_in">max</span>(<span class="built_in">max</span>(l.ms, r.ms), l.rs + u.v + r.ls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>维护当前区间的最大子序列可以看<a href="/OI/segment-tree/#%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C">这里</a>的思路。</p>
<p>再然后是标记的下传：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;u = tr[x], &amp;l = tr[u.s[<span class="number">0</span>]], &amp;r = tr[u.s[<span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">if</span>(u.same)</span><br><span class="line">    &#123;</span><br><span class="line">        u.same = u.rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(u.s[<span class="number">0</span>]) l.same = <span class="number">1</span>, l.v = u.v, l.sum = l.v * l.sz;</span><br><span class="line">        <span class="keyword">if</span>(u.s[<span class="number">1</span>]) r.same = <span class="number">1</span>, r.v = u.v, r.sum = r.v * r.sz;</span><br><span class="line">        <span class="keyword">if</span>(u.v &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(u.s[<span class="number">0</span>]) l.ms = l.ls = l.rs = l.sum;</span><br><span class="line">            <span class="keyword">if</span>(u.s[<span class="number">1</span>]) r.ms = r.ls = r.rs = r.sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(u.s[<span class="number">0</span>]) l.ms = l.v, l.ls = l.rs = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(u.s[<span class="number">1</span>]) r.ms = r.v, r.ls = r.rs = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(u.rev)</span><br><span class="line">    &#123;</span><br><span class="line">        u.rev = <span class="number">0</span>, l.rev ^= <span class="number">1</span>, r.rev ^= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">swap</span>(l.ls, l.rs), <span class="built_in">swap</span>(r.ls, r.rs);</span><br><span class="line">        <span class="built_in">swap</span>(l.s[<span class="number">0</span>], l.s[<span class="number">1</span>]), <span class="built_in">swap</span>(r.s[<span class="number">0</span>], r.s[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区间推平的优先级是先于区间翻转的，且如果这个区间整体被推平了，那么这个区间翻转了和没翻转没有什么区别，所以每一次标记下传的时候只需要下传两者其一即可。</p>
<p>然后是六种操作：</p>
<ol>
<li>插入一整段区间的操作与一开始建树的时候差不多。<br> 我们需要首先预留出来新区间的位置，比如说 $posi+1$ 节点的左子树。此时这棵树长这个样子：<br> <img src="/%5Cpics%5Cp2042-1.bmp" alt="p2042-1.bmp"><br> 我们就是要在肩头指向的位置插入我们的新序列。<br> 然后就像一开始的时候那样，基于新读入的序列建立一棵平衡树，根节点为 $u$。<br> 然后让 $u$ 成为 $posi+1$ 的左儿子，就像这样：<br> <img src="/%5Cpics%5Cp2042-2.bmp" alt="p2042-2.bmp"><br> 现在我们就在 $posi$ 后面插入了一段新的序列。</li>
<li>删除一整段区间的操作与正常的删除操作没有什么区别。<br> 这里就不讲了。</li>
<li>区间推平与区间翻转的道理类似，都是给整个区间打上一个标记，同时区间推平还会额外修改一下区间和、区间最大子段和、区间最大前缀和与区间最大后缀和，别的就没有什么好说的了。</li>
<li>区间求和的思路与区间翻转、区间推平类似，只不过不是修改而是查询。截出来询问区间之后直接输出值即可。</li>
<li>上面的五种操作都需要截出对应区间，但是询问区间最大子段和只需要访问当前根节点即可。</li>
</ol>
<p>最后放一下总的代码：</p>
<details class="note success"><summary><p>示例代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>, INF = <span class="number">1000000000</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s[<span class="number">2</span>], p, v;</span><br><span class="line">    <span class="type">int</span> rev, same;</span><br><span class="line">    <span class="type">int</span> sz, sum, ms, ls, rs;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> _v, <span class="type">int</span> _p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        s[<span class="number">0</span>] = s[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        p = _p, v = _v;</span><br><span class="line">        rev = same = <span class="number">0</span>;</span><br><span class="line">        sz = <span class="number">1</span>;</span><br><span class="line">        sum = ms = v;</span><br><span class="line">        ls = rs = <span class="built_in">max</span>(v, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="type">int</span> rt, recycle[N], tt;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;u = tr[x], &amp;l = tr[u.s[<span class="number">0</span>]], &amp;r = tr[u.s[<span class="number">1</span>]];</span><br><span class="line">    u.sz = l.sz + r.sz + <span class="number">1</span>;</span><br><span class="line">    u.sum = l.sum + r.sum + u.v;</span><br><span class="line">    u.ls = <span class="built_in">max</span>(l.ls, l.sum + u.v + r.ls);</span><br><span class="line">    u.rs = <span class="built_in">max</span>(r.rs, r.sum + u.v + l.rs);</span><br><span class="line">    u.ms = <span class="built_in">max</span>(<span class="built_in">max</span>(l.ms, r.ms), l.rs + u.v + r.ls);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;u = tr[x], &amp;l = tr[u.s[<span class="number">0</span>]], &amp;r = tr[u.s[<span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">if</span>(u.same)</span><br><span class="line">    &#123;</span><br><span class="line">        u.same = u.rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(u.s[<span class="number">0</span>]) l.same = <span class="number">1</span>, l.v = u.v, l.sum = l.v * l.sz;</span><br><span class="line">        <span class="keyword">if</span>(u.s[<span class="number">1</span>]) r.same = <span class="number">1</span>, r.v = u.v, r.sum = r.v * r.sz;</span><br><span class="line">        <span class="keyword">if</span>(u.v &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(u.s[<span class="number">0</span>]) l.ms = l.ls = l.rs = l.sum;</span><br><span class="line">            <span class="keyword">if</span>(u.s[<span class="number">1</span>]) r.ms = r.ls = r.rs = r.sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(u.s[<span class="number">0</span>]) l.ms = l.v, l.ls = l.rs = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(u.s[<span class="number">1</span>]) r.ms = r.v, r.ls = r.rs = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(u.rev)</span><br><span class="line">    &#123;</span><br><span class="line">        u.rev = <span class="number">0</span>, l.rev ^= <span class="number">1</span>, r.rev ^= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">swap</span>(l.ls, l.rs), <span class="built_in">swap</span>(r.ls, r.rs);</span><br><span class="line">        <span class="built_in">swap</span>(l.s[<span class="number">0</span>], l.s[<span class="number">1</span>]), <span class="built_in">swap</span>(r.s[<span class="number">0</span>], r.s[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> y = tr[x].p, z = tr[y].p;</span><br><span class="line">    <span class="type">int</span> k = tr[y].s[<span class="number">1</span>] == x;</span><br><span class="line">    tr[z].s[tr[z].s[<span class="number">1</span>] == y] = x, tr[x].p = z;</span><br><span class="line">    tr[y].s[k] = tr[x].s[k ^ <span class="number">1</span>], tr[tr[x].s[k ^ <span class="number">1</span>]].p = y;</span><br><span class="line">    tr[x].s[k ^ <span class="number">1</span>] = y, tr[y].p = x;</span><br><span class="line">    <span class="built_in">pushup</span>(y), <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(tr[x].p != k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = tr[x].p, z = tr[y].p;</span><br><span class="line">        <span class="keyword">if</span>(z != k)</span><br><span class="line">            <span class="keyword">if</span>((tr[y].s[<span class="number">1</span>] == x) ^ (tr[z].s[<span class="number">1</span>] == y)) <span class="built_in">rotate</span>(x);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">rotate</span>(y);</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!k) rt = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_k</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = rt;</span><br><span class="line">    <span class="keyword">while</span>(u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="keyword">if</span>(tr[tr[u].s[<span class="number">0</span>]].sz &gt;= k) u = tr[u].s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tr[tr[u].s[<span class="number">0</span>]].sz + <span class="number">1</span> == k) <span class="keyword">return</span> u;</span><br><span class="line">        <span class="keyword">else</span> k -= tr[tr[u].s[<span class="number">0</span>]].sz + <span class="number">1</span>, u = tr[u].s[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> u = recycle[tt--];</span><br><span class="line">    tr[u].<span class="built_in">init</span>(w[mid], p);</span><br><span class="line">    <span class="keyword">if</span>(l &lt; mid) tr[u].s[<span class="number">0</span>] = <span class="built_in">build</span>(l, mid - <span class="number">1</span>, u);</span><br><span class="line">    <span class="keyword">if</span>(mid &lt; r) tr[u].s[<span class="number">1</span>] = <span class="built_in">build</span>(mid + <span class="number">1</span>, r, u);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].s[<span class="number">0</span>]) <span class="built_in">del</span>(tr[u].s[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(tr[u].s[<span class="number">1</span>]) <span class="built_in">del</span>(tr[u].s[<span class="number">1</span>]);</span><br><span class="line">    recycle[++tt] = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++) recycle[++tt] = i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    tr[<span class="number">0</span>].ms = w[<span class="number">0</span>] = w[n + <span class="number">1</span>] = -INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    rt = <span class="built_in">build</span>(<span class="number">0</span>, n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> op[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;INSERT&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> posi, tot;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;posi, &amp;tot);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; tot; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">get_k</span>(posi + <span class="number">1</span>), r = <span class="built_in">get_k</span>(posi + <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">splay</span>(l, <span class="number">0</span>), <span class="built_in">splay</span>(r, l);</span><br><span class="line">            <span class="type">int</span> u = <span class="built_in">build</span>(<span class="number">0</span>, tot - <span class="number">1</span>, r);</span><br><span class="line">            tr[r].s[<span class="number">0</span>] = u;</span><br><span class="line">            <span class="built_in">pushup</span>(r), <span class="built_in">pushup</span>(l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;DELETE&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> posi, tot;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;posi, &amp;tot);</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">get_k</span>(posi), r = <span class="built_in">get_k</span>(posi + tot + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">splay</span>(l, <span class="number">0</span>), <span class="built_in">splay</span>(r, l);</span><br><span class="line">            <span class="built_in">del</span>(tr[r].s[<span class="number">0</span>]);</span><br><span class="line">            tr[r].s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">pushup</span>(r), <span class="built_in">pushup</span>(l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;MAKE-SAME&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> posi, tot, c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;posi, &amp;tot, &amp;c);</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">get_k</span>(posi), r = <span class="built_in">get_k</span>(posi + tot + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">splay</span>(l, <span class="number">0</span>), <span class="built_in">splay</span>(r, l);</span><br><span class="line">            <span class="keyword">auto</span> &amp;son = tr[tr[r].s[<span class="number">0</span>]];</span><br><span class="line">            son.same = <span class="number">1</span>, son.v = c, son.sum = c * son.sz;</span><br><span class="line">            <span class="keyword">if</span>(c &gt; <span class="number">0</span>) son.ms = son.ls = son.rs = son.sum;</span><br><span class="line">            <span class="keyword">else</span> son.ms = c, son.ls = son.rs = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">pushup</span>(r), <span class="built_in">pushup</span>(l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;REVERSE&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> posi, tot;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;posi, &amp;tot);</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">get_k</span>(posi), r = <span class="built_in">get_k</span>(posi + tot + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">splay</span>(l, <span class="number">0</span>), <span class="built_in">splay</span>(r, l);</span><br><span class="line">            <span class="keyword">auto</span> &amp;son = tr[tr[r].s[<span class="number">0</span>]];</span><br><span class="line">            son.rev ^= <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">swap</span>(son.ls, son.rs);</span><br><span class="line">            <span class="built_in">swap</span>(son.s[<span class="number">0</span>], son.s[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">pushup</span>(r), <span class="built_in">pushup</span>(l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;GET-SUM&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> posi, tot;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;posi, &amp;tot);</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">get_k</span>(posi), r = <span class="built_in">get_k</span>(posi + tot + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">splay</span>(l, <span class="number">0</span>), <span class="built_in">splay</span>(r, l);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tr[tr[r].s[<span class="number">0</span>]].sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tr[rt].ms);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>P2146 [NOI2015] 软件包管理器 题解</title>
    <url>/solutions/solution-p2146/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">软件包管理器</div>
<div id="problem-info-from">NOI 2015</div>
<div id="problem-info-difficulty">提高+ /省选-</div>
<div id="problem-info-color">#3498db</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDIxNDY=">Luogu P2146</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yMTMw">LibreOJ L2130</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvOTIwLw==">AcWing 918</span></li></ul></div>

<hr>
<p>树剖模板题。</p>
<p>首先我们看一下<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDIxNDY=">题面</span>；</p>
<p>将题面简化一下，就是下面这样：</p>
<blockquote>
<p>给定一棵大小为 $n$ 的，根节点为0的树，我们需要对这棵树进行两种操作，并求出有多少个节点的状态被改变：</p>
<ol>
<li>将根节点到给定节点的路径全部变成1，输入格式为 <code>install x</code> ；</li>
<li>将给定节点及其子树全部变成0，输入格式为 <code>uninstall x</code> ；<br>初始情况下所有节点都是0。</li>
</ol>
</blockquote>
<p>对于我们的结果，我们直接可以对比操作前后整棵树的权值和（存在根节点里面），然后直接输出两数之差即可。</p>
<p>但是我们还需要注意一点：<strong>默认懒标记值</strong>。<br>我们之前一直设懒标记的默认值为0，而在此题的环境内，0代表的是一种状态，而非一个值。如果将懒标记值为0的时候直接跳过的话，就无法卸载所有需要卸载的软件。<br>所以我们在此将默认懒标记值定为-1。pushup的时候也是一样。</p>
<p>当然，本题要求的是区间覆盖而非区间增减，而这个就只将segadd和pushdown两个函数里面的<code>+=</code>换成<code>=</code>即可。<br>比如这样：</p>
<p>segadd：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">segadd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((l &lt;= tr[p].l) &amp;&amp; (r &gt;= tr[p].r))</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].add = k;</span><br><span class="line">        tr[p].sum = k * (tr[p].r - tr[p].l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">segadd</span>(p &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">segadd</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pushdown：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[p], &amp;left = tr[p &lt;&lt; <span class="number">1</span>], &amp;rght = tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(root.add!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        left.add = root.add, left.sum = root.add * (left.r - left.l + <span class="number">1</span>);</span><br><span class="line">        rght.add = root.add, rght.sum = root.add * (rght.r - rght.l + <span class="number">1</span>);</span><br><span class="line">        root.add = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为本题的根节点是0，所以我将所有节点的编号都加上了1，这样就与正常情况下差不多了。<br>完整代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> id[N], cnt;</span><br><span class="line"><span class="type">int</span> dep[N], sz[N], top[N], fa[N], son[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segtree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    ll add, sum;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> father, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[p] = depth, fa[p] = father, sz[p] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == father) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(j, p, depth + <span class="number">1</span>);</span><br><span class="line">        sz[p] += sz[j];</span><br><span class="line">        <span class="keyword">if</span>(sz[son[p]] &lt; sz[j]) son[p] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id[p] = ++cnt, top[p] = t;</span><br><span class="line">    <span class="keyword">if</span>(!son[p]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[p], t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == fa[p] || j == son[p]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(j, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].sum = tr[p &lt;&lt; <span class="number">1</span>].sum + tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[p], &amp;left = tr[p &lt;&lt; <span class="number">1</span>], &amp;rght = tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(root.add!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        left.add = root.add, left.sum = root.add * (left.r - left.l + <span class="number">1</span>);</span><br><span class="line">        rght.add = root.add, rght.sum = root.add * (rght.r - rght.l + <span class="number">1</span>);</span><br><span class="line">        root.add = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p] = &#123; l, r, <span class="number">-1</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">//pushup(p);</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">segadd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((l &lt;= tr[p].l) &amp;&amp; (r &gt;= tr[p].r))</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].add = k;</span><br><span class="line">        tr[p].sum = k * (tr[p].r - tr[p].l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">segadd</span>(p &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">segadd</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">install</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll prev = tr[<span class="number">1</span>].sum;</span><br><span class="line">    <span class="type">int</span> v = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[p] != top[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[p]] &lt; dep[top[v]]) <span class="built_in">swap</span>(p, v);</span><br><span class="line">        <span class="built_in">segadd</span>(<span class="number">1</span>, id[top[p]], id[p], <span class="number">1</span>);</span><br><span class="line">        p = fa[top[p]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[p] &lt; dep[v]) <span class="built_in">swap</span>(p, v);</span><br><span class="line">    <span class="built_in">segadd</span>(<span class="number">1</span>, id[v], id[p], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> tr[<span class="number">1</span>].sum - <span class="number">114514</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">uninstall</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll prev = tr[<span class="number">1</span>].sum;</span><br><span class="line">    <span class="built_in">segadd</span>(<span class="number">1</span>, id[p], id[p] + sz[p] - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">114514</span> - tr[<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        a++;</span><br><span class="line">        <span class="built_in">add</span>(a, i);</span><br><span class="line">        <span class="built_in">add</span>(i, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">install</span>(x + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;u&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">uninstall</span>(x + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Youwike AK IOI!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">114514</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>P2375 [NOI2014] 动物园 题解</title>
    <url>/solutions/solution-p2375/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">动物园</div>
<div id="problem-info-from">NOI 2014</div>
<div id="problem-info-difficulty">提高+ /省选-</div>
<div id="problem-info-color">#3498db</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDIzNzU=">Luogu P2375</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yMjQ2">LibreOJ L2246</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMTAwMi8=">AcWing 1000</span></li><li><span class="exturl" data-url="aHR0cHM6Ly91b2ouYWMvcHJvYmxlbS81">UOJ #5</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzM2NzA=">BZOJ #3670</span></li></ul></div>

<hr>
<p>题目要求我们求出来一个 $num$ 数组。对于一个字符串来说，其 $num$ 的值就是其所有不重叠的 $border$ 的个数。而 $num$ 数组就是对这个字符串的所有前缀求 $num$。</p>
<p>这个有一点难想，我们不如先想一下弱化版的，即不考虑重叠这个因素了。</p>
<p>那么这个弱化版的 $num$ 数组其实就是字符串每一个前缀的 $border$ 个数，也就是其在 $fail$ 树上的深度。</p>
<p>那么如果我们再考虑上重叠的部分，那我们就对于一个长度为 $i$ 的前缀找到一个 $j$，使得长度为 $j$ 的前缀是长度为 $i$ 的前缀的一个 $border$。<br>因为 $\pi[i] &lt; i$，所以我们找到的最大的 $j$ 的 $\pi[j]$ 就是我们的 $num[i]$ 了。</p>
<hr>
<p>然后我们还需要一个优化。<br>因为我们如果碰到了一个奇怪的字符串，里面有 $10^6$ 个 <code>a</code>，那么我们就会被卡成 $O(n^2)$ 级别的。</p>
<p>我们可以尝试利用 KMP 的思想，尝试减小重复的递归。</p>
<p>那么我们可以将枚举的变量 $j$ 放到循环外面，结束循环的时候不初始化之，就不需要在不用枚举 $&lt; j$ 的部分时枚举 $&lt; j$ 的部分了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    ll n = (ll)s.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;ll&gt;<span class="built_in">ne</span>(n + <span class="number">1</span>), <span class="built_in">num</span>(n + <span class="number">1</span>);</span><br><span class="line">    ll j = <span class="number">0</span>;</span><br><span class="line">    num[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j])j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j])j++;</span><br><span class="line">        ne[i + <span class="number">1</span>] = j;</span><br><span class="line">        num[i + <span class="number">1</span>] = num[j] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j])j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j])j++;</span><br><span class="line">        <span class="keyword">while</span> (j * <span class="number">2</span> &gt; (i + <span class="number">1</span>))j = ne[j];</span><br><span class="line">        ans = (ans * (num[j] + <span class="number">1</span>)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> endl = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>P2414 [NOI2011] 阿狸的打字机 题解</title>
    <url>/solutions/solution-p2414/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">阿狸的打字机</div>
<div id="problem-info-from">NOI 2011</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI0MTQ=">Luogu P2414</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yNDQ0">LibreOJ L2444</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvOTg1Lw==">AcWing 983</span></li></ul></div>

<hr>
<p>题目这个样子就相当于是构造了一个字符串的集合，同时询问我们某一个字符串在另一个字符串内出现了多少次。</p>
<p>首先看一下数据范围：<br>字符串数量 $n \leq 10^5$，询问数量 $m \leq 10^5$。</p>
<p>况且字符串的输入格式还特别奇怪：</p>
<blockquote>
<p>阿狸喜欢收藏各种稀奇古怪的东西，最近他淘到一台老式的打字机。打字机上只有 $28$ 个按键，分别印有 $26$ 个小写英文字母和 <code>B</code>、<code>P</code> 两个字母。经阿狸研究发现，这个打字机是这样工作的：</p>
<ul>
<li>输入小写字母，打字机的一个凹槽中会加入这个字母(这个字母加在凹槽的最后)。</li>
<li>按一下印有 <code>B</code> 的按键，打字机凹槽中最后一个字母会消失。</li>
<li>按一下印有 <code>P</code> 的按键，打字机会在纸上打印出凹槽中现有的所有字母并换行，但凹槽中的字母不会消失。</li>
</ul>
<p>例如，阿狸输入 <code>aPaPBbP</code>，纸上被打印的字符如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">aa</span><br><span class="line">ab</span><br></pre></td></tr></table></figure>
<p>我们把纸上打印出来的字符串从 $1$ 开始顺序编号，一直到 $n$。</p>
</blockquote>
<p>然后我们就可以由此联想到Trie，以及以其为基础的AC自动机。</p>
<p>AC自动机是有字符串匹配的功能的，但是这样直接匹配还是有点慢。<br>其每一次询问的时间复杂度都是与文本串的长度成正相关的。</p>
<p>当然我们可以想到离线询问，对于处理相同文本串的询问确实是节省了时间。</p>
<p>同时我们考虑一个性质：</p>
<p><strong>我们的所有文本串均会出现在AC自动机中。</strong></p>
<p>或者说，我们相当于是拿模式串与模式串相比对。</p>
<p>这样我们就完全是在AC自动机内部做匹配，不需要考虑什么被抛弃的部分了。</p>
<hr>
<p>如何解决询问？</p>
<p>我们刚才考虑过离线并按照文本串分组。</p>
<p>我们对于某一个文本串，要如何才能提溜出来其所有的子串呢？</p>
<p>我们考虑这样一个有关fail边的性质：</p>
<blockquote>
<p>由于fail边跳到的是当前字符串在Trie内存在的最长后缀，且如果当前的模式串出现在了文本串内的话，其子串也会出现在文本串内，所以我们可以沿着fail指针一路遍历当前模式串的所有后缀。</p>
</blockquote>
<p>所以对于某一个字符串 $s$，从根节点到代表 $s$ 的节点的这一条路径上所有节点及沿着其fail指针跳到根节点的所有路径上的点代表的字符串都在 $s$ 里面出现过。</p>
<p>这其中包含了 $s$ 的所有子串，因为其的某个子串一定是某一个后缀的某个前缀。</p>
<hr>
<p>既然这个样子了，我们不如就不直接遍历整个AC自动机，而单独把fail指针提溜出来建成一张图遍历好了。</p>
<p>这里还附加了一个特殊性质，就是我们单独把fail指针拎出来之后会构建出来一棵树，而不是一张图。</p>
<p>然后我们考虑记录两个值：当前节点的DFS序和回溯到当前节点时的时间。</p>
<p>我们记录了这两个值以后，就可以单独把这个节点的子树给提溜出来了。</p>
<p>由于我们fail边指向的是当前字符串的最长后缀，那么我们fail树里面某一个节点绝对是其子树内所有点的某一个后缀。<br>那么如果这个节点出现过一次，那么这个节点代表的字符串在其子树内节点所代表的字符串内就必定出现过一次。<br>同理，如果这个节点的子树内的节点代表的字符串出现过一次，这个节点代表的字符串必定也出现过一次。<br>所以我们统计某一个字符串出现的次数的时候，我们需要统计该节点及其子树的所有信息。</p>
<p>那我们好像可以使用树状数组或线段树维护……</p>
<hr>
<p>那我们怎么统计信息呢？</p>
<p>顺序遍历字符串即可。<br>同时还要沿着AC自动机跳。</p>
<p>每一次遇到一个新的字符的时候分类讨论：</p>
<ul>
<li>如果是小写字母，那就沿着AC自动机跳，同时该节点出现的次数<code>+1</code>。</li>
<li>如果是 <code>P</code>，那就意味着（可能）有询问需要处理。遍历所有该字符串下的询问，并存储答案。</li>
<li>如果是 <code>B</code>，那就意味着上一个字符串遍历的所有信息就不算了，该节点出现的次数<code>-1</code>，同时跳到当前节点的父亲。</li>
</ul>
<p>分析完毕。</p>
<hr>
<p>然后是代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, flag = <span class="number">1</span>; <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>((c = <span class="built_in">getchar</span>()) &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) flag = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (c ^ <span class="number">48</span>), c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x * flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++idx] = b, ne[idx] = h[a], h[a] = idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> dfn[N], out[N], indx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AC</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> v, fail, fa;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, now = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!tr[now].s[s[i] - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                tr[now].s[s[i] - <span class="string">&#x27;a&#x27;</span>] = ++cnt;</span><br><span class="line">                tr[cnt].fa = now;</span><br><span class="line">            &#125;</span><br><span class="line">            now = tr[now].s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;P&#x27;</span>)</span><br><span class="line">            a[++n] = now;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">            now = tr[now].fa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_fail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(tr[<span class="number">0</span>].s[i])q.<span class="built_in">push</span>(tr[<span class="number">0</span>].s[i]);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[u].s[i])</span><br><span class="line">            &#123;</span><br><span class="line">                tr[tr[u].s[i]].fail = tr[tr[u].fail].s[i];</span><br><span class="line">                q.<span class="built_in">push</span>(tr[u].s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tr[u].s[i] = tr[tr[u].fail].s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = ++indx;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i];</span><br><span class="line">        <span class="keyword">if</span>(v ^ p)<span class="built_in">dfs</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    out[u] = indx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">segadd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= indx; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">        c[i] += v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">segsum</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &gt; <span class="number">0</span>; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">        ans += c[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">query</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, id;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;query&gt;g[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    <span class="built_in">insert</span>();</span><br><span class="line">    <span class="built_in">build_fail</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">        <span class="built_in">add</span>(i, tr[i].fail), <span class="built_in">add</span>(tr[i].fail, i);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        g[y].<span class="built_in">push_back</span>(&#123; x,i &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, now = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;P&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; g[j].<span class="built_in">size</span>(); k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x = g[j][k].x, id = g[j][k].id;</span><br><span class="line">                ans[id] = <span class="built_in">segsum</span>(out[a[x]]) - <span class="built_in">segsum</span>(dfn[a[x]] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">segadd</span>(dfn[now], <span class="number">-1</span>);</span><br><span class="line">            now = tr[now].fa;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            now = tr[now].s[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="built_in">segadd</span>(dfn[now], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>P2469 [SDOI2010] 星际竞速 题解</title>
    <url>/solutions/solution-p2469/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">星际竞速</div>
<div id="problem-info-from">SDOI 2010</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI0Njk=">Luogu P2469</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjUwMS8=">AcWing 2499</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzE5Mjc=">BZOJ #1927</span></li></ul></div>

<hr>
<p>题目要求我们求出，从任意一个星球开始走，经过所有星球恰好一次的最短时间。</p>
<p>我们先看一看题目给了我们什么信息：</p>
<p>首先是有 $n$ 颗星球，每一颗星球只能经过一次，我们可以拆点。</p>
<p>然后是正常的星际航道，每一个星际航道都有自己的通过所需时间，这个就加进图中的边里面去。</p>
<p>然后每一颗星球都有一个自己的定位时间，与当前所在位置无关。且我们一开始必须使用这种方式来到达某一个星球。这个不是特别好想出来，暂时搁置。</p>
<p>最后还有一个要求，就是我们只能从编号较小的星球跳到编号较大的星球。</p>
<p>我们从上面的要求里面可以看出来是一个费用流，但是我们并没有建图的思路。</p>
<hr>
<p>我们可以这样想：</p>
<p>既然我们需要每一个星球都经过恰好一次，那么我们可以对这个经过的方式进行分类讨论。</p>
<p>我们有两种方法能经过这里：</p>
<ol>
<li>航道</li>
<li>跃迁</li>
</ol>
<p>至于我们是从哪个星球来的，之后又要去哪里，已经不重要了，我们只关心我们是怎么到当前这一颗星球的。</p>
<p>我们仍然将星球拆成两个点，只不过这一次我们的两个点不再在中间连边来限制流量了。<br>他们有了其他的意义：出发和到达。</p>
<p>顾名思义，代表出发的点连接源点，并向与之有着星际航道联通的星球的到达点连边。代表到达的点连接汇点，同时还连接源点，代表直接跃迁到了这里。</p>
<p>每一条边的容量均为1，费用根据边的类型而定。除了代表跃迁的边和代表星际航道的边费用分别是 $a_i$ 和 $w_i$，其余各边费用都为0。</p>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> m, n;</span><br><span class="line"><span class="type">int</span> S, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], f[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> q[N], d[N], pre[N], incf[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">    e[idx] = a, f[idx] = <span class="number">0</span>, w[idx] = -d, ne[idx] = h[b], h[b] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="built_in">memset</span>(incf, <span class="number">0</span>, <span class="keyword">sizeof</span> incf);</span><br><span class="line">    q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, incf[S] = INF;</span><br><span class="line">    <span class="keyword">while</span> (hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">if</span> (hh == N) hh = <span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ver = e[i];</span><br><span class="line">            <span class="keyword">if</span> (f[i] &amp;&amp; d[ver] &gt; d[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[ver] = d[t] + w[i];</span><br><span class="line">                pre[ver] = i;</span><br><span class="line">                incf[ver] = <span class="built_in">min</span>(f[i], incf[t]);</span><br><span class="line">                <span class="keyword">if</span> (!st[ver])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++] = ver;</span><br><span class="line">                    <span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;</span><br><span class="line">                    st[ver] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incf[T] &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EK</span><span class="params">(<span class="type">int</span>&amp; flow, <span class="type">int</span>&amp; cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    flow = cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">spfa</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = incf[T];</span><br><span class="line">        flow += t, cost += t * d[T];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = T; i != S; i = e[pre[i] ^ <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            f[pre[i]] -= t;</span><br><span class="line">            f[pre[i] ^ <span class="number">1</span>] += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    S = <span class="number">0</span>, T = n * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        <span class="built_in">add</span>(S, i, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//代表从这个点出发</span></span><br><span class="line">        <span class="built_in">add</span>(S, i + n, <span class="number">1</span>, a);<span class="comment">//代表直接跃迁到达这个点</span></span><br><span class="line">        <span class="built_in">add</span>(i + n, T, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//到了这个点，打个卡</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b)<span class="built_in">swap</span>(a, b);<span class="comment">//编号小的连编号大的</span></span><br><span class="line">        <span class="built_in">add</span>(a, b + n, <span class="number">1</span>, c);<span class="comment">//出发连到达，从a出发走星际航道到达b</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> flow, cost;</span><br><span class="line">    <span class="built_in">EK</span>(flow, cost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>P2698 [USACO12MAR] Flowerpot 题解</title>
    <url>/solutions/solution-p2698/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">Flowerpot</div>
<div id="problem-info-from">USACO 2012 March Silver</div>
<div id="problem-info-difficulty">提高+ /省选-</div>
<div id="problem-info-color">#3498db</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI2OTg=">Luogu P2698</span></li></ul></div>

<hr>
<p>题目要求我们在 $x$ 轴上找到最短的一个区间，使得该区间内所有点的纵坐标的极差不小于给定的一个数 $D$。</p>
<p>我们首先可以想到的做法就是二分，将其转化成为一个判定问题。<br>因为一旦找到了一个合法区间，我们如果继续扩展区间端点的话肯定还是能满足条件的，所以可以二分。</p>
<p>那我们考虑怎么判断。</p>
<p>我们可以枚举左端点，然后找到一个最近的右端点使得其满足条件，然后判断区间长度是否小于等于当前二分的长度即可。<br>我们还可以发现，区间右端点是单调不降的，这就给了我们使用滑动窗口的机会。</p>
<p>然后我们就可以好好想一想了。</p>
<p>我们每一次做滑动窗口统计到区间长度的时候，为什么不记录下来然后取最小值呢？毕竟这些答案都是固定的。</p>
<p>于是我们就光荣舍弃掉了二分，虽然复杂度没什么变化，因为复杂度瓶颈是排序。</p>
<p>具体做法就是首先将所有点按照横坐标排个序，然后拿两个单调队列维护区间最大值和区间最小值，不断移动左右端点即可。</p>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Raindrop</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Raindrop &amp;a)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="type">int</span> t[N], b[N];</span><br><span class="line"><span class="type">int</span> h1, t1, h2, t2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a[i].x, &amp;a[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line">    h1 = h2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>; l &lt;= n; l++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(h1 &lt;= t1 &amp;&amp; t[h1] &lt; l)h1++;</span><br><span class="line">        <span class="keyword">while</span>(h2 &lt;= t2 &amp;&amp; b[h2] &lt; l)h2++;</span><br><span class="line">        <span class="keyword">while</span>(a[t[h1]].y - a[b[h2]].y &lt; d &amp;&amp; r &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="keyword">while</span>(h1 &lt;= t1 &amp;&amp; a[t[t1]].y &lt; a[r].y)t1--;</span><br><span class="line">            t[++t1] = r;</span><br><span class="line">            <span class="keyword">while</span>(h2 &lt;= t2 &amp;&amp; a[b[t2]].y &gt; a[r].y)t2--;</span><br><span class="line">            b[++t2] = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[t[h1]].y - a[b[h2]].y &gt;= d)</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, a[r].x - a[l].x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans &gt;= <span class="number">1e9</span>)ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>P2860 [USACO06JAN] Redundant Paths 题解</title>
    <url>/solutions/solution-p2860/</url>
    <content><![CDATA[<br>
<span id="more"></span>

<div id="problem-card-vis">true</div>
<div id="problem-info-name">Redundant Paths</div>
<div id="problem-info-from">USACO 2006 January Gold</div>
<div id="problem-info-difficulty">提高+ /省选-</div>
<div id="problem-info-color">#3498db</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI4NjA=">Luogu P2860</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzk3Lw==">AcWing 395</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzE3MTg=">BZOJ #1718</span></li></ul></div>

<hr>
<p>题目要求我们给一个无向联通图上加几条边，使得整个图变成一个双联通分量。</p>
<p>我们可以想到的一个思路就是，首先跑一遍 Tarjan 算法，将所有的双连通分量缩成点，这样就可以将整张图缩成一棵树。</p>
<p>这样的话，我们可以瞎搞出来一个结论，如下：</p>
<p>我们统计出来所有的叶子结点，记其数目为 $cnt$，我们最终要加的边数最少就是 $\lceil \dfrac{cnt}{2} \rceil$。</p>
<p>首先我们可以随便连接两个叶子结点，将其变为一个基环树。</p>
<p>我们可以证明，一定有一种连接方法，使得得到的基环树是有偶数条支链的。</p>
<p>如果我们得到的基环树有奇数条支链的话，我们可以进行一些转化：</p>
<p>假设当前有这样一个基环树：<br><del>（不如叫他<ruby>1-乙基-3-(1-甲基)乙基环己烷<rt>1-ethyl-3-(1-methyl)ethylcyclohexane</rt></ruby>）</del></p>
<img src="https://s2.loli.net/2022/06/21/8zeqAH9PdpEoUvC.png" alt="p2860-8.png" width="60%" />

<p>我们可以找到一条边，连接两个端点，而其中一个端点有支链。不妨设这个有支链的点为 $y$，另一个点为 $x$。</p>
<p>我们断开连接 $x$ 与 $y$ 的边，然后找到 $y$ 的一条支链最底端的叶子结点 $z$，最后连接 $x$ 与 $z$，减少了一条支链。</p>
<img src="https://s2.loli.net/2022/06/21/QtFkemasBWDjPMO.png" alt="p2860-1.png" width="60%" />

<p><del>（不如叫他<ruby>1,4-二乙基环辛烷<rt>1,4-diethylcyclohexane</rt></ruby>）</del></p>
<p>这样就可以变成只有偶数条支链了。</p>
<p>对于每一条支链的叶子结点，我们找到一个另外的叶子结点，使得他们的LCA在环上。这样就满足了我们“双联通分量”的要求。不懂的可以自己手画一下。</p>
<p>但是有些时候随机连接的方案不一定能让所有的LCA都在环上，比如这个：</p>
<img src="https://s2.loli.net/2022/06/21/8mlIyAtafpFT5dr.png" alt="p2860-2.png" width="60%" />

<p>这样连接就不可以：</p>
<img src="https://s2.loli.net/2022/06/21/NPgAT2fhJlLb41H.png" alt="p2860-3.png" width="60%" />

<p>这样连接就可以：</p>
<img src="https://s2.loli.net/2022/06/21/DJs9KV6TMCf41wG.png" alt="p2860-4.png" width="60%" />

<p>但是很不幸，上面的那种情况就是出现了。<br>现在我们考虑由其转移到一个可行的方案上面。</p>
<p>因为我们总共有偶数个叶子结点，所以我们最终还是会剩偶数个叶子结点没有配对。</p>
<p>我们可以通过不断对部分节点重新配对来缩小问题规模，直至解决问题。</p>
<p>我们先把不对劲的边断开：</p>
<img src="https://s2.loli.net/2022/06/21/NXe28OcVAY4JDqU.png" alt="p2860-5.png" width="60%" />

<p>然后找到已经配好对了的两个子节点，这里选取8和13；<br>断掉其间的边，然后分别找一个子树上的任意一个点连边；</p>
<img src="https://s2.loli.net/2022/06/21/bsOS24dDWPXuGBa.png" alt="p2860-6.png" width="60%" />

<p>然后我们的问题规模就缩小了2，剩下的点如法炮制即可。<br>如果最终只剩两个点，而且不在同一支链上的话就直接连边即可。</p>
<img src="https://s2.loli.net/2022/06/21/pEJU3FSLcOCKkuG.png" alt="p2860-7.png" width="60%" />

<p>最终我们可以得出，我们最少需要连接的边数是 $\lceil \dfrac{cnt}{2} \rceil$ 条。</p>
<p>然后就可以上代码了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> isBridge[M];</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], cnt;</span><br><span class="line"><span class="type">int</span> sta[N], tt;</span><br><span class="line"><span class="type">int</span> scc[N], sc, sz[N];</span><br><span class="line"><span class="type">int</span> deg[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> from)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    low[p] = dfn[p] = ++cnt;</span><br><span class="line">    sta[++tt] = p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(j, i);</span><br><span class="line">            low[p] = <span class="built_in">min</span>(low[p], low[j]);</span><br><span class="line">            <span class="keyword">if</span>(dfn[p] &lt; low[j])</span><br><span class="line">                isBridge[i] = isBridge[i ^ <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i != (from ^ <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            low[p] = <span class="built_in">min</span>(low[p], dfn[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[p] == low[p])</span><br><span class="line">    &#123;</span><br><span class="line">        ++sc;</span><br><span class="line">        <span class="keyword">while</span>(sta[tt] != p)</span><br><span class="line">        &#123;</span><br><span class="line">            scc[sta[tt]] = sc;</span><br><span class="line">            sz[sc]++;</span><br><span class="line">            tt--;</span><br><span class="line">        &#125;</span><br><span class="line">        scc[sta[tt]] = sc;</span><br><span class="line">        sz[sc]++;</span><br><span class="line">        tt--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++)</span><br><span class="line">        <span class="keyword">if</span>(isBridge[i])</span><br><span class="line">            deg[scc[e[i]]]++;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sc; i++)</span><br><span class="line">        <span class="keyword">if</span>(deg[i] == <span class="number">1</span>)cnt++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (cnt + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>图的连通性</tag>
      </tags>
  </entry>
  <entry>
    <title>P2824 [HEOI2016/TJOI2016] 排序 题解</title>
    <url>/solutions/solution-p2824/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">排序</div>
<div id="problem-info-from">HEOI 2016<br>TJOI 2016</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI4MjQ=">Luogu P2824</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yMDU1">LibreOJ L2055</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjkzMi8=">AcWing 2929</span></li></ul></div>

<hr>
<p>一看见排序我们就感觉开始复杂起来了，毕竟排序是一个复杂而又缓慢的过程。</p>
<p>我们来想简单一点的排序。</p>
<p>如果我们对一个排列进行升序或者降序排序应该很简单，就是将这个排列所包含的数进行正向或者反向输出即可。</p>
<p>假如我们每一次排列的时候都是对一个排列排序该多好啊。</p>
<p>可惜这样无法满足我们接下来的询问，毕竟这样对其没有任何影响，该得不出来还是得不出来。</p>
<p>那么如果我们对的是一个01序列排序呢？</p>
<p>也很简单，就把1全部放在一边，0放在另一边即可。</p>
<p>那这样有什么可以利用的性质呢？</p>
<p>我们可以设想，当我们把大于一个值的数字全部变成1，其余的变成0，再排序，询问的时候得到的就是当前位置比这个值大还是小。</p>
<p>然后我们发现，我们可以利用这个东西进行二分。</p>
<p>我们每一次指定一个值，按照上面的步骤得到询问的位置是0还是1，然后根据答案二分即可。</p>
<p>但是我们每一次还是需要进行枚举，时间仍然没有达到我们的要求。</p>
<p>既然是区间修改了，那么我们就可以使用——线段树！</p>
<p>每一次询问当前区间内有多少个1，然后根据上面的想法区间覆盖即可，而询问区间内1的个数可以使用维护区间和的方式来得出。</p>
<p>然后就显而易见了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> q;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum, tag;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].sum = tr[p &lt;&lt; <span class="number">1</span>].sum + tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[p], &amp;left = tr[p &lt;&lt; <span class="number">1</span>], &amp;rght = tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(root.tag != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        left.sum = (left.r - left.l + <span class="number">1</span>) * root.tag;</span><br><span class="line">        rght.sum = (rght.r - rght.l + <span class="number">1</span>) * root.tag;</span><br><span class="line">        left.tag = root.tag;</span><br><span class="line">        rght.tag = root.tag;</span><br><span class="line">        root.tag = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].l = l, tr[p].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].tag = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l == tr[p].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum = (a[tr[p].l] &gt;= k);</span><br><span class="line">        tr[p].tag = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>(p &lt;&lt; <span class="number">1</span>, k);</span><br><span class="line">    <span class="built_in">init</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, k);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">segchg</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum = (tr[p].r - tr[p].l + <span class="number">1</span>) * k;</span><br><span class="line">        tr[p].tag = k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)<span class="built_in">segchg</span>(p &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)<span class="built_in">segchg</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">segsum</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)<span class="keyword">return</span> tr[p].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res += <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)res += <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> op[N], L[N], R[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op[i], &amp;L[i], &amp;R[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">init</span>(<span class="number">1</span>, mid);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="built_in">segsum</span>(<span class="number">1</span>, L[i], R[i]);</span><br><span class="line">            <span class="keyword">if</span>(op[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">segchg</span>(<span class="number">1</span>, L[i], R[i] - cnt, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">segchg</span>(<span class="number">1</span>, R[i] - cnt + <span class="number">1</span>, R[i], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(op[i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">segchg</span>(<span class="number">1</span>, L[i], L[i] + cnt - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">segchg</span>(<span class="number">1</span>, L[i] + cnt, R[i], <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> pos = <span class="built_in">segsum</span>(<span class="number">1</span>, q, q);</span><br><span class="line">        <span class="keyword">if</span>(pos == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">            ans = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>P2906 [USACO08OPEN] Cow Neighborhoods 题解</title>
    <url>/solutions/solution-p2906/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">Cow Neighborhoods</div>
<div id="problem-info-from">USACO 2008 OPEN Gold</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDI5MDY=">Luogu P2906</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzE2MDQ=">BZOJ #1604</span></li></ul></div>

<hr>
<p>看到这一题的时候我感觉非常熟悉。<br>这不就是<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQwNDc=">[JSOI2010]部落划分</span>吗！<br>只不过这道题给定了奶牛之间的距离，并且是让求连通块的个数以及最大连通块的大小。</p>
<p>（可能只有我一个人觉得很类似罢）</p>
<p>然后做了一发，T了。</p>
<p>一看数据范围：$N \leq 10^5$。</p>
<p>秉承着“N方过百万，暴力碾标算”的精神，我认为是常数的问题加上复杂度跑满，于是就做了一些小小的优化：</p>
<p>首先，我将每一个坐标按照横坐标为第一关键字，纵坐标为第二关键字进行了一发排序。</p>
<p>因为我们不关心节点的编号，所以我们可以直接排序。</p>
<p>然后，我将原题中的曼哈顿距离转变为了切比雪夫距离，从而不让算法跑满。</p>
<p><img src="https://s2.loli.net/2022/06/07/VQ4sIFJ5MnOmfdW.jpg" alt="manhattan.jpg"></p>
<p>这是曼哈顿距离，其在 $k$ 维空间中的定义为：</p>
<p>$$<br>Dis(x,y) &#x3D; \sum_{i&#x3D;1}^k |x_i-y_i|<br>$$</p>
<p>放到二维平面里面就是 $Dis(u,v) &#x3D; |x_u-x_v|+|y_u-y_v|$。</p>
<p><img src="https://s2.loli.net/2022/06/07/pM4XwIRPrUaeiSW.jpg" alt="chebyshev.jpg"></p>
<p>这是切比雪夫距离，其在 $k$ 维空间中的定义为：</p>
<p>$$<br>Dis(x,y) &#x3D; \max_{i&#x3D;1}^k |x_i-y_i|<br>$$</p>
<p>放到二维平面里面就是 $Dis(u,v) &#x3D; \max(|x_u-x_v|,|y_u-y_v|)$。</p>
<p>如果我们将曼哈顿距离转化为了切比雪夫距离的话，就可以利用单调队列来取出 $[x-c,x+c]$ 的一段来，并在其中进行判断并连边即可，可以减小算法复杂度。</p>
<p>怎么转化呢？</p>
<p>我们考虑对于某一个点距离为定值的点构成的集合。<br>我们设这个点是原点 $(0,0)$，这个距离为 $c$。</p>
<p>当这个距离是曼哈顿距离的时候，我们这些点构成的集合就是一个倾斜了$45^{\circ}$的正方形，顶点分别为 $(0,c)$，$(c,0)$，$(0,-c)$，$(-c,0)$。</p>
<p>当这个距离是切比雪夫距离的时候，我们这些点构成的集合就是一个正方形，顶点分别为 $(c,c)$，$(c,-c)$，$(-c,-c)$，$(-c,c)$。</p>
<p>然后我们就可以发现，我们将曼哈顿距离下的这个正方形旋转$45^{\circ}$并扩大$\sqrt{2}$倍之后就是切比雪夫距离下的这个正方形。</p>
<p>对于一个点的情况下，我们将其坐标变为 $(x+y,x-y)$，可以达到同样的效果。</p>
<p>最后试了一发，T了。<br>看来N方还是过不了十万。</p>
<p>尝试减小连边的次数，我们可以尝试只连线性级别的边。</p>
<p>对于每一个点，我们只考虑与其左边的点连边。<br>同时，每一个点我们最多只连两条边，这在保证了联通性的前提下大幅度减少了连边的次数。</p>
<p>连哪两个点呢？</p>
<p>纵坐标与当前点最接近的两个即可。<br>其中一个在当前点上方，一个在当前点下方。</p>
<p>考虑正确性。</p>
<p>因为其他边都是冗余的，所以只连这两条边即可。</p>
<p>对于任意两者均可触及的点，两点向其连边之后得到的是一个三角形；<br>又因为当前点较靠后，所以我们可以断开当前点与其连结的边，这样也能保证连通性。</p>
<p>证毕。</p>
<p>然后就是考虑如何快速找到与当前点纵坐标最接近的两个点。</p>
<p>我们可以使用<code>set</code>来维护，使用<code>lower_bound()</code>来进行查找。</p>
<p>我们记录当前<code>set</code>维护的左端点，并尝试将其右移，直到左端点所对应的点与当前点的切比雪夫距离不超过 $c$。<br>然后就可以使用<code>lower_bound()</code>查找了，找到对应的节点之后连边即可。<br>最后要把当前节点加入<code>set</code>中。</p>
<p>交一发，过了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) f = -f; c = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="number">48</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll c;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node &amp;a) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x == a.x ? y &lt; a.y : x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>&lt;<span class="type">int</span>&gt;(), c = <span class="built_in">read</span>&lt;ll&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll x = <span class="built_in">read</span>&lt;ll&gt;(), y = <span class="built_in">read</span>&lt;ll&gt;();</span><br><span class="line">        a[i] = &#123; x + y,x - y &#125;;</span><br><span class="line">        p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    set&lt; pair&lt;ll, <span class="type">int</span>&gt; &gt;s;</span><br><span class="line">    set&lt; pair&lt;ll, <span class="type">int</span>&gt; &gt;::iterator it;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(a[<span class="number">1</span>].y, <span class="number">1</span>));</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>((<span class="number">1ll</span> &lt;&lt; <span class="number">60</span>), <span class="number">0</span>));</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>((<span class="number">-1ll</span> &lt;&lt; <span class="number">60</span>), <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, l = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(a[i].x - a[l].x &gt; c)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">erase</span>(<span class="built_in">make_pair</span>(a[l].y, l));</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        it = s.<span class="built_in">lower_bound</span>(<span class="built_in">make_pair</span>(a[i].y, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span>(it-&gt;first - a[i].y &lt;= c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = it-&gt;second;</span><br><span class="line">            <span class="type">int</span> pa = <span class="built_in">find</span>(i), pb = <span class="built_in">find</span>(j);</span><br><span class="line">            <span class="keyword">if</span>(pa != pb)p[pa] = pb;</span><br><span class="line">        &#125;</span><br><span class="line">        it--;</span><br><span class="line">        <span class="keyword">if</span>(a[i].y - it-&gt;first &lt;= c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = it-&gt;second;</span><br><span class="line">            <span class="type">int</span> pa = <span class="built_in">find</span>(i), pb = <span class="built_in">find</span>(j);</span><br><span class="line">            <span class="keyword">if</span>(pa != pb)p[pa] = pb;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(a[i].y, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, maxn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt += (<span class="built_in">find</span>(i) == i);</span><br><span class="line">        maxn = <span class="built_in">max</span>(maxn, ++sum[<span class="built_in">find</span>(i)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, cnt, maxn);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>STL</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>P3050 [USACO12MAR] Large Banner 题解</title>
    <url>/solutions/solution-p3050/</url>
    <content><![CDATA[<br>
<span id="more"></span>

<div id="problem-card-vis">true</div>
<div id="problem-info-name">Large Banner</div>
<div id="problem-info-from">USACO 2012 March Gold</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMwNTA=">Luogu P3050</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzI2MTk=">BZOJ #2619</span></li></ul></div>

<hr>
<p>机房大佬 <span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3VzZXIvMjYxNzcz">$\text{Y}{\color{Red}\text{ouwike}}$</span> 有一个 $O(n \log n)$ 的解法，但是祂不屑于写题解，就让我来帮他写了。</p>
<hr>
<p>首先我们考虑怎样才能让一个线段除了端点之外不经过整点。<br>这里我们不考虑位置，只考虑其形状。那就可以让线段的一个点在 $(0,0)$，另一个点在 $(i,j)$。<br>可以发现，当 $i$ 与 $j$ 互质，即 $\gcd(i,j) &#x3D; 1$ 的时候，该线段才不会经过整点。<br>那么这样的线段的个数如下：</p>
<p>$$<br>\sum_{i&#x3D;1}^n \sum_{j&#x3D;1}^m [\gcd(i,j)&#x3D;1]<br>$$</p>
<p>注意到我们线段的端点不一定需要在原点上，并且线段的方向也有两种，那么完整的式子如下：</p>
<p>$$<br>2 \sum_{i&#x3D;1}^n \sum_{j&#x3D;1}^m [\gcd(i,j)&#x3D;&#x3D;1] (n-i+1)(m-j+1)<br>$$</p>
<p>考虑莫比乌斯反演：</p>
<p>$$<br>2 \sum_{i&#x3D;1}^n \sum_{j&#x3D;1}^m \sum_{p|i,p|j} \mu(p) (n-i+1)(m-j+1)<br>$$</p>
<p>现在我们可以开始考虑线段长度的限制了。<br>这个限制我们直接加在 $j$ 上，让式子变成这个样子：</p>
<p>$$<br>2 \sum_{i&#x3D;1}^n \sum_{j&#x3D;\lceil \sqrt{l^2-i^2} \rceil}^{\lfloor \sqrt{h^2-i^2} \rfloor} \sum_{p|i,p|j} \mu(p) (n-i+1)(m-j+1)<br>$$</p>
<p>将带有 $p$ 的求和号拿到带有 $j$ 的求和号的前面，并将枚举 $j$ 改为枚举 $\frac{j}{p}$：</p>
<p>$$<br>2 \sum_{i&#x3D;1}^n \sum_{p|i} \mu(p) \sum_{j&#x3D;\lceil \frac{\sqrt{l^2-i^2}}{p} \rceil}^{\lfloor \frac{\sqrt{h^2-i^2}}{p} \rfloor} (n-i+1)(m-jp+1)<br>$$</p>
<p>将最后的多项式拆开：</p>
<p>$$<br>2 \sum_{i&#x3D;1}^n \sum_{p|i} \mu(p) \sum_{j&#x3D;\lceil \frac{\sqrt{l^2-i^2}}{p} \rceil}^{\lfloor \frac{\sqrt{h^2-i^2}}{p} \rfloor} (n-i+1)(m+1)-(n-i+1)jp<br>$$</p>
<p>将其拆成两个式子。<br>第一个式子如下：</p>
<p>$$<br>2 \sum_{i&#x3D;1}^n \sum_{p|i} \mu(p) \sum_{j&#x3D;\lceil \frac{\sqrt{l^2-i^2}}{p} \rceil}^{\lfloor \frac{\sqrt{h^2-i^2}}{p} \rfloor} (n-i+1)(m+1)<br>$$</p>
<p>发现带有 $j$ 的求和号的后面那一部分与 $j$ 无关，将其提出来：</p>
<p>$$<br>\begin{align}<br>&amp; 2 \sum_{i&#x3D;1}^n \sum_{p|i} \mu(p) (n-i+1)(m+1) \sum_{j&#x3D;\lceil \frac{\sqrt{l^2-i^2}}{p} \rceil}^{\lfloor \frac{\sqrt{h^2-i^2}}{p} \rfloor} 1  \\<br>&#x3D;&amp; 2 \sum_{i&#x3D;1}^n \sum_{p|i} \mu(p) (n-i+1)(m+1)(\lfloor \frac{\sqrt{h^2-i^2}}{p} \rfloor - \lceil \frac{\sqrt{l^2-i^2}}{p} \rceil+1)<br>\end{align}<br>$$</p>
<p>第二个式子如下：</p>
<p>$$<br>\begin{align}<br>&amp; 2 \sum_{i&#x3D;1}^n \sum_{p|i} \mu(p) \sum_{j&#x3D;\lceil \frac{\sqrt{l^2-i^2}}{p} \rceil}^{\lfloor \frac{\sqrt{h^2-i^2}}{p} \rfloor} (n-i+1)jp \\<br>&#x3D;&amp; 2 \sum_{i&#x3D;1}^n \sum_{p|i} \mu(p) p (n-i+1) \sum_{j&#x3D;\lceil \frac{\sqrt{l^2-i^2}}{p} \rceil}^{\lfloor \frac{\sqrt{h^2-i^2}}{p} \rfloor} j<br>\end{align}<br>$$</p>
<p>而最后一个求和号可以用等差数列求和公式来做。</p>
<p>同时注意一个边界条件：当线段长度为 $1$ 的时候，相邻两个点之间连的边也是可以的，需要特判来进行修正。</p>
<hr>
<p>我们在预处理莫比乌斯函数的时候就是 $O(n \log n)$ 的时间复杂度，而枚举的时候只枚举了一个 $i$ 和 $i$ 的所有约数，枚举约数的时间复杂度是单个 $O(\log n)$ 的，总体来说也是 $O(n \log n)$。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> mu[N], prime[N], vis[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; d[N];</span><br><span class="line"><span class="type">int</span> n, m, mod;</span><br><span class="line"><span class="type">int</span> l, h;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">moebius</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) prime[++prime[<span class="number">0</span>]] = i, mu[i] = mod - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= prime[<span class="number">0</span>] &amp;&amp; i * prime[j] &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mu[i * prime[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i * prime[j]] = mod - mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="number">1ll</span> * (<span class="number">1</span> + n) * n) &gt;&gt; <span class="number">1</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> lim = <span class="built_in">min</span>(m, (<span class="type">int</span>)<span class="built_in">sqrt</span>(<span class="number">1ll</span> * h * h - <span class="number">1ll</span> * i * i));</span><br><span class="line">        <span class="type">int</span> lim2 = <span class="built_in">max</span>(<span class="number">1</span>, (<span class="type">int</span>)<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(<span class="number">1ll</span> * l * l - <span class="number">1ll</span> * i * i)));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p : d[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(lim / p &gt;= (lim2 - <span class="number">1</span>) / p + <span class="number">1</span>)</span><br><span class="line">                ans = (ans + <span class="number">1ll</span> * (n - i + <span class="number">1</span>) * (m + <span class="number">1</span>) % mod * mu[p] % mod * ((lim / p) - ((lim2 - <span class="number">1</span>) / p + <span class="number">1</span>) + <span class="number">1</span>) % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> lim = <span class="built_in">min</span>(m, (<span class="type">int</span>)<span class="built_in">sqrt</span>(<span class="number">1ll</span> * h * h - <span class="number">1ll</span> * i * i));</span><br><span class="line">        <span class="type">int</span> lim2 = <span class="built_in">max</span>(<span class="number">1</span>, (<span class="type">int</span>)<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(<span class="number">1ll</span> * l * l - <span class="number">1ll</span> * i * i)));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p : d[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(lim / p &gt;= (lim2 - <span class="number">1</span>) / p + <span class="number">1</span>)</span><br><span class="line">                ans = (ans + mod - <span class="number">1ll</span> * (n - i + <span class="number">1</span>) * p % mod * mu[p] % mod * (<span class="built_in">sum</span>(lim / p) + mod - <span class="built_in">sum</span>(((lim2 - <span class="number">1</span>) / p + <span class="number">1</span>) - <span class="number">1</span>)) % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans + ans) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;mod);</span><br><span class="line">    <span class="built_in">moebius</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= n; j += i)</span><br><span class="line">            d[j].<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="number">1</span>)</span><br><span class="line">        ans = (ans + (<span class="number">1ll</span> * n * (m + <span class="number">1</span>) % mod + <span class="number">1ll</span> * (n + <span class="number">1</span>) * m % mod) % mod) % mod;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>P3188 [HNOI2007] 梦幻岛宝珠 题解</title>
    <url>/solutions/solution-p3188/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">梦幻岛宝珠</div>
<div id="problem-info-from">HNOI 2007</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMxODg=">Luogu P3188</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjE0OS8=">AcWing 2147</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzExOTA=">BZOJ #1190</span></li></ul></div>

<hr>
<p>题目很明显是一个背包问题，但是其背包容量很大，是 $10^{10}$ 级别的。<br>这样明显不是普通背包算法可以应付得来的，但我们又不能不用背包来解决。<br>一定有什么地方可以优化。</p>
<p>我们观察题目给的条件，发现题目保证 $\sum n \leq 2000$，且每一个物品的重量都可以拆分为 $a \times 2^b$ 的形式，其中 $a \leq 10,b \leq 30$。</p>
<p>这样我们就可以将每一个物品按照 $b$ 来分组，对于每一个组内我们跑一个背包，然后再把这些组再跑一个背包就可以了。</p>
<p>对于每一组内跑背包的时候，我们背包的容量就是当前这一组内物品个数的十倍，因为所有的 $a$ 都不超过10，所以 $\sum a$ 肯定也是小于当前组内物品个数10倍的。</p>
<p>做组间背包的时候，我们从低位到高位做。<br>我们想，每一次我们都从当前位的容量内拿出来 $k$ 去给下面的部分做背包。对于剩余的容量做完背包之后，我们就将下面对容量为 $k$ 的背包做出来的结果直接加上来即可。</p>
<p>具体实现的时候，我们定义两个二维数组 $f$ 和 $g$。</p>
<p>$f[i][k]$ 代表的是对从低到高第 $i$ 位（或者说 $b&#x3D;i$）的物品进行容量为 $k$ 的背包得出的结果。</p>
<p>求 $f$ 数组的时候我们就直接按照正常背包做就可以了。</p>
<p>而 $g[i][j]$ 代表的就是当使用 $b$ 为 $i$ 的物品进行容量为 $j$ 的背包时，$b$ 小于 $i$ 的所有物品占满了 $W$ 的后 $i$ 位所代表的容量的值。</p>
<p>举个例子，我们最后要输出的结果就是 $g[\lfloor \log_2{W} \rfloor][1]$ 的值。而这个代表我们对最高位上做背包时，背包容量为1（也只能是1），同时除了最高位以外的所有位代表的容量都被占满了的时候的最大值。</p>
<p>而在更新 $g$ 数组的时候，我们遵循下面的转移方程：</p>
<p>$$<br>g[i][j] &#x3D; \max(g[i][j],f[i][j-k]+g[i-1][\min(10n,2k+(\frac{W}{2^{i-1}} \&amp; 1))])<br>$$</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>, M = <span class="number">40</span>;</span><br><span class="line"><span class="type">int</span> n, c;</span><br><span class="line"><span class="type">int</span> w[N], v[N];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;h[M];</span><br><span class="line"><span class="type">int</span> f[M][N * M];</span><br><span class="line"><span class="type">int</span> g[M][N * M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(w, <span class="number">0</span>, <span class="built_in">sizeof</span>(w));</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="built_in">sizeof</span>(g));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++)h[i].<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;c);</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">-1</span> &amp;&amp; c != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;w[i], &amp;v[i]);</span><br><span class="line">            <span class="type">int</span> b = <span class="built_in">log2</span>(<span class="built_in">lowbit</span>(w[i]));</span><br><span class="line">            h[b].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(w[i] &gt;&gt; b, v[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="built_in">log2</span>(c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt;= cnt; t++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; h[t].<span class="built_in">size</span>(); i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">10</span> * h[t].<span class="built_in">size</span>(); j &gt;= h[t][i].first; j--)</span><br><span class="line">                    f[t][j] = <span class="built_in">max</span>(f[t][j], f[t][j - h[t][i].first] + h[t][i].second);</span><br><span class="line">        <span class="comment">//给每一组内跑背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span> * h[<span class="number">0</span>].<span class="built_in">size</span>(); i++)</span><br><span class="line">            g[<span class="number">0</span>][i] = f[<span class="number">0</span>][i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">1</span>; t &lt;= cnt; t++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">10</span> * n; j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= j; i++)</span><br><span class="line">                    g[t][j] = <span class="built_in">max</span>(g[t][j], f[t][j - i] + g[t - <span class="number">1</span>][<span class="built_in">min</span>(<span class="number">10</span> * n, i * <span class="number">2</span> + ((c &gt;&gt; (t - <span class="number">1</span>)) &amp; <span class="number">1</span>))]);</span><br><span class="line">        <span class="comment">//跑组与组之间的背包</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, g[cnt][<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>P3243 [HNOI2015] 菜肴制作 题解</title>
    <url>/solutions/solution-p3243/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">菜肴制作</div>
<div id="problem-info-from">HNOI2015</div>
<div id="problem-info-difficulty">普及+ /提高</div>
<div id="problem-info-color">#52c413</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMyNDM=">Luogu P3243</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yMTE0">LibreOJ L2114</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjIyNi8=">AcWing 2224</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzQwMTA=">BZOJ #4010</span></li></ul></div>

<hr>
<p>这里我们需要注意一下题目的要求。<br>我们不能直接求出来字典序最小的序列，因为题目要求的是：</p>
<blockquote>
<ol>
<li>在满足所有限制条件下，1号菜肴优先制作。</li>
<li>在满足上述条件下，2号菜肴优先制作。</li>
<li>在满足上述条件下，3号菜肴优先制作。</li>
<li>以此类推……</li>
</ol>
</blockquote>
<p>我们可以想到，对于这种比较方式，我们可以通过贪心地让最后的数最大来达到要求。<br>假设这个数为 $x$，其可以让所有小于 $x$ 的数尽量靠前，同时因为 $x$ 的位置固定了，那些大于 $x$ 的数也就没有比较的需求了。<br>因此我们可以将其转化为其反串的字典序最大。</p>
<p>对于这一些关系，我们可以将时间的流向反过来，同时将关系的内容变成“菜肴 $i$ 必须后于菜肴 $j$ 制作”的形式。<br>之后我们可以将这种关系看做一些单向边，然后建立其反图，跑一遍拓扑排序就可以了。<br>因为我们还需要字典序最大，所以我们采用堆而不是队列来存储数据，每一次贪心地从堆顶拿出元素放到答案序列的尾部即可。</p>
<p>然后就是关于特判无解的情况。<br>无解只有一种情况：图中出现了环。自环也算。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>, M = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> deg[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="type">int</span> ans[N], tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="type">bool</span> isValid = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="keyword">if</span>(u == v)isValid = <span class="literal">true</span>;</span><br><span class="line">        deg[u]++;</span><br><span class="line">        <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isValid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Impossible!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!deg[i])q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        ans[++tot] = u;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">            <span class="keyword">if</span>(!(--deg[e[i]]))q.<span class="built_in">push</span>(e[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tot &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Impossible!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i; i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(deg, <span class="number">0</span>, <span class="built_in">sizeof</span>(deg));</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>贪心</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>P3462 [POI2007] 砝码 ODW 题解</title>
    <url>/solutions/solution-p3462/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">砝码ODW</div>
<div id="problem-info-from">POI 2007</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM0NjI=">Luogu P3462</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yNjYw">LibreOJ L2660</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzY5My8=">AcWing 3690</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzExMTA=">BZOJ #1110</span></li></ul></div>

<hr>
<p>这道题要求我们将一堆砝码放进一堆容器里面，要求每个容器里面砝码的总重量不超过容器的容量。题目要求我们求出并最大化能装进容器内砝码数量。</p>
<p>首先我们可以确定一点，我们从最小的砝码开始装，一定是较优的。</p>
<p>但是题目给出的砝码总数和容器总数都是 $10^5$ 级别的，我们不能每一个砝码都搜一遍，不仅复杂度不对，还保证不了正确性。</p>
<p>但是，题目保证任何两个砝码，其中一个的重量必须是另一个的整数倍。<br>所以说，对于每一个砝码，剩余的砝码中一部分是它的整数倍，而剩余的能整除它。</p>
<p>这样我们就可以把这个转化为类似进制的东西，只不过不是严格的每两位之比相同的那种情况。</p>
<p>我们只需要找到最小的那个砝码，这就是我们进制的基数，我们设这个数为 $k_1$。<br>然后我们找到每一种不同的砝码重量，我们将其化为一个进制位。我们设这样的从小到大分别是 $k_2,k_3,k_4,\cdots$。</p>
<p>根据这一堆基数 $k$，我们将所有的容器拆成 $(a_0,a_1k_1,a_2k_2,a_3k_3,\cdots)$ 这样的形式。<br>因为我们所有的砝码都是 $k$ 的整数倍，所以这个 $a_0$ 就直接舍弃不要。剩下的同意一下所有容器中 $a_i$ 的和就可以了。</p>
<p>我们拆成这样的类 $k$ 进制了之后就不需要考虑装不下或者砝码跨容器的情况了。原因如下：</p>
<p>我们首先将所有的砝码从小到大排序。</p>
<p>然后我们从小到大放进DFS里面搜一下。<br>如果当前位还有剩余，就可以直接减掉。<br>如果没有剩余了，那就往上面搜，从前面的位借。若果借到最高位都借不到的话就输出当前砝码数量就可以了。<br>因为我们每一个砝码的重量一定对应一个进制位，我们就一定只需要在当前进制位为空的时候才会向上面借位，且我们不会向上进位，这样保证了我们不会让一个砝码利用两个不同容器的空间的情况。</p>
<p>这样我们就能在 $O(n\log{m})$ 的时间复杂度内解决这道题了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], b[N], num[N];</span><br><span class="line"><span class="type">int</span> c[<span class="number">40</span>], cnt[<span class="number">40</span>], tot;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p &gt; tot)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(cnt[p])</span><br><span class="line">    &#123;</span><br><span class="line">        cnt[p]--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">dfs</span>(p + <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cnt[p] += c[p + <span class="number">1</span>] / c[p];</span><br><span class="line">        cnt[p]--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">    <span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i] != b[i - <span class="number">1</span>])c[++tot] = b[i];</span><br><span class="line">        num[i] = tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = tot; j; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt[j] += a[i] / c[j];</span><br><span class="line">            a[i] %= c[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">dfs</span>(num[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == m)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>P3574 [POI2014] FAR-FarmCraft 题解</title>
    <url>/solutions/solution-p3574/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">FarmCraft</div>
<div id="problem-info-from">POI 2014</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM1NzQ=">Luogu P3574</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzM4Mjk=">BZOJ #3829</span></li></ul></div>

<hr>
<p>题目需要我们从一号节点开始遍历整棵树，并给每一个节点记录下遍历到其的时间。<br>同时每一个节点又有一个自己的倒计时，当遍历到其的时候就开始计时。<br>我们需要求出所有节点中倒计时结束最慢的那一个的结束时间，并最小化之。</p>
<p>我们不难想象出一个简单的DP式子来求得最终的答案：</p>
<p>对于节点 $u$ 的子树 $v$，我们有如下的DP式子：</p>
<center>$\operatorname{dp}[u]=\max(\operatorname{dp}[u],\operatorname{dp}[v]+\operatorname{sz}[u]+1)$</center>

<p>其中 $\operatorname{dp}[u]$ 代表当前子树中最大的答案；<br>$\operatorname{sz}[u]$ 代表遍历过 $v$ 所在的子树之前已经经过的所有子树的大小之和再乘以2，这个在遍历完毕整个子树之后会更新为该子树的大小乘以2。</p>
<p>我们可以发现，我们最终的答案跟遍历子树的顺序有关，于是我们考虑对其进行排序。</p>
<p>对于一个节点 $x$ 的两个子树 $y$ 和 $z$，我们假设先遍历 $y$ 再遍历 $z$。<br>这样的话，我们的答案就是 $\max(\operatorname{dp}[y]+\operatorname{sz}[u]+1,\operatorname{dp}[z]+\operatorname{sz}[u]+\operatorname{sz}[y]+2+1)$。<br>我们假定这个方案比交换两个子树的遍历顺序得到的答案更优。<br>交换两个子树的遍历顺序之后得到的答案就是 $\max(\operatorname{dp}[z]+\operatorname{sz}[u]+1,\operatorname{dp}[y]+\operatorname{sz}[u]+\operatorname{sz}[z]+2+1)$。</p>
<p>我们最终得到如下式子：</p>
<center>$\max(\operatorname{dp}[y]+\operatorname{sz}[u]+1,\operatorname{dp}[z]+\operatorname{sz}[u]+\operatorname{sz}[y]+2+1) > \max(\operatorname{dp}[z]+\operatorname{sz}[u]+1,\operatorname{dp}[y]+\operatorname{sz}[u]+\operatorname{sz}[z]+2+1)$</center>

<p>我们将不等式左右两边同时约掉 $\operatorname{sz}[u]+1$，得到</p>
<center>$\max(\operatorname{dp}[y],\operatorname{dp}[z]+\operatorname{sz}[y]+2) > \max(\operatorname{dp}[z],\operatorname{dp}[y]+\operatorname{sz}[z]+2)$</center>

<p>因为 $\operatorname{dp}[y] &lt; \operatorname{dp}[y]+\operatorname{sz}[z]+2$，$\operatorname{dp}[z] &lt; \operatorname{dp}[z]+\operatorname{sz}[y]+2$，所以一定是 $\operatorname{dp}[y]+\operatorname{sz}[z]+2$ 与 $\operatorname{dp}[z]+\operatorname{sz}[y]+2$ 之间的差值导致了答案的变化。</p>
<p>因此，我们可以得到</p>
<center>$\operatorname{dp}[y]-\operatorname{sz}[y] < \operatorname{dp}[z]-\operatorname{sz}[z]$</center>

<p>然后我们就可以按照这样的方法排序了。</p>
<p>参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>)f = <span class="number">-1</span>; c = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))x = x * <span class="number">10</span> + (c ^ <span class="number">48</span>), c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N];</span><br><span class="line"><span class="type">int</span> val[N];</span><br><span class="line"><span class="type">int</span> f[N], sz[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a, <span class="type">const</span> <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sz[a] - f[a] &lt; sz[b] - f[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="number">1</span>)f[p] = val[p];</span><br><span class="line">    <span class="keyword">if</span>(e[p].<span class="built_in">empty</span>())<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : e[p])</span><br><span class="line">        <span class="keyword">if</span>(i != fa)<span class="built_in">dfs</span>(i, p);</span><br><span class="line">    <span class="built_in">sort</span>(e[p].<span class="built_in">begin</span>(), e[p].<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : e[p])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == fa)<span class="keyword">continue</span>;</span><br><span class="line">        f[p] = <span class="built_in">max</span>(f[p], f[i] + sz[p] + <span class="number">1</span>);</span><br><span class="line">        sz[p] += sz[i] + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        val[i] = <span class="built_in">read</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">read</span>&lt;<span class="type">int</span>&gt;(), v = <span class="built_in">read</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        e[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">max</span>(f[<span class="number">1</span>], sz[<span class="number">1</span>] + val[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>贪心</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P3586 [POI2015] Logistyka 题解</title>
    <url>/solutions/solution-p3586/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">Logistyka</div>
<div id="problem-info-from">POI 2015</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM1ODY=">Luogu P3586</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzQzNzg=">BZOJ #4378</span></li></ul></div>

<hr>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这道题想让我们维护一个数列，支持对其的修改与询问。</p>
<p>题目给出了两种操作：</p>
<ol>
<li><code>U k a</code> 将序列中第 $k$ 个数修改为 $a$。</li>
<li><code>Z c s</code> 在这个序列上，每次选出 $c$ 个正数，并将它们都减去 $1$，询问能否进行 $s$ 次操作。</li>
</ol>
<p>回答询问的思路是这个样子的：</p>
<p>我们假设在这个数列里面，$( 0,s )$ 范围内的数有 $x$ 个，$[ s, \infty )$ 范围内的数有 $y$ 个。</p>
<p>如果 $x+y &lt; c$ 的话就绝对不行，直接返回 <code>NIE</code>。</p>
<p>我们贪一下心，反正题目询问的是可行性，不如就先让着 $y$ 个数先顶上。</p>
<p>如果这 $y$ 个数都顶上去之后就可以完成任务，甚至还有些富余，就可以直接返回 <code>TAK</code>。<br>而如果 $y &lt; c$，那么我们就需要继续往下讨论。</p>
<p>我们考虑让剩下的数顶上去。</p>
<p>如果这些数字的和小于 $s \times c$，那就绝对完不成任务。<br>反之则一定完得成任务。</p>
<p>QED.</p>
<hr>
<p>所以，我们需要维护两个信息，一是大于某个数的数有多少个，二是大于某个数的所有数之和。</p>
<p>我们可以使用树状数组。</p>
<p>但是我不会，所以就用动态开点权值线段树了。</p>
<p>我们考虑结构体里面存什么：</p>
<p>首先我们需要存区间左右端点（按个人情况）和左右儿子。<br>我们还需要维护区间内数的个数。</p>
<p>为了不多写数据结构，我也将第二个要求写进了线段树里面。</p>
<p>于是我的结构体长的是这个样子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> ls, rs;</span><br><span class="line">    ll sum;</span><br><span class="line">    ll tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>sum</code> 维护的是当前区间内数的个数，<code>tot</code> 维护的是当前区间内所有数的和。两者同时维护，但是查询的时候是分开的。</p>
<p>线段树部分代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> ls, rs;</span><br><span class="line">    ll sum;</span><br><span class="line">    ll tot;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">segadd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pos, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l == tr[p].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum += k;</span><br><span class="line">        tr[p].tot = tr[p].sum * tr[p].l;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[p].ls)</span><br><span class="line">        &#123;</span><br><span class="line">            tr[p].ls = ++idx;</span><br><span class="line">            tr[tr[p].ls].l = tr[p].l;</span><br><span class="line">            tr[tr[p].ls].r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">segadd</span>(tr[p].ls, pos, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pos &gt; mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[p].rs)</span><br><span class="line">        &#123;</span><br><span class="line">            tr[p].rs = ++idx;</span><br><span class="line">            tr[tr[p].rs].l = mid + <span class="number">1</span>;</span><br><span class="line">            tr[tr[p].rs].r = tr[p].r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">segadd</span>(tr[p].rs, pos, k);</span><br><span class="line">    &#125;</span><br><span class="line">    tr[p].sum = tr[tr[p].ls].sum + tr[tr[p].rs].sum;</span><br><span class="line">    tr[p].tot = tr[tr[p].ls].tot + tr[tr[p].rs].tot;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">segsum</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//求区间内数的个数</span></span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)<span class="keyword">return</span> tr[p].sum;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res += <span class="built_in">segsum</span>(tr[p].ls, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)res += <span class="built_in">segsum</span>(tr[p].rs, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">segtot</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//求区间内所有数的和</span></span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)<span class="keyword">return</span> tr[p].tot;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res += <span class="built_in">segtot</span>(tr[p].ls, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)res += <span class="built_in">segtot</span>(tr[p].rs, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>（需要O2）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> ls, rs;</span><br><span class="line">    ll sum;</span><br><span class="line">    ll tot;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">segadd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pos, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l == tr[p].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum += k;</span><br><span class="line">        tr[p].tot = tr[p].sum * tr[p].l;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[p].ls)</span><br><span class="line">        &#123;</span><br><span class="line">            tr[p].ls = ++idx;</span><br><span class="line">            tr[tr[p].ls].l = tr[p].l;</span><br><span class="line">            tr[tr[p].ls].r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">segadd</span>(tr[p].ls, pos, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pos &gt; mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[p].rs)</span><br><span class="line">        &#123;</span><br><span class="line">            tr[p].rs = ++idx;</span><br><span class="line">            tr[tr[p].rs].l = mid + <span class="number">1</span>;</span><br><span class="line">            tr[tr[p].rs].r = tr[p].r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">segadd</span>(tr[p].rs, pos, k);</span><br><span class="line">    &#125;</span><br><span class="line">    tr[p].sum = tr[tr[p].ls].sum + tr[tr[p].rs].sum;</span><br><span class="line">    tr[p].tot = tr[tr[p].ls].tot + tr[tr[p].rs].tot;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">segsum</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)<span class="keyword">return</span> tr[p].sum;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res += <span class="built_in">segsum</span>(tr[p].ls, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)res += <span class="built_in">segsum</span>(tr[p].rs, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">segtot</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)<span class="keyword">return</span> tr[p].tot;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res += <span class="built_in">segtot</span>(tr[p].ls, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)res += <span class="built_in">segtot</span>(tr[p].rs, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="type">int</span> maxn = <span class="number">0</span>;</span><br><span class="line">    tr[++idx] = &#123; <span class="number">0</span>,<span class="number">100000001</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        string op;</span><br><span class="line">        <span class="type">int</span> x, k;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;k);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;U&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">segadd</span>(<span class="number">1</span>, k, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[x] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">segadd</span>(<span class="number">1</span>, a[x], <span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            a[x] = k;</span><br><span class="line">            maxn = <span class="built_in">max</span>(maxn, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ll pos = <span class="built_in">segsum</span>(<span class="number">1</span>, <span class="number">1</span>, maxn), cnt = <span class="built_in">segsum</span>(<span class="number">1</span>, <span class="number">1</span>, k);</span><br><span class="line">            <span class="keyword">if</span>(pos &lt; x)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;NIE&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pos - cnt &gt;= x)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;TAK&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ll tot = <span class="built_in">segtot</span>(<span class="number">1</span>, <span class="number">1</span>, k);</span><br><span class="line">            <span class="keyword">if</span>(tot &gt;= (x + cnt - pos) * k)</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;TAK&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;NIE&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P3589 [POI2015] Kurs szybkiego czytania 题解</title>
    <url>/solutions/solution-p3589/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">Kurs szybkiego czytania</div>
<div id="problem-info-from">POI 2015</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM1ODk=">Luogu P3589</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzQzNzc=">BZOJ #4377</span></li></ul></div>

<hr>
<p>假设小串在大串中的某一个位置匹配上了，这时小串的开头是 $x$，那么小串的每一位都对应一个不等关系：</p>
<p>$$<br>\begin{cases}<br>a(i+x)+b \bmod{n} \in [0,p-1] &amp; s_i &#x3D; 0 \\<br>a(i+x)+b \bmod{n} \in [p,n-1] &amp; s_i &#x3D; 1<br>\end{cases}<br>$$</p>
<p>我们可以观察到，其中 $ai+b$ 这一部分对于每一个位置是固定的，我们将其提出来，并定义 $B &#x3D; ai+b$。<br>化简后的式子如下：</p>
<p>$$<br>\begin{cases}<br>ax+B \bmod{n} \in [0,p-1] &amp; s_i &#x3D; 0 \\<br>ax+B \bmod{n} \in [p,n-1] &amp; s_i &#x3D; 1<br>\end{cases}<br>$$</p>
<p>将 $x$ 在模意义下拆成 $a’x’$，其中 $a’$ 为 $a’$ 在模意义下的乘法逆元。<br>化简后的式子如下：</p>
<p>$$<br>\begin{cases}<br>x’+B \bmod{n} \in [0,p-1] &amp; s_i &#x3D; 0 \\<br>x’+B \bmod{n} \in [p,n-1] &amp; s_i &#x3D; 1<br>\end{cases}<br>$$</p>
<p>我们还可以知道，因为 $a$ 与 $n$ 互质，所以每一个 $x’$ 都与 $x$ 一一对应，形成了一组双射关系，所以我们只需要求出 $x’$ 的所有可能取值的个数即可。<br>而 $x’$ 的取值范围也一目了然。</p>
<p>对于一个式子，我们有两种可能取值：<br>（这里用 $s_i &#x3D; 1$ 来示范）</p>
<p>$$<br>\begin{cases}<br>x’ \in [p-B,n-1-B] \\<br>x’ \in [n-i-B,n-1] \cup [0,p-B+n]<br>\end{cases}<br>$$</p>
<p>这样的取值就像是数轴上的一些线段，而我们需要取的就是这些线段的交。<br>快速取线段交我们不会，但是我们可以将其转化成为其补集的并集的补集来计算。</p>
<p>同时还需要注意照顾到不合理的取值（$x \in [n-m+1,n-1]$），计算的时候需要将其剔除。</p>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>, M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a, b, p;</span><br><span class="line"><span class="type">int</span> l[N], r[N];</span><br><span class="line"><span class="type">int</span> pr[N];</span><br><span class="line"><span class="type">int</span> d[M], cnt;</span><br><span class="line"><span class="type">int</span> c[M];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;dic;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>, &amp;n, &amp;a, &amp;b, &amp;p, &amp;m);</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> B = (<span class="number">1ll</span> * i * a + b) % n;</span><br><span class="line">        <span class="keyword">if</span>(s[i - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            l[i] = p - B - <span class="number">1</span>;</span><br><span class="line">            r[i] = n - B - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(l[i] &lt; <span class="number">0</span>)l[i] += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            l[i] = n - B - <span class="number">1</span>;</span><br><span class="line">            r[i] = p - B - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(r[i] &lt; <span class="number">0</span>)r[i] += n;</span><br><span class="line">        &#125;</span><br><span class="line">        d[++cnt] = l[i], d[++cnt] = r[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n - m + <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)pr[n - i] = (<span class="number">1ll</span> * a * i) % n;</span><br><span class="line">    <span class="built_in">sort</span>(d + <span class="number">1</span>, d + <span class="number">1</span> + cnt);</span><br><span class="line">    <span class="built_in">sort</span>(pr + <span class="number">1</span>, pr + m);</span><br><span class="line">    cnt = <span class="built_in">unique</span>(d + <span class="number">1</span>, d + <span class="number">1</span> + cnt) - d - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(d[cnt] != n - <span class="number">1</span>)d[++cnt] = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">        dic.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(d[i], i));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c[dic[l[i]]]--;</span><br><span class="line">        c[dic[r[i]]]++;</span><br><span class="line">        <span class="keyword">if</span>(l[i] &gt; r[i])c[cnt]++;</span><br><span class="line">    &#125;</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = cnt, r = m - <span class="number">1</span>; i; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += c[i + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> l = r;</span><br><span class="line">        <span class="keyword">while</span>(l &amp;&amp; pr[l] &gt; d[i - <span class="number">1</span>])l--;</span><br><span class="line">        <span class="keyword">if</span>(c[i] == m)ans += d[i] - d[i - <span class="number">1</span>] - r + l;</span><br><span class="line">        r = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码需要 $O(2)$。</p>
<p>思路是听 <span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3VzZXIvMjYxNzcz">$\text{Y}{\color{Red}\text{ouwike}}$</span> 大佬的讲解才弄懂的，大家快去模%%%</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>P3644 [APIO2015] 巴邻旁之桥 题解</title>
    <url>/solutions/solution-p3644/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">巴邻旁之桥</div>
<div id="problem-info-from">APIO 2015</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM2NDQ=">Luogu P3644</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yODg4">LibreOJ L2888</span></li><li><span class="exturl" data-url="aHR0cHM6Ly91b2ouYWMvcHJvYmxlbS8xMTI=">UOJ #112</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzQwNzE=">BZOJ #4071</span></li></ul></div>

<hr>
<p>题目大意：</p>
<p>现在有一条河，将巴邻旁市分成了 $A$、$B$ 两个区域。<br>河的两岸均有 $10^9+1$ 栋房子。每一栋房子均有其编号，从 $A_1,B_1$ 一直到 $A_{10^9+1},B_{10^9+1}$。其中，编号为 $A_i$ 的房子与编号与 $B_i$ 的房子正好隔河相望。<br>相邻两栋房子之间的距离为 $1$。这包括类似 $A_i,A_{i+1}$ 的情况，也包括 $A_i,B_i$ 的情况。</p>
<p>现在有 $n$ 条通勤线路，有一些是需要跨河才能到达的。<br>以前人们都坐船，但是现在政府决定建造 $k$ 座大桥来帮助市民进行日常的通勤，使得所有人都可以（且必须）开车来通勤。</p>
<p>现在政府交给了你这 $n$ 条通勤线路和桥梁的个数 $k$，要求你最小化所有人通勤所需要的时间之和。</p>
<p>所有的桥梁必须垂直于河流。</p>
<hr>
<p>首先猛地一看可能没有什么太大的思路，总觉得是个贪心，或者是个结论题。</p>
<p>然后看一眼数据范围：</p>
<p>$1 \leq K \leq 2$<br>$1 \leq N \leq 10^5$</p>
<p>那就简单多了。</p>
<p>我们可以分类讨论：</p>
<h1 id="K-x3D-1"><a href="#K-x3D-1" class="headerlink" title="$K&#x3D;1$"></a>$K&#x3D;1$</h1><p>首先我们需要忽略所有不跨河的人。<br>这个在输入的时候就直接统计入答案了。</p>
<p>当我们只有一座桥的时候，就意味着<strong>所有人都必须通过这座桥。</strong></p>
<p>那么我们就可以将这些所有的路线拆成三部分：在A岸的、在桥上的和在B岸的。<br>而且因为桥是垂直于河流的，那么我们完全可以把在B岸的和在A岸的放在一起统计。</p>
<p>那么我们的问题就可以转化为，找一个点，使得所有的点到这个点的距离之和最小。</p>
<p>容易得出我们需要求的就是所有数字的中位数。</p>
<p>统计答案即可。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> t[N], tot, ans;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;k, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%lld%s%lld&quot;</span>, x, &amp;u, y, &amp;v);</span><br><span class="line">    <span class="keyword">if</span>(x[<span class="number">0</span>] == y[<span class="number">0</span>]) ans += <span class="built_in">abs</span>(u - v);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        t[++tot] = u, t[++tot] = v;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(t + <span class="number">1</span>, t + <span class="number">1</span> + tot);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++)</span><br><span class="line">    ans += <span class="built_in">abs</span>(t[tot &gt;&gt; <span class="number">1</span>] - t[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br></pre></td></tr></table></figure>

<h1 id="K-x3D-2"><a href="#K-x3D-2" class="headerlink" title="$K&#x3D;2$"></a>$K&#x3D;2$</h1><p>我们考虑一下每一个路线的实际路程。</p>
<p>假设一个路线的端点的编号分别是 $i$ 和 $j$（$i \leq j$），那么：</p>
<ul>
<li>如果 $i$、$j$ 分别在桥的两侧，其实际路程为 $j-i$。</li>
<li>如果 $i$、$j$ 夹在两个桥的中间，其实际路程与 $\frac{i+j}{2}$ 有关。</li>
</ul>
<p>于是我们可以考虑按照 $i+j$ 来对所有的通勤路线进行排序。同时枚举一个划分的位置，左边的都走左边的桥，右边的都走右边的桥。</p>
<p>那么我们需要求的就是动态中位数问题了。</p>
<p>我们仍然考虑使用一个大根堆和一个小根堆来维护动态中位数，只不过我们统计答案的时候换个思路。</p>
<p>我们可以统计前缀和，并且把这个前缀和按照桥的位置分成左右两部分。</p>
<p>此时的最小距离之和就是桥右侧点的坐标和减去左侧点的坐标和。</p>
<p>桥左边的部分枚举的是前缀和，右边的部分枚举的是后缀和。</p>
<p>然后我们取最小值即可。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">need</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> need &amp;a) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (x + y) &lt; (a.x + a.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;order[N];</span><br><span class="line">priority_queue &lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;               &gt; q1;</span><br><span class="line">priority_queue &lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; q2;</span><br><span class="line"><span class="type">int</span> n, k, u, v, cnt;</span><br><span class="line"><span class="type">int</span> ans1[N], ans2[N];</span><br><span class="line"><span class="type">int</span> res, sum1, sum2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exchange</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q1.<span class="built_in">top</span>() &gt; q2.<span class="built_in">top</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q1.<span class="built_in">top</span>(), v = q2.<span class="built_in">top</span>();</span><br><span class="line">        q1.<span class="built_in">pop</span>(), q1.<span class="built_in">push</span>(v);</span><br><span class="line">        q2.<span class="built_in">pop</span>(), q2.<span class="built_in">push</span>(u);</span><br><span class="line">        sum1 += v - u, sum2 -= v - u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>()) q1.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">while</span>(!q2.<span class="built_in">empty</span>()) q2.<span class="built_in">pop</span>();</span><br><span class="line">    sum1 = sum2 = <span class="number">0</span>;</span><br><span class="line">    u = v = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">senhan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q1.<span class="built_in">push</span>(order[i].x), q1.<span class="built_in">push</span>(order[i].y);</span><br><span class="line">        sum1 += order[i].x + order[i].y, sum1 -= q1.<span class="built_in">top</span>(), sum2 += q1.<span class="built_in">top</span>();</span><br><span class="line">        q2.<span class="built_in">push</span>(q1.<span class="built_in">top</span>()); q1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">exchange</span>();</span><br><span class="line">        ans1[i] = sum2 - sum1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gohan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = cnt; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        q1.<span class="built_in">push</span>(order[i].x), q1.<span class="built_in">push</span>(order[i].y);</span><br><span class="line">        sum1 += order[i].x + order[i].y, sum1 -= q1.<span class="built_in">top</span>(), sum2 += q1.<span class="built_in">top</span>();</span><br><span class="line">        q2.<span class="built_in">push</span>(q1.<span class="built_in">top</span>()); q1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">exchange</span>();</span><br><span class="line">        ans2[i] = sum2 - sum1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">sort</span>(order + <span class="number">1</span>, order + <span class="number">1</span> + cnt);</span><br><span class="line"><span class="built_in">senhan</span>();</span><br><span class="line"><span class="built_in">gohan</span>();</span><br><span class="line">res = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= cnt; i++)</span><br><span class="line">    res = <span class="built_in">min</span>(res, ans1[i] + ans2[i + <span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans + res);</span><br></pre></td></tr></table></figure>

<p>全部加起来：</p>
<details class="note success"><summary><p>示例代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">400010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">need</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> need &amp;a) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (x + y) &lt; (a.x + a.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;order[N];</span><br><span class="line">priority_queue &lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;               &gt; q1;</span><br><span class="line">priority_queue &lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; q2;</span><br><span class="line"><span class="type">int</span> n, k, ans, u, v, cnt;</span><br><span class="line"><span class="type">int</span> ans1[N], ans2[N];</span><br><span class="line"><span class="type">char</span> x[<span class="number">2</span>], y[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> t[N], tot, res, sum1, sum2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exchange</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q1.<span class="built_in">top</span>() &gt; q2.<span class="built_in">top</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q1.<span class="built_in">top</span>(), v = q2.<span class="built_in">top</span>();</span><br><span class="line">        q1.<span class="built_in">pop</span>(), q1.<span class="built_in">push</span>(v);</span><br><span class="line">        q2.<span class="built_in">pop</span>(), q2.<span class="built_in">push</span>(u);</span><br><span class="line">        sum1 += v - u, sum2 -= v - u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>()) q1.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">while</span>(!q2.<span class="built_in">empty</span>()) q2.<span class="built_in">pop</span>();</span><br><span class="line">    sum1 = sum2 = <span class="number">0</span>;</span><br><span class="line">    u = v = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">senhan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q1.<span class="built_in">push</span>(order[i].x), q1.<span class="built_in">push</span>(order[i].y);</span><br><span class="line">        sum1 += order[i].x + order[i].y, sum1 -= q1.<span class="built_in">top</span>(), sum2 += q1.<span class="built_in">top</span>();</span><br><span class="line">        q2.<span class="built_in">push</span>(q1.<span class="built_in">top</span>()); q1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">exchange</span>();</span><br><span class="line">        ans1[i] = sum2 - sum1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gohan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = cnt; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        q1.<span class="built_in">push</span>(order[i].x), q1.<span class="built_in">push</span>(order[i].y);</span><br><span class="line">        sum1 += order[i].x + order[i].y, sum1 -= q1.<span class="built_in">top</span>(), sum2 += q1.<span class="built_in">top</span>();</span><br><span class="line">        q2.<span class="built_in">push</span>(q1.<span class="built_in">top</span>()); q1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">exchange</span>();</span><br><span class="line">        ans2[i] = sum2 - sum1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;k, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%lld%s%lld&quot;</span>, x, &amp;u, y, &amp;v);</span><br><span class="line">        <span class="keyword">if</span>(x[<span class="number">0</span>] == y[<span class="number">0</span>]) ans += <span class="built_in">abs</span>(u - v);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            order[++cnt] = &#123; u, v &#125;;</span><br><span class="line">            t[++tot] = u, t[++tot] = v;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(t + <span class="number">1</span>, t + <span class="number">1</span> + tot);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++)</span><br><span class="line">            ans += <span class="built_in">abs</span>(t[tot &gt;&gt; <span class="number">1</span>] - t[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(order + <span class="number">1</span>, order + <span class="number">1</span> + cnt);</span><br><span class="line">        <span class="built_in">senhan</span>();</span><br><span class="line">        <span class="built_in">gohan</span>();</span><br><span class="line">        res = <span class="number">1e18</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= cnt; i++)</span><br><span class="line">            res = <span class="built_in">min</span>(res, ans1[i] + ans2[i + <span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans + res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>P3645 [APIO2015] 雅加达的摩天楼 题解</title>
    <url>/solutions/solution-p3645/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">雅加达的摩天楼</div>
<div id="problem-info-from">APIO 2015</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM2NDU=">Luogu P3645</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yODg3">LibreOJ L2887</span></li><li><span class="exturl" data-url="aHR0cHM6Ly91b2ouYWMvcHJvYmxlbS8xMTE=">UOJ #111</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzQwNzA=">BZOJ #4070</span></li></ul></div>

<hr>
<p>题目说，只要一栋楼里面的一只doge知道了消息，那么他就可以在不产生任何代价的情况下将这条消息传递给这栋楼里面的所有doge。</p>
<p>利用这一条信息，我们可以将doge的行动转化为摩天楼之间的边，一只doge能够前往的两栋楼之间会直接或间接联通。</p>
<p>于是我们就可以想到跑最短路。图上的所有边权均为1，从0到1的最短路即为传递消息的代价。</p>
<p>然后再看数据范围：</p>
<p>$N \in [1,30000 ] , M \in [ 2,30000 ] , P_i \in [ 1,30000 ]$</p>
<p>当头一棒。</p>
<p>我们可怜的最短路算法承受不起如此多的边（$O(n^2)$ 级别），我们甚至可以将这张图看做一张完全图来计算时间复杂度，而结果必然是爆炸。</p>
<p>我们如果一开始分析错误了，把它当做费用流来跑SPFA的话，最多能拿到36分(UOJ&amp;LibreOJ)&#x2F;75分(Luogu)。</p>
<p>我们如果使用链式前向星连边、建边，跑Dijkstra的话，可以拿到36分(UOJ&amp;LibreOJ)&#x2F;80分(Luogu)的好成绩。</p>
<p>然后我们会发现上面会MLE，于是选用vector存边。<br>我们如果使用vector连边、建边，跑Dijkstra的话，可以拿到和上面一样的好成绩，并且仍然MLE。</p>
<p>然后我们考虑换个连边方式，不在让每一条边的边权都是相同的了，考虑从一栋楼向其他的楼连边，边权为跳跃次数，妄图减少内存用量。</p>
<p>结果仍为失败。</p>
<p>我们不再考虑显式连边，而考虑在转移的时候再连边，这里就需要用SPFA了。</p>
<p>然后再跑一遍就可以过了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N];</span><br><span class="line"><span class="type">int</span> dis[N], vis[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">63</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[s] = <span class="number">0</span>, vis[s] = <span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : e[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; u + i * j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> v = u + i * j;</span><br><span class="line">                <span class="keyword">if</span>(dis[v] &gt; dis[u] + j)</span><br><span class="line">                &#123;</span><br><span class="line">                    dis[v] = dis[u] + j;</span><br><span class="line">                    <span class="keyword">if</span>(!vis[v])</span><br><span class="line">                    &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(v);</span><br><span class="line">                        vis[v] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; u - i * j &gt;= <span class="number">0</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> v = u - i * j;</span><br><span class="line">                <span class="keyword">if</span>(dis[v] &gt; dis[u] + j)</span><br><span class="line">                &#123;</span><br><span class="line">                    dis[v] = dis[u] + j;</span><br><span class="line">                    <span class="keyword">if</span>(!vis[v])</span><br><span class="line">                    &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(v);</span><br><span class="line">                        vis[v] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="type">int</span> s, t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)s = a;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t = a;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spfa</span>(s);</span><br><span class="line">    <span class="keyword">if</span>(dis[t] == <span class="number">0x3f3f3f3f</span>)<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; dis[t] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>P3707 [SDOI2017] 相关分析 题解</title>
    <url>/solutions/solution-p3707/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">相关分析</div>
<div id="problem-info-from">SDOI 2017</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM3MDc=">Luogu P3707</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yMDA1">LibreOJ L2005</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjU4Ny8=">AcWing 2585</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzQ4MjE=">BZOJ #4821</span></li></ul></div>

<hr>
<p>这道题需要我们维护一大坨东西。</p>
<h1 id="准备与计算答案"><a href="#准备与计算答案" class="headerlink" title="准备与计算答案"></a>准备与计算答案</h1><p>首先我们把线性回归方程的公式拆一下：<br>（这里将 $\sum_{i&#x3D;l}^r$ 省略为 $\sum$）</p>
<p>$$<br>\begin{align}<br>\hat{a} &amp;&#x3D; \frac{\sum (x_i - \bar{x})(y_i - \bar{y})}{\sum (x_i - \bar{x}^2)} \\<br>&amp;&#x3D; \frac{\sum (x_i y_i - y_i \bar{x} - x_i \bar{y} + \bar{x} \bar{y})}{\sum (x_i^2 - 2x_i \bar{x} + \bar{x}^2)} \\<br>&amp;&#x3D; \frac{\sum x_i y_i - \bar{x} \sum y_i - \bar{y} \sum x_i + (r-l+1) \bar{x} \bar{y}}{\sum x_i^2 - 2\bar{x} \sum x_i + (r-l+1)\bar{x}^2} \\<br>&amp;&#x3D; \frac{\sum x_i y_i - \frac{\sum x_i \sum y_i}{r-l+1} - \frac{\sum y_i \sum x_i}{r-l+1} + (r-l+1) \frac{\sum x_i \sum y_i}{(r-l+1)^2}}{\sum x_i^2 - 2\frac{\sum x_i \sum x_i}{(r-l+1)} + (r-l+1) (\frac{\sum x_i}{r-l+1})^2} \\<br>&amp;&#x3D; \frac{\sum x_i y_i - \frac{\sum x_i \sum y_i}{r-l+1}}{\sum x_i^2 - \frac{\sum x_i \sum x_i}{r-l+1}}<br>\end{align}<br>$$</p>
<p>最终我们需要维护的就是 $\sum x_i$，$\sum x_i^2$，$\sum y_i$ 和 $\sum x_i y_i$。<br>我们计算时的公式就是 $\hat{a} &#x3D; \frac{\sum x_i y_i - \frac{\sum x_i \sum y_i}{r-l+1}}{\sum x_i^2 - \frac{(\sum x_i)^2}{r-l+1}}$。</p>
<h1 id="区间加"><a href="#区间加" class="headerlink" title="区间加"></a>区间加</h1><p>我们考虑每一个量是怎么变化的：</p>
<p>$\sum (x_i+s)^2 &#x3D; \sum (x_i^2 + 2sx_i + s^2) &#x3D; \sum x_i^2 + 2s\sum x_i + (r-l+1)s^2$<br>$\sum (x_i+s)(y_i+t) &#x3D; \sum (x_iy_i + sy_i + ts_i + st) &#x3D; \sum x_iy_i + s\sum y_i + t\sum x_i + (r-l+1)st$<br>$\sum (x_i+s) &#x3D; \sum x_i + (r-l+1)s$<br>$\sum (y_i+t) &#x3D; \sum y_i + (r-l+1)t$</p>
<p>注意我们这里在维护前面两个二次的东西的时候需要我们一次的这两个量，所以我们需要注意维护的顺序。</p>
<h1 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h1><h2 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h2><p>$\sum_{i&#x3D;1}^n i^2 &#x3D; \frac{n(n+1)(2n+1)}{6}$</p>
<h2 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h2><p>我们考虑将每一个点的值拆分成 $(i,i)$ 和 $(s,t)$ 两部分，而后者可以用区间加来完成。</p>
<p>这个 $i$ 就是当前点的编号。一开始我想的是每一个修改区间的 $i$ 从 $1$ 开始，傻乎乎地传了一个 $i$ 下去，然后wa了一堆……</p>
<p>对于一个完全被修改的区间 $[l,r]$，我们的四个量的新值如下：</p>
<p>$\sum x_i^2 &#x3D; \sum i^2 &#x3D; \sum_{i&#x3D;1}^r i^2 - \sum_{i&#x3D;1}^{l-1} &#x3D; \frac{r(r+1)(2r+1)}{6} - \frac{(l-1)l(2l-1)}{6}$<br>$\sum x_iy_i &#x3D; \sum i^2 &#x3D; \frac{r(r+1)(2r+1)}{6} - \frac{(l-1)l(2l-1)}{6}$<br>$\sum x_i &#x3D; \sum i &#x3D; \frac{(r-l+1)(l+r)}{2}$<br>$\sum y_i &#x3D; \sum i &#x3D; \frac{(r-l+1)(l+r)}{2}$</p>
<p>然后需要清空懒标记，并打一个清空懒标记的标记。<br>然后就是区间加了。</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>注意懒标记的维护顺序。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">double</span> x[N], y[N];</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calc</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * (x + <span class="number">1</span>) * (<span class="number">2</span> * x + <span class="number">1</span>) / <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ret</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> xx, xy, x, y;</span><br><span class="line">    <span class="keyword">friend</span> Ret <span class="keyword">operator</span> + (<span class="type">const</span> Ret &amp;a, <span class="type">const</span> Ret &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; a.xx + b.xx,a.xy + b.xy,a.x + b.x,a.y + b.y &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">double</span> xx, xy, x, y;</span><br><span class="line">    <span class="type">double</span> s, t;</span><br><span class="line">    <span class="type">bool</span> c;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modadd</span><span class="params">(<span class="type">int</span> p, <span class="type">double</span> s, <span class="type">double</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> len = <span class="built_in">double</span>(tr[p].r - tr[p].l + <span class="number">1</span>);</span><br><span class="line">    tr[p].xx += s * s * len + <span class="number">2</span> * s * tr[p].x;</span><br><span class="line">    tr[p].xy += s * t * len + s * tr[p].y + t * tr[p].x;</span><br><span class="line">    tr[p].x += s * len;</span><br><span class="line">    tr[p].y += t * len;</span><br><span class="line">    tr[p].s += s;</span><br><span class="line">    tr[p].t += t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modchg</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> l = <span class="built_in">double</span>(tr[p].l), r = <span class="built_in">double</span>(tr[p].r);</span><br><span class="line">    tr[p].xx = tr[p].xy = <span class="built_in">calc</span>(r) - <span class="built_in">calc</span>(l - <span class="number">1</span>);</span><br><span class="line">    tr[p].x = tr[p].y = (r - l + <span class="number">1</span>) * (l + r) / <span class="number">2</span>;</span><br><span class="line">    tr[p].c = <span class="literal">true</span>;</span><br><span class="line">    tr[p].s = tr[p].t = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].xx = tr[p &lt;&lt; <span class="number">1</span>].xx + tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].xx;</span><br><span class="line">    tr[p].x = tr[p &lt;&lt; <span class="number">1</span>].x + tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].x;</span><br><span class="line">    tr[p].y = tr[p &lt;&lt; <span class="number">1</span>].y + tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].y;</span><br><span class="line">    tr[p].xy = tr[p &lt;&lt; <span class="number">1</span>].xy + tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].xy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">modchg</span>(p &lt;&lt; <span class="number">1</span>), <span class="built_in">modchg</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">modadd</span>(p &lt;&lt; <span class="number">1</span>, tr[p].s, tr[p].t);</span><br><span class="line">    <span class="built_in">modadd</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, tr[p].s, tr[p].t);</span><br><span class="line">    tr[p].c = <span class="literal">false</span>;</span><br><span class="line">    tr[p].s = tr[p].t = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].l = l, tr[p].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].xx = x[l] * x[r];</span><br><span class="line">        tr[p].x = x[l];</span><br><span class="line">        tr[p].y = y[l];</span><br><span class="line">        tr[p].xy = x[l] * y[r];</span><br><span class="line">        tr[p].s = tr[p].t = <span class="number">0</span>;</span><br><span class="line">        tr[p].c = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">segadd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">double</span> s, <span class="type">double</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">modadd</span>(p, s, t);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)<span class="built_in">segadd</span>(p &lt;&lt; <span class="number">1</span>, l, r, s, t);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)<span class="built_in">segadd</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, s, t);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">segchg</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">double</span> s, <span class="type">double</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">modchg</span>(p);</span><br><span class="line">        <span class="built_in">modadd</span>(p, s, t);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)<span class="built_in">segchg</span>(p &lt;&lt; <span class="number">1</span>, l, r, s, t);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)<span class="built_in">segchg</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, s, t);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Ret <span class="title">segsum</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)<span class="keyword">return</span> &#123; tr[p].xx,tr[p].xy,tr[p].x,tr[p].y &#125;;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    Ret res = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res = res + <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)res = res + <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">ans</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Ret res = <span class="built_in">segsum</span>(<span class="number">1</span>, l, r);</span><br><span class="line">    <span class="type">double</span> len = r - l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (res.xy - res.x * res.y / len) / (res.xx - res.x * res.x / len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;x[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;y[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op, l, r;</span><br><span class="line">        <span class="type">double</span> s, t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>, <span class="built_in">ans</span>(l, r));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;s, &amp;t);</span><br><span class="line">            <span class="built_in">segadd</span>(<span class="number">1</span>, l, r, s, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;s, &amp;t);</span><br><span class="line">            <span class="built_in">segchg</span>(<span class="number">1</span>, l, r, s, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>P3773 [CTSC2017] 吉夫特 题解</title>
    <url>/solutions/solution-p3773/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">吉夫特</div>
<div id="problem-info-from">CTSC 2017</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM3NzM=">Luogu P3773</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yMjY0">LibreOJ L2264</span></li><li><span class="exturl" data-url="aHR0cHM6Ly91b2ouYWMvcHJvYmxlbS8zMDA=">UOJ #300</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzQ5MDM=">BZOJ #4903</span></li></ul></div>

<hr>
<p>题目要求我们从一个数列中找出满足 $\displaystyle \prod_{i&#x3D;2}^k C_{a_{b_{i-1}}}^{a_{b_i}}$ 为奇数的子序列个数。</p>
<p>看起来很难算，但是我们可以根据卢卡斯定理化简，以此迅速判断是否满足条件。</p>
<p>卢卡斯定理是 $C_a^b \bmod{p} \equiv C_{a \div p}^{b \div p} \times C_{a \bmod{p}}^{b \bmod{p}} \bmod{p}$。</p>
<p>因为此处 $p&#x3D;2$，所以我们可以将其分解成为一串组合数，其中只包含 $C_0^0$、$C_0^1$、$C_1^0$ 和 $C_1^1$ 四种。<br>其中只有 $C_0^1 &#x3D; 0$。</p>
<p>这样预示着符合条件的子序列会很多，不如求出不合法的状况然后从总数里面减去。<br>那么我们只需要看 $a_{b_{i-1}}$ 某一位是 $1$ 而 $a_{b_i}$ 这一位是 $0$ 的情况就好了。<br>对于一个数，这种情况只需要有与二进制位数奇偶性不同的次数就可以了。</p>
<p>但是枚举数字判断不是特别能过。</p>
<p>我们可以尝试换种方法，将满足上面性质的 $a_{b_i}$ 当成 $a_{b_{i-1}}$ 的子集，枚举子集即可，然后判断枚举出来的这个数字是否在其后面。<br>实际写的时候我们可以将所有的 $a_i$ 存进桶里，存储下来每一个 $a_i$ 对应的以其开头的子序列个数，然后统计答案。</p>
<p>复杂度 $O(3^{log a_{max}})$，实测可过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">250010</span>;</span><br><span class="line"><span class="type">int</span> l[N], r[N], sum[N];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> a[N], f[N];</span><br><span class="line"><span class="type">int</span> tong[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%dd&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        tong[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = a[i] &amp; (a[i] - <span class="number">1</span>); j; j = a[i] &amp; (j - <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span>(tong[j] &gt; i)f[i] = (f[i] + f[tong[j]]) % mod;</span><br><span class="line">        ans = (ans + f[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = (ans - n + mod) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





















]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>P4135 作诗 题解</title>
    <url>/solutions/solution-p4135/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">作诗</div>
<div id="problem-info-from">none</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQxMzU=">Luogu P4135</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8zMjc3">LibreOJ L6180</span></li></ul></div>

<hr>
<p>对于这道题，我们首先想到的就是分块了，因为看起来只能暴力做，没有什么好用的数据结构来维护。<br>我们对于每一个整段求出每一个颜色在其中的出现次数，每一次U型你问的时候只需要将其累加起来再统计即可。</p>
<p>但是我们颜色的种类数 $c$ 是与 $n$ 同阶的，我们枚举的时候难免会带一个较大的复杂度，达不到 $O(\sqrt{n})$ 的复杂度要求。</p>
<p>考虑不考虑这些整块内的颜色，只考虑散块内的颜色对整块内的答案的影响。因为散块内的颜色最多也只有 $O(\sqrt{n})$ 种。这样，我们需要枚举的颜色也就不超过 $O(\sqrt{n})$ 种了。</p>
<p>我们记录每一块的颜色后缀和 $cnt[bl][color]$，然后再记录一个整块形成的段的答案 $f[tl][tr]$。</p>
<p>统计的时候，假如说我们统计的块是从 $l$ 到 $r$ 的一段区间，而 $tl$ 和 $tr$ 分别是 $l$ 和 $r$ 所在的两个散块。<br>那么我们暴力统计出来 $tl$ 和 $tr$ 这两个散块中的颜色和 $num[color]$，同时拿一个什么东西记录下来所有出现过的颜色（我这里是用栈），然后拿出来 $f[tl][tr]$ 作为基准的答案。<br>对于每一个在散块内出现过的颜色，我们分六类讨论。</p>
<ol>
<li>该颜色在散块内出现奇数次，在整块内没有出现。<br> 此时该颜色对答案无影响。</li>
<li>该颜色在散块内出现偶数次，在整块内没有出现。<br> 此时该颜色对答案有1的贡献。</li>
<li>该颜色在散块内出现奇数次，在整块内出现奇数次。<br> 此时该颜色对答案有1的贡献。</li>
<li>该颜色在散块内出现偶数次，在整块内出现奇数次。<br> 此时该颜色对答案没有贡献。</li>
<li>该颜色在散块内出现奇数次，在整块内出现偶数次。<br> 此时该颜色对答案有-1的贡献。</li>
<li>该颜色在散块内出现偶数次，在整块内出现偶数次。<br> 此时该颜色对答案没有贡献。</li>
</ol>
<p>这六种情况中只有三种对答案有贡献，只需要判断是否满足条件即可。</p>
<p>前期处理的时间复杂度也不高，如果方法得当的话就是 $O(n \sqrt{n})$ 的，不会对后面的询问产生影响。</p>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">440</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="type">int</span> S;</span><br><span class="line"><span class="type">int</span> lastans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> bl[N];</span><br><span class="line"><span class="type">int</span> cnt[M][N];</span><br><span class="line"><span class="type">int</span> f[M][M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;c, &amp;m);</span><br><span class="line">    S = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        bl[i] = i / S;</span><br><span class="line">    &#125;</span><br><span class="line">    bl[n] = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= bl[n - <span class="number">1</span>]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i * S; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt[i][a[j]]++;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i][a[j]] &amp; <span class="number">1</span> &amp;&amp; cnt[i][a[j]] &gt; <span class="number">1</span>)t--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((cnt[i][a[j]] % <span class="number">2</span>) == <span class="number">0</span>)t++;</span><br><span class="line">            <span class="keyword">if</span>(bl[j] != bl[j + <span class="number">1</span>])f[i][bl[j]] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num[N], sta[N], tt;</span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="built_in">sizeof</span>(num));</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        l = (l + lastans) % n;</span><br><span class="line">        r = (r + lastans) % n;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r)<span class="built_in">swap</span>(l, r);</span><br><span class="line">        <span class="type">int</span> tl = bl[l], tr = bl[r];</span><br><span class="line">        <span class="keyword">if</span>(tl == tr)</span><br><span class="line">        &#123;</span><br><span class="line">            tt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                num[a[i]]++;</span><br><span class="line">                <span class="keyword">if</span>(num[a[i]] == <span class="number">1</span>)sta[++tt] = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tt; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> k = sta[i];</span><br><span class="line">                <span class="keyword">if</span>(num[k] % <span class="number">2</span> == <span class="number">0</span>)res++;</span><br><span class="line">                num[k] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lastans = res;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tt = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(tl + <span class="number">1</span> &lt;= tr - <span class="number">1</span>)res += f[tl + <span class="number">1</span>][tr - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt; (tl + <span class="number">1</span>) * S; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                num[a[i]]++;</span><br><span class="line">                <span class="keyword">if</span>(num[a[i]] == <span class="number">1</span>)sta[++tt] = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = tr * S; i &lt;= r; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                num[a[i]]++;</span><br><span class="line">                <span class="keyword">if</span>(num[a[i]] == <span class="number">1</span>)sta[++tt] = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tt; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> k = sta[i];</span><br><span class="line">                <span class="keyword">if</span>(num[k] % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; (cnt[tl + <span class="number">1</span>][k] - cnt[tr][k]) % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; (cnt[tl + <span class="number">1</span>][k] - cnt[tr][k]) &gt; <span class="number">0</span>)res--;</span><br><span class="line">                <span class="keyword">if</span>(num[k] % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; (cnt[tl + <span class="number">1</span>][k] - cnt[tr][k]) % <span class="number">2</span> == <span class="number">1</span>)res++;</span><br><span class="line">                <span class="keyword">if</span>(num[k] % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; (cnt[tl + <span class="number">1</span>][k] - cnt[tr][k]) == <span class="number">0</span>)res++;</span><br><span class="line"></span><br><span class="line">                num[k] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lastans = res;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>P4336 [SHOI2016] 黑暗前的幻想乡 题解</title>
    <url>/solutions/solution-p4336/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">黑暗前的幻想乡</div>
<div id="problem-info-from">SHOI 2016</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQzMzY=">Luogu P4336</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yMDI3">LibreOJ L2027</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjc5NS8=">AcWing 2793</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzQ1OTY=">BZOJ #4596</span></li></ul></div>

<hr>
<h1 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h1><h2 id="Kirchhoff-矩阵树定理"><a href="#Kirchhoff-矩阵树定理" class="headerlink" title="Kirchhoff 矩阵树定理"></a>Kirchhoff 矩阵树定理</h2><p>Kirchhoff矩阵树定理解决了一个问题：对于一个确定的无向图，其究竟有多少个生成树？</p>
<p>对于一个无向图，我们拥有其邻接矩阵 $\bf{A}$。<br>这里的邻接矩阵允许重边，第 $i$ 行第 $j$ 列的值代表着点 $i$ 到点 $j$ 有几条边。<br>不允许自环。</p>
<p>我们定义一个无向图的度数矩阵 $\bf{D}$ 为，第 $i$ 行第 $i$ 列上的数字是点 $i$ 的度数，其余的格子都为 $0$ 的矩阵。</p>
<p>我们定义一个图的 Kirchhoff矩阵 ${\bf{K}} &#x3D; {\bf{D}} - {\bf{A}}$。</p>
<p>这个矩阵同时去掉任意一行一列，剩下的这个子矩阵的行列式的绝对值，就是该无向图的生成树个数。</p>
<h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><p>行列式可以被理解为列向量夹的几何体的体积，用 $\det({\bf{A}})$ 表示 $\bf{A}$ 这个方阵的行列式。</p>
<p>这里不讲太细，细一点的可以去看我的另外一篇博客。</p>
<p>在这里，我们只需要知道几个简单的点：</p>
<ol start="0">
<li>每一个方阵都有自己的行列式，公式是 $\displaystyle \det({\bf{A}}) &#x3D; \sum_{\sigma \in S_n} \operatorname{sgn}(\sigma) \prod_{i&#x3D;1}^n a_{i,\sigma(i)}$。</li>
<li>三角矩阵的行列式是可以以很小的复杂度计算出来的。具体方法是其对角线之积。</li>
<li>方阵的行列式有如下几个性质：<ol>
<li>矩阵转置，行列式不变；</li>
<li>矩阵行（列）交换，行列式取反；</li>
<li>矩阵行（列）相加减，行列式不变；</li>
<li>矩阵行（列）所有元素同时乘以数 $k$，行列式也乘 $k$。</li>
</ol>
</li>
<li>通过上面的几个操作（其实就是高斯消元）可以将一个矩阵消为一个三角矩阵，而反过来则可以从三角矩阵变回原矩阵。</li>
</ol>
<p>那么我们存储一个系数，在消元的时候维护这个系数，直到最后得到三角矩阵的时候再将系数乘在这个我们能够简单求出的行列式上，就可以得到原矩阵的行列式了。</p>
<h1 id="题目解读"><a href="#题目解读" class="headerlink" title="题目解读"></a>题目解读</h1><p>题目要求我们求出一个无向图的生成树数量，并且该生成树需要满足其中的每一条边都属于一个不同的集合。</p>
<p>那么我们考虑容斥，将“恰好”改为“至多”。</p>
<p>这样我们枚举由 $n-1$ 个集合构成的无向图的时候会记录上由 $n-2$ 个集合构成的无向图的结果，需要减去这部分的影响。<br>然后枚举由 $n-2$ 个集合构成的无向图，同时会记录上由 $n-3$ 个集合构成的无向图的结果。<br>这样一直容斥下去，直到最后枚举由 $1$ 个集合构成的无向图的结果的时候，容斥就可以停止了。</p>
<p>每一次枚举的时候，我们都需要跑矩阵树定理。每一次跑矩阵树定理都是 $O((n-1)^3)$ 的，我们需要跑 $2^{n-1}$ 次，所以最终的复杂度是 $O(2^{n-1}(n-1)^3)$ 的。</p>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>, M = N * N;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, maxn;</span><br><span class="line"><span class="type">int</span> m[N];</span><br><span class="line"><span class="type">int</span> u[N][M], v[N][M];</span><br><span class="line"><span class="type">int</span> sz[(<span class="number">1</span> &lt;&lt; <span class="number">18</span>)];</span><br><span class="line">ll krh[N][N];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>)res = (res * a) % mod;</span><br><span class="line">        a = (a * a) % mod;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">det</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(krh[i][i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n - <span class="number">1</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(krh[j][i] == <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">                flag ^= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n - <span class="number">1</span>; k++)</span><br><span class="line">                    <span class="built_in">swap</span>(krh[i][k], krh[j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= n - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(krh[j][i] == <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            ll inv = <span class="built_in">qpow</span>(krh[j][i], mod - <span class="number">2</span>);</span><br><span class="line">            res = (res * krh[j][i]) % mod;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt;= n - <span class="number">1</span>; k++)</span><br><span class="line">                krh[j][k] = (krh[j][k] * inv) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(krh[j][i] == <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt;= n - <span class="number">1</span>; k++)</span><br><span class="line">                krh[j][k] = (krh[j][k] - krh[i][k] + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">        res = (res * krh[i][i]);</span><br><span class="line">    <span class="keyword">return</span> (flag) ? (mod - res) % mod : res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    maxn = (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m[i]; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u[i][j], &amp;v[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= maxn; i++)</span><br><span class="line">        sz[i] = sz[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= maxn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(krh, <span class="number">0</span>, <span class="built_in">sizeof</span>(krh));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>, p = i; p; p &gt;&gt;= <span class="number">1</span>, j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((p &amp; <span class="number">1</span>) == <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= m[j]; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> U = u[j][k], V = v[j][k];</span><br><span class="line">                krh[U][U]++, krh[V][V]++;</span><br><span class="line">                krh[U][V] = (krh[U][V] + mod - <span class="number">1</span>) % mod;</span><br><span class="line">                krh[V][U] = (krh[V][U] + mod - <span class="number">1</span>) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = (res + mod + <span class="built_in">det</span>() * ((n - sz[i]) % <span class="number">2</span> ? <span class="number">1</span> : <span class="number">-1</span>)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>矩阵树定理</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>P4568 [JLOI2011] 飞行路线 题解</title>
    <url>/solutions/solution-p4568/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">飞行路线</div>
<div id="problem-info-from">JLOI 2011</div>
<div id="problem-info-difficulty">提高+ /省选-</div>
<div id="problem-info-color">#3498db</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQ1Njg=">Luogu P4568</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMjk1Ni8=">AcWing 2953</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzI3NjM=">BZOJ #2763</span></li></ul></div>

<hr>
<p>一眼最短路，但是多了一些条件：可以最多将最短路上 $k$ 条边的权值变为 $0$。</p>
<p>因为我们求的是两个点之间的最短路，只需要最小化这两个点之间的距离即可，这样我们就不能先跑最短路再改边权。</p>
<p>我们考虑换种建图方式。</p>
<p>我们考虑将免费的机票和付费的机票分开连边。</p>
<p>我们在原图的基础上再建立 $k$ 层同样的图，分别代表使用了 $1,2,3,\cdots,k$ 次免费机票时的状态。<br>相邻两层之间也连边，边权为 $0$。对于原图中的每一条边 $(u,v)$，我们同时从第 $i$ 层的 $u$ 向第 $i+1$ 的 $v$、从第 $i$ 层的 $v$ 向第 $i+1$ 层的 $u$ 连上一条边权为 $0$ 的有向边，代表使用了免费的机票。</p>
<p>我们就从第 $0$ 层的 $s$ 向第 $k$ 层的 $t$ 跑最短路。</p>
<p>同时，以防某些奇葩数据使得我们没用完 $k$ 张免费机票就到了 $t$，我们把相邻两层之间的 $t$ 也连上边权为 $0$ 的有向边。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>, M = <span class="number">5000010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> dis, u;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &gt; (<span class="type">const</span> node&amp; a) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dis &gt; a.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> dis[N], vis[N];</span><br><span class="line">priority_queue&lt;node, vector&lt;node&gt;, greater&lt;node&gt; &gt;q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">63</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123; <span class="number">0</span>,s &#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">top</span>().u;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i], c = w[i];</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + c)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + c;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v])q.<span class="built_in">push</span>(&#123; dis[v],v &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="type">int</span> s, t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;s, &amp;t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(a + n * (j - <span class="number">1</span>), b + n * j, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">add</span>(b + n * (j - <span class="number">1</span>), a + n * j, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">add</span>(a + n * j, b + n * j, c);</span><br><span class="line">            <span class="built_in">add</span>(b + n * j, a + n * j, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">        <span class="built_in">add</span>(t + n * (i - <span class="number">1</span>), t + n * i, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dijkstra</span>(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dis[t + n * k]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>P4588 [TJOI2018] 数学计算 题解</title>
    <url>/solutions/solution-p4588/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">数学计算</div>
<div id="problem-info-from">TJOI 2018</div>
<div id="problem-info-difficulty">提高+ /省选-</div>
<div id="problem-info-color">#3498db</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQ1ODg=">Luogu P4588</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yNTcz">LibreOJ L2573</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzAwNC8=">AcWing 3001</span></li></ul></div>

<hr>
<p>题目要求我们维护一个初始值为1的数字 $x$，要求支持对其乘以一个数和除以一个数，并在每一次操作后输出 $x \bmod{M}$。</p>
<p>同时，题目保证我们除以的数之前被乘过，且每一个被乘过的数至多只会被除一次。<br>这样就可以将除法操作转化为撤回一次乘法操作。</p>
<p>这样我们需要做的就是，维护一串数的连乘积，同时支持向这一串数里面加入数和去掉数。</p>
<p>我们可以尝试使用乘法逆元做，但是这个 $M$ 不一定是质数，所以还需要判整除，非常麻烦。<br>或者可以使用中国剩余定理强行来一波，但是会更麻烦。</p>
<p>我们可以尝试使用线段树来维护区间乘积。<br>首先将所有的的数值全都初始化成1，然后每一次做单点修改区间查询即可。<br>甚至不需要区间查询，只需要查询根节点的值就可以了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, mod;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segtree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> v;</span><br><span class="line">&#125;node[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node[p].l = l;</span><br><span class="line">    node[p].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        node[p].v = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    node[p].v = (node[p &lt;&lt; <span class="number">1</span>].v * node[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].v) % mod;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">segchg</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> ed, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((node[p].r == ed) &amp;&amp; (node[p].l == ed))</span><br><span class="line">    &#123;</span><br><span class="line">        node[p].v = k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (node[p].r + node[p].l) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= ed)<span class="built_in">segchg</span>(p &lt;&lt; <span class="number">1</span>, ed, k);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; ed)<span class="built_in">segchg</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, ed, k);</span><br><span class="line">    node[p].v = (node[p &lt;&lt; <span class="number">1</span>].v * node[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].v) % mod;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;mod);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, N);</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> op, x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;x);</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">segchg</span>(<span class="number">1</span>, i + <span class="number">1</span>, x);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, node[<span class="number">1</span>].v % mod);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">segchg</span>(<span class="number">1</span>, x + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, node[<span class="number">1</span>].v % mod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P4643 [国家集训队] 阿狸和桃子的游戏 题解</title>
    <url>/solutions/solution-p4643/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">阿狸和桃子的游戏</div>
<div id="problem-info-from">国家集训队</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQ2NDM=">Luogu P4643</span></li></ul></div>

<hr>
<p>题目大意是，我们需要从一个带有边权和点权的图上对点进行染色，并按照一个特定的规则计分，最终输出两人得分之差，要求差最大。</p>
<p>某一个人的得分是其染色的点权值之和，再加上两端点均被其染色的边权之和。</p>
<hr>
<p>因为我们需要求的是两人得分之差，所以原本一条边的两端点分别被两人染色之后边权互不归属的情况可以看做两人各取一半。<br>同理，如果一条边的两个端点都被同一个人染了色之后，这条边的两半权值都被这个人拿走了，与我们题目里的情况符合。</p>
<p>那我们就可以将边的权值一分为二，分别加到两个端点上，然后将这道题目变成选择最大点权和。</p>
<p>因为两人均采取最优策略，所以桃子取到了最大值之后，阿狸就会取次大值，然后桃子去第三大的值，如此往复。</p>
<p>于是我们就可以将点按照权值降序两两一组，求所有组内点权之差的总和。</p>
<p>然后我们就可以输出答案了。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">        a[i] = k &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        a[x] += z;</span><br><span class="line">        a[y] += z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i -= <span class="number">2</span>)ans += a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>P4654 [CEOI2017] Mousetrap 题解</title>
    <url>/solutions/solution-p4654/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">Mousetrap</div>
<div id="problem-info-from">CEOI 2017</div>
<div id="problem-info-difficulty">NOI / NOI+ / CTSC</div>
<div id="problem-info-color">#0e1d69</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQ2NTQ=">Luogu P4654</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yNDgy">LibreOJ L2482</span></li></ul></div>

<p>（蒟蒻的第一道黑题）</p>
<hr>
<p>这是一棵无根树，不如我们先指定一个根节点，因为以1号点为根实在是想不到什么性质可以用了。<br>以老鼠所在节点为根也没有想到什么好性质，那不如就以陷阱房为根罢了。</p>
<p>这样做的话，老鼠想要去陷阱房必须向上走，不管他在哪里。</p>
<p>那么首先我们想一种特殊的情况，就是老鼠就在陷阱房旁边，也就是陷阱房的子节点，与其直接有边相连。<br>那么老鼠肯定不会向上走，他的最优策略肯定是向下走。<br>况且，老鼠在没有人清理走廊的情况下是无法走回头路的，所以其唯一能做的事就是找到一个很深很深的链，然后一头钻进去，再也出不来了。</p>
<p>这样的话，管理员必须采取反制措施。<br>那么现在管理员唯一能做的事，也只有将当前节点的重儿子堵住，才能让老鼠放弃这个决策，转而去次重儿子。</p>
<p>不对，上面还说是链呢，这里怎么就是重儿子了？</p>
<p>因为管理员需要将所有的支链堵住，才能最小化其操作次数；老鼠当然也知道这些，那么其就会向重儿子进发。<br>原因是这个样子的：<br>假设这里有一棵树：</p>
<img src="https://s2.loli.net/2022/07/06/81HAXt27c63a45y.png" width="60%">

<p>其中1号点是陷阱房，也是树根；老鼠一开始在二号房。<br>老鼠经过一番DFS，已经给每一个边标上了轻重：</p>
<img src="https://s2.loli.net/2022/07/06/kr85l3wBzPnexvj.png" width="60%">

<p>现在老鼠已经沿着次重边（2-15-19）到达了最后一个节点，同时管理员也堵上了所有老鼠可能经过的重边（2-4，15-16，19-20），现在他走不动了。<br>这是当前迷宫中的情况：</p>
<img src="https://s2.loli.net/2022/07/06/L5yVWOGRHkYqNtv.png" width="60%">

<p>假如我们擦干净15-19的话，老鼠就会走到15号点。<br>现在我们想要让老鼠继续向上到2号点，于是我们擦干净了2-15，然后……</p>
<p>老鼠钻进20号点了<del>啊啊啊啊</del></p>
<p>如果20号点不是像我们给的图片中的那样光秃秃的，而是有很大的一棵子树（并且不如15和16号点的子树大），那么我们需要费的劲就更大了。</p>
<p>所以我们还需要有一个策略，就是在老鼠不能动的时候堵住所有支链，让老鼠只能沿着当前节点到根的链走。</p>
<p>于是我们堵住了15-20这条边，然后再擦干净2-15让老鼠上去，之后再堵住2-3，让老鼠不得不选择1-2，最后老鼠走到陷阱房，游戏结束。</p>
<p>这是老鼠初始的位置直接连接陷阱房的情况，我们假定了老鼠一开始绝对不会向上走。<br>那如果老鼠的初始位置不是与陷阱房直接相连呢？<br>也就是说，我们得考虑老鼠向上走一点，到达另一棵子树之后再一头扎下去的这种情况。</p>
<p>首先我们可以确定一点，就是我们不需要清理老鼠一开始向上走而污染的路径，因为我们在之后把老鼠再次赶上去的时候这里算是一个支链，需要堵住，而不是需要联通。</p>
<p>老鼠也很智能，他想让我们的操作数尽量多。<br>我们怎样对于一棵子树评估我们的操作数呢？</p>
<p>我们可以定义一个数组 $f_i$，代表我们将老鼠赶进 $i$ 的子树之后又将其赶到 $i$ 所需要的操作数。<br>老鼠肯定想选 $f$ 最大的子树，而我们会将其堵住，所以老鼠实际上选的是次大的子树，然后就这样一直走到底。</p>
<p>现在我们需要找出，哪一棵子树才是老鼠想要去的。<br>我们总不能枚举所有点，这个复杂度太高。</p>
<p>我们发现这个可以进行二分。<br>怎么二分呢？</p>
<p>我们可以记录一个 $sum_i$，代表 $i$ 号节点到根路径上所有支路都被堵上所需要的操作数。<br>其维护的方式是这样的：$sum_x &#x3D; sum_{fa_x} + sz_x - [x \neq m]$。（根节点就不需要这个了）<br>其中 $sz_i$ 代表的是 $i$ 的子树个数，而不是子树大小。</p>
<p>然后我们考虑二分什么。<br>不用想，肯定是操作数。<br>假设我们给管理员设定了一个KPI，希望他能够在 $k$ 次操作内将老鼠赶到陷阱房。<br>而老鼠既然已经知道了管理员的这个目标，那么他只需要找到一颗 $sum &gt; k$ 的子树一头钻进去就不需要出来了。<br>那么管理员就需要将所有 $sum &gt; k$ 的子树封住。同时我们需要注意到封堵这个操作也是需要付出代价的，所以每一次我们封堵的时候 $k$ 都需要自减1。</p>
<p>如果管理员的手速不够快，老鼠钻进了一个 $sum &gt; k$ 的子树，那么就宣告失败；<br>如果管理员封堵太多了，导致 $k &lt; 0$ 了，那也宣告失败；<br>否则就算成功了。</p>
<p>下面是二分函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">chq</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m, cnt = <span class="number">1</span>; i != rt; i = fa[i], cnt++)</span><br><span class="line">    &#123;<span class="comment">//向上遍历到根</span></span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = h[i]; ~j; j = ne[j])</span><br><span class="line">        &#123;<span class="comment">//枚举子节点</span></span><br><span class="line">            <span class="type">int</span> v = e[j];</span><br><span class="line">            <span class="keyword">if</span> (vis[v] || <span class="comment">//会被老鼠弄脏，不需要堵</span></span><br><span class="line">                sum[i] + f[v] &lt;= k)<span class="comment">//不会超出目标，暂时不需要堵</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!cnt)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//管理员的手速不够快</span></span><br><span class="line">            tmp++;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        k -= tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k &gt;= <span class="number">0</span>;<span class="comment">//需要封堵的太多了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，所有的东西我们就都分析完了。</p>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>, M = <span class="number">2000010</span>;</span><br><span class="line"><span class="type">int</span> n, rt, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> sz[N], fa[N], f[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[p] = father, sz[p] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> h1 = <span class="number">0</span>, h2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[p]; ~i; i = ne[i])<span class="comment">//处理子树大小</span></span><br><span class="line">        <span class="keyword">if</span> (e[i] != father)sz[p]++;</span><br><span class="line">    <span class="keyword">if</span> (p != rt)<span class="comment">//处理sum</span></span><br><span class="line">        sum[p] = sum[father] + sz[p] - (p != m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;<span class="comment">//遍历子树，处理子树次大值</span></span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j == fa[p])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(j, p);</span><br><span class="line">        <span class="keyword">if</span> (f[j] &gt; h1)h2 = h1, h1 = f[j];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (f[j] &gt; h2)h2 = f[j];</span><br><span class="line">    &#125;</span><br><span class="line">    f[p] = h2 + sz[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">chq</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m, cnt = <span class="number">1</span>; i != rt; i = fa[i], cnt++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = h[i]; ~j; j = ne[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = e[j];</span><br><span class="line">            <span class="keyword">if</span> (vis[v] || sum[i] + f[v] &lt;= k)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!cnt)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            tmp++;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        k -= tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;rt, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(rt, <span class="number">0</span>);</span><br><span class="line">    f[rt] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m; i; i = fa[i])<span class="comment">//处理到根的路径，给它们打标记</span></span><br><span class="line">        vis[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">1e8</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">chq</span>(mid))r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>二分</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P5024 [NOIP2018 提高组] 保卫王国 题解</title>
    <url>/solutions/solution-p5024/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">保卫王国</div>
<div id="problem-info-from">NOIP-S 2018</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDUwMjQ=">Luogu P5024</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8yOTU1">LibreOJ L2955</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNTM4Lw==">AcWing 536</span></li><li><span class="exturl" data-url="aHR0cHM6Ly91b2ouYWMvcHJvYmxlbS80NDE=">UOJ #441</span></li></ul></div>

<hr>
<p>保卫王国这道题是一道非常经典的动态DP题目，尽管其刚刚推出不到几年。</p>
<h1 id="题意转化"><a href="#题意转化" class="headerlink" title="题意转化"></a>题意转化</h1><p>首先我们做一下题意的转化。</p>
<p>题目要求在Z<del>imbabwe</del>国的每一个城市选择驻军或者不驻军，要求每一条道路两端至少有一个城市驻军。<br>驻军会产生正的费用，我们需要找出费用最小的方案。</p>
<p>对于上面的部分，我们只需要求一下这棵树的最小权点覆盖即可，也就是点权和减去最大权独立集。</p>
<p>然后我们还需要满足一系列要求，要求钦定两个城市强制驻军&#x2F;不驻军，对每一个要求我们需要输出在当前要求下的最小权点覆盖。<br>询问之间互不影响。</p>
<p>对于这个情况的话，我们强制选点就可以将其权值改为 $w[i] - 10^{15}$，强制不选点的话就可以将其权值改为 $w[i] + 10^{15}$，最后再在答案里面消除影响即可。</p>
<p>然后就是如何快速求出答案了。</p>
<h1 id="动态DP"><a href="#动态DP" class="headerlink" title="动态DP"></a>动态DP</h1><p>动态DP是一类树上问题的统称，其一般源于一些简单的树上DP（就比如说让我们求树上的最大独立集），但是被加入了<del>丧心病狂</del>的修改点权操作。</p>
<p>我们先考虑一下正常的树上最大独立集怎么做。</p>
<p>我们定义 $f_{x,1}$ 为选中 $x$ 节点的最大结果，$f_{x,0}$ 为不选 $x$ 节点的最大结果，不难得到以下式子：</p>
<p>$$<br>\begin{align}<br>f_{i,0} &amp;&#x3D; \sum_j \max(f_{j,0},f_{j,1}) \\<br>f_{i,1} &amp;&#x3D; \sum_j f_{j,0} + a_i<br>\end{align}<br>$$</p>
<p>最后的答案就是 $max(f_{1,0},f_{1,1})$。</p>
<p>我们在没有修改点权的情况下一通 $O(n)$ 的DP就可以解决了。</p>
<p>但是对于修改点权的情况下我们无法（也不一定用）承担 $O(nm)$ 的时间复杂度。<br>我们再次看一眼上面的式子，发现只需要更新点权被更改了的节点到根节点的路径上的所有DP值即可。</p>
<p>这样做有一个风险，我们很可能遇到一条链的情况，这时候我们需要更新 $n$ 个节点，我们担不起这样的时间复杂度。<br>我们希望只需要更新 $O(\log n)$ 级别的节点……</p>
<p>tbl大神从上古论文中翻出来一个“全局平衡二叉树”（<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2Jsb2cvX3Bvc3QvNDY5Njc=">题解在此</span>），（看起来）比单独树剖要好写，还不会被卡。<br>“全局平衡二叉树”固然好，但是Kaiser不会。<br>所以这里就只介绍树剖做法了。</p>
<p>树剖有一个性质，就是其重链个数不超过 $O(\log n)$ 条，我们最多需要更新的次数也不多于 $O(\log n)$ 次。</p>
<p>这样我们就可以将我们的复杂度降为 $O(m\log n)$ 级别的，看一下是可以过 $10^5$ 的数据的。</p>
<h1 id="维护信息"><a href="#维护信息" class="headerlink" title="维护信息"></a>维护信息</h1><p>然后我们考虑如何去维护这种信息。</p>
<p>同一条重链上的节点DFS序都是连续的，这让我们可以使用线段树等数据结构进行维护。</p>
<p>我们保持 $f$ 数组的定义不变，新建一个 $g$ 数组来迎合树剖剖出来的重儿子和轻儿子的概念。<br>我们定义 $g_{i,0}$ 代表 $i$ 号节点所有轻儿子都不取的结果，$g_{i,1}$ 代表 $i$ 号节点的轻儿子可取可不取的结果。<br>这样我们就可以大大简化我们的DP式子：</p>
<p>$$<br>\begin{align}<br>f_{i,0} &amp;&#x3D; g_{i,0} + \max(f_{son_i,0},f_{son_i,1}) \\<br>f_{i,1} &amp;&#x3D; g_{i,1} + a_i + f_{son_i,0}<br>\end{align}<br>$$</p>
<p>特殊地，对于叶子结点，$g_{i,0}&#x3D;g_{i,1}&#x3D;0$。</p>
<p>我们不如再合并一下，让 $g_{i,1}$ 直接代表只考虑轻儿子和自己的最大权独立集，相当于原来的 $g_{i,1}+a_i$。<br>这样我们的式子里面就只剩下 $f$ 和 $g$ 了。</p>
<p>这样子仍然不好维护。</p>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>我们考虑像维护广义斐波那契数列那样维护信息，也就是定义一个矩阵和转移矩阵，用矩阵乘的方式来维护我们的信息。</p>
<p>我们大胆地定义一个新运算 $\odot$，定义 $\mathbf{A} \odot \mathbf{B}$ 的结果 $\mathbf{C}$ 为：</p>
<p>$$<br>\mathbf{C}_{i,j} &#x3D; \max_k (\mathbf{A}_{i,k},\mathbf{B}_{k,j})<br>$$</p>
<p>相当于就是把正常矩阵乘法里面的 $\sum$ 改为了 $\max$。<br>不知道什么原因，可能是取max和求和都具有结合律吧，这个操作就是满足结合律，我们就可以用矩阵乘法来维护它。</p>
<p>然后我们把我们的式子拆成类似这样的形式：</p>
<p>$$<br>\begin{align}<br>f_{i,0} &amp;&#x3D; \max(f_{son_i,0}+g_{i,0},f_{son_i,1}+g_{i,0}) \\<br>f_{i,1} &amp;&#x3D; \max(f_{son_i,0}+g_{i,1},-\infty)<br>\end{align}<br>$$</p>
<p>这样子我们就可以利用矩阵维护了。</p>
<p>我们确定我们的状态矩阵是长这个样子的：$[f_{i,0},f_{i,1}]$</p>
<p>然后我们需要找到一个转移矩阵 $\mathbf{U}$ 来使得 $[f_{son_i,0},f_{son_i,1}] \odot \mathbf{U} &#x3D; [f_{i,0},f_{i,1}]$。</p>
<p>经过一番推导，我们可以得出我们的转移矩阵是 $\begin{bmatrix}g_{i,0}&amp;g_{i,1}\\g_{i,0}&amp;-\infty\end{bmatrix}$。<br>（比较简单我就不写了）</p>
<p>于是我们就可以开心维护了。</p>
<p>对于每一个节点，我们存储的是一个转移矩阵。在重链上的时候直接就求区间积，需要跳轻边的时候更新转移矩阵即可。</p>
<p>不过我们访问重链的时候是先访问链顶再访问链尾，我们的左右乘关系需要倒过来，整理一下可得<br>$$<br>\begin{bmatrix}g_{i,0}&amp;g_{i,1}\\g_{i,0}&amp;-\infty\end{bmatrix}<br>\odot<br>\begin{bmatrix}f_{son_i,0}\\f_{son_i,1}\end{bmatrix}&#x3D;<br>\begin{bmatrix}f_{i,0}\\f_{i,1}\end{bmatrix}<br>$$</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>;</span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">1e15</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span></span><br><span class="line">&#123;</span><br><span class="line">    ll m[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">Matrix</span>() &#123; <span class="built_in">memset</span>(m, <span class="number">-0x3f</span>, <span class="built_in">sizeof</span>(m)); &#125;</span><br><span class="line">    <span class="keyword">inline</span> Matrix <span class="keyword">operator</span> * (Matrix b)</span><br><span class="line">    &#123;</span><br><span class="line">        Matrix c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++)</span><br><span class="line">                    c.m[i][j] = <span class="built_in">max</span>(c.m[i][j], m[i][k] + b.m[k][j]);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fa[N], son[N], sz[N], dep[N], top[N];</span><br><span class="line"><span class="type">int</span> id[N], dfn[N], ed[N], cnt;</span><br><span class="line">ll f[N][<span class="number">2</span>];</span><br><span class="line">Matrix val[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    Matrix v;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].v = tr[p &lt;&lt; <span class="number">1</span>].v * tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].l = l, tr[p].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].v = val[dfn[l]];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">segadd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].l == tr[p].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].v = val[dfn[x]];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid)<span class="built_in">segadd</span>(p &lt;&lt; <span class="number">1</span>, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">segadd</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Matrix <span class="title">segsum</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].l == l &amp;&amp; tr[p].r == r)<span class="keyword">return</span> tr[p].v;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span>, l, mid) * <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[p] = father, dep[p] = dep[father] + <span class="number">1</span>, sz[p] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j == father)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(j, p);</span><br><span class="line">        sz[p] += sz[j];</span><br><span class="line">        <span class="keyword">if</span> (sz[j] &gt; sz[son[p]])son[p] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id[p] = ++cnt, dfn[cnt] = p, top[p] = t;</span><br><span class="line">    ed[t] = <span class="built_in">max</span>(ed[t], cnt);</span><br><span class="line">    f[p][<span class="number">0</span>] = <span class="number">0</span>, f[p][<span class="number">1</span>] = a[p];</span><br><span class="line">    val[p].m[<span class="number">0</span>][<span class="number">0</span>] = val[p].m[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    val[p].m[<span class="number">1</span>][<span class="number">0</span>] = a[p];</span><br><span class="line">    <span class="keyword">if</span> (son[p])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs2</span>(son[p], t);</span><br><span class="line">        f[p][<span class="number">0</span>] += <span class="built_in">max</span>(f[son[p]][<span class="number">0</span>], f[son[p]][<span class="number">1</span>]);</span><br><span class="line">        f[p][<span class="number">1</span>] += f[son[p]][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j == fa[p] || j == son[p])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(j, j);</span><br><span class="line">        f[p][<span class="number">0</span>] += <span class="built_in">max</span>(f[j][<span class="number">0</span>], f[j][<span class="number">1</span>]);</span><br><span class="line">        f[p][<span class="number">1</span>] += f[j][<span class="number">0</span>];</span><br><span class="line">        val[p].m[<span class="number">0</span>][<span class="number">0</span>] += <span class="built_in">max</span>(f[j][<span class="number">0</span>], f[j][<span class="number">1</span>]);</span><br><span class="line">        val[p].m[<span class="number">0</span>][<span class="number">1</span>] = val[p].m[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        val[p].m[<span class="number">1</span>][<span class="number">0</span>] += f[j][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addpath</span><span class="params">(<span class="type">int</span> p, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    val[p].m[<span class="number">1</span>][<span class="number">0</span>] += k - a[p];</span><br><span class="line">    a[p] = k;</span><br><span class="line">    Matrix bef, aft;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        bef = <span class="built_in">segsum</span>(<span class="number">1</span>, id[top[p]], ed[top[p]]);</span><br><span class="line">        <span class="built_in">segadd</span>(<span class="number">1</span>, id[p]);</span><br><span class="line">        aft = <span class="built_in">segsum</span>(<span class="number">1</span>, id[top[p]], ed[top[p]]);</span><br><span class="line">        p = fa[top[p]];</span><br><span class="line">        val[p].m[<span class="number">0</span>][<span class="number">0</span>] += <span class="built_in">max</span>(aft.m[<span class="number">0</span>][<span class="number">0</span>], aft.m[<span class="number">1</span>][<span class="number">0</span>]) - <span class="built_in">max</span>(bef.m[<span class="number">0</span>][<span class="number">0</span>], bef.m[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        val[p].m[<span class="number">0</span>][<span class="number">1</span>] = val[p].m[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        val[p].m[<span class="number">1</span>][<span class="number">0</span>] += aft.m[<span class="number">0</span>][<span class="number">0</span>] - bef.m[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> type[<span class="number">10</span>];</span><br><span class="line">ll sum;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    cin &gt;&gt; type;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, x, v, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;u, &amp;x, &amp;v, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> ((x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) &amp;&amp; (fa[u] == v || fa[v] == u))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll v1 = a[u], v2 = a[v];</span><br><span class="line">        <span class="built_in">addpath</span>(u, a[u] + (x == <span class="number">1</span> ? -INF : INF));</span><br><span class="line">        <span class="built_in">addpath</span>(v, a[v] + (y == <span class="number">1</span> ? -INF : INF));</span><br><span class="line">        Matrix ans = <span class="built_in">segsum</span>(<span class="number">1</span>, id[<span class="number">1</span>], ed[<span class="number">1</span>]);</span><br><span class="line">        ll res = sum - <span class="built_in">max</span>(ans.m[<span class="number">0</span>][<span class="number">0</span>], ans.m[<span class="number">1</span>][<span class="number">0</span>]) + (x == <span class="number">1</span> ? <span class="number">0</span> : INF) + (y == <span class="number">1</span> ? <span class="number">0</span> : INF);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">        <span class="built_in">addpath</span>(u, v1);</span><br><span class="line">        <span class="built_in">addpath</span>(v, v2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>树链剖分</tag>
        <tag>动态DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P5290 [十二省联考 2019] 春节十二响 题解</title>
    <url>/solutions/solution-p5290/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">春节十二响</div>
<div id="problem-info-from">十二省联考 2019</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDUyOTA=">Luogu P5290</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8zMDUy">LibreOJ L3052</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzA3NC8=">AcWing 3071</span></li></ul></div>

<hr>
<p>在想不到正解之前，我们可以看到出题人对于树是一条链的情况给了15分。</p>
<p>我们可以先想想一条链上的做法，毕竟树可以被剖成若干条链嘛。</p>
<p>然后就是看根节点的儿子数量。<br>如果只有一个儿子的话就输出 $\sum M_i$，<br>如果有两个儿子的话就对其左右子树分别建立一个堆，每一次取出两个堆的堆顶进行比较，取$\max$之后加入答案。当一个堆取尽之后，把另一个对中的所有元素加入答案，最后加入 $M_1$ 即可。</p>
<p>然后考虑将这个推到树上去。</p>
<p>如果我们从下往上合并每一个节点的所有子树的话，其实还是几条链的合并，因为我们最终会将一棵树合并为一条链，忽略了其他对答案不产生影响的信息。</p>
<p>从而最终还是进行了类似上面的链与链之间的合并，正确性也是毋庸置疑的。</p>
<p>时间复杂度 $O(n^2)$，预期得分60分。</p>
<p>然后我们尝试优化复杂度。</p>
<p>对于两棵子树 $x$ 和 $y$，我们假定 $\operatorname{sz}(x) \geq \operatorname{sz}(y)$。那么，按照我们上面的做法，我们的复杂度是 $O(\operatorname{sz}(x))$ 的。</p>
<p>我们考虑将 $y$ 合并到 $x$ 内，这样就省去了再将 $x$ 中的多余节点加入新堆中的操作了，时间复杂度就可以优化为 $O(\operatorname{sz}(y))$。</p>
<p>最后总的复杂度就是 $O(n \log n)$。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) f = -f; c = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="number">48</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, a[N], f;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N], t;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; tr[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].<span class="built_in">size</span>() &lt; tr[y].<span class="built_in">size</span>()) <span class="built_in">swap</span>(tr[x], tr[y]);</span><br><span class="line">    <span class="keyword">while</span>(tr[y].<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        t.<span class="built_in">push_back</span>(<span class="built_in">max</span>(tr[x].<span class="built_in">top</span>(), tr[y].<span class="built_in">top</span>()));</span><br><span class="line">        tr[x].<span class="built_in">pop</span>(), tr[y].<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(t.<span class="built_in">size</span>()) tr[x].<span class="built_in">push</span>(t.<span class="built_in">back</span>()), t.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; e[x].<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="built_in">dfs</span>(e[x][i]), <span class="built_in">merge</span>(x, e[x][i]);</span><br><span class="line">    tr[x].<span class="built_in">push</span>(a[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        a[i] = <span class="built_in">read</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f = <span class="built_in">read</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        e[f].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(tr[<span class="number">1</span>].<span class="built_in">size</span>()) ans += tr[<span class="number">1</span>].<span class="built_in">top</span>(), tr[<span class="number">1</span>].<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>STL</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>P5752 [NOI1999] 棋盘分割 题解</title>
    <url>/solutions/solution-p5752/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">棋盘分割</div>
<div id="problem-info-from">NOI 1999</div>
<div id="problem-info-difficulty">提高+ /省选-</div>
<div id="problem-info-color">#3498db</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDU3NTI=">Luogu P5752</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvMzIzLw==">AcWing 321</span></li></ul></div>

<hr>
<p>题目本身已经很简洁了，我这里就不再赘述了。</p>
<p>题目中说的“均方差” $\sigma$，其实就是标准差 $s$。</p>
<p>我们如果想要使标准差 $s$ 最小化，可以使方差 $s^2$ 最小化，效果是一样的。</p>
<p>我们可以观察到，不管我们怎么取值，我们 $\bar{x}$ 的值一定等于 $\dfrac{\sum\limits_{i&#x3D;1}^8 \sum\limits_{j&#x3D;1}^8 a_{i,j}}{n}$。所以我们可以提前预处理出来 $\bar{x}$，使用区间DP的方式来最小化 $\dfrac{(x_i - \bar{x})^2}{n}$。</p>
<p>我们设我们的DP数组为 $f[x_1][y_1][x_2][y_2][k]$，代表在已经切了 $k$ 刀时，左上角为 $(x_1,y_1)$，右下角为 $(x_2,y_2)$ 的这一个矩形所对应的DP值。</p>
<p>由于暴力枚举循环会很多，所以这里采用了记忆化搜索的方法。</p>
<p>每一次我们往下面的状态转移的时候，我们都有两种方案：横着切与竖着切。<br>两种切法都是枚举分割点，然后向下转移。</p>
<p>向下转移也有两种转移的方法，切成的两半都可以向下继续搜索，而剩下的部分就直接利用二维前缀和 $O(1)$ 求值就可以了。</p>
<p>当然我们还有另外一种方法，就是维护平方和 $\sum x_i^2$，使平方和最小。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>, M = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> s[M][M];</span><br><span class="line"><span class="type">double</span> f[M][M][M][M][N];</span><br><span class="line"><span class="type">double</span> X;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> delta = s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>];</span><br><span class="line">    delta = delta - X;</span><br><span class="line">    <span class="keyword">return</span> delta * delta;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x1][y1][x2][y2][k] &gt;= <span class="number">0</span>)<span class="keyword">return</span> f[x1][y1][x2][y2][k];</span><br><span class="line">    <span class="keyword">if</span>(k == n)<span class="keyword">return</span> f[x1][y1][x2][y2][k] = <span class="built_in">get</span>(x1, y1, x2, y2);</span><br><span class="line">    <span class="type">double</span> t = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x1; i &lt; x2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t = <span class="built_in">min</span>(t, <span class="built_in">dp</span>(x1, y1, i, y2, k + <span class="number">1</span>) + <span class="built_in">get</span>(i + <span class="number">1</span>, y1, x2, y2));</span><br><span class="line">        t = <span class="built_in">min</span>(t, <span class="built_in">dp</span>(i + <span class="number">1</span>, y1, x2, y2, k + <span class="number">1</span>) + <span class="built_in">get</span>(x1, y1, i, y2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = y1; i &lt; y2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t = <span class="built_in">min</span>(t, <span class="built_in">dp</span>(x1, y1, x2, i, k + <span class="number">1</span>) + <span class="built_in">get</span>(x1, i + <span class="number">1</span>, x2, y2));</span><br><span class="line">        t = <span class="built_in">min</span>(t, <span class="built_in">dp</span>(x1, i + <span class="number">1</span>, x2, y2, k + <span class="number">1</span>) + <span class="built_in">get</span>(x1, y1, x2, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x1][y1][x2][y2][k] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            s[i][j] += s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    X = ( <span class="type">double</span> )s[m][m] / n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>, <span class="built_in">sqrt</span>(<span class="built_in">dp</span>(<span class="number">1</span>, <span class="number">1</span>, m, m, <span class="number">1</span>) / n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面还有一个维护平方和的代码，也有相应的题目，是<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDE0MzY=">洛谷P1436</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>, M = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> s[M][M];</span><br><span class="line">ll f[M][M][M][M][N];</span><br><span class="line">ll x;</span><br><span class="line"><span class="function">ll <span class="title">get</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll delta = s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> delta * delta;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dp</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x1][y1][x2][y2][k] &gt;= <span class="number">0</span>)<span class="keyword">return</span> f[x1][y1][x2][y2][k];</span><br><span class="line">    <span class="keyword">if</span>(k == n)<span class="keyword">return</span> f[x1][y1][x2][y2][k] = <span class="built_in">get</span>(x1, y1, x2, y2);</span><br><span class="line">    ll t = <span class="number">1e15</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x1; i &lt; x2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t = <span class="built_in">min</span>(t, <span class="built_in">dp</span>(x1, y1, i, y2, k + <span class="number">1</span>) + <span class="built_in">get</span>(i + <span class="number">1</span>, y1, x2, y2));</span><br><span class="line">        t = <span class="built_in">min</span>(t, <span class="built_in">dp</span>(i + <span class="number">1</span>, y1, x2, y2, k + <span class="number">1</span>) + <span class="built_in">get</span>(x1, y1, i, y2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = y1; i &lt; y2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t = <span class="built_in">min</span>(t, <span class="built_in">dp</span>(x1, y1, x2, i, k + <span class="number">1</span>) + <span class="built_in">get</span>(x1, i + <span class="number">1</span>, x2, y2));</span><br><span class="line">        t = <span class="built_in">min</span>(t, <span class="built_in">dp</span>(x1, i + <span class="number">1</span>, x2, y2, k + <span class="number">1</span>) + <span class="built_in">get</span>(x1, y1, x2, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x1][y1][x2][y2][k] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            s[i][j] += s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">dp</span>(<span class="number">1</span>, <span class="number">1</span>, m, m, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>P5994 [PA2014] Kuglarz 题解</title>
    <url>/solutions/solution-p5994/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">Kuglarz</div>
<div id="problem-info-from">PA 2014</div>
<div id="problem-info-difficulty">提高+ /省选-</div>
<div id="problem-info-color">#3498db</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDU5OTQ=">Luogu P5994</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzM3MTQ=">BZOJ #3714</span></li></ul></div>

<hr>
<p>首先我们可以想到一个性质，就是我们在知道了 $[l,r_1]$ 和 $[l,r_2]$ 的奇偶性了之后，我们就知道了 $[r_1+1,r_2]$ 的奇偶性。</p>
<p>这与我们连边很像，所以我们可以尝试将其转化为“连接了 $(l,r_1)$ 和 $(l,r_2)$ 之后，$(r_1+1,r_2)$ 就联通了”的这种形式，这样我们就可以对其使用一些图论有关的算法来求解了。</p>
<p>但是这个+1就很不方便，不符合我们正常连边时候的性质，我们需要想办法将其去掉。<br>我们可以将询问 $[l,r]$ 的奇偶性转化为连接 $(l-1,r)$，这样我们就符合了连通性的规则了。</p>
<p>现在我们需要知道每一个点的奇偶性，就相当于是让图中的所有点都联通。同时还需要让我们的总花费最小，这就相当于是让图中的边权和最小。</p>
<p>于是我们就直接跑最小生成树即可。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>, M = <span class="number">4000010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> edge &amp;a) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; a.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;x);</span><br><span class="line">            e[m++] = &#123; i - <span class="number">1</span>,j,x &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)p[i] = i;</span><br><span class="line">    <span class="built_in">sort</span>(e, e + m);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = e[i].a, b = e[i].b, w = e[i].w;</span><br><span class="line">        <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(pa != pb)</span><br><span class="line">        &#123;</span><br><span class="line">            p[pa] = pb;</span><br><span class="line">            ans += w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>最小生成树</tag>
        <tag>建图</tag>
      </tags>
  </entry>
  <entry>
    <title>P7619 [COCI2011-2012#2] RASPORED 题解</title>
    <url>/solutions/solution-p7619/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">RASPORED</div>
<div id="problem-info-from">COCI 2011-2012 #2</div>
<div id="problem-info-difficulty">提高+ /省选-</div>
<div id="problem-info-color">#3498db</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQ2NDM=">Luogu P4643</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzMxNzk=">BZOJ #3179</span></li></ul></div>

<hr>
<p>我们首先考虑没有修改的情况。</p>
<p>首先，我们假设已经给所有的居民分配好了一个烘焙披萨的方案，并用 $pos_i$ 代表第 $i$ 位居民的披萨是第 $pos_i$ 个烘焙的。</p>
<p>这样的话，我们设 $C_i$ 为从第 $i$ 名居民身上获取的小费数额（如果为负数则表示需要向该位居民支付的数额的相反数），那么就会有如下的式子：</p>
<p>$$<br>C_i &#x3D; L_i - \sum_{j&#x3D;1}^{pos_i} T_j<br>$$</p>
<p>那么对于 Mirko 收获小费的总和 $\sum_{i&#x3D;1}^n C_i$，我们可以推一下式子：</p>
<p>$$<br>\begin{aligned}<br>\sum_{i&#x3D;1}^n C_i &amp;&#x3D; \sum_{i&#x3D;1}^n (L_i - \sum_{j&#x3D;1}^{pos_i} T_j) \\<br>&amp;&#x3D; \sum_{i&#x3D;1}^n L_i - \sum_{i&#x3D;1}^n \sum_{j&#x3D;1}^{pos_i} T_j \\<br>&amp;&#x3D; \sum_{i&#x3D;1}^n L_i - \sum_{i&#x3D;1}^n T_i \times (n- pos_i + 1)<br>\end{aligned}<br>$$</p>
<p>最后一步是这样推出来的：</p>
<p>对于 $T_i$ 来说，它会在计算所有 $pos_j \geq pos_i$ 的 $j$ 的时候被计算到，所以总共就是 $\sum_{j&#x3D;pos_i}^n T_i$，即 $T_i \times (n-pos_i + 1)$。</p>
<hr>
<p>然后看带修改的。</p>
<p>我们看刚才推出来的式子，可以看出我们能够对于 $L$ 与 $T$ 分开考虑，而事实上我们也就是这样做的。</p>
<p>我们对于一开始没有被修改时的数据计算出一个 $suml &#x3D; \sum_{i&#x3D;1}^n L_i$，然后再计算出一个 $sumt &#x3D; \sum_{i&#x3D;1}^n T_i \times (n- pos_i + 1)$。<br>我们最终输出的数值就是 $suml-sumt$。</p>
<p>假设我们有了一个新的修改，将 $(L_x,T_x)$ 修改为 $(L_y,T_y)$。</p>
<p>对于 $suml$，其只需要变为 $suml-L_x+L_y$ 即可。</p>
<p>对于 $sumt$，我们可以看成首先从数列里面删除了一个 $T_x$，然后再插入了一个 $T_y$；其中 $T_x$ 删除前的位置是 $pos_x$，$T_y$ 删除后的位置是 $pos_y$。</p>
<p>我们可以将删除和插入分开讨论，也可以只讨论改变位置的元素。</p>
<p>如果分开讨论删除和插入的话，我们的分析过程是这个样子的：</p>
<ol>
<li>对于 $\forall T_i &lt; T_x$，我们的 $pos_i$ 不会变，但是 $n$ 会因删除而减小 $1$；而对于 $\forall T_i \geq T_x$，我们的 $pos_i$ 和 $n$ 都会减小 $1$ 而最终抵消；对于 $T_x$，我们需要减去它的贡献。</li>
</ol>
<p>所以我们的 $sumt$ 在删除 $T_x$ 之后会变成这个样子：<br>$$<br>sumt \to sumt - T_x \times (n - pos_x + 1) - \sum_{T_i &lt; T_x} T_i<br>$$</p>
<ol start="2">
<li>对于 $\forall T_i &lt; T_x$，我们的 $pos_i$ 不会变，但是 $n$ 会因插入而增大 $1$；而对于 $\forall T_i \geq T_x$，我们的 $pos_i$ 和 $n$ 都会增大 $1$ 而最终抵消；对于 $T_y$，我们需要加上它的贡献。</li>
</ol>
<p>所以我们的 $sumt$ 在插入 $T_y$ 之后会变成这个样子：<br>$$<br>sumt \to sumt + T_x \times (n - pos_y + 1) + \sum_{T_i &lt; T_x} T_i<br>$$</p>
<p>如果只讨论改变位置的元素的话，我们的分析过程是这个样子的：</p>
<ol>
<li><p>如果 $T_x &lt; T_y$，那么对于 ${T_i | pos_i \in (pos_x,pos_y)}$，其 $pos_i$ 会减少 $1$，从而导致 $sumt$ 减少 $\sum_{pos_i \in (pos_x,pos_y)} T_i$。</p>
</li>
<li><p>如果 $T_x &gt; T_y$，那么对于 ${T_i | pos_i \in (pos_y,pos_x)}$，其 $pos_i$ 会增加 $1$，从而导致 $sumt$ 增加 $\sum_{pos_i \in (pos_x,pos_y)} T_i$。</p>
</li>
</ol>
<p>总的来看，我们的变化量可以看做 $\sum_{T_i &lt; T_x} T_i - \sum_{T_i &lt; T_x} T_i$。</p>
<p>再加上 $T_y$ 的贡献，减去$T_x$ 的贡献，我们推出的式子跟上面的是一样的。</p>
<hr>
<p>于是我们就需要一种数据结构，支持</p>
<ol>
<li>插入和删除元素</li>
<li>查询小于一个元素的数字个数</li>
<li>查询小于一个元素的数字之和</li>
</ol>
<p>树状数组、权值线段树和平衡树均可。</p>
<p>我这里使用的是替罪羊树。</p>
<p>对于不知道替罪羊树的人，我在这里安利一下<a href="/OI/scapegoat-tree">我的博客</a>，同时也给出<span class="exturl" data-url="aHR0cHM6Ly9vaS13aWtpLm9yZy9kcy9zZ3Qv">OI-Wiki</span>关于替罪羊树的讲解。</p>
<p>替罪羊树虽然比较慢，但是所有的操作时间复杂度均摊之后都是 $O(\log n<br>)$ 级别的。</p>
<p>这里粘一下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line">ll n, m;</span><br><span class="line"><span class="type">double</span> alpha = <span class="number">0.75</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Scapegoat</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ls, rs;</span><br><span class="line">    ll w, wn;</span><br><span class="line">    <span class="type">int</span> s, sz, sd;</span><br><span class="line">    ll sum;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="type">int</span> cnt, rt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].s = tr[tr[p].ls].s + tr[tr[p].rs].s + <span class="number">1</span>;</span><br><span class="line">    tr[p].sz = tr[tr[p].ls].sz + tr[tr[p].rs].sz + tr[p].wn;</span><br><span class="line">    tr[p].sd = tr[tr[p].ls].sd + tr[tr[p].rs].sd + (tr[p].wn != <span class="number">0</span>);</span><br><span class="line">    tr[p].sum = tr[tr[p].ls].sum + tr[tr[p].rs].sum + tr[p].wn * tr[p].w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canrbu</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tr[p].wn &amp;&amp; (alpha * tr[p].s &lt;= ( <span class="type">double</span> )<span class="built_in">max</span>(tr[tr[p].ls].s, tr[tr[p].rs].s) ||</span><br><span class="line">    ( <span class="type">double</span> )tr[p].sd &lt;= alpha * tr[p].s);</span><br><span class="line">&#125;<span class="comment">//can rebuild</span></span><br><span class="line"><span class="type">int</span> ldr[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbuunf</span><span class="params">(<span class="type">int</span> &amp;ldc, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">rbuunf</span>(ldc, tr[p].ls);</span><br><span class="line">    <span class="keyword">if</span>(tr[p].wn)ldr[ldc++] = p;</span><br><span class="line">    <span class="built_in">rbuunf</span>(ldc, tr[p].rs);</span><br><span class="line">&#125;<span class="comment">//rebuild-unfold</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rbubld</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    tr[ldr[mid]].ls = <span class="built_in">rbubld</span>(l, mid);</span><br><span class="line">    tr[ldr[mid]].rs = <span class="built_in">rbubld</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">calc</span>(ldr[mid]);</span><br><span class="line">    <span class="keyword">return</span> ldr[mid];</span><br><span class="line">&#125;<span class="comment">//rebuild-build</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rbuild</span><span class="params">(<span class="type">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ldc = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rbuunf</span>(ldc, p);</span><br><span class="line">    p = <span class="built_in">rbubld</span>(<span class="number">0</span>, ldc);</span><br><span class="line">&#125;<span class="comment">//rebuild</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;p, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">    &#123;</span><br><span class="line">        p = ++cnt;</span><br><span class="line">        <span class="keyword">if</span>(!rt)rt = <span class="number">1</span>;</span><br><span class="line">        tr[p].w = k;</span><br><span class="line">        tr[p].ls = tr[p].rs = <span class="number">0</span>;</span><br><span class="line">        tr[p].wn = tr[p].s = tr[p].sz = tr[p].sd = <span class="number">1</span>;</span><br><span class="line">        tr[p].sum = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[p].w == k)tr[p].wn++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].w &lt; k)<span class="built_in">insert</span>(tr[p].rs, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">insert</span>(tr[p].ls, k);</span><br><span class="line">        <span class="built_in">calc</span>(p);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">canrbu</span>(p))<span class="built_in">rbuild</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loschn</span><span class="params">(<span class="type">int</span> &amp;p, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].w == k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[p].wn)tr[p].wn--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[p].w &lt; k)<span class="built_in">loschn</span>(tr[p].rs, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">loschn</span>(tr[p].ls, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">calc</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">canrbu</span>(p))<span class="built_in">rbuild</span>(p);</span><br><span class="line">&#125;<span class="comment">//löschen，delete是关键字就不用了</span></span><br><span class="line"><span class="function">ll <span class="title">uprgtr</span><span class="params">(<span class="type">int</span> p, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].w == k &amp;&amp; tr[p].wn)</span><br><span class="line">        <span class="keyword">return</span> tr[tr[p].ls].sz;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].w &lt; k)</span><br><span class="line">        <span class="keyword">return</span> tr[tr[p].ls].sz + tr[p].wn + <span class="built_in">uprgtr</span>(tr[p].rs, k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">uprgtr</span>(tr[p].ls, k);</span><br><span class="line">&#125;<span class="comment">//相当于是使用greater&lt;&gt;函数排序之后的upper_bound</span></span><br><span class="line"><span class="comment">//输出的结果是小于某个元素的数的个数</span></span><br><span class="line"><span class="function">ll <span class="title">uprsum</span><span class="params">(<span class="type">int</span> p, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].w == k &amp;&amp; tr[p].wn)</span><br><span class="line">        <span class="keyword">return</span> tr[tr[p].ls].sum;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].w &lt; k)</span><br><span class="line">        <span class="keyword">return</span> tr[tr[p].ls].sum + tr[p].wn * tr[p].w + <span class="built_in">uprsum</span>(tr[p].rs, k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">uprsum</span>(tr[p].ls, k);</span><br><span class="line">&#125;<span class="comment">//跟上面差不多，输出的是小于某个元素的数之和</span></span><br><span class="line">ll suml, sumt;</span><br><span class="line">ll l[N], t[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="type">int</span> temp[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;l[i], &amp;t[i]);</span><br><span class="line">        suml += l[i];</span><br><span class="line">        <span class="built_in">insert</span>(rt, t[i]);</span><br><span class="line">        temp[i] = t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(temp + <span class="number">1</span>, temp + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        sumt += (n - i + <span class="number">1</span>) * temp[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, suml - sumt);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        ll b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld%lld&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        suml -= l[a] - b;</span><br><span class="line">        l[a] = b;</span><br><span class="line">        ll sum1 = <span class="built_in">uprsum</span>(rt, t[a]), cnt1 = <span class="built_in">uprgtr</span>(rt, t[a]);</span><br><span class="line">        <span class="built_in">loschn</span>(rt, t[a]);</span><br><span class="line">        <span class="built_in">insert</span>(rt, c);</span><br><span class="line">        ll sum2 = <span class="built_in">uprsum</span>(rt, c), cnt2 = <span class="built_in">uprgtr</span>(rt, c);</span><br><span class="line">        sumt += c * (n - cnt2) + sum2 - t[a] * (n - cnt1) - sum1;</span><br><span class="line">        t[a] = c;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, suml - sumt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>P8021 [ONTAK2015] Bajtman i Okrągły Robin 题解</title>
    <url>/solutions/solution-p8021/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">Bajtman i Okrągły Robin</div>
<div id="problem-info-from">ONTAK 2015</div>
<div id="problem-info-difficulty">省选/NOI-</div>
<div id="problem-info-color">#9d3dcf</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDgwMjE=">Luogu P8021</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzQyNzY=">BZOJ #4276</span></li></ul></div>

<hr>
<p>我们考虑这样想：</p>
<p>假如商店每个长度为 1 的时间段内只能够被抢劫一次，那么你就只需要站在商店门口盯着就可以了，而把问题抛给了强盗们去解决了——而强盗们的问题是，如何规划抢劫时间才能使被抢劫的财物价值总和最大。</p>
<p>对于这样的问题，我们可以想到带权二分图最大匹配，然后就转化成为了最大费用最大流问题。</p>
<p>我们将每一个强盗和每一个长度为 1 的时间段都设为一个点，然后让每一个强盗向其可以抢劫的时间段区间内的每一个时间段连一条容量为 1、费用为 $c_i$ 的边。<br>然后每一个强盗向源点连边，每一个时间段向汇点连边，这两次连边都是容量为 1、费用为 0。</p>
<p>然后我们会发现，这样连边的话边的数量是 $O(n^2)$ 级别的，无法达到我们的要求。</p>
<p>于是我们就引入了线段树优化建图这样一种节约边数的方式，使得边的数量减小为 $O(\log{n})$ 级别的。</p>
<p>线段树优化建图的大意就是将线段树的区间作为一个中转点，由其向其子节点连边，而不是直接连边。</p>
<p>我们建立线段树的时候，与正常情况下建立线段树的方式是一样的，只不过这里不需要维护任何信息，只需要将每一个叶子节点连向汇点，同时将一个节点与其左右子节点（如果有的话）连边即可。</p>
<p>这道题里因为每一个时间段只能够被抢劫一次（上面说了），所以代表其的点向汇点连的边容量为 1、费用为 0。</p>
<p>但是线段树中父亲节点向子节点连的边的容量就不能是 1 了，必须是 $+\infty$ 才能保证其覆盖的区间都可以被抢劫。</p>
<p>这里写的时候不是特别放心，在结构体里面存了一个节点编号，其实在线段树节点有序的情况下不需要存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].l = l, tr[p].r = r;</span><br><span class="line">    tr[p].id = ++cnt;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add</span>(tr[p].id, T, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">add</span>(tr[p].id, tr[p &lt;&lt; <span class="number">1</span>].id, INF, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">add</span>(tr[p].id, tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].id, INF, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是区间连边。</p>
<p>我们其实只需要向线段树区间加那样，向每一个最长的完全被覆盖的区间连一条容量为 1、费用为 $c_i$ 的边即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">seglnk</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add</span>(k + <span class="number">1</span>, tr[p].id, <span class="number">1</span>, -c[k]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)<span class="built_in">seglnk</span>(p &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)<span class="built_in">seglnk</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后注意一个小细节：线段树内的叶子结点代表的区间是 $[a,a]$，而这里要求的最小区间是 $[a,a+1]$，所以我们可以将右端点自减一来替代一下。</p>
<p>最后放总的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2000010</span>, M = <span class="number">2000010</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">int</span> a[N], b[N], c[N];</span><br><span class="line"><span class="type">int</span> h[N], e[M], f[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> q[N], d[N], pre[N], incf[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">    e[idx] = a, f[idx] = <span class="number">0</span>, w[idx] = -d, ne[idx] = h[b], h[b] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].l = l, tr[p].r = r;</span><br><span class="line">    tr[p].id = ++cnt;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add</span>(tr[p].id, T, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">add</span>(tr[p].id, tr[p &lt;&lt; <span class="number">1</span>].id, INF, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">add</span>(tr[p].id, tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].id, INF, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">seglnk</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add</span>(k + <span class="number">1</span>, tr[p].id, <span class="number">1</span>, -c[k]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)<span class="built_in">seglnk</span>(p &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)<span class="built_in">seglnk</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">memset</span>(incf, <span class="number">0</span>, <span class="built_in">sizeof</span>(incf));</span><br><span class="line">    q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, incf[S] = INF;</span><br><span class="line">    <span class="keyword">while</span>(hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh == N) hh = <span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ver = e[i];</span><br><span class="line">            <span class="keyword">if</span>(f[i] &amp;&amp; d[ver] &gt; d[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[ver] = d[t] + w[i];</span><br><span class="line">                pre[ver] = i;</span><br><span class="line">                incf[ver] = <span class="built_in">min</span>(f[i], incf[t]);</span><br><span class="line">                <span class="keyword">if</span>(!st[ver])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++] = ver;</span><br><span class="line">                    <span class="keyword">if</span>(tt == N) tt = <span class="number">0</span>;</span><br><span class="line">                    st[ver] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> incf[T] &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EK</span><span class="params">(<span class="type">int</span> &amp;flow, <span class="type">int</span> &amp;cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    flow = cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = incf[T];</span><br><span class="line">        flow += t, cost += t * d[T];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = T; i != S; i = e[pre[i] ^ <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            f[pre[i]] -= t;</span><br><span class="line">            f[pre[i] ^ <span class="number">1</span>] += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    S = <span class="number">0</span>, T = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> maxn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a[i], &amp;b[i], &amp;c[i]);</span><br><span class="line">        <span class="built_in">add</span>(S, i + <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        maxn = <span class="built_in">max</span>(maxn, b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = n + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, maxn + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">seglnk</span>(<span class="number">1</span>, a[i], b[i] - <span class="number">1</span>, i);</span><br><span class="line">    <span class="type">int</span> flow, cost;</span><br><span class="line">    <span class="built_in">EK</span>(flow, cost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, -cost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>P8025 [ONTAK2015] Związek Harcerstwa Bajtockiego 题解</title>
    <url>/solutions/solution-p8025/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">Związek Harcerstwa Bajtockiego</div>
<div id="problem-info-from">ONTAK2015</div>
<div id="problem-info-difficulty">提高+ /省选-</div>
<div id="problem-info-color">#3498db</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDgwMjU=">Luogu P8025</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kYXJrYnpvai5jYy9wcm9ibGVtLzQyODE=">BZOJ #4281</span></li></ul></div>

<hr>
<p>这道题的题意已经很简洁了，我们就不需要解释了。</p>
<p>对于每一次操作，我们可以分为两种情况：能到达与不能到达。</p>
<p>能到达的直接跳到对应的点即可，不能到达的就直接模拟直接跳就可以了。</p>
<p>因为数据范围是 $10^6$ 级别的，我们尝试优化复杂度。</p>
<p>首先我们可以使用树剖来求出来两个节点的LCA，这样我们就可以快速判断两者之间的距离。</p>
<p>对于跳不到的情况我们还可以继续往下分为三种情况：跳不到LCA，刚好跳到LCA和跳过了LCA。</p>
<p>对于第一种情况，我们直接跳重链直到跳不动重链为止，然后利用重链上DFS序连续的性质直接输出结束节点编号；<br>对于第二种情况直接输出LCA；<br>对于第三种情况，我们从目标节点开始向上跳 $dis(x,y)-t$ 步即可，而具体的实现与第一种情况无异。</p>
<p>至此，我们就完美解决了所有问题。</p>
<p>总复杂度为 $O(n \log n)$。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>, M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dep[N], fa[N], sz[N], son[N];</span><br><span class="line"><span class="type">int</span> id[N], nw[N], top[N], cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> father, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[p] = depth, fa[p] = father, sz[p] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j == father)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(j, p, depth + <span class="number">1</span>);</span><br><span class="line">        sz[p] += sz[j];</span><br><span class="line">        <span class="keyword">if</span> (sz[j] &gt; sz[son[p]])son[p] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id[p] = ++cnt, nw[cnt] = p, top[p] = t;</span><br><span class="line">    <span class="keyword">if</span> (!son[p])<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[p], t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j == fa[p] || j == son[p])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(j, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[p] != top[q])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[p]] &lt; dep[top[q]])<span class="built_in">swap</span>(p, q);</span><br><span class="line">        p = fa[top[p]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[p] &lt; dep[q])<span class="built_in">swap</span>(p, q);</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (dep[p] - dep[top[p]] + <span class="number">1</span> &lt;= k)</span><br><span class="line">    &#123;<span class="comment">//当可以跳完整条重链</span></span><br><span class="line">        k -= dep[p] - dep[top[p]] + <span class="number">1</span>;</span><br><span class="line">        p = fa[top[p]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nw[id[p] - k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="type">int</span> u;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;u, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v, step;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;v, &amp;step);</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">lca</span>(u, v);</span><br><span class="line">        <span class="type">int</span> dis1 = dep[u] - dep[x], dis2 = dep[v] - dep[x];</span><br><span class="line">        <span class="keyword">if</span> (step &gt;= dis1 + dis2)</span><br><span class="line">        &#123;<span class="comment">//能跳到</span></span><br><span class="line">            u = v;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (step == dis1)</span><br><span class="line">        &#123;<span class="comment">//只能跳到LCA</span></span><br><span class="line">            u = x;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (step &lt; dis1)</span><br><span class="line">        &#123;<span class="comment">//连LCA都跳不到</span></span><br><span class="line">            u = <span class="built_in">jump</span>(u, step);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;<span class="comment">//能跳过LCA</span></span><br><span class="line">            u = <span class="built_in">jump</span>(v, dis2 - (step - dis1));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>树链剖分</tag>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title>P8161 [JOI 2022 Final] 自学（自習） 题解</title>
    <url>/solutions/solution-p8161/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name"><ruby>自学<rt>自習</rt></ruby></div>
<div id="problem-info-from">JOI 2022 Final</div>
<div id="problem-info-difficulty">普及/提高-</div>
<div id="problem-info-color">#ffc116</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDgxNjE=">Luogu P8161</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8zNjYz">LibreOJ L3663</span></li></ul></div>

<hr>
<p>首先我们可以确定，如果我们某一门课自学的效果比老师讲的效果都好的话就不需要去上课了，所以我们让 $a_i &#x3D; \max(a_i,b_i)$。</p>
<p>根据题目给定的数据范围，我们肯定不能用暴力。<br>我们需要一个至少 $O(n \log n)$ 的算法。</p>
<p>数据结构虽然能带一个 $\log$，但是我没有想到任何能够维护这个信息的数据结构。</p>
<p>那就只剩二分了。<br>我们来观察一下到底可不可以二分。</p>
<p>我们二分就只能二分答案了，也就是预期的最低熟练度。<br>而我们能够发现，一旦我们一个预期熟练度 $k$ 能够被满足，那么 $\leq k$ 的所有预期熟练度都可以被满足，这就为我们的二分提供了保障。</p>
<p>那么我们怎么判断一个 $k$ 能否被满足呢？</p>
<p>我们考虑这样一个思路：</p>
<p>我们遍历每一门课程，记录一下这门课的空余时间 $t_i$。$t_i$ 为正时表示该门课可以空出来的时间为 $t_i$ 节课，而为负时表示该门课需要的额外的时间为 $-t_i$ 节课。</p>
<ul>
<li>如果 $ma_i \geq k$，那就意味着这门课不需要听满 $m$ 节，只需要听 $\lceil \dfrac{k}{a_i} \rceil$ 节即可，这给我们留出了 $m - \lceil \dfrac{k}{a_i} \rceil$ 节课的空余时间。令 $t_i &#x3D; m - \lceil \dfrac{k}{a_i} \rceil$。</li>
<li>如果 $ma_i &lt; k$，那么我们就需要用额外的时间来补这门课，所需的额外时间为 $\lceil \dfrac{k - ma_i}{b_i} \rceil$。令 $t_i &#x3D; -\lceil \dfrac{k - ma_i}{b_i} \rceil$。</li>
</ul>
<p>最后将所有的 $t_i$ 加起来，看总和是否为负数。如果为负，那就意味着我们需要花比我们所拥有的时间更多的时间来学习，而这是不可能的，代表着当前最小值不能达成。</p>
<hr>
<p>一个小细节：不开<code>long long</code>会炸。<br>同时判断函数中间可能会出现爆<code>long long</code>的情况，并且二分区间右端点必须为 $10^{18}$ 及以上（$m \leq 10^9,a_i \leq 10^9$），请大家酌情考虑使用<code>__int128</code>。</p>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>;</span><br><span class="line">ll n, m;</span><br><span class="line">ll a[N], b[N];</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//不需要double的ceil</span></span><br><span class="line">    <span class="keyword">if</span> (a % b == <span class="number">0</span>)<span class="keyword">return</span> a / b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a / b + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">chq</span><span class="params">(ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int128 tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m * a[i] &gt;= k)tot += m - <span class="built_in">calc</span>(k, a[i]);</span><br><span class="line">        <span class="keyword">else</span> tot -= <span class="built_in">calc</span>((k - m * a[i]), b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tot &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;b[i]);</span><br><span class="line">        a[i] = <span class="built_in">max</span>(a[i], b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll l = <span class="number">1</span>, r = <span class="number">1e18</span>;</span><br><span class="line">    ll ans;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">chq</span>(mid))l = mid + <span class="number">1</span>, ans = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>P8162 [JOI 2022 Final] 选举 题解</title>
    <url>/solutions/solution-p8162/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name"><ruby>选举<rt>選挙で勝とう</rt></ruby></div>
<div id="problem-info-from">JOI 2022 Final</div>
<div id="problem-info-difficulty">提高+ /省选-</div>
<div id="problem-info-color">#3498db</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDgxNjI=">Luogu P8162</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8zNjY0">LibreOJ L3664</span></li></ul></div>

<hr>
<p>我们首先可以得出一些结论。</p>
<p>首先，我们不会浪费时间。因为演讲时间可以是浮点数，不需要考虑取整的问题，所以如果我们只需要选票的话，我们只会在这个州演讲 $A_i$ 的时间，不会多也不会少。</p>
<p>其次，我们可以将存在多个人同时在不同州演讲的情况转化为只有多个人同时在同一个州演讲的情况。所以我们只需要考虑当前人数和在哪个州演讲就可以了。</p>
<p>然后，我们可以确定我们的演讲顺序。对于一个已经确定了的计划（即每一个州的演讲时间已经确定），我们肯定首先在所有能拿到协作者的州演讲完拿到协作者之后再去其他州演讲。</p>
<p>最后，我们可以将所有的州分为三类，分别是“协作州”、“支持州”和“反对州”。“协作州”指拿到了选票和协作者的州，“支持州”指只拿到了选票的州，而“反对州”指什么也没有拿到的州。<br>如果我们对所有的州按照 $B_i$ 为第一关键字，$A_i$ 为第二关键字来排序的话，我们可以发现，在最后一个“协作州”之前一定没有“反对州”。如果有的话，我们可以将两者调换一下位置，这样结果也不会变劣。</p>
<p>于是我们就可以想到一个DP，$f_{i,j,k}$ 代表前 $i$ 个州中有 $j$ 个“协作州”，$k$ 个“支持州”的最小时间。<br>同时根据上面的性质，我们可以忽略支持州，只枚举协作州，将 $O(n^3)$ 的DP优化到 $O(n^2)$。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> State &amp;x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (~b &amp;&amp; ~x.b) ? b &lt; x.b : b&gt;x.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="type">double</span> f[N][N];</span><br><span class="line"><span class="type">int</span> tmp[N];</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tmp[i] = p[i].a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">            f[i][j] = <span class="number">1e9</span>;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//没有进行过任意一次演讲，耗时为 0</span></span><br><span class="line">    <span class="type">double</span> res = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="built_in">min</span>(x, i); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j] + ((<span class="type">double</span>)p[i].a / (x + <span class="number">1</span>));<span class="comment">//不需要招协作者，就等到最后再演讲</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt;= <span class="number">1</span> &amp;&amp; p[i].b != <span class="number">-1</span>)f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + ((<span class="type">double</span>)p[i].b / j));<span class="comment">//需要招协作者，就立刻开始演讲罢</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = k; i &lt;= n; i++)</span><br><span class="line">        res = <span class="built_in">min</span>(res, f[i][x]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = k - <span class="number">1</span>; i &gt;= x; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(tmp + i + <span class="number">1</span>, tmp + n + <span class="number">1</span>);</span><br><span class="line">        <span class="type">double</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k - i; j++)val += tmp[i + j];</span><br><span class="line">        res = <span class="built_in">min</span>(res, f[i][x] + ((<span class="type">double</span>)val / (x + <span class="number">1</span>)));<span class="comment">//加上只要选票的耗时</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;p[i].a, &amp;p[i].b);</span><br><span class="line">    <span class="built_in">sort</span>(p + <span class="number">1</span>, p + <span class="number">1</span> + n);</span><br><span class="line">    <span class="type">double</span> ans = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; i++)<span class="comment">//枚举招募协作者的数量</span></span><br><span class="line">        ans = <span class="built_in">min</span>(ans, <span class="built_in">get</span>(i));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.15lf\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>P8251 [NOI Online 2022 提高组] 丹钓战 题解</title>
    <url>/solutions/solution-p8251/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">丹钓战</div>
<div id="problem-info-from">NOI Online-S 2022</div>
<div id="problem-info-difficulty">提高+ /省选-</div>
<div id="problem-info-color">#3498db</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDgyNTE=">Luogu P8251</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNDM5My8=">AcWing 4390</span></li></ul></div>

<hr>
<p>看到题目，我们就知道这个题应该跟单调栈有关。</p>
<p>我们考虑每一次将一个二元组压入栈的时候，会弹出所有挡在其前面的二元组，直到碰到一个同时满足 $a_i \neq a_j$ 且 $b_i &lt; b_j$ 的元素才会停下。</p>
<p>然后我们对于某个区间进行考虑。</p>
<p>题目是要求我们对每一个区间开一个单调栈的。<br>但是这样的话，时间复杂度绝对会超标。</p>
<p>所以我们考虑如何将其减小其时间复杂度。</p>
<p>考虑在当前区间左端点 $l$ 之前的二元组。<br>如果 $l$ 可以弹出这些二元组，那么后面一定是不用考虑的，毕竟后面再压入的时候，这些元素也是一定没有的，就不会对后面的元素产生影响。<br>如果 $l$ 不能弹出这些二元组，那么后面也是不用考虑的，毕竟当前区间内没有这个元素，也就不会对后面的元素产生影响了。</p>
<p>那么我们就考虑记录一下，对于每一个二元组，在其被压入单调栈之前所遇到的第一个不能将其弹出的二元组的下标。<br>我们可以将其存储在一个数组里面，考虑将其命名为 $idx[]$。<br>那么，我们对于每一个区间，只需要看一下在这个区间内有多少个元素的 $idx[i] &lt; l$就可以得出答案了。</p>
<p>这样就可以将整道题目分为两个部分：处理数据与回答询问。<br>其中处理数据的时间复杂度与单调栈类似，是 $O(n)$ 的。</p>
<p>但是，我们在回答询问的时候，时间复杂度是 $O(n^2)$ 的。<br>这样会大大影响我们的总用时。<br>（实测35秒左右）</p>
<p>然后我们可以考虑给他加一个 $\log$，比如使用一些数据结构什么的，这样就可以过掉这么大的数据。</p>
<p>于是我们就写了一个树状数组。<br>然后我们就可以将所有的询问离线下来，按照 $l$ 来分组解决了。</p>
<p>我们一开始在预处理完所有的 $idx[]$ 之后，就可以用一个桶来记录所有信息。<br>每一次我们扫到一个不同的 $l$ 的时候，将 $idx[i] &lt; l$ 的所有二元组的编号扔进树状数组里面。<br>处理询问的时候直接在树状数组上面求区间和即可。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> idx[N], tt;</span><br><span class="line"><span class="type">int</span> t[N];</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; tong[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; qus[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, idx;</span><br><span class="line">&#125;sta[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">nod1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">        t[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">        ans += t[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">    sta[<span class="number">0</span>] = &#123; <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (((sta[tt].a == a[i]) || (sta[tt].b &lt;= b[i])) &amp;&amp; (tt &gt; <span class="number">0</span>))</span><br><span class="line">            tt--;</span><br><span class="line">        idx[i] = sta[tt].idx;</span><br><span class="line">        sta[++tt] = &#123; a[i], b[i], i &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        tong[idx[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;q[i].l, &amp;q[i].r);</span><br><span class="line">        qus[q[i].l].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; tong[i - <span class="number">1</span>].<span class="built_in">size</span>(); k++)</span><br><span class="line">            <span class="built_in">add</span>(tong[i - <span class="number">1</span>][k]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> now : qus[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = q[now].l, r = q[now].r;</span><br><span class="line">            ans[now] = <span class="built_in">sum</span>(r) - <span class="built_in">sum</span>(l - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>树状数组</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>P8255 [NOI Online 2022 入门组] 数学游戏 题解</title>
    <url>/solutions/solution-p8255/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">数学游戏</div>
<div id="problem-info-from">NOI Online-J 2022</div>
<div id="problem-info-difficulty">提高+ /省选-</div>
<div id="problem-info-color">#3498db</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDgyNTU=">Luogu P8255</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWN3aW5nLmNvbS9wcm9ibGVtL2NvbnRlbnQvNDM5MS8=">AcWing 4388</span></li></ul></div>

<hr>
<p>题目大意就是，我们给定了 $z$ 和 $x$，我们需要找到一个对应的 $y$，使得 $z &#x3D; x \times y \times \gcd(x,y)$。</p>
<p>当然，我们不一定保证给出的 $z$ 是有解的，所以我们需要快速判定出无解的情况。</p>
<p>我们观察一下 $z$ 的组成。<br>首先 $z$ 必须被 $x$ 整除。这个非常显而易见。<br>然后 $z$ 必须不为 $0$。这个也很显而易见。<br>这是目前仅靠观察能看出来的无解的情况。</p>
<p>然后我们考虑将 $z$ 分解掉。</p>
<p>设 $\gcd(x,y)&#x3D;g$。<br>因为 $\gcd(x,y)$ 肯定能够整除 $x$ 和 $y$，这样我们就可以将 $x$ 和 $y$ 分解为</p>
<p>$$<br>\begin{cases}<br>x &#x3D; x_1 \times g \\<br>y &#x3D; y_1 \times g<br>\end{cases}<br>$$</p>
<p>这样我们的 $z$ 就可以分解为 $z &#x3D; x_1 \times y_1 \times g^3$。</p>
<p>我们将 $z$ 除以一个 $x$，得到的就是 $y_1 \times g^2$。</p>
<p>这里有一个 $g^2$，如果我们可以通过 $\sqrt{\dfrac{z}{x}}$ 来得到 $g$ 就好了。<br>可惜并不能，因为 $\sqrt{y_1}$ 并不能忽略不计。</p>
<p>我们考虑怎么把 $g^2$ 给单独拎出来。<br>我们在别的地方尝试找出来一个 $g$……</p>
<p>$z$ 里面显然是不能再找了，我们只能找 $x$。<br>想一想，$x^2$ 可以分解为 $x_1^2 \times g^2$。<br>我们如果可以通过 $\gcd(x_1^2 \times g^2,y_1 \times g^2)$ 来得到 $g^2$ 就好了。</p>
<p>实际上还真的可以。</p>
<p>因为我们将 $x$ 和 $y$ 分解的时候，我们找到的 $x_1$ 和 $y_1$ 实际上已经是互质的了。<br>我们求gcd的时候，无法再从 $x_1^2$ 和 $y_1$ 中得到新的公因数了。</p>
<p>所以我们对 $x^2$ 和 $\dfrac{z}{x}$ 求一手gcd就可以得到 $g^2$ 了。</p>
<p>这时候我们并不一定得到了 $g^2$，可能与原来的数据有所偏差。<br>我们给 $g^2$ 开一个根，看 $(\lfloor \sqrt{g^2} \rfloor)^2$ 是否等于 $g^2$。<br>如果不等，那就说明不存在一个整数范围内的 $g$，但是 $g$ 却一定在整数范围内，那就一定无解。<br>否则就继续算下去就可以了。毕竟我们只关心有没有解。</p>
<p>最后我们的 $y$ 就是 $\dfrac{z}{x \times g}$ 了。<br>输出答案即可。</p>
<p>参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll x, z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;x, &amp;z);</span><br><span class="line">        <span class="keyword">if</span>(z % x != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(z == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll yg = z / x;</span><br><span class="line">        ll gg = <span class="built_in">gcd</span>(x * x, yg);</span><br><span class="line">        ll g = <span class="built_in">sqrt</span>(gg);</span><br><span class="line">        <span class="keyword">if</span>(gg != g * g)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, yg / g);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>P8365 [LNOI2022] 吃 题解</title>
    <url>/solutions/solution-p8365/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">吃</div>
<div id="problem-info-from">LNOI 2022</div>
<div id="problem-info-difficulty">提高+ /省选-</div>
<div id="problem-info-color">#3498db</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDgzNjU=">Luogu P8365</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8zNzM3">LibreOJ L3737</span></li></ul></div>

<hr>
<p>一道很有趣的贪心题目。</p>
<p>首先我们可以确定，我们一定是先做加法再做乘法，这样才可以使得数最大。</p>
<p>我们考虑将食物按照 $a_i$ 的大小分为两类：</p>
<ul>
<li>一类是 $a_i &#x3D; 1$ 的，这种食物只能利用它的 $b$，在一开始就全部加到初始体重上面，我们记这个处理好的值为 $B$。</li>
<li>另一类是 $a_i \geq 2$ 的。这种食物里面最多用一个 $b$。因为如果两个食物 $(a_i,b_i)$ 和 $(a_j,b_j)$，我们都用了其 $b$ 属性，且 $b_i \geq b_j$，那么还不如只用 $b_i$，然后用 $a_j$，这样的得数 $(B+b_i)a_j$ 比两者都用 $b$ 的得数 $B+b_i+b_j$ 更优。</li>
</ul>
<p>设第二类食物的 $\prod a_i &#x3D; A$，那么我们一个 $b$ 都不选的结果就是 $AB$。<br>如果我们选择一个 $b$，那么其价值就会变为 $\frac{B+b_i}{a_i}A$。<br>我们枚举找到这个最大的 $\frac{B+b_i}{a_i}$ 即可。<br>当然，如果我们枚举到的所有食物都会让这个 $\frac{B+b_i}{a_i} &lt; B$，那我们还不如不选，此时 $b_i &#x3D; 0,a_i &#x3D; 1$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll a[N], b[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;b[i]);</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="number">1</span>)ans = (ans + b[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> maxn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> ((ans + b[i]) * a[maxn] &gt; (ans + b[maxn]) * a[i])</span><br><span class="line">            maxn = i;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = (ans + b[maxn]) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == maxn)<span class="keyword">continue</span>;</span><br><span class="line">        ans = (ans * a[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>S2OJ #1497. 树 题解</title>
    <url>/solutions/solution-se1497/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="这个密码好像不太正确呢……" data-whm="这篇文章的哈希貌似出现了一点问题，但是您仍然可以看到解密之后的内容。">
  <script id="hbeData" type="hbeData" data-hmacdigest="0a1281c2f465cebcb0dcbb07f1bda80397c9d3634f6070a948be3dc9899655e6">dfee31cc98606e570b6a243cfb69c484d0094c388d5c5130dc4a9b5f224f8dc0a95fa38793058ac1fbe0ec669e9a2c1e9269de44a1db9845700873d6f7eead08900edccb3f414c00b942e513aed58780a97cfdf01117ae1f4f532797219a8f6f0de30331ed7ccabe040976f4ade7bd6de183adf47e3fce5ebc4adda980fcb6c36fa9a94d6e9e93bd29e4fd59b2e0da15dbc96f385efd9e2953d9dada2d1e13d3455da66120e55cfda7ec1bcbb60719714b18b27d6dae8ddd885f9b51e51b81e92660e91adc530dced4c335fa654de7c230d7756a75b222e98b7586054ad69539917a43e08572bfc364d0e25925b13c9cc79dd4f72c4e127f890a53b899824a171a42349b03cb9419a3b0c1796f3176d5848ef3a8a3dc50a4fe2d7e3d512cba04cde5410899f008ef961e4f1e13e3def721ecc5291f0db6839d0eb65f544f4ffeb4eaca72c83229a9f26997d4fe5aeb521d50105558772e0df085191cb5c3fd398e82d370efc59baee136bdd8e57e205b6a0be21f118597cda46f9c8eb33a2370fbe9a15f2aacb13dd03491058e25b1f094085f1aaf7e740685ef3b415d17effa5c66013450c003f013186fa68a104e771d985aa61533499b671d162884f219801b8505c0cbabf833eca16f4d85fa0aad985b0a43883e740e39fcd86dc7e76870583a5f4cc42aaecd35b55bbc866dc0d14e8c3ca1decd59dfb22f6f68b2d053ad8f72567a564248064922cc0fe0d22549f847ce1f7d38e8006c8fa0bcba0bccc160498081a5e6c54282e0fdc5257fe025d8068fa0abd1d78a4223304c1afc40820a5ca86c8a1a008f00424604e9a6631715206932945f95629929dac18d298a80e64d28735ed5ff09b78d594e0216efe37cd0366d089551ab0d1683eaff255bdaa9b6826d09c6b35d4eec8405e298030b16869e241e9e48163d2f56c7b441e77101ce3458f079da57a3850a3f7d1594f1a58cb87deb31dcf47c1d90be853d6b5ccbf4eeb0134d598d9a72a839838fdc4340034b7dd03c6e2b4021a761ef228fba45258cd6d521c7af330d5b7b1490f59f8a8b6b031b8e84e2ca7277804ea7184a9ea63e6e2182c196e4a9e9197bd29dcdaef35d6db42282d7261d5a4b83cf92e9f148e1be2fd596ae4a095fb9389a097022c4e8f63b5d48940f0e102d55b4d5b66585db9418ae28efef0126693bc617a27be3b9d183b9409b62ec8f84f52cf0e5eb54cc423e436b80a127c58e24884a6f6abdc6c123a2bb3212424dec7d9b59b556feb4edc210d153b7f8e874533104f2942f0b55a2c8ed7fb13f0fa317d59f7c6fc47c75750316f293c278bfe336586aa0734d2f9a12bbe497f48c1fceb0b6f7a20bdbdc42c50b11ec6b7a7c09493f0ff1d4442393494754299d22632c9db700a1e3239e189ec365256fdaf7caaa3330a38017e2b366631843c77dba8415eddc43dca4b3958344277017c120a75abb256a11aef1d17dc092313dad4c6659f41052485d6e5930cf98e23cc6e63e918dafd0304aff30f3f01047bc1cff4ab4e717affbd6aeb668998e3cf71279c2e8e436ea4c51ce52d5ef93fff7863d7d0837b0ee70ed600e2a05e110d3363a2dcb7e05dd49380cf3f87e41a5a67a9e49419512555238e2198d7c9eb6e0a367d52f798bfb03b86a563c8ad45d1096ade0166eb48cacf9bcb34538fda45b94b2838b153728e15c5f697e0ac55ede23c1684cebfbeb3a0a2fe3a90573775a055b251850981ee579cd24bad12406a10bfdd3e7704796b3aa6378e54a115deba7ace72954e3674797d6b40d85183bcf11ccf17ff784d2b73535393758354059aed0d30298b7811ebf383e40298ac0cb581a06eeef5405510ee671a37b9e5e5dc7b46c3c8476be75c61c74cf7ad5cb0f91940c9a6b58e903a4c4d7aa8ab77dd67812105fcf3c4c674d46c21ea18b6c0b8959a44b65aadc6a759a255dfb6afd21766641bd078f3648c14d26fae2c81f3022cdd748c863755ef98c74a30a54cd59e522974797f9359fb92367d38e7997ed398f960e4636ae50c0d2dc0157ecfc56362a04bab7969297133aea64efb3de0dc38adcc2bd7a0493101d8394ec688b1dee05ead6a46a7fa39005419d76504b8e543e2aad51021fea09d7786597f1f1dd77591676114970589e73e998b6d706d9e233912447a409ac26dfedd66c60a09a78ad2bd3093aa7e4d4804138cfd55e3d8afb24ea8db6df382686bd8d270f955b0d1eae7edf874d47e2a2b1aec2eae44ffff199df1745a47463e219993caec5d7afa6c25cb3420b5d41f08a4db5dc8a983aaf426d02bc7a0b90eedcc837e5bb48cdbf602a22bc6515fa0e0ea51fe7cff083a932648899ef982dbd1fc3b024ce8108506b5492d9853b25bf102a229ed3229f04d2a725e08936270c8c61c03e9997ed0505cc4b70592735ce4011c6ec0b1b4b9e2191719ca8220c1e1d8efa41e3efa0613eaefcfac66809c5959c1cdff483d93b7edb3e8f268439226880a84add1ee0998f3ab520d9d13a2447f1aebb62137e6659c249d48d0370131e459b179b0280fb4c4bfe04d09cda92a2ed907aa5f9dbac08e3a9899659c22ac0934282d04072a676392731e3a0b8c73c0ab29bbb2243f9369b52f4938b885724d046279afb7e38b2c569cac3a122bec6c5b8f4420a91869fb61168a9469c515a8812ab3a5c348c8e034ce89d0321ec933ae18cfcd74b91de7a5f60fdc873f04e78146a685b20bd393a8a440d9108e70bea5c7f56cf29e955744afe768fffdba26d4f5d33e66c7c5eca10f3168ad221d03f24d7e05604c54a44704d106d3b1745da7525bb76767444ca047f3eae9dcfb26bd80ec9b2dda0492c95024d161633b41ede5fcdd0e8bb6f2775923da37efaafe49adc1a950b55f4b3a8defa9e520b85221c2c23b35d7ccb6ad2b706f5ade91ea30919e66d09edaae4acb718a7e35e573c6f1e9aafff8160735c223394033fa48e2afcee4c7f3251f4cc23adad6f7785e735e1d9cd543e9519f1581f0b9feb1270ef50e6b597220c87a1f937ad723ce7e7242d2aa64e97dc8ecb01a2f41f9ffcc5117975ab995f5c4d8f1d8e23bcf1fcb44bac872717e64808c9381d234bf030807719a3346e7adff655fbfce1631ae59a4c2151c738c89892c5deb10e14d66a0f30d550224026f3033062d83489a72d3f377698859c4d522cc8da35630098702f9a4d8dbaa290feb8252de9afa8604f072420ae70e38a384c6ab3a5f71bc2cfc37227631b0f5fa8f37d8d42067931c8b4e9a60699a9d77fbcfc7cbda5cf22a5eae8e4800916cd1a3520768b9c7aacaa1638e1ac3bcd4f4f60c1a44501a0a04932be4196046f056526b8a2a53ce61844daff6a285ffa40cda4bd2b46bf268b64eef4b61f619ba4fdcf37b5f1b8e3357d230f87b5f3e22c418709215dcebe9082c30d3e8d17fd06e7cef150004c51c82606ee7fccd1ef40aa4d6a02ca016a64454f3a46526e7c321a29cf080965c9ca6e1560a171ee3278127cca94c2079ee1eb38e290246a22ba842aac4d6a90b8292651e3f99e71b1f159d60f190289edab6baa6262e41168d19f5cdd826c0217cb9a7f99f81062a8304da5c8f638bba0f6453761546b9422e07ebcd03eb580daee2cb450a645f3d0e830586e0b3831f37b0437147023d36590c2932c19114fa0277b83804eec74148a7f044dd12a6779b1a2f4188a46d72aa6a3c31aea10f5857cfcc60f7153d5cba3adb4cd9d3d13a9c1b9c3ed6ea6adc0222154884ed0d0b60a7225d15d96174b6cb9e6279b3c0e2093d5a648c9d060f98d04866dc3687b758a854e2ee624a252172161951c8e1b2e10e24b792e8ada9ea6c90dfd4563f6f39e0ef6c5793382431d7789fcb019614f7689be083133005f0f0f613c54fb8c63fd33ea42d3f675feb90434e7e41a94308eb338f7889329cdc10f8c58a8d0f2eff464e0652b5f8b0831b474574cffcfc87df3d303a8e9f5f22b28b5b3005ff93bbad0f45b9f3f0f50ecbb3d280d6cef9fe8add0d67c485bd45d5e25c3b0e9ad4b29e70469eba17c3f8eca56ef386711da8c3daeb30e4f420e4485450b9909e0e728f3d6b2f03bbbd87bb7de601f97f7d36df47f8195fe9bba07c58836119c89c7efd0717f376b899bcd92d6071955b2824a97103532d19f627191205bc6b9a5328f25fbe174aea0be25e2cc83a4759d9d299fab875cfc203cdd2c624d000af3705434c3403aff05b7ad1f0ac981dfc6533f05180736ef24247be15809a1e25900663a89be86d058dfe1fb72a7247dde4407ed457a06ab638c808123478ec07892837e9ff84027e894ce35e06b48cccb622b40c3bf0343ed1c7f7ce3b0292b27bbc0040c9e80d808a8eb383a95fd40c6820a3af86a9f4c2b1ed010725de44e30063cd557e4ae17939cbff39f3791ba1c3d6636774a34939c9bb7a740699b8302c96f26cf3b96435a4a5a8b3882910ceb213548713b23d737a46c03db6e57417250155eadfc53a9d1ca0c8d3eca42bc3494c3e0bbf052a32ee9908e8553039b2b91f447f47ffe68d42b1b69e9939581ad0e074e1db58792f05b251ae597b5adc6c462297d050bf52f67afd41c1c6009904273f16880a6365f3c5dccc681e731d9f99bdb8cc46c83bdb47dac538a755b33375389656c9a41825618cd014b85ecc6e9430a9efd702cef04a0aad9e200d4ecd09e06c81fce41e612a9cfdde29992cb490d3ef62d1d39ddf7a82f8bc2c509af1957a2b2210b80da6fd1fc11540571e68b19ca21a4483949d24da58dc0781ecf03ec5bca3911142bf1c014a1c52a66e5f1a2ee7b0a463df95153fbfc9307e74297eb0b769c3316497aeda491862eae91609685471be60fc7ba8c4b8e9c6c66a5837d951674ac7dd3a1d2b69509e146a1adbbc450f3f731610fc3c9459094b8e8d52c3b555c6e67b2a098e85092b8c754ea6d70d29ddd41d8d7105b59e02c321fab05353aee1d9b12b667dd96d2d4e68e33a5a348d6a14ac29975687837346bf39d883abc95c1051bcd6df462ee5a57138675af144e24ca8c916ad605b9461a140f9e9dbb860bd1f8aa5f0d02215aa0d3d9385d0a83b2cd27af7a25388b6951a5cbc1bf9f0206132636339b320114fc9e1954777bc2702dafb683196b213fca57245c8ec9e1366219360d7b289349bc7c7e71810e9b81396c62187bf09f5675a338feec76c1f51e29618f44b8c0fc239c58a783091748461014da05854c868c8cfb4a7856f2eb8f1846f281d0a5c8f8a8a86828391b66108a0793f2a43a03c7f6f352adabd1cdfdc3b7cae3bbe5fb1cd7a33c13e6066582c793eb8fab1a1cd0507543e5cd7d3947808c04f3e5b2e6feffcca5757aae1afe56641a589eb10c6c5b2b860e1f4aa1b7de8ebdadbddfcd451d64a386fb72a7ae6ab43cc56572e11ee3933e35f672d7d79807e5dc1773014ffe03559cd3c18aa6236640fbe76d3844b2c156b1adb54f2654f9eb59d4e75dde1d9a618c1ea3759f1e7e17869861edeb455bc117a5a9a2c3c1dd9f5cdb8c316c62c3f922e8b7a63379b44cbd69e54540b736948972f8bf78369d97ea2a6be3535a52c92858e664ed27008939861b9cb5657c0e46df41bb8c135ae4d3d3a4f51a7c9ef108da4695af8a2200258169ba9426074e221bb9702ca9e644650629aa4de416bc604560e77141f141052c4f35a8d02391d64b6c395812172a120e45e8de74b585cef6383c0a45c8f543cb432761cd3c0de4fb4673cbc11b99661bd539b1c86ea00a5c04c91dc994313a5427205f232d820966e884d3c5e9cca789cfabc06766fe7f43a6a167a8a0c8ecff5391f6b5af2d6f94fe10b4a8d681db68aa49d193e853c3c343be7afa54754a25617ead52c76aac714e849c3cc1d1ba64905915caa571db1405d0a41b7987199dfb7a219553a6ab6656fd1e27fbde5ecb822b00e64fe330a13fa9b3ce5de6aa939c648fa7a33d567a5e1b2f05b7d7b20726826bcc478c59cac43608fd3739a61edc844d36283e1702de4fb44b903047a4c9dd9b248fffb2c08c4279b0e379c2e5def4faa9b67a04e3313fcc45e5ef8ea94676f3512a26862cf1fd8f328646b68737b4e301cde492422d4e40518695c62cc9449e331bce7115e037815947524586202fc1ef115b8ec93e5b04ef6e97c160d661e976a687c1a57e0865d7dc39a99ffc19e63c62a2ece55acc3f3c91d8e085bb8afe3e5041d2ab0435aecdceab95f80fdc67be30dfad12aa252501e5f0aa101dcdac95b22eb1ba0d5b1907ce5345576ad79d633f3e6410e9b4d5b19f73c34b96cb5826cf46da9effcd12111cbac473f828e95fba4247134dc8ec499ce3a6c15fc4e09cfbd866dc1ed78d36762ecbcd955f3ca367d424e77b156abfd057effcbc44a5808eeb5c9de17b301f369cc37446c970cada1122077cabfa4b6a2fe5ab187750255106ad338e3200dd6d0ee2b6bbc53b53341b1f9f5b80e74234e8f7a7a7c3424e1d5a09451b6f45e1d075fc6cb20be84c0df6c67c05066fd516f6a880262f86d19d70ae79a3d223ebf4d12c6364f1974118f75b91da139cccb85626fef4a4b79c97335af404e8520f78450085283c067d4a699236229e90213ed6c4d0d41ebeac1cf6672dd40e73b1bcffb9663b022829d34caff178e76acc11578864769da92ea5c9255c38ba5ab37e8e3d22b74c9c6c4c8c1e736a4200e24d94dbbff81e2bd1b42a635877f0094fe9a2079be3721b635eb8b068f61eaf1ec9bd2a9c88a445503552a051a971f416c199c54eadcd54edf77fc6991c39df0aaa72deb41127f292e2c52916c8015612b62d6b4bc476422e7218fcb775869520a5d8629f2ceaa3b05b7815f954d95c2b745b5df131a752035ca7d8cfb48c2588d76a271123c2d1657d991183f68132752ea679987cf3100b2f00324fa6e91cd1d71a545bfe1a3b00ec3fab3736a3f884b992b2d1726c50cc879230ab7db8c892970529dbb441554c1c84200f4b1d537b2400ab3146f59e190eea5ba85cc8887d4d8b8e590fcc24dcf8308283e2894e43bc551d09ee40d1eeb196f8d1cff5facd087d97d17ef633756517b5e0dc6ab5d624c7929d6c25bef70200f4f5cdc665313821e8f659663402ad5a727933065e86f8c67e9adc9572e9cd15f34fc50e84c768dcc458a0c4f0e7f5ce2b7692b6c82e68f207fc32d9298fa2c96cff58f719a96556900c7feff37ed4f2b5e36cdcad3b24c13b548e14fae3b9728fe12a5cc5181b9bbb6d6fef348ba206bdbbee96913815e4a445f4f78ebd129526e75014aa0e39daaadf3f84e9f3dfc1be93e6ceab495f97f595dffdc1377ad6d26aebf9e75d80d25ad39f27735b4c813a63a79209fc64c4c0050220a309e7c15a8fc189d64ffe09970b29583bfd892d75c1536fdf30b654fa78fc59cf6d5d0df66d6bb6300d3ec01cf43d8ca0ce25a3c00b0f81f36e25562214908c04b11a617e4e6dfd1ac223b23be96dbcdfb3b3eca203a4eb248cb13f0f3724b69b7baeecc9c0a4f6fb87ffd160f29f8affc6df9d0bfca58d1780b06a7ceabb95bff50ad8a7be72845bf3eab64cde4d530d23a617557aed64fc8a8dfbb6a0a8f68091ca125ace982336a1371aa2fdedc5d6831a27e34d25c513ec15a31a09b6d2331c067c3e370de65cecdad0a4c36d2e858781a33cd8550d893fc5061a4fe247a5db87446f3bac534753499385acd9024b70fc2a3e431d78ebe8fda3870c9600ac01787f98920fbacac0822bc68d0e4986a04c315349e049cf466b484e6a4b9e5d1063e71a197f05b473ca7b7e907b9e34ca6da5cab11b564a10efd0ba32471bd365c036c1e194f954a3fdfb8afd24567717a1c406cfebd849add215edfdfcc30899cc1d08a63bfaf5a3d35dd919e92091f7105ebf176251790627292ff0c8fc61a55d21d358ffcf28fd88c2cf564b293cea930a5f2fa4d4b2c11bd2cbfee2fad2ef5445a0cdfbc33a6da814fd148029aa4604725e01fc2dcc64a761b17e040a3dbf56600e9e5afa69d52023276db924fd33004eb8505d6bf2cb00f4b30607ca28e25c191308c3856e83c6a98ab3bfb1b78eed809b10229cefd2fe16dea16f85fb46da2957f5a48276256e1d72d37d2530b6e42c9478422f73358fcecba3b3b85268e1224d352cca74e21c915dbcd89f3db27239df1d4b41ae20775a332b586beb3ab2251a1d7f6a4de09104995e32f693f719f5687d8ff15057d0de2dee5a91fea38a3a7a23292b901fc30fd1cce02bee0beeee63dc466f05de6111e1e7a7b323af0ff987ff3407657d7b62507c70275fbe65a6b1eec2598294c29454670c1f3096c99858446cc56cd65a7fb0cc9da5ff64a82ca361ecaed48db03e5e385e79f5389bf5c3769de4899b4cb492bb5e3487115930dcfdb7f1b7bb24bf6f9e550ac324efe94e3491798167aca63eb7542fb8116e67233fd07f3ce7c13de7491df599b2b01c882b877574d3521c94d8ed80227c45d4df2e6fca0436e8cba8abae453cd751dded94fe5d8e2ebf6ebdfbf22c7fce9df99f185cac7bf4fe16a7aaf455290f24424514faf5a0daa9ea8cab7b2e4617052ca829213f3d63e2fbd218b377552663de40d21529c6684e9ecb286b85c514a758c2b0d96d7733901909d9a733061ac5da17b100988ff15978e3f9498cd655f9bdb228c66783e94d8f530f9f4797013cbad0bef84f9f66fd0575b9059bbe6ce2902f7707be2b7fae11908cab42119a36e943190dadd97ca4da40b2a65d661e16ff366369c1f6a3e6a0c06ff33080a71de4bdf1243174da01e95d0aa08b5d4111f49844c13ca8f3711e71466573f3bb7d5fa82074c7066b95300387c70df4d5d82e0fb4cfc79ae8109e26c52032e0cc467e36109f143b5c171a8ca85ef0689c31a6652b39530b28edc20d96d17b0d3f23379abf9a17763eeb386dd1a1e40ac3451dd6e08d5f064401f3c72a4804224be1411b6be17f4f85acb7134ec19c7e0f94f1d2f60208244a33ab56e2ef80ac921511c976b19bb4a56ac5b44ddd1ff2a871838c7f0895a25cc11487f02e3fa868551177f52a9e08d8052baf49079c0b3998211a1ad4d9a6678b1efe8957fac7088bc713a56abbac80060c17b39be469356747e0794675c14805b625e62f845a5f9d5ea50e63eaca11ac45d719d246026a188a6c92c0f19050da5c66113223d9fece2ddbac3bd7096e04cf5c6b14e6088d77127963d5c792105b3f363bd1dc3a323f05231b9eec29c11ad9652a177e20ee3e667a9f3f33ff4d2a32aab527565f3a46418da6cdd7709bedd93f2bf1e1d83f2e6b929f73aba6f498347b67e1226d7bacf21f05b2fc646275ad3e65f978e3d24698128601fbc9e5e57b39f1d7c1f12a271f68d481b3816a4ecc6d5734faed158769f92acfd42fd344f4a9228673763c217600bc060f3fd7288ca0d03f2054b9a50789e897ad9557bef15abf79c3b0a94d260db9f2be19777af76eebde9e8d5223ce8152994f7f1c5d499d9f5693bc4f0222a098b2a57529d6405139c7f1bdc5871f6ec6c8b9dc4e0045d8bc5f28f15214b4d36b7cc3c836216fb7dd53873bdd4f84828fa0691d52aa7ce721fe241db2a1c1edc2b8ac54f0aee9080a2593a8cfbb74b97280ebc4c31b8b857e03b62c8c377e292399e86e287cbc0b32de85b709ccddcec8e4dae2a06925edb43ea375b21ae577e621b41b37f7c078d352c6cefb372d5db863d58384f36345d1f0cb5ed61713d323b80dd5f72c4ec8e23f844ba1576433405ca9bb440fd1e0e6d43bc6d614eeb862b262474e06238dca076345e1452dbd273c3eb8b6c55544f476ea77ba6b9e32e72ba90839c421c3739ee7f60e8a9b1a388d1a5b0ef62fe93b01c3bd5d3a7e13ff9f7a66b7b2fba3746488386dacb1fbce5fe29b3af2670bbcdc90022a69c76804f8ef61bc5cf6038547271fc0da52948b0b73971f7323fa3e53a9d062cfa996e3e70395e5f6cd1a4754393e7200178dfcc3ce5766cbcc8c16328f0d95e85717acb26473da91dfd122854c4dad7366dd33e76d68626e9cd61efc04de1a7a970a0f4a593180ba87bb455cf7ad6fa9a5960493c22abcab1c16180331653aefe5ff9010c781b4ead05e9d93df457ad0b58b91679444abfc82e777d941be2198f723c81f6b9a9e5647d118c2d428eb46cd2b475163728cef012b220fc6159f7e15dd05a066ade6ec769f37c03ee3ba97b2efae25520ee07e510da69ac75f6086adf6b2eee56fe687051e7c86a4f6dbbf462f38425c301be5b7d568549087bae3d778d279e102bb8fc7c4b7e2f4d5654f619cfbb54d3abf9de1db2981356c6fcb8c8c037435426071efbb106199b482c8694dd560a48b0a5f1ed80c7cd7ceec39b5e3e4b471fe22993fae5771bc9aea7d9699d071a38d96fc3b0d11b45b345b3acfc01e6608e54554572488e00901bbcaada9b3700ad63623e98836e8e11bf3810fd8a76c2b5aee4c19390fa5c2f2a500f2a5602d757a51ced690dd2e182208dfa21174d5c4a5127bfae2ff28919f2ef5b958b2338bd50efb3fade713b0974dcb92c97c4c55faf11df8be2524b5e436e7669209c1198943c7651907727acd722beef2d9a45fe5017cf75d7e2fe780f7c07ae8af0ff7af90763b94cb7a4f8fdeb3599656b2722356d89dfaedc75c14d9abe60083fa30f6176f0036985f225f4120cae9730749d6f8a44f6d80318fe2279b77546e88a721616536fe63352883c541b2f5838e82456af298a9923b96ed56f352e5aadc972e2813d4c4042f76a62c83f19957f8125820137080ffd19b37ce87491c58ace6df48387d63a58978f43eb139acc9d6c3bbf45579d352735142f261a929c398fe1b5a4bc2878d0d6aae91147e928b2bdda7e6aedbad7647d4b03e03e477f7f6d8b03e1f1092ada6d9c2e17e40ecfe6278efb0539383d341ea0375505340ffde1204e39089c76b1d8b5d8e8cf64c8d527aef6380e6d4a71ee4df650e7b4a405f2e693d6c50088cf00ca611f0ebf31a259c48fb5078bca76218ecff2a78b1c7aee240170d8df638520a75cfca63f3fdc6bd50b1db77806e64f12222ea140bca5c17b6c7164ec519fe5b1d4654c9cd4071bbf8b7fc1c98da4df91a8be29715e56070a96f7e7711830369a67a6935b48b5bbb59e7b9840f7f93fe7e16320df9b34564c359fb3f61d4393efaf0e839275cb096010056b45c984e16c293452e9bc9f2763f49a905dda2e1ede51c60fceeb95be8598d58b6a3a2c3d7b13cec06dea3937f8e1ccf39a86367cc244479d7f84aa8dcc068aa595ce248f617ee186f370c36b0594e94ab6e5b42bd2f204fc7e7116ec81557fddb7ee6998883ac5629cd25512f244480390e1fc6d7823540ad54b1527fa27d6d6454bc3e5a3262c23e3b474ac6ff2da793e9aa87c43a2e31ce368e5006b32b00b5f4a481103e6323e45d76c622679f6ea33cfe00cb352b0976c43b41f89b0d498e7c37d837a91fc16fbb91260b49fd27970c9ca60a1df24f8f6d1add6223b18e8fb19711d8fe958f3172f0ef89f7f2e25ff2e9ab9fd60f0ef3544a1d92b82af716cd59678ec0645e03e052e60d51744a564c827b050a6f6c2cc027c050395efea6f89315195e847037e742b426faa50d001143b2b72d465bc84e07aaa398bbe6494ed8c973451f998ddf65752b3f0d8cfe3c6226eb2d0c0ed776ff07f00a117980fb277a22899c0ffeffe6241a0be0ef335f640e3d6ac3f1829d3ca8145558f614688fc982a4914d5316ff37c5f6f0df74336317afb90f9d93a6fb6671231b97b661364991c256bcd13cc3551ba920e840d98bf9d3429362c83f3775d230e12de433198b2c21059283685303237bcdc88ed8a10b3aa136fa18629cf66b46534f55b8b771124beec9e619b2a8b8738d077c41e1abf95d2abc5d08e919d3098686bef9c122b8b16119e99880c9872e6d361a26797732774344b0d21c48860f60f7392e465ba0f757764f2364da0739cb07b69e2d4eea41fce21360d88a307e45b8127e034eea54e30201c3b4e570bac29b36da9dcfe53219b3e76ea00eb339232b263f1cccebf849f7a7f351a847b0f50830c330291c96a17c05a542adf0a032bc8d42d61afee3f7ce5f0d67dae55684817a03dee0cfea5fd181b8820c2c9e70b22b754b1576ab452405cf5d697ac5d3f3921ea72d1bf1b41650b7bd4cd56c393c4a0f0d7019fee4ade53ecb835d0bdbe94524dcca416e89b3cd20b174ba3a29046c189d46279a2120bb1b9e2eefc0b9ccd15a21879cd54362826fe239f51b6a0747ceff9b36778bdb7bec4c3fd3dfcf68690607ddba42672fc7ba5bb923cbe40be19f243278adb614ff5d689bf62d7d5d2f30af8b3415ffec13f22fea85dd8fbad58ff022b16dac93118fe147cee019444e787d966bc040f81e94e407d1c1405149e5304d3fc9c0291530842fa3c4db53a0dfaac1090c59194c04dc93d0cc875f58c58e26a233e6c00b50b3289cd023212fdba4af089f5b0d3dd53f3ce43330021accef5eb579523cf636dc6636d2ba08698ad6c78d2e9412d2da05f7045ad0270c8a8c9c8cc0cf60800be1a45520ac8c3c50242cd79882bde55a44483abc8f7353208439ba25d56b90d2aa19b7746f62c3c50f57293148a0607078c416c6818395fed95bdbf331ef2cdeb0bcf750b830ba3b431956550348b02310920b9a6eb671e47d04200d303510b7f6f7e49828c7f605fc8a689c0532a533e6b877ce1e4e2e437465f4fcbf477a3b2a7447a7601e05ada600e2e9383ff886df69d262a3ddf9faa9a713a1c02b55a0a0c58b62c775ca437598f07654ba0f529c325e09ad2a48c07eac97b44e9f98bd6419243d639d5eb6ed13766e52a532d929687d5cd37cc99b1359d52fe590942896c6f95353e81d87787c527dac247dd99d3d33650a335bcd91c21a1d8406b42ed18e77695e5e7263ac2b423a08c3b9f20139485bee5a958b10b55f58500ec72a00bb46d413fe9674a041ba0a5364ffbce2ec2d4d7ed843e0e59b3836e0b185b5c2cc7ae0518ba71904361a5f8b9b5e81655a03c04abfbeb2462fd62af89d32e9224ca0f156357d4f39b5da4499e8582cd8da51383b08a8e47ac827de595a9e890466629760bdf13f2a25aed468c97fe3257d3e91e3ded693d1abd1e9d34ef88b8e310922f3995ce40da7b7f2cba60c8fee6c60da94e81067cf69fc963940dd7399a6c544cca031141c5741e6285ecc4efde416f7dd4885ccebd7a8e72dfe37db7cf3b934fb4cf66c1c359663ff2edfc5b5a19c2f3a8ef8f81351847f18e57690ad1aefe1d70dbb3b0d71aca96da48dde3ba06b867e7db74e5f4e1f1b4eb62d24b2978359074c70fb80fbfcafd34d4e8194a2739dea249aeaa3235583c9a18914a63ca6391115870a9244fc34530614f5d41a1c091d26060b7c63938fe2fceff27575a2f040201486e984742bfa52db0160fd1ca69a38675ff67c1dc11dbc5975cc67464aa39ecfa08a034a3ec2419e5b0d9f17329f9a8125cee0c6aa996ea7829448759d0f6c4eeaf4732c9351cfd90c4b8aefc7336c828e2871bd</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-flip">
      <input class="hbe hbe-input-field hbe-input-field-flip" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-flip" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-flip" data-content="请输入密码……">请输入密码……</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>STL</tag>
        <tag>S2OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>S2OJ #1498. 换乘 题解</title>
    <url>/solutions/solution-se1498/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="这个密码好像不太正确呢……" data-whm="这篇文章的哈希貌似出现了一点问题，但是您仍然可以看到解密之后的内容。">
  <script id="hbeData" type="hbeData" data-hmacdigest="f25c05b906fce15416d8bbc0155af68f63096b6fad095d95e6ac1d803f480823">dfee31cc98606e570b6a243cfb69c484d0094c388d5c5130dc4a9b5f224f8dc0a95fa38793058ac1fbe0ec669e9a2c1e9269de44a1db9845700873d6f7eead08900edccb3f414c00b942e513aed58780a97cfdf01117ae1f4f532797219a8f6f0de30331ed7ccabe040976f4ade7bd6d40ffc8e931eb53d67392d357238e5cb6149ac5eb516a963786859029b0bf33bad2c343aee304da4f69f1987c3c58aaacf8800198d61867231d7ff4d5c4efd2e81c8ecb9125cfd1d1cd4a5f882d954f0a2c933c1262ae22dd382160c4d5959a4fa516cfcb66d8a5dfa2bbd184bbaea064126c0e3f3d1a20df4911350021da86beede4ecf71f80dd4fc220902c690151a45ef44e7dab794521d5ea829f5925137106e3c06866bd2280b72894ee35f89241a5768bbc9c77ca35d7c9f4b1bf89ab75bab94575d1015e287e7317422263598600c6220180ddc5ce137e5e0c5885a71db7d549043e9752d93c09e2f0e63507e1210628ddd92af6c5c09c25f79cfab2ea060135a3c0c9309b1bc9efcae7968b6385b0f57c4d3a71a3e1e8f1efc2de873e00ac59568f138980979e14d0c1978c17ee52f82863b849f4074d2f2dd6a923699735bf9b4e4ec8c4ce87459aa764010d3c3fee3b44a4f5f8df11fb31cfbfbec7913e7f6e68f7e9a9492b11eef2bc0492f606e4857b9fbaea30effc058cea5674525f0775024557b043ac2f96ef01b3e521768d69ea6008f0693f5c312ec6d932b87fa6075df5a28fc86aa51519293e805f2d524265ebcd4893fa9cc412c72f958f22097eb77ad74eab09526eabbcf06faa8008e443dd49030de20173b7b92c4d790a3e7451540172d7202e3e5964c646737c1b984bf7e6ca03c558b359539dca646f8074992fc1f1cb025969b5233c5815f43d5a74e55e68bb323c9a7ccf783f3a7ead5a1807a2854add08955f5d93db22663f3f419c72e18b4b183f01a33badf4a4b2b50fac7e0f0ab9887fe0bbe58b8ebb28c3a1e7404eaedc19146bb774a51032f2dd9027ab4b3de9f887bee1ffa6e9e9c14987828643e0a4f45f068d917bdfd6974b4a651daec09dd860dbbf4ede3d60059f3c73bae1a9c3fbcdcd5093f52351c778db3b37b888ac2426fe682641af1b2e59107978f78d8b43d0902b7881430eaa2459d11a32a26b1c968135afdb55c25551bfc6a1b7b127663d630a6268f5d58f0d705f82c303d66e8fd034c2078558e14bb788092c3da733d2dda09ccd122753414acf86481826e59b981e4feff479c2e1332b451d7f628906ac9579aab5de7f78ba6616f08fbdf1848df7497a619ccdf6ee778c407ae78e8123c4613a818043a1b5f7f1a99afbe64ea0536d7579c239fd3d81ccdaaebed262023fc4595216ecd363a59645fa61791571e1f4117d8dde4009ac6d4a379e9fea05f10fc3c03301086f7b0f29266b0ede8b765eaba10c6ed2fb5dcc60106fa538ac7fbc655c2d04c57e54a556ae8c384d79a0b5f8c47bcef6eff6c96618618161b7c126384158f3a11dce76c9b05ed180a85aad01f34a8327107b0a299ac423a16caf85ec8f040c2429c710e130ba8303918c1595d45966dfc559e581c9a0cc72f3a53d1c09e00d1048e9d65985dbdda201d02bdd9ab0470e6900ca60c1ece264d10a3ca79c27c9f5c82e6c63d7b687d3cf588e8ede56dab158daf9f8c7e7499ec61b8625b3ff930f4135136915c83e23c245494606dea0f82bdbb379557948a486255d5ecb213a182148242dcf080aaba01a771e653f9c980a0da04eb45f179dc30a8c7f0e0af7ef971e4ab7c1e26d6fba5947aceb2a737ba569a030a02fbac646bb3dea801b77d0b88d6e100e99ae6d3d7c7f646aaf64696dd1e5a7dc152bea762a61d68daee9f1eddc14719a281431914887022d362a7710c31e77984c501960c068254fc64b02e894b7d8b02a9a9d05a72deb7c7bf404f8d1ca533832457ffa3473d398df15b443a9258be3ce409c4b53ce3b8c5f62d5c235362f4d9e5af8126e79440b3c757332703d7bf37b7581ef438c5c90effb33b9db80301d7d8af126b6aab6a05769b7818bb2b5edbc6357a0e29365995246dafd7741b317d351f994b94590abc10d898e147dd26b721d278c564c8deb692443d5f1b4112f13a9b04f92a4c4946f4921c00cfdfa41e37b31bb93135d223f8c5987f31f1107b57090eea3f1b2e9169360d6d9917579dc47574b7d71d78c6a5701ad2d4b2af47b95eb9ed98600938a14b46f32d9db2e3f196a30eaba388f1b00e0fa52012474c30233488495e4c6e123a6092fecef8c6dd50e6f157df93026be170899754aa3cef1fc4bb3a901075077cd9a24cf56a30dcc9cfa89c4b24eca6d39557f4f051892a07c4726964d48b08f93457ac82654c6e4b064fb70e2e8e499019242f1ed0a64184d3b2360f9e088f2fb88a69fed85a44fdfc646bae867941592b4c761ffbeec011d0d28f8a43677f015ab87499517c9fee97a649f5212787d6556b6c99ad3c09ce2bbc0245663b05ac69bc79112adaf8f67f3631d1e009162afe13701e9cad0267ca12ec040f2568ddb9f1333239324624c529053141c5e9c90556568202e7ce9bd4534271f323e17e06aa6584d6b775a551b6fc4bb93b00cc887d8613a0429df5edd76cc48149948fd97b74070a8338b6cc8a999f03dc5f3323f5b85dd5d71eed8fa4041600a6b48bfa1d250aba68da935ab299e5141f0f0374ce2d95b30de26586d4a461ed6d8cff3ea0f0c827b9266c1159376f2d94d825a6ae78c8f1937a743468eb0f865f729ce2bd81abcb07cbabc872fc5f4876ddc20b77667524c8782ebe32c117b8a8003b6ecf11963397e484c52bb5e5e1b4066fb8e9a65a1108a3496c9cbd48aab94456ea58ba37bc7682c822de276e2d7d91020c3efbdd20aa28157597c48d7e382862f5a2d64a7f4891ca1419130fa8794b2fb6b9b17553f22389b88a33bd628dd1347ca658975e68d3afa22eca101ea959f586038c3b174f0c17d4092cde8c0ab1c9bbe4df1622762b26245bfb45864366813652258f2d1f64dd9ddf08230102ce55c477b2f5ab35766b82cd8982a0924cf54d2f8861460dcf81d9039fb0c67d22c0d84b2923e7c5cd87d0ebb8292d19ac8c3062cb92d310dbb89c7f25461912f68034f9fe4455f07a400ef3af2202ac7eacebb150a1b16fa5a7bc3521059e3eab5b80cccd24746e1580732c11867bcc99539207f5f27b3af02715de98ed972d1b76d027f2265ace63693656bcfcec00f0d8321259c4edd8edc08b5cfd6db73b77868ba86d7ba71a85332de4f4c1e14d5afc5508b361a5d5e5f657bbab48df171fc2207774af9109afc4cfa7b29db9fc3f65ef1b6416467424de3a5be9d4d8d8448ca81aaed95a641752225af3b7b276a4f72e43a27a8284e0c928961db50618891a6d9b83ba3acbdd437bf7ff08f9239c42242f3ebe2353fb2db77d71a8f2e27a47a5b50774489eee12d77649ce55d8a6c3abcfe785e3592872ab84b063d30cc4c9f1228ed8a32e6e35d50855119797125a4a3e298dba6353ff668028ee644f74508c2d5d3fcd9adb86d9183b10066afd23e350bb99b2c03ade23ad144b1ac9b56e397ae2686ff01749721c4a51b5881bed995f654826b666ba185d44f3d7ba5df8408b89f20d574e7f769e25f23d50635e305aecb6ddd2f35dc2a7c8f87dd58be28bb8b2cfbec73bb3e9438812df336b7895e4ad3c8ab716b24b8e9e3e5faa92db18e701326ba57d9dfa8c2091ed61f798987770be41d7b4380cb7f069a6bbdc90ef7bfbe895fe8e071ffedd227dc30cb844254d677029a821d763e691cd732fdddbd97a58273a355d20d4c80240a632cb276ac08adae997bbe836ca7dac1045d8202b245d5687076bf444609a11ace239071770fb3ecade6afd69c21f538d1f30ca211a57661fd5cca54edeb4b74af092d36b2fd68aee5302aec1d7afd7b48d1a013984c85fafe22c15b8c7371cb6acb149289b82b658d1c142104fa2a6201f7fd7f055f51ccf66085ea62c8e8857bd7361cabb7666359eae05257a03a1ee9ee2f5c209836995de3f92a0772e7ad34321f5d2351add3c255de348ef491c136d927e048fc07398fccc933b248c8c08373973b438ae1d2e330d544e06dc907edd2811740f32cc4cdad12ee323716900884f531a42ed656a05672b734267e5cbb3d19aebf8c82f48231b582294255143557f42f9848589d34c8e1d38f6e3df6056eed6dc7075f8f3007b9ad943cdba965e24f5fff3856eca4ce0dfdbc4ab8986c6d449b615565b9c6328237ea76710a060089b164408d9b280f6bb132aff5b3cf238c11717ac99a964073580810f9206ffb07ca318dd92cbe71ba4fce5bf54eb9a8527b43184fa13962302907a81f4f9f33de730918f5b18656a090685af5b90f44e9fd4f99fdb23e1f2187596e5889e1cc7d407eb502774ac2e01f46e8b7943d06b6c9f0ed4423abb24fe6c0813a80518c84dfdccb4be627281664702cc1a279f1d72c47a5f7fb81f978f25443ac171aa44044f4633921b8102c231b086f87c84be1691087e71b3ebfbb1879c319fae626d973e93e449092a8e148f7391943296d30dedcb8037c9d5d2908a92089ab2e8cdb5747967b764059d60027034d45ffb5c323b77af43be5c4fcb2a53eeaa60563253cb20fbd6b023e3f7ea4be9d3eb49aed297ce7b171703fe92876092f173a228d9edea8f149b4903c95cdecf3a5aed12491236db6940f4a228e96d56a7814561b0613cb3ec5df8bfbb49388cfe200a09e759f081ece701d2fa4c33789dea8032b1e60849ae1ca4c28ab64164e968a3418176c9b45cb2700cea45e0f6ac3ed5ac8fa4a66235eaed20f4abbd8efaa83e9e1629090a6056b8f50ca1a9109acec39c8eb726cee4c1e6ec197a860d6624ece362b1a934cf01c7c98934ccc8efd8d354ff0116eac25768bd54f36810b03dd638d3ed4a9ae9885fb785c5200506d503cf87d97832ad01bae6bc73f06e2f5afa246373db0015a1bb3addf376bc34bf56bfaa7a910282f4ce47c18b46384683f4363d4d5b494b73a94acb659c008c185f2028ded3da9c0c52575bd4be7f1cbc1e23e37304d994151e21025362f30d3f346c61e6ad07e765da5e9bf88726805b95bb357d3669ac087ea0e7ff31d6fc16bb2f7b8859f2b035982383863e9666310c5c960affc5af4b75d51d418d1a24bfe8b8d31d83121c790418510c53975185f60ae12df7a7998b05213eecca848ec10bb7efefd09f198dbd2328b9e88e459ed91365eaad6138bc413a21bcf99eaa29b2af7ff04e0193f4f7a23383a57c3effe0477ce5d0dda9a1cbb3fd80b873a4f477feeb72174c22ebff9507166f588e1731fbd43afbb53a39540422714faceebdc6850a8b0ea4c631a2d41581fcc0dba70953028f11f89110079b5670eb8f9726ea97f486093529027bed0ef6fc3a57d13959860f0becd7013bed06b7dd2a1a84d3cf65e49e7e0acc1b32497884785e7c71bd3c56d7b52f121c022ed4308e6b4c83f437441104860fdc73dc848c404aae6d9045b49720b476d7b8b36e5580a0571ece6aced8be3eba298ffb621ef5d32a779fd6441d02b1e503373844ac18432cccb441f593517e7d4caa7d08abd186ff5ec56d2cb12444a87023715128f6095b15e562f33d0b987664db0cbaac582920a528c0cdd9c4f6480f970c0d734144c1aed1a5368284e6b1e9a9a0a7dc657e48070f0d19ab1f6fcd13c4f23c09f7b585f1087142293172c512bcbc3e5fbcf2efa3aa2ac8856eaf7c93b75619c9def18aefe2aaa9f3869978d094c72b4da57f862c655747e31d67e22afc3bc4bad1d13d095f8695199a6b867b000c445d4b600668c297630c0b23bfd965fa82b4e3328c6645dd4abd1fdb888fe7afd823b731c69de9826c200a0ac57f4603f6b5c1b4dbac2f605437f5148091d72d8d9bfc00425e08132639018ad17d18c48385d3c49992c5dc93ff7c0179cb2198c0f09fed0cd19cd66f61d61834b415797182965607457a8dacb791c3a7251aaac015ed15e2574960c31ce399457c65f4ce898c1d4046c10a550111b91e50691208a1231f8fc63718ea0800f151fcee6762147be0e4bc9b4ad1bb8378f44b74df55244395055ed42ec9267f41ae4f71616adb1ccd5c117fbc81e9d4bc43e038a7e04389acf6e4743d5140eaf2e85533b0c99c75c2113e1ceec426b5145894fa436929177f8660add2505a9f7ed4d2a2373b5ef7324ca1f594da48853907306daaebb9f09a16b523e996012514f524c0f3da29a2dddc624b88c86557de149534ae235ceeebd4993095bf4db9a76a448a980ea6fd963c212d977cd53ee108a6fe0b258c04132c8b6aa5f17d0bcda80b00c839d8dd245ef31f33e9cf9f5f4998eb95e3842cdcac370aa22a3d76deb8b99ed45e1227629a3b9fbdbe3a2947c4a1a0d6cdc8b518e185365d9efd575f91bd8b6fa8235b098837ce16812e65e4f42b2eb70e7cba46e6544427e4810b99b5448b9adc6cbe0a7cea2e285ebc55217a868c04bfdf082464839ade2c59226648a863ddc923593a9eedcef68722af7cfc4ce537caffb98215f199977a12f940e503e2d8d5a07fe0753d99c1613160d47ef5ce41f7c2ac944b8501820d3b47da0885fd14ff09d852f7a81fa67f8ba14462e58592b5dfddc490a4babe22e502a3f55369e809f668b1bd4e68a55c6cf8bf9ee367e0e03587c3401aef3ffa669b0070b128c99d1019321039f323cac8d48abd69da384074cbaf9d04e9d43679ab1d7453552f07fb24c3f48376fdb84bef732baa57d485343c33695787defad268c4ad7e982da23b3eeecc4a5209611e1ee6c10aadf3fbdbf840d959ffa55879656bdb72e313d47e762c17218c3a3816268eaaf82b3d615bbfb595a7bec6a7d1c0a0c8884a648fd2a041083a98035675628dabfc536579a024ed623b7494df1cfc68316804484634f1d396eb6189bdb7afb749290c229e3e1e35d23934fc7b707aa61a388e3c3d876ee8e6c942eee8b79ccbb819a055c083b4fd8531b50c537933f7e9b36e1a8912e35ee6a8a3471f66918b790084ba59e3d922f4b7a88e8cb6aae11b3fcec855278a547ba168a252649fe43fce7d8ca14441e4af2eba7550847847c08098876abb06f6fb5c0b79b9e761003775748df206f25d14571431b10b3d0b25e57db07367a9ff934f25fe998403becbce8ab2cfdedb5da9a562fa9b8a988a4ad8e57906da85fd55aaa597df600c5ba5c6ecfa68e3abf54faf810747590ccf496d3a49b8ff9da1a99515b47574afb23751630744341ab91eec6912f0ecd26bdd1720dcac7540c67cf01e89e03d72c477021ba75f0efc433163ff20b4de548f5fd3318962350d99bfc528f22104916fba17dce3a0ecfe5d1e3e75edc16938a673e4467adeaa1294e7749f06ac6f40e0b1c00b8dc8be92cd13e5403056ca968734a12a077027f46a11f39307ba1f40b84071da8ef96b1c4fabc79a6d77a88ac0d71a057785a85ab0b9837e3e21c48cae6783f1caeebd88c1dc397406d5be04e145152d68929b283ec4a41b389fe341e17328af0afe8c990a50a4ae5603119ff278142d69c5d91340d06774612a7c407d308a4d0ac5e7403b6b4b7688867582112fd72a3b313c51a6f2dffc8e4b7f9b58dc0d92576c81012aab1ff968a823a21269f697f69ff0253608c10a523688b00486c7c400f9b201a1f207ef46eba7ee1e1e378b273bf5547d25a53b5b70b7b6a8708bcfa6935896f93615a0d113a72f7217e3a4cae1ed33774ba1f349b95393da3ce9e3ef6baf0f99642ceb6f24d73068b0a538e2f336f8cecce888d1501674cc421ff383ab592dfe49d32e5d7144ae4c0d8f413d9a14a11e10e9891f8d6f3f1b0666c6d7dd0b67d2bef6d4bf462d5af6e8f5dabc984c9b92122f55f6bc81a25f8c6b06fbcbc1dc694d005e2f1de367507580d4776248eec706ca08021843489b11d15a03e4e818bbb00940b4c729c938769ede74fb71cb7fa4ca00f8fd048b1e6c5344da06bdbc4e790a82889bf828e9809a43042733ad598f9bdcd67fac9a884e61b385f171fbfb368d6cbdf5aca1ff3f0b144e5bc9a6791ab380ee2183560b0f5a61aea2d530e6b297b9adc26f4abdddb182f8de60f8d7333be9098afd4b55e35ab94afece9b8cf5deb7a050314c92c0293316737c5cdf6f43079c6ea058ee185274004de6c97d03d9ce605a5988a55d44807764920e18b3d86057e5e1043f900aa849c9ec9746a5f0e8094dd82faccc186a46a7767f1797d430bacbb956c1b588d939051f17d2d6dabd9f2ff71a5cd84d69b6924f0d2235919dddebd1c355529645aca71d96d349263ea02f1a35dcf295dedb2c4232042ce0128e62bac2678bc4201155d61b6cf30966fa3a5c91cd8dc3a43aa1ebf0f7da4f7a90e938e119c43fdf8091855d5973210dfbe99455d3469c6a2ddaafbd873f622931970c7d4d659170f695a983cd61817bf24e9c15166f209e50610309d47c39d88094cb60e8a3816195a68bcb644d169e0b11616af17586ea755a0a449c325f8c85d765f4fa02837e88c05cd9c62354d80671d0a8c16085a84d7dfcce4f0f62c58b1537790b80aa9752f3b2f8f40725deeac5aff81bfca51849e75e08e20b052740724119f436076f9602495a7f953e95f8c869aac0adf5d05738cdf87a7041eabb63cf86b7b27f66cca78d64727b2408786342d225c7e8a081516571515eab6a7e6f256c867033da59857bc1f9823060813991e61aaff16280f418aa9d1ef1591d25beca8fedb6b1ab1473c5058cdadddc01e2dd728384a2ddeb512f8ab3891027a54b44afdb3ee95b95d997f3a0ea95dafc71fe6db37eae1b183512925816a9021e7aeb71907013cb07ea83f66dd0bd7b9d968a299151fd7da7fcc25cff946ed8dd23069720703d5ea17d1e2006bdfc6d376c747924f6e4d7b676aa2b4625dbaded6ea3b4043248a20b4841d7913933fd40373795187e073b7a641c96f7dc746548e4630af09bf7711be22e5a87100118f05dbba5a4d88174f63b6720ffd9b3b71f543b2b183bc559f3c32e020b6c3c2234b148d7c1ee9d87bd68c3d334338b89de995f3d96d355b8651a8138adc056019886351534a9e6ad0608a7b365e7b154c999087090a61644e156d838fdee94c6f65b621a8278b6b02da446397a3b65ec21dfc12d2026d9aa19e6ec5d8e4cf714f4a2c4864f3883dae82a551b1b8c15fafbf15ed64756d0e661a34ba2da1a04d174857ace78045fe2680799308007c38f8ebd42157f8f0370c58cc03da7b0fc6b029e8d21a0e434d7a380a6f8e0f776fac1a583371819cab3928845a7142fcf81bb70bc69e05977d4ffd6653b0c108a45fe281d4ad366f61b872db1d632421d9b54f1ef3ba2009b3f3a220e3cd5e9072ef6fe777639da10239e88ca51d9930f11f41e73daa186a10dff5cd793940c5ec712717a65bbd6a3a4dab03f8184003086cfdbd2631813fc553c8c9701ceb45613c47a76086ea696c78188156f4bc0a0a388f0372ca8f291a25d762bd8217a2528a9c8f477ae81d11d23899d79777efa95434e6a5c32c9d63084a983953c95c9e210af345f0451fa330b347c4a36eb6819d768e0e2b8a4d72d531af80ba705547142f4049682ed71e24bc5bb8deecaf465a7f74dc83ac01f32f821b929824cd3e9d925e2a06e0ac0b616d2f04fac460938a9869ea9e89c4baf25fba958033ee8c72a3dd6b0431cf65550409236356d09e8dbd960d2c0294330a926d5c3ed3a74a0e47667ae26f8baffe5d5b1a5d4c178cef3e70ee551428dd2d6689c0272f5e652dea9742343532122bbf787ecf7b6f44dcf8066de7ce907ab2a263d6a46a934df44a4a8f935f1832bef23555281065ab94df1a7b9e1d247b229abd47cc9c51cebe1d78234d21c868c0cc4c4843858101b63ce5176f7facc8d1af787b11f15757af5e40669518d944b08d7b253de0c25b6169d36d338e81cdc1558a23d02519695d955a03ac397c311eb1ec7833c6e7faec7d043c63d875ad109658a29ef83b4babe8895b312589557b3f48731e15557912e1551423ed111a5eebf6ea119fd942e25d46dbbd18df9a62a67950c291286789cb1520fceeacd4293c9136dbb325568ee03e711a3a4a66479c558f4be5ca0b4757280c4ff61a9911ccc31ec2e0af1b63f5ff2492dfa79d222011b5f4e15ac2f08fcdb0c50056c435a515f609f67ab6ed51692730d93409e65f6fe585720002a0852a25f95612cde807d2eecb21a8b42d6192ae7b88cbd13ce535cb02aed03f22fd0ef00af645be1e470533f1fe575e0f3304e09388b21caa93d2cd00064367a12aaae8bb2e3431b10acec67e986c2cc15653e72188759cdd331a6ee3d1452644fb5376db6dfe0145fd2fba46a7cab9ebaab5df50024d0a258a62db79090fe7a1f92af510064568a68b4517409bff4722e7d7fcad20d306b84d7151c7d10f798eb646b233b0b017641e8dd5d914722b03c8ca0be044f8f5049933b847f703b1887ffd16c17ae93d87e971aa1f611bd1a9e92d474b37395a8822143604d82383dfed07089631ca27daebb15afc800b8ba86f71e07c9090d8b6b8c089e8b9b1b776b5abd8077a6091ccaa0ba9430c8f54b767fb563f74d71e16b5a8f078978e0f18deafacc30b53a84681b7b0fcc08eb2b2529f3fdff58f3ea218fe4ea98dffff7d257e2e8cd6e07e307a55d79f1589e52c3a90f46fc588b9b9757fda197e314422fe5f934fc4836c5453cb8ebe014be8318f35108a84110fa39cbd52a8a5395e93fd88495f26c5abd481b910b7e7192ca5379023593f6229c5bd7a249b887013f6d55c5c83e6cd67427f9f57b9249be361d90f6bc9551713e5bad0244aae4ec64864aa4363fba5d9d2393f27e8e096d261841f54c2f85c1039c6dd31c72b60bb34977367c119b45605aac20ee941d94a4835563af90fc1d0e8b8b3b8998a54a69f0c0001230e719f9236f28ef9bd1086416c0574874fbbc847d3ddef3d73ae52ee5de732d8a1cd5f0a775c5ef7317a7cdbe65afdc129b95c3da19b86e813f1012f97f1003f5e27d28bdb08712102553e751f1a9001ca2cf8139f4c4bd154f8db5879f6fab38c45fff198bdef42d5c75e59c408f30095fe96416cd3bae57cc6c849d5e6325df0eda22547daa73ac73f12b0df8c9f576220cd2669a9b52790ca2ed6980c360c813550ca190146894167cef34a9e927e33e3719b047e47677d6b739615c8ded86350233bee112e3ed2b218658b2b01241ba317dbd83ee849abae9782895be1484ecbea24593b11f7ec7f440a92ea8477d6bb6fb0197643a2e0f9ae323ca4463e613542884796a67c6321ea497666de4bbed4e1995b83f13cbd9e7f40ac1a871259f95aa60d681912d87608bca64eae1abaa766b4c829c156079ef2c61add73d06b7132321ffc404c81153ffa0ba3f4f1abb624b5bc5ddcf9545d1b5766748ca02e72b03a22934402833da3ef7be695d44d6084342d60eb7ec4b79e7eaa26f02766ce8d035512f92e8297660bf3014bb6f1daa8acc7f7621925382c34b1a12be63f791784b3d3043bc0b1fd971adab6ecf4d076f406036fe60aad0ae68d0c5c420b9aa05a4efbf851d006f8037e43089f3d9cbc2ec09b7b1a4ae75a3e6009ee633e06abcbbe2fdae8b3c0461f9411923900628eed615ffc8a39a904a13ffd353fdb36cda25c482b9cb82b8a00e6bda57c4f19cb6b4658e40674ac2d7eafbd6356ae0d30bd582ad7f11a2eda3c3461d3524a0d39fb39dbbe49323151a15e32f0d60a22808afb51aea3111b0cdb803bb122318bbe22ccd4bfb05fa061603814a240306aeee42297985d4d68e5439904b76aa6bea80d61490c05ccc96bdd5a8339f73cd181ef4834c50e260803d6bb848add138c62359dc6737bdb26fb2678fa78284b99c5b657988f12d442fd9265b5683b5d8f126866e328bf5c742b273052abab3253c02ed4ebecdaa92a9d878528fe5757ec48fcf8bda11832d2e2e5abad33295610a8defa99cef3403d70a1d5527a8d46231f8b156d1c827e6c52f111d7a7f22a95eb35f11ceaf7a0c3ae995ffa18760fed9836d81bf5bf3639698a3a9da689c995e1e622cc050f4032ea3fbbd0b2a18a42d8977bf6da3b9882fa5e41a40401c2fb4306fc7232cf36f349d586b179debcd6a7cbfffaacce086bbc6e7456e4e599274479301ef26f776972edff77b6d5e44b46a9ebc9308afca7171cf624c1292d8f1850ce6419fd171929f7acd8359deefa267f3bfe498730fa2a4b4bf6efdb8b387fab473673cc6038e3cff6f369980b4bc34f7e6c941b6cf63a5a549a5704b355227ca1c08f46cab8e029c67c50a764cd56f54e51830e71f2cb4c52224273594b4ae4becb87eb5c834c738542a682e93dddada6cc931024216d30c601cf5e807ca8e9d85b27383f562b0495b78089e0591c8eb19655b5a9e3f2c49b78cb407975528c1083e9d71d09cd49aaa7ab944d0075f78915f246c1595b036d0c5ba0c4d59b240381aaa0afab9c28d29f3d24e8f3c4ae70c3d8641021d8896e46d328a174a0fc23b207e420560d130a433c7d8fad2798fa0b99413ac3ac2469e4c6a8c440baad4415916a532bf9f926b59f8d25eaa0930bea46c63d11ef579918730e5a826fe0dac8501c3d0e133485f7146a3f4c991f320cd7a3cd3ba20ed80425de469bea8b4cde08301b8b0f591510d73d0f4ea6d050468ddb8d535cf91e5e709d7443d3a5c6692d797af1bc9937ccaf2ea76306a565bfa509dec9f86355801c988cb81282287d933d5f7f37bc98cda2da765853f38b26d95b003cb3cd20b5960b86b7d1866d2413517107be3b24ac88ed1c71caa81672b26a23fa433c4fe92440e22a20f1313ff6f976e33ed7d65216c37ec26def2451b063d8c38c6b349a1003c050ca2124162e2c878cb74017aa7d48b1d6659b0814a002c35a1a45e3c81c53e50371ef0d929a01cbb0e3bab70f8f5cb16482ebe3e16536b443241cc48ba59e3ffee91d2809b36f9f183175839610c148f8233687bf0f4e33bc25155e4fdce04fcf8992b837efe5d62dfa271745a0c7d417f8cea68ff4ed7ef49f2c2286fdc6067990cb5e6b6169fb434c1a00fde92c456b66424a731f4f7d4c3c367e57e8b95f9f48b7ccb8f1a6587798fd20260b3ba47476d0a86c097277a580db1657e5a22c554ded6de7c35cb21efb2727f5de66f88fb5469ef18a7e7925d471bdeacf9982dfdd7d7d710ba18746d7a558199712ff2238501e3e68d6c2352fe242a6688f9814012d6b032269c8d4d930e9aff090fe74207420c1a732059e867adec80f78b68c2eb60ecce919a8892f9ff07236beecf5857c21e53183bcf0e8c652c45ffcf8b59df1e4d0716c6691f88aaa37b1a25465554c602b40134956e1d8ffae5731054a832f5950327987f3cb423a27d20f9a5c100969dbcc929ba0dbb0ccf7abfc0c07f4f4093061a31ae01dc20c91c899ebd2cf90ab173d600e41c6c700458f25f78505a4eecc2c33915ab3691459b23dc8c41f3b3913d5bf28c0df36410d66a89564564f8532471f00017043eb1a6b95c5a28b8d5af6cf4e9dd53199b1a58af1e5c9756016889093d8bc86ca2e8de0581cc97d3b4e5974228e9c9aa31dc13b2a6cbb4cf97cfcbaea4ad66cb4069490ffa4eb1159791068910084cd56972d7e18e624674bd31ddb51071e36d0b171da44059b954efdf7e2cfd1733ff43dc8b99ec1a160cd37abf6e10e9c3968ec3d2cb00efada20c5de5bcd4f232aba1f8eef2deac440fb05a8ce331d4baf3ec0b30e75d0e750263387a2dd8fb01506a90870dd10d078c4a6458cb6ac910cff9f0884b6c09a3f581d80eff5f823aadb582f070daab0b18675f244a38f668081188dda2e5480d611cfc887088bf31bcbe889a612383b6c58af62e8862c444c1ac9a56f47973e992a6531c34001e665d993af700d32cfba1473f6039568ff01df32285860b773decb3e483b210d2a77f1c8feca85d527398fa804c50fb7398b90cb1f3eb471be317914b87f6caca0d81215b16812dcc188af989731294d7bfd43c155c56b957df6b4ff14de6509a4d6bb6baffae0e930cd69d47fd90e6c9516853aaed62319d3f2f6118ae9706f5c8d6de0792653e2f694a1606af95926ec3ca55cb5c96b17e7cbc8410b88e92fac66980a5f0118bc001f4bfe8975290ae8c223a711fb28eefcc70e54f2e4e5910012444781fcd82d73ab4ded403ce93c245d9e2bcb49709bf6f003f9e3a5484e4114c6d8d2fb670af6ecdfe61b737af1da864bf2f5b7e28f3f77dd9735f3b2ef44455366d2864cd79e07cab8a8219a3b4f79283a43802d57e270ea0e3281d77003683de6ce0a95f71842845bb761edfa138cf16f6b2746d07ea2563cbb2224f81dcbe83c898a5e46fbe3c5fb598267f4e7d61e6213bde9a3cee0552950a2f89f7752f43049abf4038aa5b6d4274dedb5ca785de649ebb8fecfe6379779a6892f18cbe79f9ab774d84f9640df0109f7e5e2b59a6a4c1a3c4f59b4c6cb7777d20541e4611cf67fde95ddaaf48833972dbc8ac91aa6f21ba3b7713342283cce049d5d08eea3ce1b67f3b80cf7efb7188cf46d5a27c3ce7b1903aea46630cf2d9b49c665e0e701d115465ee60416bf706d52f260c2eeacbdee3e38bb99a7b881faf1cb4ccceea691ce5baf117697bb74ab457e7c678ea1d571bdc7374df10b06526763e2998e2c33e00200330e587dec3d0a5bccff6b8f827ccee9f227ee8f0ff8bfbf33b24d2067145b2d7d9b4cdec7a8b125e2b2ad83cbd922aadf838ac920122d5c57f33e3a1a33690cbf4ce67d7f3dad866a6eb31c2717b1e945587ea00412df539c55d163738dc47008d906bbe7490e41adcdcd12db5b784825fdbbd646fa0da2a170085766101baa27ad8c2a3e25fe2674c4258525b8b532db749cc968aaa58cfcbeae1411b252a6495da9f32a8bce69c86d76c83f70b5900f6681964a14c2f00cdc4d3d756b286b241d63efda7ba0b0d6eebffe5f19d054fe524c7c81f62c4eb71de2d19dca4755cbd4f5ddb80f88e539c80f92501e12ff1d84a71f93d1c79b66ce742ef22eab8c0ceb4bf8aec617c2e2029f7db99fee55c3faed87efbad4cc6071a58b524a41eebed50156e0e3628922a9004a0713d0d6c6dc31d02bb3fc58bc7f16c2ddb7c3d483cd6a90e97dd149cf4c08c0b7abbd21ef75c45ae35604714d068dc2dea2a2ed055394b3f27de98830691498507889e41da83bd3527b798b80c4b1e322e7d19a509a272f124f4b034794e3010f88761850b9c06cfcf14b15f82315d351570e68f3cca689d90e53c03d2cd5d230e17c5aa55aac2cd02f5d535c0cb78860ce5ad75bcf075e4faa3e1b60155dd72960d56fc12bbb6bf404098cb48a7779db7d4fb570c4364c4ca191eb7130ca1826677c933cf2f9f5afaec5139e57a7d240faeac1f85c6567ba7c88468e7e88dc302df4fd2793efea307e1885bc8deb4a5f130a679397be3fcb96cdf7ddf5a818f1a734b450539b360f96df3c5aabd01c9d05b8df4a971dca06621b32306c95e5374cacb8eb0bf586886bcfd3baec922c78b12cfc07e296e3b86fa5a3a03321a98e27fee2e9b66b20016b745d392b9019530aedb1067b2fb4372262cd8c75ed3b2956bd7eec4296b9872e17b6741f06b89b5cec202689f11882f44760ea7a8960c6ed505aa91d152a776ce67a8054717076f3f1dda0799d775412eee4b481b3daf4b783e6e2843ebff4e908c8892a24dbc1f86afb09e5e61d8278bd728783daea1d97fed670b21cb105882fbafa878af2b86d3fb29ca68543c4ad1a968d57d9dddb15028cee5d7d6a0ac29d6faca8a6b592a7b13bbefbcba11742f0561a3d8a1ac9efb538e1689e66af8fcbde4c6c92f54c6658cf21d5ee98ffcd27dd4436881c1a181d27c8c7d6fab847f0efacf2fb9d545dd31f9c74f2de3e1737f5cf6a0b080ca233873174981cd6307dfe8cf88d49b83914f31e45768dc178b1e6c0b2919698e47acb78de6d70973a4e4d04a8770614d1afb0a39813789bbe473fb6c7e610fa15e3d5d8ea0d3fe5ba8f23cb291763b4d45ae3ea59b40363e5bfcacd13cf01aa5816e86c2aa629d0223bc18e79650eebd54cb1a1df0fa4c3daefcbc4688d09c8ea44ebb242177c0cd5102cf6beda26a67b4f4ef1e3458faf9dae36e69c9376e89db9b5e70d0e2ba3eca147ff7a6e6e5463a42f4cc5e79eb492439b6668a78e0f1c100265b64459e6537940ed40fbf8cba249d0f3f51aa692801ac635bec84552f12267c0bd6e5c35a2f031d4d52681661edb16b7afe02927b7c0c44ca3f7e6a504ea31de87ab9bc2abb628ac734e55abe9844c40309b37e873e2a868b11a528e96328a1449131b7b6e89d7be6faec0692c05a46c7c1c81f336c242c8d4b4950a9580bc8d5a09a1cf927f2fe55bf7ee8df64d72dc9f7566e8f493d204aaa70fbb5e285d7445b90ef63f6bec91130c773f733d3523872234a07b7d4cc604a170142dddf64cd8a46f8ae6457bdbfdab7bb1b0d777787f33c31610e429474567ed292a38b9934d1911ddbb2bc4b5d0aeb68f037b0e00597d5cb137d2992d0fc299dd4634f8389e176b1d20b5f53a13974f5d74837716e20d02b108492b29c4484dbf2d60c3809a2c3e807f44095e7a0cda3c6b41ff0f0d9b9e2b28bd3ddd18ea9c9a4a4a7c63e7de0baeed8108595be2ab38f88130c13344e29a2169a9698c4c16ce4cd04dd462917e1d2859520fae23b248a1b088416b2fc4f1cc625f4e8b19f3a614dab60dcafc02a5859fdc9d5d389fbb105219380ed73ec141698bc383930d3f55a689f2fafbb6f585abdc5ac0c72dccfb5af00247f9be8e0b395b0748c5b03407d0bcc78cab9d65aaf4801a6023861b658e4ea69bc0fdd15ed71be88efd8dd66a3d177b8d2d5257c86b1ad71cda8fb9364160a1fed37e4170e714f70dfc1145a1c2ce6eda19af57bb48fce26c71ac185e8d759614cd118f0e450426609b895abed5b04d0d2ff1f9535846a8ce93c248e97bb69cf45f190b97e6079f2acaba4678596f29329fb130ee7741624a420ac967fc3eb87dde6b97299caf2e38d8e449b3e63761441008d463444ba6ea0f6ff69c9badca2d047ea13783ffaacf6a78574d704425b8eb51ae860bbca505f0ddd0d3a5beb82dc76ec783b06a167b300d20d511f0f7e541e0d4650d814e65849f151de3d25a6fc1a8f4b3f9326ca3baf83d8f78d9f8f57dcf6196ed2134320b8c4bbc47cb482c31c47b4dd868d1e245b4ea5b060d2b9f13ad8428cd7ccfdd4334b04b9bc31ded744269ee9fbc986f8db795df191ed403c81bb9178f649e3c6d7e59e88333f61659ea654822b564372617dd5a88ebc5f5620629</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-flip">
      <input class="hbe hbe-input-field hbe-input-field-flip" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-flip" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-flip" data-content="请输入密码……">请输入密码……</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>最短路</tag>
        <tag>S2OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>S2OJ #1506. Antifloyd 题解</title>
    <url>/solutions/solution-se1506/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="这个密码好像不太正确呢……" data-whm="这篇文章的哈希貌似出现了一点问题，但是您仍然可以看到解密之后的内容。">
  <script id="hbeData" type="hbeData" data-hmacdigest="37c7119519973eadb5152592694468d0405d48ac9416d9920ae1d93cb93583ab">dfee31cc98606e570b6a243cfb69c484d0094c388d5c5130dc4a9b5f224f8dc0a95fa38793058ac1fbe0ec669e9a2c1e9269de44a1db9845700873d6f7eead08900edccb3f414c00b942e513aed58780a97cfdf01117ae1f4f532797219a8f6f0de30331ed7ccabe040976f4ade7bd6db232bba8dcfdb8ae1eb548eac49640607c1b73b04b8db383c401802978922d897153c1ae2f180525919a896ad79755da6b80190da8e251b3a2d209a6c6845ce3faec2ae7abbdba6720213f26e07e694100fdf18905c38d3e7f539830615176cece0619987f9be02ef3f231838b0cd8b298292e296e4ee0cc9acc7e252b63cd361bb4ccc43a8f331092e50edd54b627a0ea2193dac1e7f64236c2249f7c7744ddeca51f29b73781079ac8043dcfc6bb036d2bef7c6f702063123897c0160a47f3680196e1c028a419ad5bdbe41cd83b7391e0737b23f07afd88aa454c41cd15ac412a5f9133ea3cc9be17c7db04f3f87e75472f1d2d96e5bd6a2dd4af9a7ece2b6f53aa5942998313f72420224b500b085c69b0de4a5b48d4a88e559128497e568673a66e718d677aa67d6b5ffc8a603093cc0581cd67444acdfb6ee688ffe25f61a287b8caf69073e78c55ad23dcf7f2ceda918f44bcf1496f84027a5bc43f673e90173634a54b61fece2e86cbc9bc8ff3bc918de02dc8b0e08f33ef8fb8b49cd9c05e86a1639f33973c532babe066cf0eaedc7c05f8f6390786eefa8f562516fdcce25e0eaa6db30251e9e9d8e5829781b9e00620127150f1812207051b85a3a0291200749352de2cccaf5ced9ae5fda3bef102b6aea06099c8e380bd26d3f7623dd11a830540c143f2cc27c4a6d8b241714129cb3efb424af6be1e2b3406f8fc6d6ab8e486f48d732d781eeeb7fc0f582b2881cfff50b5a7e584755022e357071257f8619d75e0783810a99e0962c2e1358a5ee51090007d70b5caf5ac39ed40dfb2ea97576fdda5028025e0d72e1a8e19d4ad4b7bfa23606486a8c77a010dfc0df935cffaf919760f530bd84b25d923ef15086069328817b0153e0b6a7b3f3edbb85798420166467fe4c16560ff0654cc01be4fdcfe054bae1c2a61778430d3f840bab6cf7550fcc253ca509b5476364beede0de8f309623c6175a307722b783c4bec160f7f562175436f61b9f3557c9a4b72635a303fbdc3f231057f07c9520d47a4a681548822a553c85e2351f6bbc5ef2a6d12747b186c0ea9ef073014e147badb666653f166ea9fe145a2c413cdc4e54c6fb9ac7732184926935ecbe32656ae8d817a60deca4309208fdb754409835a99065cf6eb0c49373d935ca6108321d4221cf200f5b98074c4192bf1bbb4f9a948d04864a8850914a525e371da57b5347171ef0a6f010a586d60570befebd01cefa7fb3345ff811eb7e97af78d9f2a0accadee2dc036a28910e22a07c3b3db98c2e6db3b49a59693a6215785e3e4a39f0ef068390e02cf54f1c80eb50ef0c45af7c52a9b7cb55e98baa412dacb2599c388a56a08a156f6e0f7c5d5c81f2283bd47d1a7fae49d6fbe2cab4bee45723f9994980c125cc449e7e97ae09fde23f0c96c564d590150780ad8b13965e6b84a10d48a94d9a95c7289920657ac74465fcac50f958244ad33f9cb67690349bdef9e3a2678a364cd042eed9f17ed3381f9d5eb2844fc8503704c73effc835769a07a8fde290590122e8582ed4d877417fa8bde5499ab559321d1d51d74846d51d1d703f24404bc988ab7dc6229d7eb8180058032a9fa7e34123890ce4b762820d38a0c0a65dd387fcee517660faab9f8ea821db403a08ed365ff9a07f82be26ecb2f3b68f211432b37c08ff272e34f429151c8107ff1a40f7b50d0ce7ed655f8837c0a6823406784e527f6395c621bf86b0b67eaab19c7528c8a5902ef4846d4b7d91bf873e6e711ab4b6fca3420e311c41c1425f49771a7f079077815a8cf2406072c58095475828c87de947e205dec298490ee81cda434bdd65f6e8506af99072343358d35e06c618c8a80e5c4f24cb99dc9df0a794969f7c4dd10464021e890691f227244ace4a015752246e600bb43ddbe425afa20e330ecae6b1ffbd96e6be9ee47376c032d4c24db8e65064b5ad412b2c0c64840dd9eda394c58d851ee71670d3f844b00ca00aa9edd97fc4691f9489d99fb06bfced278d780b3d91bc7315642835b50b40a3c88a572a3ef7082903d362024f054ecbaef7b9fa8f7206325fb2e8f94a910b977d7d80243dc036af893143f1091c26c5bfdb3a13b5de01e203f96aa9a984a996e4581765eabdadf3d4c841fa93f370ef4cffbf9ab9ac1b15370cc366c641d61caecd7d20956a504fc7b86c3da7b03525d86a3531fca2366e7d2a9b862680103d0e79c3986d3bf04678a86ec9215d9140c383a54ed4c4bc18a8333ef217294b94c2e9ea83b38f6c6ea04aa05b273a50d2d7006b5c354cdf4302512a1ee385033df50710b8616f0f63f1af2f9c3da8160cc7d20fd7df6bb9df29ce07184a53e25fa1109d6dbc86d59462dca66b4f29ce6fbeef1ca940c891b5ec41f89c366da5b9d3558e482408a0ac10dde3bd95218b4582aeb5d24fd7b32dbd3b8963810982094b600ca3e0113e552913c7edaeeb3bac465319f6a95413e49dcbc6bcec7c6e7ad82bac7a48e5283903618b08ff19ba796c79fd177f9fd03b87c9f59e9f618af94e04e9cd0218ce0a8d3ede54c4230eb82605026a75139ee62caa182abc8d7887734b403e789ce8d0d4a3513ce38078a0439042d209be8631fc575e4b3b893f6457b4fe36355cf71e88ab5889feb8edea477488e5db1b92676862d034928f775043f37123bd9de8113967377924d95062000d390ccc31d0a2be2b05cc8cc00f042339ca6b54238bd3a77695835daff091d930c1676e519dad25f64f1ed23c57cd5eba94507ca5e96b2da4d2f52d604ce53eed7248d9e3f6ed1d9e3e469b3f27f78dfa1e0ba15d62ec9bc0f7615255727ae87211952459de5411e63f73080794d5fc1122e64618e61bafc3b8d95cdcab4058c3af61a03803c894e7aaa4391f3c47a03cf06102b8b72196b5c4d8da11fa76587bfaeac9c86c0f5599f7c38bdcd89d728e19d7d3e11a6c91528d1aa89ba7886310676679e44950ace4e4c27d439434a19ebbc68584e59088d167b8a00e7ff557a3c3c8fc7ed3478ec878ab0c9822789443210e0eda8b9d2d6ee740424f250b6c1949af0914321fc44a620f75281505d15293cea3eaad48273efdb9972a26dc0668430f82a7ad37ff813663a3e1327a50cfba98ca373696e181442bdb365da514ab3f9c308c20a0ff968944033d6a74ea0358b1ebf6868b86de2b6c68cb88c8c91ee6d3f6a1ed41c85fd345512c10b10c14b0be3ad64e3a5707d32504758a35f4223a2e4b2151f0c0c835ac56556679f5a1bf7c90d0745775e1b43598a47674866f473973b26db3a1777250ee7abc260b21978f679aad933d477e6920ecd16001f89fa2ad7e0ee90b12a5139f120f83b465426079aa2a8a9af02b6b7c0377a2ddad350588d46c29d463eab0cc83216f13248e479cc42561287fcc804c6d939604c1e88194826b4afdd8feb53e3ac357ef7ab0cf4f07099ab7a71d273fb22d3997b2d92683c31a0a677878c23204024d1ec8bcf97f699bfa1796e81fad25c305c8ec804b099eab84498e0040563918ba02738e3cdf0a9e2628e69133b220e77a27a94cfb7e51362398c801c838ae592a05281d00d9c31a3a9a18895a2e772889bbb9c83de169f5813118bc5118042a86c367b713dc24ef2ce374f97bebd49ca380c1749286098ae99b0ed937e6b697fb089b91eceaa19beb929c72fbc84998120a118d4a30dfa012c8afc956c1c9ef959a7fc727ecdac94be9fd863d5a441e691cead8de7248a78222280dc6bdad9d7b3c7ea39d795237bd2964e50e16a695618d4635b6e002d0158232a7eb354cfbc76c97163d4aed4cb59fc613852dcec6ba1712c6a172bc29b121943f7aaa5499255239ba1bd837bafdffd96b82883a13d7b891f88b7c26bde4fe306bac9b2c4cb133853e394df45a395825224b09d66b569c99128b35f49a2fd8cacc340040e7a52e6b8238c670578a5387a4337f6da5ef041fcf1ca41610c06b78c62033741f249a1ebde6ba9182c1f9c73e1c9e05971ae99dd654e6e7aa0f5f877f0448c24b8cb304170b37859e35eabe0aebb2a262de8151c567a8e8e7b937a6309a0c54a6f9b35d742bf07a2139c96449f30b007d792b05fab3834ebcf5052b363f779ddaa15c718d4db9554cee67fda54b39068bb8a227772d698facb484b412043fd475899552bc8ce701763ced7b54eba06cb5e8f10441b8ca9269487b1791d8b5530846f8c7fca0aa4a69e267cbf74981f8f44261bb4e3058743be0c2ffc3e4f0a7647526481ff407deea16cb6c0ce275454dd9788f8d091975546ac6fd75f0fde8f778347405c341099423ff0ebbaff94bbbc528a764a96600ce48e755d31847c2cb41a89daf87a17d81a8a35fabfd6bc22a6bbd1c0ecf771910bd46a4c3fd89661277f8cf2bee89a7b52b4352c531d85b0742fffea765592676fa47330480910470faa4e69f0c41f5e92272ceff832ecb3df13c3d33208ab4a36873e0b8e1c3e9aba47051cb579a913a97282a1b01de63cc2ba9ed1c9c0da29672b61d04856a85c28834d0c3d64a34e131834214f8db0f858ec1e5e5a5ecdea4919aa459b33c27c94870382821130137822d02efd0c0113c2ffb79fe6dacb9d4665efe50156d7b4dffce6a948d02301ab902321de925366f3e41c483b999442fab15bb41800db7ea0b3825cbbe56d709fb7df4d3ec35727f1adf311b033d50b79233d87f24a634025453467a7e803d379a7033dc0cd0b190834a175f303e17d64b68e8d8679258f61ffab007db81d0d8574173732feb51bcb63d15de1686e0840492b96e701ac1d27f555d5d13ba9a4d91b8a104c891faf11ebaa2e1398eac8320188a8fb9332e76d640b921d4bb4fc5633f32ef4bc35fac6ca0e2143db4d30bd1deb061a793f1c6c21a28fd5cf197538ddf3a50fd91d49982c53ba26545f60654f14a203dfdd35a3c8f31564a9c824138d7e98b11bcbdd525ddfef775b7facd49583f70b67c27b48f07892cada8b765697be8e8e79803968660fcae9ab9f1a683228526b0f0c21b083499acb89742caf6d993382d7eb6c09db19f10b4b63d422ce824fde16f10faf65ab42a09dba59f46032b0ee2c46773ed0f7ccbcc7bfe3074a2038713d9de2e45e2eb0f2d4ad7c1d228c2769a8053627c6385a4c0ffbe5b118e13fe17a404b174b69eab9a6ef84cf38642bd7202a20d93c0687172a82ebec7a1bb03462b03956e7a670fd5fa38b11a44fde3c5476aa31817030a3c45b1813bec6530f10775d9dab5b35b4f16a6261bc6916743153eba86acb6d34016c36cf08ee952083306a1cdb4465dfa9a2ce164b2f5368042da60a256291132e3b0732a50a6bfb1274215298785ea4484dad820bf5372221906de8e5949729b024553b6466d9ecf16b5b24a217cc17b0a63a3144e03794514b10bef07a45de7d623ff738f7b8fa8bdfe4c943167dd034e559a773da8e00a5afa3e68121c50809da78d2056af895e163824ca6c31c2cc711f46b21dcd470f177ffc7d715e6d7575cd53437000bd0716f14ceebd3be816620caa541dddadacd634318e626d41575cf977e965e01425794878a377e540ab4b6f65b6824d4e1947e7c895e7d249543f936ecc56f5d3da994b34f327765c309372ec0a6fbb1a4b660a11fc01b1f1ba44d73219268db0e4e7a6fc6eec659d30de3b10d839276f2b40546cee4c4403f9dd2490fb1c9a321cfe6b40e4ff81c5b258cd093d1ae21de2b69fe6f8e709331ad6e6807dccb1ba0d1f3a65c7c7f7d3aa09fb5cf2ab596fb44fda875345f2be1f0b1b19ffa88765ccf57593b0d64f2cdbe13d44df361280c0907464726d0b6701a3f25d59df45f1e1649b08f0c292b9a083a9123abcf6d59820a881c9d8dcee644a4f557b98ec86ace6db773fd6056307d3581afb28523557e685aef802471cf7a7405d89daf4ff2d2854d2271bc992008c4f69833ac82f4fe49e04aea056a16a880bd032da9d8b52aea785c3b811ae3e7b031303b41d04279601cd847cf4e80a6ce1e7011ffa3702fe8a838575d0118eeba0b8b9b704348fd00f40b526cc25e33473d037f5788bcaaded0e5bd9b2e303009e2f683da595a30e2982f6d23b53d1af32fc0e92d83aeb6d19d56ea99f91993131377da9a00addcf4f893a26383fab87103095a0eb9595ad2ea2d58d1ad407676395a5819283eb8bc3e287fa86681f2bec912b2e53372bbafcb55236b66365e4f1b851fb3528291a56cdd9b20ffec0404dbb2b65691a914fe42568dbac20378d61f7688bd1852f0937a2b45a7ca4d742fa808bfa4601bb01b8fb768005ca6dc1199ec5836ec9c5fd436dce88a7467f6af624756e340ce50d967aeef0f337b500d1ca83bda94f7f2e3776485032a720c6b219985f506a2d27d08571aea22bf64f5618416cdd0a50f651e63bb57062ac01779090914584c2e589d8445d4e1f8c2c844330c8a87edb3691268920b51b465f61605cd4a5d33aa736e04ab81d844acd290ce3279af6eabb98e01fcbe0774c2e6e5d7b75eb2985dcef004a5759ef4fd53fd7d42e5cd0d1c3d7ce6595eefa1e1e857c667b62e2093ee25667ee7724f87a9870ac4d47155ab266b0cd419ec7e11c1f75659e5f6a7d1cbd692e7b68cec308e8d37c1d3952eed349a5560bb3030daa7119ded4bbf3f0ce7328cc2feb91e40c1045ffab31a43dc835bcdb35c8a327e32d641629c96a16da1730a4ff698c8b5c66c6fdd733f5945566c0132e3d136e32db8f5a0b6b026054cf9f06a4761f1f28a11fda4c9a8dfc42e9e9b2568045e05106060adee8fcc9656e4398973c8dc5e018aa953b00290f58b5d643afccd20b0c6bd9705476d71ede9f280bf9900a9e58989329ba2d3f7372191a7d8785dfd07d1ec1ad1fa4a82df3c1a66ed2973d67a6eb540085034755f5aad10f089e1848bc4b05313ec1e0940da2c303340aaf3a3b6efe79682f9bdbfad780483e10ad79408f62e861d8e32e3abf662716c0bd9961ba56d2991fb454d6cd29f2e6e18c3d5805b2d63460f0fd12364cd54a58021c8f567ced39978392a34c8b249f82fc76aa097844049b2dbd5263f64f36cfa4ff445c31d37bafda702344881ffa60d79bcbe1bd1b1a1459fcf8b341994d99baef712dceafd4a1b03b85ba345cdd9ddfbff2cdf1afdf78b086ceb7a51dd9ed00925ecc0914395dd93dde5c7d6ae2998e08d9e2ac146b72682fbc0825b17c45946f23a1c2a4cd1f2826e9fc45131138c9c554c15100fa1f52a36c36bdf76e58346fd059e1cc581fa2aec1ec594b74b4d17146bed3b7a1285f83b1420b4aa32b4f1de835a5676dde2df88ba0dc4b83ea089815fe1762a0be792cb17f64a7ab762b4361b052f3f84dee64777669190803d5b9a999e022b3e58371a69a9e25b7d273f7a51e173855909240b8618b11af2c4700850c8619f98bcf4b50f937a201129e39e3f33a07fe4176de0582600e139b70a57793d19a87838d93442271b2cc74599f1bb6a18daaae3a9b2c0f1bf7713063d57978a59c04747a48cad380196794451a168bcddf0b3f13c48e99225dfa259f463fe0ffd717337fabb62632c658ee91f6a70e51f2d30bdc933a032fdc370f43470285dfcbf573e56489307a508adf56d1c8f2369183ae77495276d83a82a0d1f36a8ca9b7f6371014c6de4a4af5525aec5d7207607529ed5a4c0124d1d1f26097da5a8898d8461622d90dfa5539fa4323dff0180c333ec2c3a417b1423893ed3bc69a6685a9da6d9ae0d98c4f1f709f553327fbce6120e30bcffa8d8847b78ed2bb6fba299338b0ba30cc82269b25e71922f67f9475d4ed93627ee04d654ec422048142ae01045f6b45cded98e5da8761dc602f6860736fe0a1c7ff33b526ae25cd09515cc3d69d636743ed743976a92ed0b826210e9848675dbe9c904e03413ca982e9e454ffcbdd3378eb33f9ce93ea69b8f17473762433ee4e16f371944213a7d247fd186e2a3d6bd74dc31235dee30d4228f562fefa565febc246bda177df7892192f69bc06dcf752faf42b4f6dba103cd60ec750265b537eb3de49101a86e82f01526f2be68c99b3f3bbea3438442ef06b45f4f5a3051f9f9dd112f929bbe2300b09d9959b6cf5f42df7ccb0ede2d0412a848c523853f9bc3161956587f1c336087ae377428d2fce184b30c7bf3e7e4e9ee7e89e8a5caa8b4c520f0b2c933cdb204983f6a301542fd88243df329f466e1cb24fcec01bf020305b4a0bd92c241ae24fa0c4bbb62e7f352d273bf5af034004c06530a0f0be3786d5a18849a34578572ad0588ab06e74b7f723898cbadcdaef21e0f2bcceeaf79c67555f3e0acb66c0705a9cc812477ee6f4f526ac4d34fd1c26c9a19f4bd2a88c815608afec6b00e72869a246bbde55d8cfa2b32e48daf551efffb75afe3ad62e25a74296586d9341b8a83a22089de6d08dca93afb5bf0d24312138b67c5194cb70371ddfe51f1c9e8b0d53e44b21c91f0089d1c924d26a30900e350e85a3f25b5f21edd955f1095b6255d3e894528d5e7e8e5deb512a769d5c8b54dd7c6732c6f406d2e66649f222586d53ef328415f2fab11c83cb99679ef4342ad1b4a0da04f5e745ff2cd63f5c3657fcecfa16d2b3c3dfed62a00a78553fc169d645fdbb16a9c774f4b5fb0a53851478c0ad291b00606cea0ff3c711c421c53eb1d356fb057f40aa803933b62a7dc60f4a27c2c9081bf37f22306dcfdec5afde4419b929234b60ecf6f20dad5b56547b44b90ab79ee30eae36e8fdc651da4f75bf2d823e7700fec077461f76ea98177fd199f758ba04996884f16ef4611e698c06834f4ed5a0a5ae8fe644c0175e28dda57a103e8ca62988cab6070827b34502aabb1ef99f7998e27f870434f3f0501db85cd9dba200fb01bcab36640b0893e6830d1b0c85a88a51ab249619321d72d1a1f94cd2402ad44f2c5fe788ed235ab4cf4c163ef1bfcbfdbca93ad0226a4c768b33396f840d7de84e9b88f292206241306d6212b2e4e56bcc034c413012e2bf359f2094b57b699d2315897147e1f22a7c0abe8a6967e426d80501980ca9d59acc6903d73c82f6ccbb7393408ed711f04f1b879a801c8788f82d295ebce659b42b61fe35580f0337dd5fbd3a5ff2eb39d3882a0c27a99755491f2bab64d96088617c1ba8bc51e8790ef91b55f099c851f534c86962f1a227e1db43e00701dbbcd000b2536a236d339f6ae7fd636a818c5aa60434cf653d65535de378dedb815da4f8a26b8fcd619104c5139aeafa150a510d557b59fdd8bd916cf42e7ccfbd047657de41a2b7810aeffeb1ca17b3e0af0980e3ddb82bd7f8e2f01d660cf0b4a3ba4aeb8577c1e1b74b36d7ba403f18cc02f3e274f5b01550e911ce748527131e3a25c9641dd8dc352b2486a5d84aac44138b7ab93974232dadccea093ad23431ed7d02d4f16cfc1c9a72e6e52b2c5157ecd9c3bc09a7dc1f0b740881a3dab58104c877800fe53368add2379debcc25448afc89d46e984399806566918982dcca804279399263a0d303e11f5f1879b4fb1486699e3c0a8919f08a12abf2eae23868ed332b3d1a9dd14dbdc9b72a773c1777d41880c59c2a77fb4803dbc282b14ff47a2715e7363a516833edeeff8d05d682ae065c3cf259bd08d9fa2f4cb183b3008d5cd1b6dba8292eac5d658d03c4ab315b401a8b9c8692a55a1fc9bd722e662411b25f1c337327dd95882289c5fee2001e247798008497da4e2ee3c4e51b0f8429959c9c1df7aa2b416212d0208e1bbd81379902449a67ddae73f7a8bbe68878554361ef4968d607c1f25b3a7328b8c70bf34c88263caf1cccb1569c1a321f0cf3594258a76f22e456626d6dd6af731c87e81e19cfcadd610eb743aa01d68155a335402ff12e7d47753980118c60b8ed9ba13b610332c95d77133ef39700cecfbb353d619610f79811ce2105c1ead828a184813314b76aba3fcb7cf1cbfb7c0c5d61b39da240fbf6fbd12accf6fe85237f6f62ff6024bd004ae3f4a3bd890bc3de35742adca7d9e7bb5c2c12c920d0bd19ec1d99dc56c9e704826c43c0a827a72569009fc8009e6b223e0be25f928bc9564d4ab741e50112d6c98d484ae1ea6e770ba6e6d3cbf7e0e855a0a80b242f6455c813137101d06e0c0a0daec1309e483783f1bc05ba6863e76deb5dcf5e09132fbbe08c8087841583b1d095ca78f4c4290fc886e37f3479261950d9567a129c829270ba943949d4fe9d9c688b13804453d8a8aeabaa9ce621ccb92bfe4ac6bf1b26128beae3bda1bb4b45da9d42d586a0c1dfa161b728ed51e2b8db2e98d65d01120c841b5ef62ce055e3e948ce93c0f3348c6c9be0fdea018c08a0a75a2c6d7a57e9235510b52fb63d49833590af656c2af9c976d04652188f8d3417b124668c074792f365bf0b8453a6e64a000235cfc6d65e6087b80ae6045b496ad7bad71f1ed7d48373a2cc3b41dc6678038c5a4f68cf0277ca6af5dc6e5ac348e05375cf6e3694a6f3ae4afd7176b2abe561c53f0a34cfbd797a37e53058a3025d386b0b61c163dc1eeff28675263dba368ba7cf0bae03dbe62df6ee3e59b085d080ec027079a9fb5b4762170dc9a01230252370ff766936a726c39ba03f4a9e3f032e1807d73f688fb4147580818c4d18ecfc2fcdac46f578b017d6a54b9f41f6d4a2e4154325101eddc7ed9689346c16c701fdfbc18aac8f189852015d6b82642aa45608406f9396f4a18bdef2e327b2c9b1e1a556da2212a2ee10aa5aafb78eb8b597a10a32c7b1c8e928db6b2c53faa197c47ec8d95b0f6662a721e2c618b629a3c11d95c4d900a34b4858e7781268ef9aa260b58be358fbb53ec2634e3325213bcb35e8b8df30715f907d69b297783e8b18b7ecf1229db2f26dc7cf109ded53f5bfb3134bfc1e2d27c7e63b70318ccc2b4c0a0579d1091deada601511a8d56f2050e88cc1958061a7a9c259692d045866557516b2d4fc59fe50681260a2433ee1c3da4f7af5767311a944c5e2c3f55c32c100f84bb6e9e5a7cc36a3e3f4f070c9653e1a37979ed5f30c9e8a5694a66aed9d004799f053143e1ac634f44635e7c8ab73caef4c792bb9126b6903248d2b1c13a95b2a657195fcfd5abe29adca73fb695ed086a9aac3179a3a0c07679bb0d73dd42f4e8f5ac7140ae5a820534dc7b4104dc9335bb2c569dd4b7b8a0cadffa13bc768ac24384f244d87f4056d55bc640e002efaef88eb2eab0fd16524c8fda5cc32c9b27d5a7c6d22007411f0c632f47774f43309b36e72597c5a968d816ef4968da6e32893130a87cbf14ff8fd202362d6a47015c0334c32220d8e77cbb695b88b2e60e71f18dc936aa13ea373ba9d50955d6f3c827104e0a8481b282b2029e4cf6bed02fc48d1dc8f7435e2014d2048f10dd872ef5cb2b64d77255eadd90612e613f371db5b362f0b83fd63fbe79fbfb67a7b07131d0b710a65deafb85b20acbd4aaee39b8b72f0629827fca915535ccfae586d0a59474ea2b93e0587ca6576ef722edd8e4b7e627dc0647bf95816b91eecc47cc03218d0860d44cc71328f8424eff3e7ff5a2a241c69cf8e95916266ec8ad7caeb458f8c201d12de68e88420413e4fe8cc2bee49444cc85ed5addfd0367442e5f0839269a6fa9c0f29c3eab4625fb7be2f6b3871218260f05108b3de0b7838a52d7e12c3807bed6c8444153c82c29e2e573e0cba46455cebd19463fe421461b4e218534ffa65d7bdf5b39779fd5da0f520345c8f7458be4365e34ab5b9e26d70370819558c09d3da41ff2b22d762ed2ef56f62df96f1e598b5f69556b5009df0f91a15917113b6a3330e9a4235a1ab1e059edacc34dc4d280781b47769878002f32750982d187c8d332c788d86bc402e0f65744bc471b7bafec475bb8476259cdda8441c81035dc143e62848a99fc9d485bfd968c99df98bc6be1b8924196282e7dd32314634abc2281cf4fc69908142b50719336756f7ed54885038b5e35e6abe02423c41a3151bf1da005450cf40a39dc76f195a83442cdac82f213b6bb4c091fbde9bdfc1fb1f9fb15149e97344f35cbd72af46994c19ae84d48d040d55ee0c18dc7f1f60bc8bceef04a36b77ddc568d5da8a55a451505d51cb33ef7ee2ef1edb9ae0cd61e39779e63fe744ceed4ce04a9c66d3f5488091b2bbd8a233ed8556d33398a4b1b7fe4a4e020d023533d38e847932ca2328c8cb91a1538f5fc47536c973873f7fae0a30cc8f2f8f9ce4fb822191bed8708efdc83f4c8627579730c21217a2060b5b71b1621424dc13b9154c337389afae297cfa0fcd1e68d5fff71cf772977a61fda07fc91effccb679e66152012cc621ffeee993a99f557fd3517a9b7b4d6ec08743f83bde48dd008d537333192d43e1f69e8a47672efe5a2f222ffe439385f4113a5bdf15cb11186beea7e184fcef0f794093ae8b33a5039aac754d53fc83dd6beb00b657d96d48abf050d4e9b308c9d682a96e254d3b73f3410d50cb6e898e5b8d59ca4710c9f62529b9f6cde23f6000129a0049185c032ec56e6a3e961e0e68eb09b1689978c2663f289d4d33059fc414cc6389909b22c7fdb81067d0b1cd146349d01530353f6d08a8357aa8c58202c23d910a2400ecc21b92085d0af8ab22b94ff57e028832c5f14d8b58734e935302e645502b416bcdc17ab2a8f656abddc9949237e31bb50a7a98c5c90fbc9618e67688840e2bfacc357894d30e44620dfb4cf60f0a50c34a49547adc3538b5fbafddac4e2f956dc21c22d09cebc568b0750d361c29514a665506569de4eafcb2d7145860bb062332d9296332a1df52c006183876d7ac1670506d82b637236c221f7bc79c5b38bcbf971e710f9da98273b68266d979b1b23aae295586f200206619476e26518c821208900e13912791890123d9f5392dab73ffdf69b81e9d99aa209b5d7ba34c71ffb6c7041b69d44fef0f08fae5dc3dbfdd0403050e91bdb056ca517452fc3d5ad7f6a9fdc3a4265bd15707b85b9c1ba19e9e02bf8ac0354630ec45ce2b1fef5baf3591b3caa9f27caa298d84a72820a4b8f3d92955c25ccec5aae4d9bce77e727cfac2d43b06eef6960071e32391671bfb958e94d208866de21772d1e2163d6ec031146d9ba7cabd67a0a2dc660ab3ebfa705f66ee10d2de82323cc4d66e38474c3633e7c50a01e4c255ce9783093d378ae72f56b129ffe04addba6bb35547d5dcb3d66a073dfe76466b52737f14745af17081da43591166f8058aaa4d07898423ac1a633da6689ce2a31effa4557c9fd43435c2af45a8a96c57d329019bd519d887e433ea3b87b5100ad8c975fc2e559451a70cae1e8c32829dacfea56d76426bf76e7454cbd90c6c7054a6663c37fae7d7521c036a8c9dbc2c3c0a0f6614fab3f801c554300bdf1ff8322befa026dba148474c0f05f067d8c7a284b994ef10ad105784d377cbf2093e0bdb5184564391f19aa3cb71056a3fb7c51da1387df1478640d5f31761140ba321005e985760f3559f06fcfeb6ff4cf4c599a0d0ec7641a9b3752dbb1ae0f540c5b80e7dc03e26ffbad9cb123735dfeb75d5a01ac3ca7791c875d3db6af268c4b2b53717c403eb24ccb20b17ad7bf6bb0f5fd557a61ade6fd3bbcecdca8eccd26e6fea24b3f3dd113d65e94f85d45ab3d5900cc882a2e3f90eddf0624cfad04cde73463588a14d5cddd34cf5bafe7ec4d17a0de84275ecc553808d3f197a3eabd3612f14724b5f2490d4140cacb84d325a142fd706c8c1f13757174853ee62fcbb93062b6c8cc478d44fe3512370c5cd9559a51bd71a7c4688eb690c8b4bf334930f522ab59f44169e94b7db4f5c7a9b09d8d05eddc869d740783a6a729696ac79558d34e1895dffd62e068015e03b4869ada4d5d6790030a3e4806b477ac51847b96af2d343e1da19518c86d3d393bb65e7d596e8c549e9d41bafaf3ecaa2d05e725d0f2fc975d34c63e2748b2379c50cb911d039f565790b7baf4a8cbf78866dfe9db146e631b1aaedc0fe71f4935c9c5967e5b94192bb362a9004aaa1bad0b96fbe111c990039580835b4cfe847454ad0e842058343ef1d67db56dfdd89d7722f617cf0c89b8c003cd8924f5e5c5ccd2dc3004857eaf573ffdccb57db7e4cbfd1474be4bfc5417dfa07957f4a071f31459853e59e4c61734fbde52571bcf015ab3d6ec14a635c3d3191a7d2cdca4c6c64726dc4531a802f6f1a1e62a7728cf94145d173ea3241cda7e847d2b8bae068bbf96e18093fbe18d9b697fb8b5251a63627fc6c251e9fe01d731600d5fded4f69210a9213b6da70fddb5f4cac83553b617b3342e509248b3b967e4e8033dfeafec9744ae61c02315d2fcc0924c1d25c9f6df5327b16a3d0afd379e571b56295aa27dc15d6688b90fef30a3c6fbf5d4d125db0e82f3c98b48df8f7a322b21cf5f15859f32d1ac43bbe9e4ec27d9f6c7d3c3ce234265d2c7228ed23d35dbeb3499c246b682c78196007463491ce15ef0ca33f1e5cfd2370d887995f98ce83ab6da8c65e129841d1fb7d465bc4914493cfce578df9dd972fb8b280c3482f424960bbf16d56f2f99caf649d005dc83ae0611253abff4e3adde7506ca1653cbb3bd3d487550b7b318aa7a8ab83804ad75c525f6ea382d150c6c2087ad3297b79b4b95ec2cda91238f8fd3e6948a1bc658a48067276634f8607dbe1b8b58cf63bf1d890a87195698debaf6b14a4802a62a84011fb2d0bff4391c095773b7cfd8ce36f2d6f109ae5bbbc26bff680287722cddead2eab043867b65d983574e4b39fd17b24c08a8de02941e4afc33b36289128cac90df5d0322d09865d7cc8e0efa27ef35f3c0ade59e17e31946129aa9e89eadbc454d0a35bda2e427ea0019dee55f4c6c2b2ddb70439bd96d0864f3dac287a75431ead50338ad16b0465ca0c60132029ebc4bde5961b45b812a93a1a6f70f8f2c6f2c40253c461f1a83c9ce2f9cfcc36559fc92aead33d194585d7a2033816fce232f921ad4294720015ecf71d3c1563bb2d89864adf583970dc75ed72f90a4a5adf63391066b4eab58558da54121654a1a07ec44afb271182c82e0049e0bef9036d3379a36e2cb90e0aa8d786f823cf4a1b7447eb66a5342c81ac5a773ddc16290894eac5f7707c3f8a194a0fadabbc0da2f7be92f650eba83bd8106049c660a84f5f18d43c93f63a9dd375b62d86ae1bce753baf299d9b9615426813c12c61c08e9cae074b9a23af2fc833a41392a435cb5b2d868ec6bd008ea2ca1460753d668872af89b7041e97e39972d63dd847efeead2c09ab0cc6f5284134055cea7236468ca5f78cbd81db0e51b1a5711694d0cfd98a6d32660306eb90bef3f948e0ff859417534b5af8d663ba7c79d652b4482fd38af2cfe9857faf8301216c85cf2ee1cbc478fc6e346e1f4c6a3e9443d0b17812f371615e2d058c0495210da9a02e4e947171b0b889214992ca74401557e6a2c8e116327f9c03e9b5c3cbeaef2219597afaaf39796a5b4d715218d2009739988c5a388ad85fb83c224b36cd31dc053eb4add8cdb8875f60c3d6b34671639cc19185d847b7842b975b18e31644bfbe23812d897e275da35add3c1966a7bba576bcc966d52e3f53ad3057c53f45ea4160d7a18df4657094855f4650c1d403b2a575c72f42db03d26c646ebd29f8ace0b52cd4950bf59c775b4cc3b565a8dded4d8be78bc4f34470958034ed7afbe30b3c0fd3cf9b20ed18ebd1ed66469efedb93bbb87e910a54ad1a37227fe5076a4a71af81176260d3635d6a01a1ed162973262ecc1e9f6c7abaaa43e01544e2f5b000f2529d60adee2abdab1cafb87acc54d298483d1bd7ed8f47eb08cadf7c082cb922b321d37b947ccf4e29f9e6f18bdd37f0085275ab52f6f03072c8c6c21097b50617f653c7e08dc0936eeecb588d4d6e2a5de33ebfac162f1724ba203d28f878b5490c846197267cdcf76ea207623032c963b70b4ddfacf623206fc4f1eb1c9fc18197da770e28b5b3618e29f3440cbc31e116d9ccf3179c2324965cbcf4116a3c1ea738c02f2536c5272b1fc32d13fa704c58c56c6c2e18213527086cc093c77f1a39e22b918dcefda9c668af68ed44944c2aba7d7666f70dfbe40692e027783b0cdacc626f680de0caeb175add20c6a178e3fbc302b996c7471da61d251799d879f52eedcb6bcfd79fbcba3e4a848a0c49ebad3353b3b47c68f4781d32273accd8c6717e7e7adf9a66e90f2deeb7b1d10db3ad62a1e5f7a126386ecae8916a0461956c0f48b2e98b664fa8754fbe4cd9d525a972c5e0530b9261a81826b5fa7ce9e42b09fa92e371303d5d042b33de97c758e6e54c8c47a96e726c996c3976f6b7c21cbdcbfa3afecfe4ea456de548db0ef4e94f255a5f598828dd744eb7d4daf35535913db25cb68f94e29ab24288c1c11d3308caa4172582c64f27d9e02c50f9114c311e93dd1d6dbd05c239b75ea08999c199ff9d46c5dc18a207f5d8236fc24e077ea53bcaeb2a6dd78f81c6c43aac62ba2d0b136f7844efff5c1bf7a8160162475ced12280c9e6bf3657c7ce249559baa9e2131597f008a76138767b4ebfe9071358e1a55438ca7b5c8f1e3fa2933328925039adf763992b8b7955eb0eaa38989b96cf4626d5431c47a0b6c1723f3490203dc6f4d766e59d44ee90139469ef23e30adc54c1997dbfe570cb18c2cbc6043212b5a8b8068057fcea7fdb961cdb445edf6f734c9bb329c104e88f65b27cccc1043efbc31440bdb39ad06a9705d56860a44790487d795f7db83a48fd796ea39050332e9495fd13785f6d4fce61cc517d3ddfc09c2e5f951bf3347631146ffd32b6cc72914216e624cbf794864f83d1fa7b593f20579eeb04c79e6dc21b9f267b805643ab8362d39ab84aee8718569b81881e724111ba3f9b9c1d9a58ef10a220ec09da09d30525353f6ceeb758c487cc8862d3b11ee77bb9f6f920a2d88f1952c8c0755b8c054dc3f21655df3d7421567d82588b173f7b17853f28fc7837450829011eb9e403bf3624cff7145b44215d665c7c15e5822757c787e864e11714bfc98fd068e930228371f566a6bfea238641d2a4786896930eea7375a424b658b042eea0dc488250a847d8cedb4feb751827b111ec6c4db9862772227dced52166310e84388a442b915da07c47bbe57920e50c82fa64b6090e12c911bc16b87002ccea3359c9fab3b5601e8bf3c7ffea672875affb7c7465487f12e0921e23e6f0f65bca7d607a1ddf9f6cbf3cb95ee8f554d95f4e0645b45efb9e17dfcc47c320b967fabefa0ff5925c9303877fb0e9b25a3a3a1767013a0783fa1d9e3a0952375690f75374cb89dd52c9334a299a3cbbf0fdc6c4c4afe3b23e0eb7088f703845225aac56a0e7acd852b1936ba970a204b05b356ed6a180c96070238ccd92ce77c06f71c936ff9837ee7a9fe6491565a529e81ba7b906730a3c967dee9ca8e8202b59cfc26d07233f9676cd28a2fe50fedf5e1435d59faab0973eaa611438fcbe2b0f4a280f95d5dbfccafd3be2c56f5e08fa6a5ff99f422d33cb9cc4f5b06b0844a997df7f7346661bdb7cabfd7d76b97b72d4162c1c3f57319b40c714cd57aadd5f40b604d771c8e4cad43f1ae80db5389c96815fbe9fe8ad7f8fb598e3c7697c6be853c789c5f9d24b1e63abe134166df7075ca624f65fe4b038c696453e6f42425f5f644b5a7ad597889a83f73aaae33adfe497e6b167a751a7dc2abfc5db53891307dfbbfa68f6ae117e56953485ec1649da9d6935483292aa8359691e080eadf78c833a11b1e6d0dcbbae642363d366a83f7a5b7674f56af27c9c8bb2b051736a55265b0b6b55fa34a01dc6e37d67ef32fdceb6f4cfae74e579b6c51eed2e949422cda6f536d4b7e25f364de274f076a3cdd22fc9d8d17fd382f187db934829d8a4077fce20901dc72d36c773e20dea714bcd184d</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-flip">
      <input class="hbe hbe-input-field hbe-input-field-flip" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-flip" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-flip" data-content="请输入密码……">请输入密码……</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>S2OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>S2OJ #636. 购物 题解</title>
    <url>/solutions/solution-se636/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="这个密码好像不太正确呢……" data-whm="这篇文章的哈希貌似出现了一点问题，但是您仍然可以看到解密之后的内容。">
  <script id="hbeData" type="hbeData" data-hmacdigest="8434c09819020b56ce6ba95530e6b36c626924990434ff30c65e04d8298694e7">dfee31cc98606e570b6a243cfb69c484d0094c388d5c5130dc4a9b5f224f8dc0a95fa38793058ac1fbe0ec669e9a2c1e9269de44a1db9845700873d6f7eead08900edccb3f414c00b942e513aed58780a97cfdf01117ae1f4f532797219a8f6f0de30331ed7ccabe040976f4ade7bd6db388b9043103b782a53cef3581aca8d0f6428c946bb070b3b2f239237eaf4d174c65a767619bc7ac160e653099875c431ce9f4cfc96511cf18331fe769a0adf27d8ac38e208d431193ac8b63c1838b4b1f8fca6f5741451e6a0ef5c87089e606ac2d12d9d9849649b01e6586d54d75ce953e0fb3a5e34412a92bb88c85d1fe8abfacb5f10750ae972a7784f6ed7bf0f2f2dd289c456da0ff8c7273e928642e924a43dd0db29c64df4443a2ceb204881276a8f1eb74e0aff0d8489f74087820a4965ffeaa221342602116a7be46c31b4f15642210b1a24abee7b28780eb75afee34dc9c35a2ae97b36b336e76232d0b93e4ce8927590735ba474147eae9c97903fd736605226c1653b609914e6b9f03e08171532113cfa989fe450c73c8490f37b3f092b7b0ef2d05c709f43787241c31443fcf3e50e5fa36ca98c9c0f54eb44763dd124713488573bab9962db9bec3e1898fd497a2b762f745b5a3fbaad3707539d500348b5ffea39e3c94ed40c067e527d06076c4434ff6f969f38358d8356f860d209a7b8c37dde99ab0a967cf2a6786a81231ce7ac04ecb1ed25067a26a20cdd32f077b6fc09bea596b887ccfbfefe0777b08dbfd1690ed49f097775e0c8b88278d51be1eac9c594b221663cbcac7e86bc449d33ab427e38ffb291739fac2855f7ac810912c448260571297febfc74ecb9f49fae7da036a17304bb90f5d5259517f5d4226d1f315d07ccb9514490899884e5abde9367f2092baa479b2b024def6aa6c2b442aa84d522b8254f1b6b7a8ddca6b230c8fbb316c400a46f23639d813841ed50f6297f9fe726c55be06e79b3d3f6d9d7c4c55050e4213e3c4d87edd21e41a46e9fb8c6944f1f71b8daae8d6e5d5f8345a8fad1354840a109c445e6d46f4c1ea76ec1e8e97ef07d4a1b2323224ff9df0e32f5a944b7e2f43fd86343c26f7a10af2fcacc327f93553279033478bcfbeed99efa159f25537435f575c7c0fab4d5cc1f501767e3d3e25d3d3f04e2821804e9130c8ff94b7558bf40af467395c97e694fbf8ed2bf9657472e1878fb9920e55a2434f12b5af6331f1455b2b5dff1a4796173db2d9b7552a0432113d5d401b8f5a88d25d5e5b56364491eabfb024952bef4aacad0344b047015a5105bc03a05a580271f347803373860c9b497df10b3e95d2e1cdc27dd10d441e3ac975707905b002a8b6387fc9ff3cf9c24d9ac33307e020f15dcc8979691f840382ad8a24d73a969a8e4db6abae7ce3f1f7c4d436b93864548357465f5ba78aa9dc92de2b1d6876fb346bdffb9d763ffc845eadc827727794614bfdb9f97d9ce6e91ad55b7aec1841d820bf1d3e301ec2260e60a8df7e2b7fcac3b910c94a02c35d948bca8b0a33ffdcdc64cb23821c914e600b8fe4b94d6ac58bedfc23ad97162f5ff2c8514fa1d00fe6b6d4dc7adeb0799ccc28c389dd1904979eda63a065980f415ba34b39c00914c23961db01551a159e36ecbf649bc4008370a589b00bf8237a37b7669068c7a3b08b4df79f6d1822015e28a462a28c9f93c85a9095c840c1125b3f5fb0ccbc42a2fc9b9c7b14627e57cbbb33851e7be027da362f1cbf4e67896fe831da3ab3bf929c1e335bc255f046e442755665fac91b357461bf0227d965f761f8975c1286c7d5da31391d2aafb34dbb0b8f8edb48f66d44f503cd02901ae94e70a4fb2ece2c6976a673db216ce8d4952d949974885a0817485cde9bbc7fb1060a93d4d4da741bce8db9a1584388b11ec892b6ac9066e4b953e88c41f39b8a309aa505bd4349ef63e51426b92eecc399e31403926ab16027809d1c1a0d2902d5158a01b976439f9439aa36c23a52d939236fb117ac14c165975ae7701c22386e278356deb5cfd83f95821f125c8a97aaab1d41626fe50480dbe71b5d19da3dd85a596535a662b3a98f9e8d7883a72b7193360b92b9c58499137db6790e9475b12fe70ba60215521f756f3ecd29ba9d00ea9ed4e4955592b5a0f6d3952b734e5605eda969e8db99471beda9c8c6f8c653450e9749b05d4986e135d977dce817635762b91f0763c7da0f575c34c7aa758649aead1145ef700bf1bc31f25e04f62203206815d275e0d72c26df2de295d2f9234a33d4832d83d8c298122826f718d096ab065b4ac3b6888215d19083b97552ff1090afc267a109b94a3ca5ee754a361b61429723554c5e5ec63dc7551a08a70c9d190408db2c65a79f8cabcb7c45484e5c013698d9fb4fc758e84979afc82f656106b539ebd1822eb4a84e173baf82e7613b7494daea14c010d5c0fd0bebde0aeec75e3d3064cc33ec79f0956606e32caea7e1f786b4e6bd0d357b6f0c186c8f14650e0a5ccedea4649106ed82192afa0659918b2585b0ea183256d20ef0d717f807d6c4ebdbfd28fa939d5fa01f78feb231ab777399a717e0bbf21f6777389c61bfb1bdabb931babdfbbfb99c055288303a67d84fcb97329b24e6ac1db048a6798849690b16ffca4f432385a13be508859dd205ca9cce1dfeed40a212e734ebe582a44468d11aa4e7a234f72db4a6f8b95113b92655bfd4fc02cb2f456c9112df34a99b6cf37109e20ee6584ebc9c2ec0a6548ac2545493295ac49939952973989bc5848001f4c0fe778f5146ef8e9b020a8f33cf8747c9ee57b12fb20201a12b8d6c7001bd7c4752865b948e9bb4c9bdcea4c063fcda222dcb949399c5212905f6ea12a09c0f77d11d1e5d80cb5f8d495573d4131beecf32969a92ab276b538005fe1f0562ce02e9909063a485c403ed4440f7315947b4317f5862bf4f824124cc0f3e57b31591ab3e013c9fd7fdc91fd4296e73ae543992a206cb36f0f21b691069c503fcf2b2e210408cc4b45ecda6f896c68c5a3484e437e7b76bee2d29ad1ce72bb077949052a68d3a5e48267522dda47788ed64ed7bb742f4cbedc4d5b7e6f24d5448784dd698f108061d5bd1b53599f1667ac028260d77e7979d104d42b5792f5bcd8460215662a4b2f8d9712ddbc35add11fd67945609cf91a14ba7f319cf4d5700bd0ceca29be66e30ed78bd7820ba4cd885b0f5da9537a95469f843b21d296d8ffb9147ce3d58d3a60bae7f4f345925a93936ae367959f7920612e7816bb9ab2cf907dabfdf3bbf819b0e42aea02aee286100621533ef45ca4a02bbbc25796ec9e8d9e46d1c0c8f46ec1d8a77a6be1f4af3fd87c8bdce749a3083ce0c8ff9bc8ac5705e78e29c1329e487acde92410a94ca9a74766c3ddba140477544740f3fc54eaf076f959c8333e4dea44e2f6913825054ce5e60baaa00bd64060bdc681279abee068fc26cd3554161e319842501a93400f819fc737f257d94220128b623d3cef963649f84c89f7f91339ef2f6abf69d299a4f297456cd80eda25ac58d338c311730267fe50c195496589c846d56c6b05e84f1d7a21347974872f63b4b1ed763e8658fb5b250794ec3876c237f81477c5785eb970f0d78b3606e90ebbec3666f840b55b83ff22dcffe584ca4e5583439bc289a2d113f2bd07012663fd8f79e5b5a2e4a293775244d812dcac32caec1ed4ba289af88faa2e05ab00360128c153283a2ce8bf42951671490de4564cfbd1c0f70ba9a4026dea0676817a2b9e279e34830f1762c3e02134e2dd60e472ace5b3948dee74b5f5253b1d1668ab1ce99d0f6b96cd449ea2614d42f1ee607f5f7fc5cdabd9ac0b7b34fa0f4f5e4a415879d099766be37ca9c8a0839ae53e3f6b12e66c7fbe89410663d29b58f44ec4629bce06a2ee7bcf5e2e5a57b6b35455716a449936e7c6caf1b22e6e1ed07c483a35adcd70a9a53a8c58e480f511872fd3a0b13ac9f211661cc202e98c67ccfed555c3233351ebaa63fa7931811f27b99399d29578f4ebabff78a3f7c74dfd286a71281ee8448fc754fdf594fe248b17d8296417332b811415f8c3635b8a90a8f0a58f3cc3f97c08d6705bba01bb1261d214941dca0ce8189dee478428776e1e0e33ddfa6e7f56cc6863798d20e74a9f2b956e67b1d44494cbe94dc471834dc24528231b54801dfb96121bbaf818dd72a4caab119583fa7719eafd3cdf47901b88cca794e9f79be1d53c9c8860a399975208888f8df0c89e63272a8c3dd33e98d9b275f352312d32adf619aa88c01fc4a2aada8eae23eac68c1c8ece4c7a337c9411c3b96467b0e5f7548e4307d08781d3624703609b0cdc01ab0f56f3d6e861aa7de04a75a102a7b6420345f6d2320f7edfe8d92b99a701d7a3d7be01ba441bb4680682b3ee119b74e3b930b52ebaafd6a9ebf9c252079aeac775540a79cfc9b633c70f4d856480795ebfae915577be8d006df4f81ecf67a94ee740421c86b2eed9022b4233b1ee5c2750cc82cf98cffabbb0eb2eb283f3348a3f6390374a4216bbe2d336db61ba22376ffa346f7c43df2ae8a9902089069b77131cd0b81785076730e70587db6b54e9510d17b86b319ba6dd25eb1cb793d4418fa273268b89749ef281665d4ec1ab76013dae814579e5cf827d16939815ce8077eb14bdd9241cc0de7409950d78ea911fcd3bf46b8a9cefa9e92e165af6f2ebe3e3cfa3e64b7c071e90430679ffe7cde33915d597ab98f3312714444ddc8108d1abd847f0a08b09d787937a06019649ed787a97707e41550a83cfbd5ddd94eedde9d418d0431d2d847f594af91e0d8297b500fbbe44b0b720ec13e4e13276cacec6f1a88afd2e3ba5f175e3bc56c9ca611ad929f08e824dbad09f225e043270c1734032894547afb5a5863b3d1b305d79efc27fb28b14d31e507dab3f825b3962206e51c14fceb7e3dce7dc5bf9c4b9b40950346d874a152f7765635022ede19cad12adc141052503467815afc73e9c9db32666a58cd9d3d793c4d928350fdb6027f5418048d4c9a8d4a7a6a42f66916706538fcfe6b862dcdc74ebd434e08af468b1cb52b9a3c5facfade284037d978b43bd0eaecaf27a7f0ae85d6586aa4c00e889818ee905944edf82cd0b55f64ede6554a75d1ca0f292fab4421f10ec9135517e8f1364326f3e61dddc5904a64ac4dea08254822638c900cb57d6366f3f3f6d51661d5c55d05aae9783a799c7b6cfea986faa98630329437a948958dd099f6ee4aa671b5870f06c2a4df4deec424aeb5cad7d2181c4fd2d517d21a10097bdc5fd5b702aab96364c63941980856ebb377607366a12ec12d6b85c3c25135b2a93d2c3f5955c91eece853a977acb5f9b320229765f1128faf537ce4552a0096a959540de216c405be6323db18d38d4421d62476538eea7777ef33ba72846d96d2bf729a29299e12833da833c591d2a15e58d1520772f72333b6907a105f53c37f56622b346ea9dad471d457feada4a182cacc77b72eadbf11ff2263428576c1aff62e32c055b0ce711faaaae7ead1a0c41f1b4a067f058ca50e989b6ce00b1d5704533b0940b1f1cbc4b3898d0d028dfc971067aef077109bde6d48911ebad5d2cf3da28b084c57ee54dc5c5caa18997ee2fe3e714c8090c0358a5b10bb6ffc7f3c4feadcac22374edbd2532c5c2b555577dd7c54d2784772e4c997a35302e2016b3ff281432d80ad29cf4848d4d4017bfb9769c0855eba0a89f856cb9aa549aa4a65b1977c5529467a7ba4ce1e76c5776ed5599697e752726fe4689687643c31e98b5239ab9ab798f238d0092b4c10b3d412ebf5bb36d374ad7ed81527d6b317fe64ae0dfa94f4f8a7d505b51eafa4b996cd8f7363defd1bd270ca8abad4744d93dd5fe2190f7a04a5f1fd461dd4b786441a088f10f18f249fe8bbe00fa9e05b48b64f4580ad71ac25c623039f1b451804443fea391ae5309e105230473a84c8ceb46199bccd902bb1996c5285abe7591b617e000787e7796f1cf761a669131ff6c0d67f3c86f716ce11d4fb26f0cfe7b1212170089251b2f7cc013288ba3fbcd240865170f0f3877ab555442b6a0f8bd8e533bfbefb1fd8e05a0171cc3318139dc46c9168b447b864abd10a1e4e423a14d35015e0d7950707ce695316125ef3c38585066e2c1e99b8e315710b7e82fc2a9ce08acd20cdf6b1212a90b38fd4f41fe71ba07c6bcf836ac5f11441d44bf36e90da311493326513405ef7329c4e86d327396fd8bc8aa904578ccd0272f57ad0880a64a49a552c2a35b263ad82ac4c334da724e9904d38f9085206ead8be7a042a5e5ea55aa27792232239af6c59885099e525577ca242e4946b305ee8b5a5344f85b0e32b691eb34bdf0830d55d95476c42bf0a85b8a893c915e511c02fa80f0474eca9eb1e145518822c757b3fe3384793cca12649cee74887aca39d31273db4388e915313907480b9375fcef458d52585bae8e28b7d72b61bbb8263f2771c9f447323376e18a9c660c53b751d66c7b5a7d84fec31cf106e99035fdddcc44c34a3ff3c1f115a5b31b4af32aef6437ce83992514ea1983d4f95ac3106bb6a2e826cad555d62f6bf1a52cf6b658e329cbfb09b0d71d567055d8460769c77ceaf141695e4bfe5e329a217cfa6cab41f7579238f457ec9c54f6c06511885e312b92c480e838c083f46a07affa8980d7fcd0b0e445ab68900ca16411daf63effbf9b3c6d66839b8375946453e2682f3967bc759db84ccf077233a0716205eb875014ca61eece3a01bb84d8ba33d61fb01604ab5739215e5e0db554ace1bf7a143930773b276c9d1c0aa79ee1445d54384e9bbe00a6c92988f9693d79bfe8076a600d082b7f7546e8e67c2d5d98c8cb401a3228f0115e4414af11cd31d85e5a427ce388662558cdd0300f3f12dfa801aa59f192257f31935bb286e429a9bad713bfb97bd5388f7fc9611e2c865e1c97d59847bb48b8c727daab4fd33491845aceade6c475e9c7b8bf3a76f3802e2ffcd31e1b63739d25d5bf92e9aeca2fde79b5afc0b50aa30dcf39df6049dcb8ce904134482f384d243e1e49ba00eda204efeb93d8e33006444206be7ac2efb1e37fb70c9f7d8c16cb40c29f19a0b88586aac6e6cd571cedadc59190ea067baf3b908c210ad9e86463314e5a94c488b9c20b02acca69ef5ba9f7397f973faee775f6e5d62cb22ec4a1bb8d54727e323475c3c09d72af93a8a7486610b40a46ad3e7951352f769a488bed14ffc74d2e9b430020ccaf28788ce6f94bc9624d4131cf251aad1150107c004224e2cb9e8c78ca5c56e0b996e74be71adfbc76b11f2bba4ad7d4c9df1b83f0618eccb56693a525dcc838670c1f5be6e0f37809c527375a34fd145b960ef31659bffdf2036474d4345a1a7a83e9a8e5ce2885a0db6ff87dfd85fba096254b468882e7af839ba6c0b9486d8e1734bb1609de7c171cc6a543393edbfe7162cc72a0eda8d0a5c1e7fea3613dcae08101041e9ec16af3418b5641b5131b2229eb72b14f6b1e0d0fc1511038e16b0d895b056419bd184902aca275960d23985b79af708497b540eceb6fcc783ea065c085c4288407eb0157faf4f2d3c948de4b9aa1c00c010df755fec19efcc21dd01553befa50dc5a3298ed5d9fd19c5d8cd8668087517b3ae459687d2e536e916711acb4fb9f295bda37e76bd6a7bae16d02a6cebc23e30a8464797986ebd757aa0265159cc720c33c5c0b1a9ce4cd93ddaec3e9353589d94d4e2ccf69a9eb9a2442df6b21adec3aeb8931525ef337d5f584179dac5253b0f986418f1414b9e5d0cb8baefef79df26d18cba164cec3d0185ee2523f24f531edf39285e52e6326be24e578850c73eafeaf6d56a55c9d06aa904a5a4f43bfc2f3b81b4bd353b920d924c5deb746475fe1a68394a3c46db36640e06fa43b82895fc49af8c8b425fb9fdd4d013d81973c5747cb02b1330ba89b81843d9b3884003e6dbce3723d5cac877d4780b0015b61d4c31daebeb286414746a346e9dd6b537a51d8fa2e0b8cfbf1d06e1bf82da1f0ba6054be6a7626626f1011294fc8caa88ef273704523054f8a9f55246b1a71bbd8ee5ea0dbc942ebe35d7c757dc5a770027d296d49710f8e43fba0dbac66c734feabe8fb88045f063e64b4666998256f644d7fd00b3183bb459a737e47794902589e6d31e6ea31b0b3868cecd28a7e512cbefe612ff445730292d35834df37f971dc7c610bc6cf16c5ec320df9a8635afa6ddca449465ea95e2ba8f71ba8d6a8ebaec5a785a8a89fb7d8802c193c786e8b61320759f7a2728c02846676e686863429149807743eca7b4348927fde14598cb83ea1131c9f7b29ed2906454bce8047c2395ba5b6f95bcc0938333b8b02ba29305e8b0bc92aee778dedd168fdd437a8e639c79748eebfd51621eec5a5708f7ff07d2281785a53ac1822e69387b0e1de55592dfb511b1eb58ae6f8f74b37f17af2c93fbcf1a29051e54caa11f0031ad084d2990a57c232973a2737d5a17d61a304c34c84b04828b6e96a9bdab468606bce07633d7e935b9e426ad5ff0bdeabad5d370d1f7e57de335c61aea5b11b51ea4398c74721caebbc267fd24791915a926e3e4aa277b8bfd1b2fd625c22e3155fb424564006061ecdd738606054f466e3568cf0394a0b80b0aac8b000f92c9c3af89c30f29aaea04b29b2b4d30aae332e098b40ef2c660f13ee749831018427cb2cb1cba6a27614cf4b2ecf589afdf39f145d415b2cc566eebaea353289cd9cef4b16ad7405c9ba7ad27e7786794cd3d9219618993b15de797b991d950cc73ce008e26b4429c97f928c60a1ce163bd788fb5d5f831bf21a1afc400427a0fb2a589396846be7b1d84e220506f9a88840e8b88f2fb634cdcd88eb5fbbcaeb7b3e74ff9856e4a6aa7344e7264a4dbfa7631674982bf71ca7030a3e14be1e9bdee9abb3e5d1c6f87904e0e6ce04da1b9a703db72e03b8d5724eb87d4be06d869172cdd5c7a0c172f6832a25b3bf8bd02efb51d7ff4acf4a743dda0b0199043ffcfd1352bdb4ef23416759869e9512ffbab4688b30500201e5bf4638206663a605a74b367a74d4618ca70a2877a3b4f86755d62ae984367d635f6c8f64a320f80069cebd5e583d3d8b34887a67b72237af1554a4314f756e501577d262d3e1339e01ee53fb8c975835bd717e5b1482786dc2fd1c48a734f36818fe139a72afec0394c97450a722840284f3d9e2e4e8ebc40eff7bca69bf0b47abc853f875c2eb363f04aa26cea0c2c6c5c063a36abe4bbbdad420816c1bd94cb6c70919be7cc05c399659155fcc31536bae94e77e788de4021c8c2a3b90e6f424f50e32d5e24f6983d69434d6da06ff16f870cd170210c9288ebc95effe250ff8f5b784572b667898b75e79393fb01b9d3bc1bfc982e417dac51436e1aa97ab29b93bb056648f72d263411f9aed961bd8206948160425c1f99988fadb12855e90c5c252121f317b1c848de45cca637249fc44acbc9cdd246f98ecbe5cda042af2cb915cb986d4a0bb9f9b3d49b89793ebeab58498ab16cb166dfb95e1fbbec113f6eff7752f47435c3db04a551db1c1e8870f7c65f7d6e653a362069cc79589e1b20e868c5d5746a6cc040f1bfe943c95f9c6efa6962f4426d69b3cc1fe835635e2c69212c293c1a9855623b99bcac0c1ce245e45f304e53d28cac1650e712949e699f92ab802a523269332116a25918b581de84f2cd34dd5ee3f1661a62251d8f9dc45866213356adbd9fdb115c46b36a9db590dc30f9844b9b681a4cb21ed8a9ec0ea38f56b733641179b28185770afd3ac07d6d820ba377809741d4a854a03d8cd2e0bcbc51345bcf5744ad09a91b50ea07d3ff332c70a74cda743a5423dc25c4d8bf3aa41efc9af87a420d236402763c801e066ca7b75d761dceaf9339a404acb580b1d5287db08f9ee7288ced12308bb5e463f40923e9618d1ea797989ac3e517bd3f2d9f25d2c4c96ce76f6df2c0b45f20f0c287e922a557c380212cf0efc06dcc0c2017c35e054b26657fecd61a29715a6af52c3bd59abf50c9f006ef1216343a6d040c6a54db7b90db746d7e1c106fceab5122549814554aa83aff783f3fb29141ff1a223062ad574cae96c47d7df1eeaf47205d18892f52431eb8b4598f741cbb5a923b2ae34c371bf0934e3b32aac6848883c3c7fb270df65b6ed3721e3b4cb8b0a480552643e1b2dd2ac8879f925166fbea95b4af31ffc48f1232518d166772e8c7c126ad6ff7b27fa3c5bb7510713d086a46d5ee6eb9bb63094e363f1be6ecc073c642ee5959e33803dcf5f2ebc3ccae991d7bdc89801cb2942b4808862da4c45177b98a55d6e516133ae2831797f3649912661058f0ee40213fbadc26e928a2232fb793e81bca63cd382797a25496eaa92ae241018c251f661cce8856fbbd09f3787b6ecbbf4e9205c17533f20d52d95a6d5dd3cd01aad698252724437991e5853d3cf969516cd3b8686fcc1b84c60cd99767d41af3f6d99ef7477b4430baea1bb1eb7cc8be4754e3a15756be877c458e4ba5b30d4529e4d9e858e6395aa7661847659d4d9a793078541c21e2ee2f8027fb0deafb1b0f469b1a16f109f632a406f6b27c8928b11c1767385b9f022d52442a3b78cad3ff5a9c7e472363275a3738115e6ed44ff810f8e672f216bf87f7b2992c4eff895b0315ea62e4104e218d0813750dfd48039888214d4d18d6d381af0c4c976177429fd096f301e7de2c789b334174d41d03281efa0ac05fcf944669a16bc07b9614392eb691fae0231a6a83eeaa117bfd6d2b98d595d8e637d5b8ef33c85fd767c3a6b4e8b9b2a09d63b25ac3de11f04465a13d36033ae6dc0ac9bdd62d90708e67a0bbaf21a2f827d54653e40bbc470092e7cb3281d179d0f9f02b7c1b35c050ab419477aef0914dbe45b02c349261d84f7209dbfe0947f1ce151c5aa653fdaf21a7b728568d4a4dd587c504581625450c1550e031644281fca83ac8044035566ed092b35ba431a7618aeba55e7be48adc9508c84b6322e1e29316baa6b1384730ab567f5d0755ca38dec8710064b2efd814522ff1bba111998d0a9aaa5a317b57b815618cfe260cdba2bada769d6f36f91fce8510dac62bd859eaf447c08b6f215f768b312b51f11ef55276fe20c54b417cc567e95bdc42d043733f1e12728c9fa4de7ead6951a548c87cf80fb69e95b3002573e4e1fd6986c1007f5cef4e79fb55648adcd60112c57bb7be36d331dba1019c2978482bafc682f0258701fa12d319941623c5e69a7270652d0b5d9e7102957a486232535ffa538965352c37270c1c0c24aa2cb566ab0b9b34c660c0f0c7cbd56072ebfb92881374fcddcee229511ccadda72aea0ec8b3d54e1db9b5b6dcf82dd74d04deca2310e28a6171771fb24264861ffd1ed586ebe0f648428a6d65752eda87fcf835e4b1696aa27aa936367c13f3653a6aa77096781937294323b22f04384a8ec7a55b2e59d59d093d168b4a982b4188904bc299d93be4f76df418f9203dccf671f6c67c627c352617ac41a2aeb31391eb5ec8db009b18ed271c237386e4414ba5cc8bea875de088e608b58a349c6e651a3703c4a4a4c641c2375f03b50d5b6e7b6ae041a99461991746b2f6723a64bcdf4948ba9fb19d0435e08e55005f61f5696ca1b53df02109579ff9871f4ab5f6cf436dd39e570d5b3f3b2a4e207650c54cac25e402ecda04c2d3cb9a0779b1b6c4d42700f7e41be86c56281293ec7744a8ccd6e6b3fc93557d716772f59addb2a7755e914a0c9346c976abed786b4948879e18034d3992c6aea1542f83ce579af2b414631b09e9f76cccda4e30a75bc86fbb1e268a7734e99591f0a668d71a5e8e378e77f18747aee25747ce0cc762d37751381af5f3ec27189337eaa56ebdd830c35c8fac2abb2bc9157b66b992e7a68fafcf15af96f2c91fb8d6e25f7e3c359260ca049820327552a98fd525e07bbd35d2a19b3336ce9f344a783f2759d0056d0d2f88d9eafb828074bd5dbd326da5e1bae702f4c0f51fbc27f2f97786dbbf1b406c883df11cb40c0ee44cb4e5bdef7d67467a2bb090da745c130904963f6c49a560fbc6e6c089f2d54edf7021cece6e44b6b9cdacab12a0a59535f2138260570837374bdc84988b5bef6323f430192d7f4ffa91ac59070f6b02dd86bbd77c00b71c2976b3e35727939e9eed92d74773b6dca0fc60f007</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-flip">
      <input class="hbe hbe-input-field hbe-input-field-flip" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-flip" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-flip" data-content="请输入密码……">请输入密码……</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>贪心</tag>
        <tag>S2OJ</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>S2OJ #993. Merge 题解</title>
    <url>/solutions/solution-se993/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="这个密码好像不太正确呢……" data-whm="这篇文章的哈希貌似出现了一点问题，但是您仍然可以看到解密之后的内容。">
  <script id="hbeData" type="hbeData" data-hmacdigest="9d12caf8cf14162410f446c78964d0dbeeac8306ee5fbc6b5f2bc495a6bf268c">dfee31cc98606e570b6a243cfb69c484d0094c388d5c5130dc4a9b5f224f8dc0a95fa38793058ac1fbe0ec669e9a2c1e9269de44a1db9845700873d6f7eead08900edccb3f414c00b942e513aed58780a97cfdf01117ae1f4f532797219a8f6f0de30331ed7ccabe040976f4ade7bd6dbdcbe1bc38e6cdd397e7d3b22b06cb7ce095823249098bdc36ee9049a418571c4a6daab97bf41dc81ae8e3ed90ac2c91a1b9315b0a21cf17baba16f5e292d7c8b05a42e6a7613e3b03ad646bd25c9e5fd1838aa52793f87506d637d72febc287079e4bcb41177df96afbe962b260459e5b8d285c42805cf8be0c44df7de647867a999ea6f6474afc13915da175734eb5e6f0f2c7cf0e5de9f8b04494514d22f95d86bfa9e29d64b504081e0046faf4b9a71049973ae23f771afdad7753943b7ec8bd3f39e50430f5b888ee982a7cddc75305a045346c51a413336e9ec47d949a4dd656f48b49afc86da2e9e75d2979d4169146a9bf3759d60e0f5603036883dd452953dbd50b0bf8540b77c4f743489805883776e01eeefda23203998b2264292512a1b4424bea7d33e007345e28537a466342e5af4c3b17ee7a4c5085d9aef80965ff04cff0f92cf08af6700a881340acd55de6cdca33497dd859ecbe6983d9eef5c169a235b254d2e505eb32bc764d8ffd398ebc3739e71777017a29aba8e62aa126912ab2a06f37f1ca6e7bb4fb55f0e1cf8ea6323e27947af28eeab04be86bd5f576c9d4f71e5f9b2dc2cb6f43b1eae14df73259780610477985d4908b426f41a927dc4be433ebd0466cfe2822ec9d5f876b8fa394faad719eec15e3a2bf7880134357d17661ba6b232b03b5686599410b9403cbf08ff1ff71b39cf3832190be98b674660cfcf933cb8e00693d6cf61ebbd7f7b3353626d20b4152bab900aa087345f740131b3e313edb7575b21aab9f5d1e9ebc391ac4ae6e9f9294935719d3943066cd2677d68ee046eb2df095ff59a28af9267465c22cb1f49a84c22ea19bbfb1922faf4752b194cf801e3d90a2cdbe97481cba811ec809c206f63dd6d80268d9ae3445eaf950f595263f9aedcc3194633e18251854c56327e5ec0d33784928dce1f66a3d969877f482da014595cbdfc961209cc79ba79edc6f060601320f82df0cdb6073c1b49892cde0555c9fed44fc2a79988ee3ab38f92281752bc4a31ad83c1929ea935723d8678c5199882b9fedde59e325bc5a17ebb86e87536200b4cf9cce20e36f8d4dbd85796fc956c3dcb8d61cbf9ff8a68b25e918a4b0de860734a1afdb2c58a72b7734be5129107b3a65b5d1e1fe121fd6c16eff5c99261b1902cae93d842eb70d3976bcb7c8c38364b70e08a3a310e892739c37eab26cf2791750c27e80b200342989e662a5584079feb89a5a9d3e4217aed15ab592a27e7dd99865d74c49b24ec4d9617988002e8fae784a5f5728dbeae94d35455dcd634dcf5113caded8ae0d44258e1d092d0ed63fa6516e5f931f5e440cbdabaa03a67d476d5c15271284338e0d945c5edeeff5b9f1418b9d75f5acc22221f9a8907c294e15856560b8893167dce3d37f6d4512050bba98930b398414ed4b3c1b6e6cb0a68673b377feb8089caeb8fb0da005400a717bcc0029171a93e6d7449080f190c05637debfe3b58a8992e680493e7dc91ac3fb8de7e1529b689e9be970fedc80d4e0570668b6cc3326f964ca8e615e5dab4897b8bf8398d30f3ebd87a28c42d816c321884a6d62a2fcc0a1073d3db32b7d3a56c4369041fca972d396165fbe156eb658eb2549cfccb1effdeb90a9d91a44828b93ec213f285e1c32a0912440095b8ba93f79b4683b601f2aa0d1c356a25673bf9595409a6729cf1401a482c097fcf2fb6818ed5764030a3ff99564369d6af2afe85b105ca9bd49c02524209e3fccdf2cdd7bd56658dc132b26ceab719958368008978f96409e98afbfbb0bc918aa98c97f800023f3ada084672f97e965c7dd8717ea500ffd4b5675c8cd05c2894a461b7cdf6e2df17c091869c8df89920d123beff47c78f55dec181f7fbedd30e78633d77534671e5a031e1de7025d78d4e0d0fe12ed81699d7d1a11c87e8b1335452f615937b2724ba494a805a801c07caa1f830e65f8324458166dbc8ea2b627c5003e1d59be01c23ca7716a437f8f357ed3f0c057e4962f84815494731f38f13f213740f025779f7c16d7754c7bd9b7b782f2a5157bf1ccb18a7981974186d11a390e9ba3e65d7c6f2d2d2864fa3716278985315eeeb7e9a4c5fc1c19db1421694bb43f8e9affcfd43535bf2faaab19d82b5d84b43cd98868225f153e82059eaca6e4a324314d888a008dda8540bc3a1e6c1aff0c7e7cb0b3f8fa8f3e22019787d4ab8a348ad4431f41682a08b63c72e1d16e2fdefaeb5efd187bcf55576b8c778cbf31568e2789122f879a5dad011796a9c9135a6d8d8791a05fb147136dc900128daf145ec8e480b9238a1da2ce20b495edda7c1aefcafe64b16f2b07ce64bae92475b8af652115d15c0058342c4306928cfaefbb0bdc4c0bce3889e3b0001e6dae62935ce565e0561401b9bcee2dc88f2462a3a18ae3e882fd4cfc5c44b1f2ff1def6320d8b158a0049165d3b8f18eaac5a7ae1d07b33e69b06a27e3392c9ea1115cd37dbaf7329eef9f0be33fdf3301b09f0e0c3bc7eed1731522a1973827c857e433a48d8ec2a351414b05448bd6141ed61a85b43db55e89167f89be6368df72e01bb4bea8d87864d81d019294a9bf672edbbe5243299d14872a970824983e5fdefdc4dc1c61dbf7c81ccfa4ee4321202f6a073cde5772fc42080219beda73928c3dd0241b4eb0e0c9812b89ce89f203eab17e5c9b4f0059958706f2b03744b714f673652fecea5614a1f247cddb26a7b2e4fd24cd65f4443f9e86fad04ca57ff5a6efd1c6872950552193271b9ccbe51114074ad31a52e2e91bec54a20e0e9806d7a3837100a829b41695935fd78ef39278ed3801f1a975dae9edd351ce765c9557b21e400e195ecbeb6c36b5668a5403047f826e3ffdfc83f9569ba8d0d059f17431e4300406d78135010261be488b5805055df2b12e6f0d6b240642a7e634a45ad649a0b1abd13057c195220cf9e2be7f183c6a56810702d1338ed12990cc7e54f1707d623e92abb1378c68e9455ef16ba470d1bdb898a126d1d8a9a4b022e2178cf1eae1b28ff8bfb03ef002b35c9ff842cf1b86fcd0119d70606fec6bb2e393f9ddf629e422a07378e70f29dc5d89b59f9f14f94a4e08777462cc65f09ed5e7a0e8fce4c1c54c4439540560f5db86a917ec1f274648fa5737a901942605d16176c345edebd7c35a468e5a7779068288a8ad485b1de6a250f36a312de7dd2ca434e8e024b22669300940dad748687ad76436519c9df5299b36fecd49fc9c0b93add3ef641113d8a695e81adaeea22a95ac8d5e28a556ce7dd775434cd232a30d4b131548f82f69b82214e0a3d98b3cf0811bd0cd188d90879cfa2828282e1de8eeff81cbf025aad6283c0910665958a91b8c11a2febe9c5bbad4a9e38cde4850afc82eaac41c9878eb6d0dcd2753cac8cb285e0430b297b4536854285e00b7216b0cd2e92946f10bb72663811c74a5509ea121396029503bb3d44a46236bffeabb8b50f98bec24c94588a7ab39df12c1e19ddea30a73930fa9274630dd8cee1d653aefb5024f2238ab89a520610d6df22d77277d3da61b601d3514e4e7ee8cf97f4cd7842ae58a8f27a4e8778f81f1f9498d93706b8c08d2fd243305783a03d93612726c89c234ee53273678b2bebfa859fc95baf1f634604d09044ba952ee339149a52b93c8018eea11e2fd721dae07f39c1d62fb0567ffd31151cab03c334c98f42243738081886b167823e428f7265560671f2af19ac6edabb5b5ff325db96c97f13a16314c6f19bc974605e305372c1588959ccdb53466adae53c42a6ae4491f3b94a8356f9e740f7a0a385c6222b48885b92be72ca3de0ebfdf409736e109a70383434235edf016593aa9e4000162e3a06b2056e57a320ff176e5ad2a93b39c699f8b7926b9a3adf03ef71896e0668203809340f918b5ad100a66ce721731a555fb5bbdc024c06cbc224982fec11c57122ea16c6b1b8b0bda2f12e9f521aebf013c6b58226232647c5887c7562b2ebb2f517e1ab5d1a4cd1c78373efbd0bbd33f75d3f9660967424c2e497ce0e81989da127e3a9fcb4eec339705299cdce1f99507ce27f98b275e9cc679b442cd5c9d5ad3f80499afb87ae2fba45ffcac9ffcedd8a254b2c433f2fd3e5e5d4b095b5b8c56383963c8062f22a326b4232e5d50e8cc53540866c63619da1f44b461524a6e35b4e71b0778d73ffa781c57368ae7903fefa2b5b2314fcfab43c087545b7a5ef78daa7791fb5446ce3b00c60648b57d7a4327e882db04d75bd8e38543677477a4e164d338e73154c0af737850dc963184420e0ed679864d731b127f2fc9dd5b4e11eae175dce9ba47134682619dfb18566c513683442bf8ac2997aa007fc9fd873ba0aad0fb6badcd204e915c873719d9ab48ab61347310305bde2db2b42d9ccc04aa9d2c6d640606ed3c5842b0e77beebffc4a6d7c760ebf901d52caf3234645178bf88bd412ba19473739e98dffe1dd3cd3f96a90e7766a59373aa7c3cb9e466322a286bf36398c1d0f49aa430ba729728532d73f194053db353473ca584abc8e23a92c83c99f9c626d153eed8c992ff13700a25b2db5837b50900c5a91a447674a618f156651183525be73996067e56707a8ba12513025929a6b7e384dddf7bf485a8bc658e773ee9e935b49f286cc2ff3533c844a363c99131f27b6708438b1910a45d421856cb47b0759a1d8d46a1a08a38fadd10825a4af8bfaa08d033c5f455601ca0157f24a8b59d0fde6224d0acb120b93aaea94296a1af87082d27fb0bd152ca2966e33088d11f17400090d5bd52edc6f68b771d6d924fedb5b26f2be5b5a214fa511169d314e7be7a8d38016efdc7e6dd6b3efc09721ddc98d731b50719e1e6631ccd3f90963b7b370639b6c6cea58cf761f024293952674657a3fa7bc7d9c54f3029283fc5dd95e31c398193f4a0c8a3366843ada9ccb2306680b07cdb050a615201c6d84a499ecc27149a0c96fd1bf7f4471574fc98fe3f95b793973854fccacabd5bae2b227a85d84b6adc69aa7400dc81c245f593f1c92db8729b1bb2910e2b3a81048e2049ca9a85c96a47ca73ce1d65a0325bc529e77ad656020f15d8b49d95debbb8bcd40866af0e2323a283260faa41692f0d84116337f6fa3fbde64fdc9d4f14e4cd166323678d00f43522116fd38ba8729186cce6c801a03bdce4156d8c3c32772da126706087c7ea17a858160ff595ca61954c9e73a9f5c07113ee4f87bdd233907c9607d4221f47664ed65c456ae50c4ce59dd9f7417db6355f4f40a35f273d3f57e0a8be60cc18f0f1e62cfcbd5272c49046ff1c1665fc5d0cda5fb495d43efa43b94a7dfda5ee437e877e3ae59482bd94acc7690a093415e8e59cee0aa7fe79c7a6ba0933904c43dd86cb727607ee9e4493c9b1fc731c4d892e63ef9d04d2f07a9f8cbf086ce924701f6b474c25037c68599091175de3e6070ade89c3a371ad1a5bf07e6122dcbbdebe9d89bee04fc1e86d8a680fa81a5f969e358806b9c24c5dc3b8830ef8f03e09b41d3f2d24db4ddb89a70a93ec98a3587bbfec2af3b6b009fbfdbcdd5826e186f477f76220563c409ba6fa01b37382b006584367bb726dabdf9967a6cf048bf0160fbf65420c9ff3949445e5caec6567d1a85b68a1c0dc5846d80cb620355faf37514ab72d3df7389c264389109027eb278a7ff4cd8723077e4ef2a03b46cba95ee1a06d42b1f301fd0616e766914eb90a83a32248b213299789044a66dde0eccae94a82bcacd22849fdace7ebbf29dcf6fc0a1107a2636be86c45a9d0b17102f654a941cd86a53033b63343a417c70546c4919ee15d4db8a023ca3a265226132d4f475905b0083fb61cfd1cc4e7bd3c16a28772f005315cfa1959760c5080960d8682e29cb38aaf3387c83f0fa1aa3c18423e6ad15d18eda87531a626cfeccb09e4562e482474aa7cec541ecc0d418eff25053f4159eec446064a9b3f448056a261fcf0f4596ed6713679647adede5c1a9081527359f8d962e25a417981ec048531bb56608cc6b6f9415a28bd9f76e199cde9d6e90764fd49eebea8f2925919e5a40e3baf1afe53d70586b7e9a2a70032db9aa1f82acf5a30c9e529aa84b2118c68acd7f8eead3c8e74ac743abc213285dadb322da1c4f39d0d7baeef1937dd47bebdc48c33aed1597f57efcec1b9e7770ae2068847fccecf23786fb0ab8490e39a613851ee08be5f482804107722b3c4b819b633a0b8be4b6f874359c184506bb9db23bd7e1ee56219251571adb911ab3da84b86abbd02f6a7af70a2392711775be0ce8d277f44174ba84a5503bb1038a841796b44a0d48eebbbb0729a6ee625b4bd17e3d85971ee09d5fa2c5de95a4a70d773a7d587657ac9dc671fe8c2615450568d3a7e9812edc36aca306a16134b824111dc01cc89e8b5c26d3de2ebda168a801b22360feea8ce8c2e4c2402a43bc09227880e0b817700d72a8257dcabbfc6c100be0e450a89400d6524c851ca8e9d6a7c4e90ab239caa3f3c469f846a07d228200934cceef02419db40b41e404aab5eff462bcbb94c2c561d590b3f6e747ec2f87a7483a4f9ebbaa9f16e8724f1e1cb01609e7de1b86765846f46877b140c451e7ae1b48be1025e0dcbc974c5ddf487a3a993f6155db7c9cd89d23b262bcf3ad5e3fdba473aed93b1d9f3a67a486db94b5fd0e505953f851ae476fa16d4d86aa063b2675ccc19e1dc0e004a40d5ceb2f04f8c4e30bfcee35291a48593c8efcc86082b9bde0415f0ad982b63739ef23962a24f5e06a0c092e23cec39032f878fece595ab7241989959117db112096cd8f1688639279cb31f0af14b24b943d77544e14bf6db556a3d5777e7c3d90a7c764895b1732bd9a2b153c000055d0e494b327aa52e23ccb0b8cad681945a7a3d37bb0ee31d4b40f1a36bb7ffc95afb08102c14bdbd2b5f79ced0006274200f68d9c2fc182c377e5867dfa2ee74c8b2d20124573429a4f981514b11964ee597af91290d17307bc01a506687528228ec78887adc2246740e5e65678bf2adea4fb46d141e0913a923b96ecd3434c8c70c3d8f95ab9306f9b5fc3ae2ccabdcc745e0c94f28b45d766e335043b65b2ef044fbdb05eb95be5415bcddffd2d816dd54178efea066db20705a5edc9a7b14e75299ad010e086a07f6c37cbe2669f5180053ab2072d45f12795ea96961ee4afb4ae07f4407a435e6b8bfd77b1c008c69f0d5f7a92de18e88e6aabcb734e1063f78c7ef44fdf49e32d9722ef22b6f452112e10d1e92170d03472c8d22749850f9096f8528347420b67de74287fed698c5fbbbffef8620b3401b77fe3d35b9064c1ec309f49543619a8e2521d24eaa0d8deac1d8caebb3da5ff56e85650d8cb82778402703a059d609e8bd85520b4b60200e3b49f0b047db420161f0490b6c7b6ca1cf6b3f7bb56e9f06e8f6c14b876c42e54c61be78eaf48fc992d386be148752bf3ee030321a68c6770eb48680c974583768c7d86b3fc1400b95b93a7fbd3d02dd0af93bd43d44dcd8b58e4ce2bd8a1e4d8a87f8918c8a7c42cf5c227507ce0bbc9c8808a05b55d3515684d3fd1b1afd4551f318703601df5d31cee2f11c1a3d0f6a320172b4eee954c310ba36dd98cff88b0615b2b733c220689525a22b55045bf3bdd81a9260e0be2f4a0b0c6f67cac8169b87855b79b1590547ce850b8668f93348ce4c8e11b0229b6dc23f82121a3ae5202738011eede27b1583923fd6bad0fbc497118947c7cc7ab2fee6d7c5a47628d5f6280c551692e70773b0c2627ded284632605f37419aaf249e1150a39574755c37b9292ee45da209c12d7d5dbacdedb5340cf9b5890f822a18f66ade00ba2396aa0dc7b3eefec5af83da91430fe5facc614d999a92df7506e54d92b6af934266f9a85090a58cf976137935659cf3a275735e03265f986c64979b6e36f3c37c42817d44526c0feab8833e0053212bb2a262f7499b8f0dd303c7691a28b46c31cbf8835433fcec8ea54541034eb6255b738bd29a442e6c4bedde5551baad680586dc8d52dc9557dc1ac9cf94cf379a81a97658bb7bb1f506e7704a15f8f565eb67637080a48cf17ab059dcd2ca87ae8c133e7794f3764de6aa9e6ff5de24212b402f16635081e40875ed189c6598a938ec6a69a82c3c8f897db3e5556687262442cbd5a81d2c908d7826dcf21a95d226144d8580e57032105004821aca16780baf5773b32445df819a113b71deacd8e98b17dd8c12f8c6e18c545fd3d031ba7e831ae315f30bdd4ac5c1fa5f0bfce11778a5cab9e324a3a10f580b362b59c55e425007e01cdd4dbc167e62c3b1d02d90011885d0ca5d4e0b9d4fb4ac2fcb17211a9ccfabb185c66c3576e647f3970d823f3e00de7ad1ab0e849b25e9b02963f9226ed1528413b35c79af41e031156e44378153e5e22359e9637596a60ba4806b65cdd5db7d01acdbcce67bfa9c5c80840b582b0d55ab110ec9413cd5051b1515378434b9f73a31c4da3cdb02e04117c2163f85aa31540afa2fbc017f64bc9c3349679b1b47a3cdfb0909d8a7e30a00530ac159eea47771340d8c7c210e78ed3a31986155972a48582b9aeba80b3a5f577090a810bc0e22ab8f762c017807020a03aceb63c98a22f5b06bc43798d2e9ccb0db78c137fdf95bd07f713dae2552ac2c20740a47ae78d080563dadee98fc3f6e176ad86e5775be70327e432744de98885da66b635e0f9d23b8f942ce5683773c00b1a075503e946f6032c36a6f44891d35ae62b019096b45176c87295297c43444af377d92bc885e1f9958a6384cf07f9dc031521545a22f448c0dc35397b83184ff6cd51770afd98c3efd0ad3f4a12a41593b4480b2e7b651c33855201a63294c857321d374e1f6003c0b9282c3c47497043891fac78f600aeb54f71db670cd325627980a73e0da84e44b3bb7d936f708a4ac29cd4484083c5a31fb7d452bbdb8eeed275e1e0602f2c699d69cd844368ff318b539ab42a43c680ca9733dd9b963095f3e1b1bd199abe0a7f21638c772e8a61b31090038939ee11b79d9dd3aabac99e889a7d223b9f5c7787758d504c0ac601832b58de069e4f625a89e05bf94fe1b571356a127f97973d92661b1e45daea373674d64cdb389b9bde949d109cacd15e6c4fac84d80b5261158b82f5fe2261650422dd2edf31131c041d843762c9fee15f2dc9f6ead2ed1279854b05f3a7c179d6a8f6d73e7e0d1f527ab50b743a139d259698daedb639d20256427c2a0d6b962d2836b0265ade8c9017b38bac3358996a4fa8013520d28e42b567e12d11e43ca87b82907cf07266744262c08562b79eba1b06d9c0fbd956e1f56052a91b6d67102d5fe6632036d9d051faf44dbd3d8cdedd1b6dda3a4445806645e82e57ae571934bc02aca407f1e2bcd385ade6f6c524e48fc9524d93511444bd15ac1714bb4e7b9d6eb99c662aa19595940cde1419e9364b62889d248be0733dee31fecc35c0121ee7094340ac55b735c7515d9be79e53bbdda7e7507ef8e3b7cea1aeaccd5f905c4180d7520624757e4d9c57418f52c4e297da2380bc2dddb23c0ff9e780e115995f64f21894fad0f921d73d5b099f89889388dc362f63e70ac88e43dd39f3edd86b38d1fd64e46e69f0006c93a7d5985489056d9352bab6275234c961d4549e6a239c372919e5478479491449d2e3fbb2b00b0d4d068b0f41296c8de726a19f6c08c81fd7faa9076d63abee8f1000e90d1883fbcd42e7a4e0fb27cb39f88e17c21b7666e865b5641d457af82f26dd854d608fb9dc96c49c252f46adfc226cf00b7c5264001f2edfdca2ceb0a7f056eb751efef706b2213eddb4e352b84e120f6cf5f043afc182025fb4e87f9db875450ce02ad51a837e4fbf59c0a225ebbd4b8918a81024ec8b2f64db73f8b0b206e81c74df54cec8cc7e695cce6a6c16ac9c3ee006d3291a19ebbf0193a5bb0ff14f3b43128ba2768ddfbad571f63f3f912a6615774685759b412cc53684d72d27629f9c1372aaa49310a0ebc237712f64233fc44a1cef3aa7cfff2613dd533659aac0c2122911e5667ad725334451c735bc24cdba815f7307b3150b8ed1022c2421ca3be288ac7b3972629e2734ed464ec64020c26bb8944f2267709ee166a6d291d8720c859cda8bc499505a2845d3cc02f84551b915c869c8efa91373e24dd0351c6adcf426a895fab8f9f9e8babb6878a3047d5c835023015e39cdc40de9ae0cb32c141100ba033edc7e959b8651948f8569ad07008e5d40759e09c05ad214abf43fd58f1a2b2acf352c5b44f9801cf89d853ec8774f7be26b7fb2fec8ffa1876b3d34f3f61d929f9fd7657db3a40484134eceb051026172c017363c223cda324b832beb9f29a5d9a48abac348cf1eea552261a56c002ce0213ab947c94f6b1374e7b677219f140dcd82b084fc02381010d088e1767ca33c076652bdabe879e3e8a8c067d9a9e2c6cbff72b371c0854a392b0ebd0d8396c6ea11b3bcf71ffe3fb8cb9c65741fbfcf8ce1780b9d1ebd6ff1841355f3b55667e83412935b8b2214fadeb634d7efa86225ef03f0eb3c289cf180f9a773b718097592bdcbb161d1ef548ee3f1dbe820eaff82ced1c7996363a6844fd3f70c3d300411bf3882229ca7c4da4c4747392784651851483983dc0a68fbd535bb73260af2afb836f37ba300b9ed435b40d9f23be0ed7739968569ae1af4d13b8e3da32dc832224d77592acf3a120ede8ddab200a4ce9a9bf460c236ab1038e81d9cd67c06c52de67a89b9072b64cd70b77f3d7ee0bc6532b381252dbf3b0b3be873971d4a839344d2c53e5d3f0f7eb941607a60842e1fc3c200b323164d8ca3f73882226991b179167a17b43c6153c2de207ed63ef19725ce2e8877bd649a17afc56ea7f37a24c8c94525cb16d0bc86da9422e6c2a5a393bd5ad3a55987b5382050a46d47d60190f3abbb90cd76d0b29317ca3133d1d28fc9023f78e9aa5545cd043d888f4e747c1cae2823b4c0b653ba6ff0c455b12517a3c17fa924bbe6e53803b2a67aedcec6f8d0756164d94051684fd06f6b4255aa9cc38ac3b8d8137ee283a4175b93ea40c1d5106d0cfb2c6ccb554f7b7977392d6f79945fd8c226c815603e2a00870bf6d63b361a2103309dd8e6149b931ee6ce327e139352ff5229dec5701e6f8be09a979f95bde671536866d312882bb1fb232c57c12cab4155ed64f9342f921d910ed18f945c1696508d982da79cae2d326fab3879115f9ae7ae0ed45066c4ddbf6dee03d4ed094bbab5487b565c3ff1882af476f00e80782f19fccc54723a8d2ec56fae95af5efca7b27285e2dd53ce37d0f9fbf6780e1e656adf382809138752699bceff3557baf318b5d940f84de859ace1f1d753dfefd692920a82f2aa1079aaace6d7c2e3b300a58bca2dd92fa5fff13a9efc79295e9495c1e0ae36dfd7e6138472b6807e91c2ca18cc3676db32c169a49bfaa0a19c94a7b9323f8bad64e942982b146b1e1b160bc1258ed30104a7058df3d4a7ffda25880a3e1936a2f991ebe30859d40758961d143c798b020e5f57080a135a33741cbc51da221322ed49b75f002e4a62dc4997800eee23736a5c3e8f3d2e98f6e5740eccf8444d26cb719e586b446278c7b9ac6a7e80391e0d21a23e09f35622ac4daca02a4519abd13837daaa255ac9fa6ef330098eb30f34fc8cf9f282e371be051cb5af40f2f86dde1f7ba0177d0b327de7e90cb8f6b3d6abe72b5d6c23d94cf7d77974db4c7a3cf95f6b31f27ab04fa06180e10400e817f33c0d66717c5465c75cad14d76cd36580cccbb20a541d5fd25be47aa6ba31f1e7adfe05e04cc93484bf86e460dec58398747914576f9bc6d97227ea1a42149e146b38f6c9a13d9099bbfcc7a9fdafddb36efa64175449c0e28faeeb16a0c9c85b9301aae4d69bbac2246542c78aa7ebdf32894de40508e394e3bfe6f24ec8d42a0b771298a326a486714ef0e80c951958ca9e7944a6b6a8113f8ac01de7c11598cbd95505797ec52ab032b2260770658634272e3f0af524699679593f93dbb0b451fe64cef9bdbf932b6fb5bb714c5c0599e39d4f37abb65da8dbb7e9bef6cf1b3783c2ffe569a926e71a1f07625b6b73526dfee926ecfa132888958d28ff8aa693c3218f241e0464cd19f9aaab61ae6b757e374c3aaf5d8319842c614984d62760969678aaf2bb558aae129b664ed32c03699bb0fea824c5751a22f3829e53d169092407078e68f89c791be6d157183e1e320a2749cd3376d54cbdc9ee591bf55850cd32b959ae4a922473cce3a721e6fc7c9dbd4a05496d26029765aa5a64ca6808186ad2d8850ae7bbc94861e02e0fafd2eddae59ba82f6030c62b4ca17261a2a8ca056c84e5357753ebea811304e862d6e4634ad5c5a56229d3761e73c76f70b648bb29e4aba6f3d98c10a65a3d0902a8a702a1ba8a8f25e1667c94860693029e7003ac9a06265bf870f8791a43b594b9a24e33d5227f1916c8fca27b7fecb0cc78545150f185f6ac2de67e91149f83cd0f17229e7a5a1ac11b40bc2a61ea36a0add86d17b0cd3ab4e44583551b77fee067438e0419a79ff2ea9aa4d39a048361db23e1be19f2ebb576f77ca589fb3a420d48af2d8406cf6c175bf73081cde60b3e99d9a5d3dd12d8d1a46e76c87b3d9f0a46bc9718fa7f9df752aeef7ecb07366fd3cafe46f031be90d36165ee1bd403ac7dce435246e0fd61035dbcc6c0587a277e54fa9b350a5814113bcbd526a2179d13f2680650d64799592ca16979ebfdfd670da2f334a0cc4b4da7ba7be899bd563c52a46d8c81ed5b1c7fc997fe2fd4280e2917213a1c58a151c84925144e96220ac5bb4a27c92e20a98827ea883d8c2d4a8cfbc52ce6b636147dbda493ed3185f1fdd833ecdf49938f1e29209f704ffd15da828d10ec3a8447143865cde92f08842b699518b773142c85702f41954919a5956b712450d424c29795e1c0736f879ef32affa02db46cdcefc40b1dd0bc5272471de875eb09def66acc10325afbf63fab9c6206ead9b1d95003ae8f14dd4d631f1b00947c449f14d69400ebb5044a1f3dd5815e94cf164ec5fc58e8dbfb3c86aac54a97f30fe870d2880600afebddf31ab74075fd13575903b8812db644a4cd365baa5a0a44411f0b937be29cbb65a8d36298bde5eb80785c130cb047a26e06e45b3541c34f65f976cc98a99c05965782d33feba7864b9872dd3eadf517529ec0f402cefc717ad011839eb4f1b3234f5c1ad04bc10461d83e90911f1eda78265dbf9e9990806969c01612a364b2f12ff288677c850d84c53e0abb1d7eee00f8c33c9e9c6469e5c42d3d30f31a85ad29ed0a4ee34ecb5a43147d70853f9363c63e093da515a892d853a68c4206bd1c08c7fec7fbaae9e2f955593cdb23be1db25331b2f808e44687e24203a1b43cc97a9255c5096088af9228174c305479a2b3cad2f666c6f8a81e226ea474e0513371ca7f4c6a6c1dd8b1243e979df455c4d07cda1508138c380bd341c44b148c00b2c3d41a817116c443cc30e6550cbc6d37f80e57b1a19f559f9d2c5075c95792e35e148d4ca1c3ede18e82099d4c868cee777d9a9f8db3543e54db0250edfb142c54f5388784befa1803d40936576247def8bc56364e107aefb8a491b70945067d95c3e6804de6b46692154b4e2bced87f3e1ac3f629f56cced57f99db1eb47a45dda0522a4530b6b43f3ee33a658e098ffcd48f1ab3810af2002ff445821916dbefa8f973fd5391e357f789718c70e8d48f4be95593321fa61209749ff896c902192e1134e15bafdde1992beea263ccab06a1fe19fcfb9d44c5dc56f580273438b556bf86ff9ac2962b5055fbae2d249fc1698f75f0a7f2322758d90f2edf4b49d07d65848cd04e8e517e1b27df7d5648ec38a688238462641c6e1a6066f111c41165fdfa9fb54d65fcb52e1686c38b4460acd41b2c6e45d7548d15fd72b3ee410e316bb5d950fffb3b6e9c8bd929153c978bff307e75699dfcb7e6ebfbcb70e353cd6677f85e2140aed2e8a10752d3f60e5044ea7e2d9f28d03312337c324a3772db1d6c71579d85a513f76c7c13f98724acde7d2605d44293208f24240bf41766466b468449811f7d0b173ebf3d19592fa08630a6ee6b5388fdc235be0b4fbfb43798851ee553728d1e5fcfaa0d19d304d49cfbca8e48cfe96f79785393b8fc3498d0ceb6cdab1c8edfc943967fb14e66a3af217492c360366653b142036aa3878a2a5632d22ee939de3bc92a7a3639b042fa560d049c0995c71f9e44b643caac80e4c1c8b50aa456acf9a5a04d327faf0dfa9dfb37e9388792a97877e059022081137b6879854251d27072298a1d1f44b019f144e3a8cf833fd91419bd90ffce2dfc203e0e65a8f721b77060d0dfd8cd6fb03adff374e1f8dab3ce13d06e9e294fe7630a1c64769fe51d88661ee783a5adb3aac4e6fb9a0fa0ac7f0913058d68be33f05241acc36a2cb5e5d37daff963cb167f1ff26983cd4c130707032c381f7c20dc7a88b5a8f53517e60b26cd74b37dca7e2559133621bc1dd24ce233bfbd5126e0c4768c8c5f976d7cb7e2753a177e9da515a19c48edfa55e3c37be277efe833263400904e9bf8398040b72a1bf880e1cb69b1762a681cf6b5fb6c10295fc078e7ed41440cc98ee30499446b92570983caab95277d03f8003bd0469c39416594b23d0fe4aab0502e12519265fd43083555b342ab235147012305c45a610dc3e9fee41714b62a2b52aaeed7bc9631c27a993d318aa92098deb40682884df2701b0cdbc5e2a9351bfee161a0fda2104d82ee26bba2b827ee8b86eb14530ec58852bc17cb2c711c95dce93e15a6c3b23f1e39f3d10ea4fd8a34dae83a0698fdfcee86ede57fdbebf063256d47b97c1ce3241e2fd42f4f372f67bb36e395649082f625d5dbec25c6be949aa608125458b148427730d5f5ec4a5937e5da695a7e7ec51208ea155ac2abee0151c4bdf84e1130b57be84d0747a462a4a055fa999a447873bd7c1354bfd65d9962bb2f0fc0147a5f99c780127e8586f7930f9c0830b381c5626f9806878f48cffd87040fcd401e8911f6f90791ce8d0e291cf407b73aab10e99ee237e3b19f388b07ba1628fb3de4763903d933bf4145fdfaeb4616b86e974c28f7ebab0523024d36b0244984c45f162f85a2a9d63a73b4a2bdb373fa1e6400098b04028091da499ee1520c22d63f2d05d7b0f4c85df4b39572635c75a414aba72755fa5458568bf8b9fc48503822ab6c0377b6bd80e6afae92ea45f32865ecef1391e34b39d72f034f98ce17f79e9b844a1f4037c71999663c8e38b5810b48b7e1b94ceaba043c9b3139d84bc77db63ce2cf763e2baf09ab86db22abef6406870331b661e7f52546c6f6148edd845ceae56c08065492303fa9b1d52ad7b473816e6942e46a63ac14c44aca797466dbd2d2c7f857332f5cc757ea10ff8a274cd12e464277dea6561ebf82d2bd31094a385fb133c76a1cf69ada4341bb318f38f1ab5db984c3f9e6847020fe7abbddbc48665c7c002b3ff396393a34cce612a9c657710dd24ca1fee354131a89e4946012470da8bfc43fe95521c3ecb6b1f8692d8aab2b9765e98db9bc16bdbf9f7a07ba092b926d5665559605eabe78a88fb7dfed2adb8442737d87379474c6a8b29673a276cf8ea0930b230571b50ba59ccac86303833c063a1d8764ea1c0e3e8b7c4d7c99aa0c3adfd5464d68d4e8c86ecabfc554f0bdcab6f370985dae1c70110728fc67f6360804e3a2e139811b0cceafed1f11f9bfc6384f73bcfa0802af271d4e181c4f1af087567e935fb0ff613db672ff878d8addfe6378ecf4aef16472a6b9c7325e69abe6568f4de39d4c74f8fd76c720748b2d72333147e71b28b1752e4308c1937ab42497d925c0b49e95953d40e8211ed0c9ce242ec873755be54464f9fe3b5879c2b943b779a14234dbd9024bc1e5689eff05b1166fc590109e7b12a782b857f3fd3e4a9198d23791d4ad8ecc72398e56638ec852b1086e661a4361c75617c7b7117a0d86b516501a0738a3fb7dca09a5e74523d5b2329a1ae5d57fcb037ac9bcd7acfffd5d1119b63d0277a8605be1c44ff42bf599d5cf3ae862222a70d0a558402ed23c162f3af461b362d0cafd971ae5fc7d4f193c843ef0ddfc4e04f1e42457970bc4dd53a1ba567de3758f80501505bbe92b1ede826c59d5e749d0fcc28311aaaf616c221bcb2d32458b738b52c7cac24e9f14ea920ffc8a2ae59e771ba350090c92f16b59622c165e2d0b303076b7a6f844b7855435f88bdb5f83088afd51060f3cad726fc884760f154195a2cc9014831d0de08164f7bb2dcbcb6320bdcb21462fc5c06a85b9ef076258ef3c530994ec848adb5bd12a46d69cd9e6f52ec3684425754d3adae6c4e9193997891ebaaa3902ab6a8bc7883fa2f4dae1da4fe1a7cdb1c43ab2a5e3d09125525eefdfc8251d87cb5fe1c979a402cdedde9b3cac96c7916380a8d179dd725d29efba949475bc48ff081d002af109cbe0508a50a6888a72a7001a77b64eee62af8b4d052db38a3ffb19ef15838f29ee47a378f60cf5c09c2ded9cb7cf829a8d11bfebcfeb4245af88d867097cd15c211966ab58c21a40ebea629e956fcf57db30e10f41afcf8fe41ac3639f3c5c8582dd127bcd51e0a69b5aa3d0395cc2baf1a169cf37b8339d24fd9d511aec479509d9777aa5963c92c7959b9b267ab64655a6b73db4b101ef105b9878c20e08cebf25f8151611b137cc9f3e265af740734f621d31f30b482ec53c7a48653756b75466ee6a728b4cbe7ec77031034a7be2dcfa012a14b2312d16c52afd31d9daa70244261d059b66f46aef4c439cdd3f87b41847e8264c2f5ebc6951f1ce7dc475c568cba68467de8cf1711fb1c68021e411d170c03048f80e59e4ed049df2068f4a1649f300c06b200147c875e46d8cba3018ff3c0e3dddac3e68b768d4ffbd52ccb83dfec9cafe506c71809dd63e4a95175d231d96a551df35c80ed74a75d341a4f0c1</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-flip">
      <input class="hbe hbe-input-field hbe-input-field-flip" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-flip" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-flip" data-content="请输入密码……">请输入密码……</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>贪心</tag>
        <tag>S2OJ</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流 做题记录</title>
    <url>/solution-flow/</url>
    <content><![CDATA[<p>网络流相关做题记录。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<p>（我为什么要造孽放代码上来……）</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="网络流24题"><a href="#网络流24题" class="headerlink" title="网络流24题"></a>网络流24题</h2><ul>
<li>LibreOJ #6000 &#x2F; Luogu P2756 飞行员配对方案问题 <a href="/solution-flow/#%E9%A3%9E%E8%A1%8C%E5%91%98%E9%85%8D%E5%AF%B9%E6%96%B9%E6%A1%88%E9%97%AE%E9%A2%98">&gt;</a></li>
<li>LibreOJ #6001 &#x2F; Luogu P2762 太空飞行计划问题 <a href="/solution-flow/#%E5%A4%AA%E7%A9%BA%E9%A3%9E%E8%A1%8C%E8%AE%A1%E5%88%92%E9%97%AE%E9%A2%98">&gt;</a></li>
<li>LibreOJ #6004 &#x2F; Luogu P3254 圆桌问题 <a href="/solution-flow/#%E5%9C%86%E6%A1%8C%E9%97%AE%E9%A2%98">&gt;</a></li>
<li>LibreOJ #6007 &#x2F; Luogu P2774 方格取数问题 <a href="/solution-flow/#%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0%E9%97%AE%E9%A2%98">&gt;</a></li>
<li>LibreOJ #6008 &#x2F; Luogu P1251 餐巾计划问题 <a href="/solution-flow/#%E9%A4%90%E5%B7%BE%E8%AE%A1%E5%88%92%E9%97%AE%E9%A2%98">&gt;</a></li>
<li>LibreOJ #6011 &#x2F; Luogu P4015 运输问题 <a href="/solution-flow/#%E8%BF%90%E8%BE%93%E9%97%AE%E9%A2%98">&gt;</a></li>
<li>LibreOJ #6012 &#x2F; Luogu P4014 分配问题 <a href="/solution-flow/#%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98">&gt;</a></li>
<li>LibreOJ #6013 &#x2F; Luogu P4016 负载平衡问题 <a href="/solution-flow/#%E8%B4%9F%E8%BD%BD%E5%B9%B3%E8%A1%A1%E9%97%AE%E9%A2%98">&gt;</a></li>
<li>LibreOJ #6015 &#x2F; Luogu P2754 [CTSC1999] 家园 <a href="/solution-flow/#CTSC1999-%E5%AE%B6%E5%9B%AD">&gt;</a></li>
<li>LibreOJ #6122 &#x2F; Luogu P2770 航空路线问题 <a href="/solution-flow/#%E8%88%AA%E7%A9%BA%E8%B7%AF%E7%BA%BF%E9%97%AE%E9%A2%98">&gt;</a></li>
<li>LibreOJ #6224 &#x2F; Luogu P4012 深海机器人问题 <a href="/solution-flow/#%E6%B7%B1%E6%B5%B7%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%97%AE%E9%A2%98">&gt;</a></li>
</ul>
<h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><ul>
<li>Luogu P1343 地震逃生 <a href="/solution-flow/#%E5%9C%B0%E9%9C%87%E9%80%83%E7%94%9F">&gt;</a></li>
<li>Luogu P2472 [SCOI2007] 蜥蜴 <a href="/solution-flow/#SCOI2007-%E8%9C%A5%E8%9C%B4">&gt;</a></li>
<li>Luogu P2891 [USACO07OPEN] Dining G <a href="/solution-flow/#USACO07OPEN-Dining-G">&gt;</a><br>Luogu P1402 酒店之王 ^<br>Luogu P1231 教辅的组成 ^</li>
<li>Luogu P3701 主主树 <a href="/solution-flow/#%E4%B8%BB%E4%B8%BB%E6%A0%91">&gt;</a></li>
<li>LibreOJ #2239 &#x2F; Luogu P3163 [CQOI2014]危桥 <a href="/solution-flow/#CQOI2014-%E5%8D%B1%E6%A1%A5">&gt;</a></li>
</ul>
<h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><ul>
<li>Luogu P7368 [USACO05NOV] Asteroids G <a href="/solution-flow/#USACO05NOV-Asteroids-G">&gt;</a></li>
</ul>
<h2 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h2><ul>
<li>Luogu P3931 SAC E#1 - 一道难题 Tree <a href="/solution-flow/#SAC-E-1-%E4%B8%80%E9%81%93%E9%9A%BE%E9%A2%98-Tree">&gt;</a></li>
<li>Luogu P1345 [USACO5.4] 奶牛的电信Telecowmunication <a href="/solution-flow/#USACO5-4-%E5%A5%B6%E7%89%9B%E7%9A%84%E7%94%B5%E4%BF%A1Telecowmunication">&gt;</a></li>
<li>Luogu P2057 [SHOI2007] 善意的投票 &#x2F; [JLOI2010] 冠军调查 <a href="/solution-flow/#SHOI2007-%E5%96%84%E6%84%8F%E7%9A%84%E6%8A%95%E7%A5%A8-x2F-JLOI2010-%E5%86%A0%E5%86%9B%E8%B0%83%E6%9F%A5">&gt;</a></li>
<li>Luogu P4177 [CEOI2008] order <a href="/solution-flow/#CEOI2008-order">&gt;</a></li>
<li>Luogu P1361 小M的作物 <a href="/solution-flow/#%E5%B0%8FM%E7%9A%84%E4%BD%9C%E7%89%A9">&gt;</a></li>
</ul>
<h2 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h2><ul>
<li>Luogu P1004 [NOIP2000 提高组] 方格取数 <a href="/solution-flow/#NOIP2000-%E6%8F%90%E9%AB%98%E7%BB%84-%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0">&gt;</a></li>
<li>Luogu P1006 [NOIP2008 提高组] 传纸条 <a href="/solution-flow/#NOIP2008-%E6%8F%90%E9%AB%98%E7%BB%84-%E4%BC%A0%E7%BA%B8%E6%9D%A1">&gt;</a></li>
<li>Luogu P2457 [SDOI2006] 仓库管理员的烦恼 <a href="/solution-flow/#SDOI2006-%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86%E5%91%98%E7%9A%84%E7%83%A6%E6%81%BC">&gt;</a></li>
<li>Luogu P2517 [HAOI2010] 订货 <a href="/solution-flow/#HAOI2010-%E8%AE%A2%E8%B4%A7">&gt;</a></li>
<li>Luogu P2153 [SDOI2009] 晨跑 <a href="/solution-flow/#SDOI2009-%E6%99%A8%E8%B7%91">&gt;</a></li>
</ul>
<h2 id="上下界网络流"><a href="#上下界网络流" class="headerlink" title="上下界网络流"></a>上下界网络流</h2><ul>
<li>Luogu P5258 [JSOI2013] 旅行时的困惑 <a href="/solution-flow/#JSOI2013-%E6%97%85%E8%A1%8C%E6%97%B6%E7%9A%84%E5%9B%B0%E6%83%91">&gt;</a></li>
</ul>
<h1 id="网络流24题-1"><a href="#网络流24题-1" class="headerlink" title="网络流24题"></a>网络流24题</h1><h2 id="飞行员配对方案问题"><a href="#飞行员配对方案问题" class="headerlink" title="飞行员配对方案问题"></a>飞行员配对方案问题</h2><p>英国飞行员连向源点，外籍飞行员连向汇点，可以搭配的英国飞行员连向外籍飞行员。边权均为 $1$。<br>跑一遍最大流即可。</p>
<p>最后枚举所有边，如果当前边连接一个外籍飞行员和一个英国飞行员，且其容量为空，那么这条边就被流经过，说明这条边代表的一堆飞行员可以配对，输出两端点即可。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p2000-p2999/p2756/p2756.cpp"><code>Luogu</code></a><br><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Libre%20OJ/6000/l6000.cpp"><code>Libre OJ</code></a></p>
</div>

<h2 id="太空飞行计划问题"><a href="#太空飞行计划问题" class="headerlink" title="太空飞行计划问题"></a>太空飞行计划问题</h2><p>这是一个最大权闭合子图问题。我们可以将这个转化为一个最小割问题。<br>讲解可以见我博客的<a href="/OI/flow/#%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE%E9%97%AE%E9%A2%98">另外一篇文章</a>。</p>
<p>其中，实验就是正权点，仪器就是负权点，建图连边即可。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p2000-p2999/p2762/p2762.cpp"><code>Luogu</code></a></p>
</div>

<h2 id="圆桌问题"><a href="#圆桌问题" class="headerlink" title="圆桌问题"></a>圆桌问题</h2><p>因为我们想要让坐在一个桌子旁的人两两不属于同一个代表团，那就可以转化为让一个代表团的人分散在不同的桌子上。</p>
<p>于是我们将所有的代表团和桌子都抽象成点。<br>我们从源点向每个代表团的点连一条容量为代表团人数的边，再从每一张桌子向汇点连一条容量为桌子容量的边。</p>
<p>然后我们将每一个代表团都向每一个桌子连一条容量为1的边。</p>
<p>最后跑最大流，得到的得数就是最多能给多少个人安排上桌子。</p>
<p>如果有人没有安排上桌子，那么久直接输出0即可。<br>如果所有人都安排上桌子了，就搜一下来确定方案。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3254/p3254.cpp"><code>Luogu</code></a><br><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Libre%20OJ/6004/l6004.cpp"><code>Libre OJ</code></a></p>
</div> 

<h2 id="方格取数问题"><a href="#方格取数问题" class="headerlink" title="方格取数问题"></a>方格取数问题</h2><p>我们一旦取走一个数，那么这个数周围的四个格子里面的数就不能被取走了。</p>
<p>那我们可以转化一下，不考虑<strong>允许</strong>，而是考虑<strong>禁止</strong>。</p>
<p>那我们就可以按照权值和最小的原则来得到一种方案并取出，剩下的就是我们所要求的方案。</p>
<p>那我们按照国际象棋棋盘的染色方案进行染色，即对于位于第 $i$ 行 $j$ 列的点，如果 $i+j$ 为奇数则向源点连一条边权为当前格子权值的边，并同时向周围四个点连一条边权为无限大的边；否则连向汇点，边权为当前格子权值。</p>
<p>由于最小割最大流定理，我们在求出最大流之后，拿所有格子的权值总和减去最大流即使我们要的答案。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p2000-p2999/p2774/p2774.cpp"><code>Luogu</code></a><br><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Libre%20OJ/6007/l6007.cpp"><code>Libre OJ</code></a></p>
</div>

<h2 id="餐巾计划问题"><a href="#餐巾计划问题" class="headerlink" title="餐巾计划问题"></a>餐巾计划问题</h2><p>详细分析可以见之前写的<a href="/solutions/solution-p1251/">这篇博客</a>。</p>
<p>我们这样连边：</p>
<ol>
<li>源点与餐厅输出连一条容量为当天用量，费用为0的边；</li>
<li>汇点与餐厅输入连一条容量为当天用量，费用为0的边；</li>
<li>餐厅输出与下一日的餐厅输出连一条容量为无限，费用为0的边。</li>
<li>源点与餐厅输入连一条容量为无限，费用为 $p$ 的边；</li>
<li>餐厅输出与 $n$ 天后的餐厅输入连一条容量为无限，费用为 $s$ 的边，代表快洗部；</li>
<li>餐厅输出与 $m$ 天后的餐厅输入连一条容量为无限，费用为 $f$ 的边，代表慢洗部。</li>
</ol>
<p>然后跑一个最小费用最大流即可，最终的费用就是答案。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p1000-p1999/p1251/p1251.cpp"><code>Luogu</code></a><br><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Libre%20OJ/6008/l6008.cpp"><code>Libre OJ</code></a></p>
</div>

<h2 id="运输问题"><a href="#运输问题" class="headerlink" title="运输问题"></a>运输问题</h2><p>费用流。</p>
<p>源点向仓库连边，仓库向商店连边，商店向汇点连边。</p>
<p>跑费用流即可。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p4000-p4999/p4015/p4015.cpp"><code>Luogu</code></a><br><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Libre%20OJ/6011/l6011.cpp"><code>Libre OJ</code></a></p>
</div>

<h2 id="分配问题"><a href="#分配问题" class="headerlink" title="分配问题"></a>分配问题</h2><p>费用流。</p>
<p>源点向工人连边，工人向工件连边，工件向汇点连边。</p>
<p>跑费用流即可。</p>
<p>和上一道题惊人地相似。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p4000-p4999/p4014/p4014.cpp"><code>Luogu</code></a><br><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Libre%20OJ/6012/l6012.cpp"><code>Libre OJ</code></a></p>
</div>

<h2 id="负载平衡问题"><a href="#负载平衡问题" class="headerlink" title="负载平衡问题"></a>负载平衡问题</h2><p>首先每个点向左右两边的点连边，费用为1，然后：</p>
<p>如果这个点多于平均值，那就向源点连其权值与平均值之差；<br>如果这个点少于平均值，那就像汇点连其权值与平均值之差。</p>
<p>这两种边的费用为0。</p>
<p>然后跑费用流即可。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p4000-p4999/p4016/p4016.cpp"><code>Luogu</code></a><br><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Libre%20OJ/6013/l6013.cpp"><code>Libre OJ</code></a></p>
</div>

<h2 id="CTSC1999-家园"><a href="#CTSC1999-家园" class="headerlink" title="[CTSC1999]家园"></a>[CTSC1999]家园</h2><p>首先我们需要判断一下地球和月球是否联通，这个只需要使用并查集即可。</p>
<p>然后我们枚举天数，直到某一天转移的人达到要求了之后就停止循环，并输出天数。</p>
<p>我们在枚举的时候，逐天按照飞船的行进路线加边。因为每一次飞船都需要花一天时间来走一次的路程，所以我们每一条边都是从某一天的某一个站点到下一天的下一个站点，容量为飞船容量。</p>
<p>然后每一天跑最大流，得到的最大流结果就是当天以及之前所有天的转移人数总和。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p2000-p2999/p2754/p2754.cpp"><code>Luogu</code></a><br><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Libre%20OJ/6015/l6015.cpp"><code>Libre OJ</code></a></p>
</div>

<h2 id="航空路线问题"><a href="#航空路线问题" class="headerlink" title="航空路线问题"></a>航空路线问题</h2><p>题目要求我们找到一条从起点城市到重点城市再回到起点城市的路径，并要求除起点城市外每一个点只能经过一次。</p>
<p>我们考虑拆点，除起点和终点容量为2之外容量均为1，然后按照飞机航线来建边，容量为1。</p>
<p>当然这样我们是不可能得出最大经过的城市个数的，我们需要用到费用流的手段。</p>
<p>我们将每个城市拆点的时候建的边的费用赋为1，其他的边赋为0。</p>
<p>然后我们跑费用流即可。</p>
<p>然后题目还让我们输出一个可能的方案。</p>
<p>于是我们就直接大暴搜就可以了。<br>还要注意起点终点直通的情况。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p2000-p2999/p2770/p2770.cpp"><code>Luogu</code></a><br><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Libre%20OJ/6122/l6122.cpp"><code>Libre OJ</code></a></p>
</div>

<h2 id="深海机器人问题"><a href="#深海机器人问题" class="headerlink" title="深海机器人问题"></a>深海机器人问题</h2><p>这个就是很明显的最大费用最大流，我们只需要把生物标本的价值抽象成为费用即可。</p>
<p>按照题目要求，我们每一个点都向上和向右分别建两条边，一条代表采集了生物标本，容量为1价值为c，另外一条代表已经被采集完了，容量为无限价值为0。</p>
<p>把所有的可以出发的坐标连向源点，容量为 $k$；所有的可以作为目的地的坐标连向汇点，容量为 $r$。</p>
<p>然后跑一遍费用流即可。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p4000-p4999/p4012/p4012.cpp"><code>Luogu</code></a><br><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Libre%20OJ/6224/l6224.cpp"><code>Libre OJ</code></a></p>
</div>

<h1 id="最大流-1"><a href="#最大流-1" class="headerlink" title="最大流"></a>最大流</h1><h2 id="地震逃生"><a href="#地震逃生" class="headerlink" title="地震逃生"></a>地震逃生</h2><p>最大流板子，只不过在跑之前先要用并查集来判断一下连通性。<br>当然也可以直接跑，判断最大流量是否为0。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p1000-p1999/p1343/p1343.cpp"><code>Luogu</code></a></p>
</div>

<h2 id="SCOI2007-蜥蜴"><a href="#SCOI2007-蜥蜴" class="headerlink" title="[SCOI2007] 蜥蜴"></a>[SCOI2007] 蜥蜴</h2><p>这道题在做之前得首先解决<strong>平面距离</strong>是什么。</p>
<p>根据实际测试，本题中的<strong>平面距离</strong>其实指的就是<strong>欧几里得距离</strong>。</p>
<p>由于其 $d \leq 4$，我们就可以直接暴力枚举。</p>
<p>下面是一张图，代表着我们这道题某个点在不同的 $d$ 时需要连边的范围：</p>
<p><img src="https://s2.loli.net/2022/04/21/5IUqMYC4FfsnXSD.png" alt="flowsolu1.png"></p>
<p>然后处理题目所给的信息：<br>石柱的高度就是当前点的容量，所以我们需要拆点；<br>跳出地图外面了就代表可以连向汇点；<br>有蜥蜴就代表着可以连向源点。</p>
<p>然后就跑最大流，得到的是可以逃离地图的蜥蜴个数的最大值，输出蜥蜴总数与其之差即可。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p2000-p2999/p2472/p2472.cpp"><code>Luogu</code></a></p>
</div>

<h2 id="USACO07OPEN-Dining-G"><a href="#USACO07OPEN-Dining-G" class="headerlink" title="[USACO07OPEN] Dining G"></a>[USACO07OPEN] Dining G</h2><p>P1402、P2891和P1231实质上是一类问题，都是三种物品进行匹配，求最大匹配个数。</p>
<p>对于这类问题，我们的思路就是拆点。</p>
<p>将匹配的主体（比如P2891的奶牛、P1402的顾客和P1231的练习册）拆成两个点，中间连一条容量为1的边，然后两个点分别与剩下的两种物品连边，然后跑最大流即可。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p2000-p2999/p2891/p2891.cpp"><code>Luogu P2891</code></a><br><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p1000-p1999/p1402/p1402.cpp"><code>Luogu P1402</code></a><br><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p1000-p1999/p1231/p1231.cpp"><code>Luogu P1231</code></a></p>
</div>

<h2 id="主主树"><a href="#主主树" class="headerlink" title="主主树"></a>主主树</h2><p>经典题目。</p>
<p>我们需要思考一下为什么图中箭头指向的是输的一方。<br>加入我们按照这个思路，每一个byx的人都向能够赢的诗乃的人连一条边，这就是一个新的图。<br>我们想要找到最大的边集，使得边集内的边两两不共用端点，最后我们求出的边集的大小就是byx可以赢的场数。</p>
<p>那我们考虑对这张图建立网络流模型。<br>我们首先把原图中的所有边建立起来，容量为1。<br>然后把所有byx的人连向源点，所有诗乃的人连向汇点。这样每一个流量就代表byx能赢的一场。<br>然后我们需要限制点的访问次数，我们可以拆点。<br>然后就跑最大流即可。</p>
<p>注意我们需要将得到的最大流量与比赛的场次取<code>min</code>再输出，最后才是真正能赢的场数。（没比赛你赢个什么）</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3701/p3701.cpp"><code>Luogu</code></a></p>
</div>

<h2 id="CQOI2014-危桥"><a href="#CQOI2014-危桥" class="headerlink" title="[CQOI2014] 危桥"></a>[CQOI2014] 危桥</h2><p>往返算经过两次，所以我们可以将危桥所说的“经过两次”转化为“往返一次”。</p>
<p>然后，危桥只能往返一次，普通桥能往返无数次，两个人分别想要往返 $a_n$ 次和 $b_n$ 次。</p>
<p>于是我们就可以将一次往返当做一单位的流来走，$a_1$ 和 $b_1$ 连源点，$a_2$ 和 $b_2$ 连汇点，最大流就是能往返的最大次数。</p>
<p>但是这样会忽略一些问题：从 $a_2$ 流出的流到底是来自 $a_1$ 的还是来自 $b_1$的？同理，从 $b_2$ 流出的流到底是来自 $a_1$ 的还是来自 $b_1$的？</p>
<p>我们考虑反向跑一遍，只不过只针对于Bob。<br>这次我们将$a_1$ 和 $b_2$ 连源点，$a_2$ 和 $b_1$ 连汇点，最大流看是否还与上一次相等。</p>
<p>如果两次均等于 $a_n+b_n$ 的话，那么两人的愿望就可以达成，否则就不可以。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3163/p3163.cpp"><code>Luogu</code></a></p>
</div>

<h1 id="二分图-1"><a href="#二分图-1" class="headerlink" title="二分图"></a>二分图</h1><h2 id="USACO05NOV-Asteroids-G"><a href="#USACO05NOV-Asteroids-G" class="headerlink" title="[USACO05NOV] Asteroids G"></a>[USACO05NOV] Asteroids G</h2><p>我们如果想要消除一颗小行星，那么其肯定在列上或者行上有布置过一次武器，或者两者兼有。</p>
<p>那么，每一颗小行星就可以对应二分图上的一条边，我们就需要找一个点集，使得所有边的两个端点之一在这个点集中。</p>
<p>这便是二分图最小点覆盖。</p>
<p>我们就可以用二分图最大匹配来解决这个问题。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p6000%2B/p7368/p7368.cpp"><code>Luogu</code></a></p>
</div>

<h1 id="最小割-1"><a href="#最小割-1" class="headerlink" title="最小割"></a>最小割</h1><h2 id="SAC-E-1-一道难题-Tree"><a href="#SAC-E-1-一道难题-Tree" class="headerlink" title="SAC E#1 - 一道难题 Tree"></a>SAC E#1 - 一道难题 Tree</h2><p>这道题要求我们求出使任何叶子结点与根节点不连通的最小代价。</p>
<p>我们可以转化一下。</p>
<p>我们可以知道，如果我们要求任何叶子结点都与根节点不连通，那么从根节点到每一个叶子结点的路径上面一定被割开过边。<br>我们还需要让费用最小，那么我们最多每条路径上割开一条边。</p>
<p>于是我们就可以用最小割来求解。让根节点连上源点，所有叶子结点连上汇点，然后跑最小割即可。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3931/p3931.cpp"><code>Luogu</code></a></p>
</div>

<h2 id="USACO5-4-奶牛的电信-Telecowmunication"><a href="#USACO5-4-奶牛的电信-Telecowmunication" class="headerlink" title="[USACO5.4] 奶牛的电信 Telecowmunication"></a>[USACO5.4] 奶牛的电信 Telecowmunication</h2><p>题目要求我们求出，我们需要删除多少个点才能使题目给出的两个点之间不连通。</p>
<p>我们之前只做过割边的题目，没有做过这种题目，考虑将其转化一下。<br>方法很简单，就是拆点。</p>
<p>我们可以将删除点改为删除连接被拆的点的两部分的边，这样就可以转化为割边的问题了。</p>
<p>然后建图，原图中的边容量均为无限大，拆点得到的边的容量均为1即可。</p>
<p>然后跑最小割。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p1000-p1999/p1345/p1345.cpp"><code>Luogu</code></a></p>
</div>

<h2 id="SHOI2007-善意的投票-x2F-JLOI2010-冠军调查"><a href="#SHOI2007-善意的投票-x2F-JLOI2010-冠军调查" class="headerlink" title="[SHOI2007] 善意的投票 &#x2F; [JLOI2010] 冠军调查"></a>[SHOI2007] 善意的投票 &#x2F; [JLOI2010] 冠军调查</h2><p>题目告诉我们，我们需要求出来冲突数量。</p>
<p>我们先分析冲突的产生。</p>
<p>冲突之所以会产生，其根本原因就在于与自己至少一个好朋友的政见不合。他们要么违反自己的意愿而产生一单位的冲突，要么违反好朋友的意愿而产生一单位的冲突。</p>
<p>其中第一种冲突完全是由于第二种冲突而产生的。<br>如果这里没有好朋友关系，那么就不会有好朋友之间政见不合而导致的冲突了。</p>
<p>而第二种冲突呢？<br>来源是一对好朋友之间要求与对方持相同政见。</p>
<p>如何解决第二种冲突？<br>简单，不再持自己的立场或者不再为好朋友关系即可。</p>
<p>于是我们就可以连边了。</p>
<p>每一对好朋友之间连双向边，然后每一个小朋友向自己的立场（源点与汇点之间自己看着选）连一条边。容量均为1。</p>
<p>然后跑最小割即可。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p2000-p2999/p2057/p2057.cpp"><code>Luogu</code></a></p>
</div>

<h2 id="CEOI2008-order"><a href="#CEOI2008-order" class="headerlink" title="[CEOI2008] order"></a>[CEOI2008] order</h2><p>如果不考虑租的情况的话就是最大权闭合子图问题了。</p>
<p>因为工作和租用的机器是一一对应的，所以我们也可以用一条边来代表这个关系，而这种边也得可以是被割掉的才可以。<br>那么我们可以把工作和对应的机器连起来，边权是租用的费用。<br>这种边割断了之后也可以使源点和汇点不连通，割掉了代表我们对于这个工作是租用机器的。<br>其余的还是正常的最大权闭合子图问题，只不过原图中的边已经建好了，我们就不需要再建了。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p4000-p4999/p4177/p4177.cpp"><code>Luogu</code></a></p>
</div>

<h2 id="小M的作物"><a href="#小M的作物" class="headerlink" title="小M的作物"></a>小M的作物</h2><p>如果我们不考虑组合之间的关系，只考虑每一个作物种在哪里，我们可以把每一个作物抽象成点，然后从源点连向该点，容量为 $a_i$，该点连向汇点，容量为 $b_i$。<br>以这张图跑最小割的话，我们可以知道</p>
<h1 id="费用流-1"><a href="#费用流-1" class="headerlink" title="费用流"></a>费用流</h1><h2 id="NOIP2000-提高组-方格取数"><a href="#NOIP2000-提高组-方格取数" class="headerlink" title="[NOIP2000 提高组] 方格取数"></a>[NOIP2000 提高组] 方格取数</h2><p>每一个点向其右侧和下侧的两个点分别连边，同时每个点拆点，容量为2，边权为方格中的数。<br>$(0,0)$ 连向源点，$(n,n)$ 连向汇点。</p>
<p>然后跑最大费用最大流即可。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p1000-p1999/p1004/p1004.cpp"><code>Luogu</code></a></p>
</div>

<h2 id="NOIP2008-提高组-传纸条"><a href="#NOIP2008-提高组-传纸条" class="headerlink" title="[NOIP2008 提高组] 传纸条"></a>[NOIP2008 提高组] 传纸条</h2><p>每一个点向其右侧和下侧的两个点分别连边，同时每个点拆点，容量为1，边权为好感度。<br>$(0,0)$ 连向源点，$(n,m)$ 连向汇点。</p>
<p>然后跑最大费用最大流即可。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p1000-p1999/p1006/p1006.cpp"><code>Luogu</code></a></p>
</div>

<h2 id="SDOI2006-仓库管理员的烦恼"><a href="#SDOI2006-仓库管理员的烦恼" class="headerlink" title="[SDOI2006] 仓库管理员的烦恼"></a>[SDOI2006] 仓库管理员的烦恼</h2><p>我们想要找到的是一种方案，使得每一种货物能够以最小的代价各自被分到一个单独的仓库里面。<br>但是题目并不需要我们输出具体的方案，只需要我们输出最小代价。</p>
<p>因为本仓库的物品再运回到本仓库是不会产生代价的，所以我们每一个仓库运送货物的代价都可以表示为运进该仓库的商品的代价之和，这等于所有该类商品的数量之和减去当前仓库内的该种商品总数。</p>
<p>于是我们建立 $2n$ 个点，一半代表仓库，一半代表货物种类。<br>每一个仓库都向所有的货物种类连一条容量为1，费用为所有该类商品的数量之和减去当前仓库内的该种商品总数。</p>
<p>然后跑费用流即可。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p2000-p2999/p2457/p2457.cpp"><code>Luogu</code></a></p>
</div>

<h2 id="HAOI2010-订货"><a href="#HAOI2010-订货" class="headerlink" title="[HAOI2010] 订货"></a>[HAOI2010] 订货</h2><p>我们考虑以每月仓库的状态来建立节点。</p>
<p>每个节点都从源点连一条边，容量为无限，费用为 $d_i$，代表进货；<br>同时每个节点都向汇点连一条边，容量为 $U_i$，费用为0，代表供应市场；<br>每个不是最后一个节点的节点都向其下一个节点连一条边，容量为 $S$，代价为 $m$，代表存贮。</p>
<p>最后跑最小费用最大流即可。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p2000-p2999/p2517/p2517.cpp"><code>Luogu</code></a></p>
</div>

<h2 id="SDOI2009-晨跑"><a href="#SDOI2009-晨跑" class="headerlink" title="[SDOI2009] 晨跑"></a>[SDOI2009] 晨跑</h2><p>将十字路口抽象为节点，将街道抽象为边。<br>这道题就不需要我们另建源汇点了，题目中已经给出了源汇点。</p>
<p>一个周期就相当于是从源点到汇点的一个流，路程就相当于是其代价。</p>
<p>于是就建边，跑最小费用最大流。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p2000-p2999/p2153/p2153.cpp"><code>Luogu</code></a></p>
</div>

<h1 id="上下界网络流-1"><a href="#上下界网络流-1" class="headerlink" title="上下界网络流"></a>上下界网络流</h1><h2 id="JSOI2013-旅行时的困惑"><a href="#JSOI2013-旅行时的困惑" class="headerlink" title="[JSOI2013] 旅行时的困惑"></a>[JSOI2013] 旅行时的困惑</h2><p>如果我们想让任意两个岛屿都可以互相到达，那么我们需要在原有的树的基础上面建立一棵有双向边的树。</p>
<p>这样我们就可以建立一个上下界网络流的模型。<br>建立原树边的反向边，容量范围为 $[1,\infty]$。</p>
<p>因为一条交通线路从任意一个点开始或结束都可以，所以每一个点都从源点连边，向汇点连边，容量均为 $\infty$。</p>
<p>然后就跑有源汇有上下界最小流即可。</p>
<div class="note success"><p><a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p5000-p5999/p5258/p5258.cpp"><code>Luogu</code></a></p>
</div>

<!-- <div class="note success"></div> -->
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>2022寒假测试8解析</title>
    <url>/contestrecords/2022-wh-8/</url>
    <content><![CDATA[<p>2022年寒假第8次测试解析。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="T1-「JOISC-2016-Day-2」女装大佬"><a href="#T1-「JOISC-2016-Day-2」女装大佬" class="headerlink" title="T1 「JOISC 2016 Day 2」女装大佬"></a>T1 「JOISC 2016 Day 2」女装大佬</h1><p>原题为 JOISC 2016 Day2 T3 「トイレ」。</p>
<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><details class="note info"><summary><p>题面</p>
</summary>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>题目译自 JOISC 2016 Day2 T3 「トイレ」<br>题面魔改原因：原题是男选手太多所以要借用女厕所 译者表示无法接受<br>IOI 的队服有两种，一种男装，一种是女装。然而很遗憾，所有参赛队伍中并没有女生，只有女装大佬。现在 IOI 设置了两个发放点，一个点只发放男装，另一个点只发放女装。<br>现在，所有队伍总共 $2N$ 个参赛队员，他们排成一列来领取队服，领取队服的规则如下：</p>
<ol>
<li>当前队首是女装大佬，如果领取女装的地方是空的，那么他就会领取女装，否则如果领取男装的地方是空的，他会去领取男装；</li>
<li>当前队首是正常男生，如果领取男装的地方是空的，那么他会领取男装，否则如果女装位空着，他就发挥绅♂士精神，给身后的最前面的女装大佬让位，让他先领取女装。<br>已知任意一个人领取队服都需要一分钟的时间，现在你需要重排所有人的顺序，使他们在 $N$ 分钟内领完队服 。<br>定义一个人的 Dark 值为：在重排队伍之前在他后面，且重排队伍之后在他前面的人的数量。<br>你现在需要找出重排后整个队伍最大的 Dark 值至少为多少。</li>
</ol>
</blockquote>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote>
<p>第一行为一个数 $N$ ，为领完队服的时限，同时 $2N$ 代表着总领队服人数，需要注意的是，这不意味着正常男生和女装大佬刚好各占 $N$ 个；<br>第二行为一个数 $M$，指队伍共有 $M$ 种；<br>之后的 $M$ 行，第 $i$ 行包括一个字符串和一个数字，描述该队伍的组成，其中 <code>M</code> 表示正常男生，<code>F</code> 表示女装大佬，之后的一个数字，表示该字符串连续出现了几次。所有字符串长度乘上出现次数的和等于 $2N$。</p>
</blockquote>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote>
<p>一个数，表示重排后最大 Dark 值的最小值，如果在 $N$ 分钟内不能完成领取队服的任务，输出 $−1$。</p>
</blockquote>

</details>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>（这里的说法是基于原题“トイレ”的背景——撤硕分配来说的）</p>
<p>首先我们需要判断哪个序列是一个可行的方案。</p>
<p>我们虽然可以从头开始模拟，但是这样需要耗费的时间实在是太多了。<br>因此，我们考虑从最后一分钟倒推。</p>
<p>既然我们有两个撤硕，总共 $2N$ 个人，需要在 $N$ 分钟内解决问题，那么必须是每一分钟都有两个人在上厕所。</p>
<p>那么我们看一下最后一分钟。<br>如果最后一分钟在队列里面等待的是两个男生，那么他们已经可以商量谁去女厕所了。<br>所以我们可以猜想，男的必须尽量靠前。</p>
<p>我们尝试将每一个 <code>F</code> 当做 $-1$，<code>M</code> 当做 $1$，基于此统计其后缀和。<br>我们需要确保所有人加起来不大于0，即最多有 $N$ 个男生。<br>我们还需要确保每一段后缀和都不大于1。自己用手推算一下的话，那么我们可以轻易发现，一旦有后缀和超过1的情况的话，那么最后肯定有两个（或更多）男生需要决定谁进女厕所。</p>
<p>我们可以选择二分让队尾多少个男生去往队头，也可以统计整个序列中后缀和最大值之后再+1。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>100分代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll n, m;</span><br><span class="line">ll chq, ans, temp;</span><br><span class="line">ll t[N], p[N], maxp[N];</span><br><span class="line"><span class="type">char</span> s[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s + <span class="number">1</span> &gt;&gt; t[i];</span><br><span class="line">        <span class="type">int</span> lens = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = lens; j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            p[i] += (s[j] == <span class="string">&#x27;F&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>);</span><br><span class="line">            maxp[i] = <span class="built_in">max</span>(p[i], maxp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        chq += p[i] * t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(chq &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = m; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i] &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, temp + (t[i] - <span class="number">1</span>) * p[i] + maxp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, temp + maxp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        temp += p[i] * t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一发36分的Java8代码：</p>
<details class="note warning"><summary><p>Java8</p>
</summary>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//import java.util.Arrays;</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">S2544</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span>[] t=<span class="keyword">new</span> <span class="title class_">long</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span>[] p=<span class="keyword">new</span> <span class="title class_">long</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span>[] maxp=<span class="keyword">new</span> <span class="title class_">long</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span> chq=<span class="number">0</span>,ans=<span class="number">0</span>,temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner scan=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">long</span> n=scan.nextInt();</span><br><span class="line">        <span class="type">int</span> m=scan.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            String inp=scan.next();</span><br><span class="line">            t[i]=scan.nextInt();</span><br><span class="line">            <span class="type">int</span> len=inp.length();</span><br><span class="line">            <span class="type">char</span>[] s=inp.toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=len-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                p[i]+=(s[j]==<span class="string">&#x27;F&#x27;</span>?-<span class="number">1</span>:<span class="number">1</span>);</span><br><span class="line">                maxp[i]=max(p[i],maxp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            chq+=p[i]*t[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(chq&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    ans=max(ans,temp+(t[i]-<span class="number">1</span>)*p[i]+maxp[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans=max(ans,temp+maxp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                temp+=p[i]*t[i];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ans-<span class="number">1</span>);</span><br><span class="line">            scan.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">max</span><span class="params">(<span class="type">long</span> a,<span class="type">long</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h1 id="T2-【常中20180812T3】-test"><a href="#T2-【常中20180812T3】-test" class="headerlink" title="T2 【常中20180812T3】 test"></a>T2 【常中20180812T3】 test</h1><h2 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h2><details class="note info"><summary><p>题面</p>
</summary>
<h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><blockquote>
<p>Tom在学写动态树，但是做题时过了样例，提交RE。Tom抓住Jerry要他写个暴力来对拍。Jerry觉得这任务太简单了，就让你来完成一下。</p>
</blockquote>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>有一棵 $n$个节点的树，初始时根节点为1。现在要支持如下操作——</p>
<ol>
<li>将某节点设置为根；</li>
<li>改变某节点权值；</li>
<li>询问以某节点为根的子树内节点权值之和；</li>
<li>询问以某两点为端点的链上的节点权值之和。</li>
</ol>
</blockquote>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote>
<p>第一行两个正整数 $n$ 和 $q$ ，表示树的节点数和操作个数。<br>接着 $n−1$ 行每行两个整数 $u$ 和 $v$ ，表示有连接 $u$ 和 $v$ 的一条边。<br>随后一行 $n$ 个正整数，表示每个点的初始权值。<br>之后 $q$ 行每行格式如下：<br>首先一个范围为 $[1,4]$ 的正整数，表示该操作类型。<br>对于1操作，之后一个正整数 $x$ ，表示将 $x$ 节点设置为根。<br>对于2操作，之后两个正整数 $x$ 和 $v$ ，表示将 $x$ 节点的权值改为 $v$ 。<br>对于3操作，之后一个正整数 $x$ ，表示询问以 $x$ 为根的子树内节点权值之和。<br>对于4操作，之后两个正整数 $x$ 和 $y$ ，表示询问以 $x$ 和 $y$ 为端点的链上的节点权值之和。</p>
</blockquote>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote>
<p>对于每个操作3和操作4，输出一行一个整数表示询问的答案。</p>
</blockquote>

</details>

<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>根据题目所给出的要求，我们可以使用LCT做这道题。</p>
<p>但是LCT太难了我不会啊QwQ</p>
<p>所以我们考虑退而求其次，使用换根树剖来做。<br>实测可行。</p>
<p>换根操作只会影响作用于一个节点子树上的操作，比如子树加，子树求和等等。</p>
<p>巧了，这里就有一个。</p>
<p>那就有点头疼。</p>
<p>我们根据要需要操作的节点 $x$ 和现根节点 $rt$ 的关系来考虑分三种情况：</p>
<ol>
<li><p><code>x==rt</code><br>这种情况明显很简单——就是整棵树。</p>
</li>
<li><p><code>lca(x,rt)！=x</code><br>这样我们可以知道现在的根 $rt$ 没有在 $x$ 的子树里，此时 $x$ 的子树与根为1时的子树无异，可以直接操作。</p>
</li>
<li><p><code>lca(x,rt)==x</code><br>这时候我们发现 $rt$ 在 $x$ 的子树里面。<br>此时，$x$ 的子树就会发生很大的改变。原先 $x$ 的子树包含 $rt$ 的那个儿子现在成为了 $x$ 的父亲，而其他儿子不变。原先为 $x$ 父亲的节点成为了 $x$ 的其中一个儿子，原先除其子树以外的节点都成为了其子树。<br>我们称这个子树包含 $rt$ 的儿子为 $v$ 。<br>现在 $x$ 的子树是 $[ 1 , id_v ) \cup ( id_v + sz_v - 1 , n ]$ 这两段连续的区间。<br>我们可以考虑对这两段区间分别操作，也可以选择对整棵树操作以后在减去中间的那一块er。</p>
</li>
</ol>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>100分代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N], h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> id[N], nw[N], cnt;</span><br><span class="line"><span class="type">int</span> dep[N], sz[N], top[N], fa[N], son[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    ll sum;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> vater, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[p] = depth, fa[p] = vater, sz[p] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == vater)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(j, p, depth + <span class="number">1</span>);</span><br><span class="line">        sz[p] += sz[j];</span><br><span class="line">        <span class="keyword">if</span>(sz[son[p]] &lt; sz[j])son[p] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id[p] = ++cnt, nw[cnt] = w[p], top[p] = t;</span><br><span class="line">    <span class="keyword">if</span>(!son[p])<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[p], t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == fa[p] || j == son[p])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(j, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].sum = tr[p &lt;&lt; <span class="number">1</span>].sum + tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].l = l, tr[p].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum = nw[r];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">segchg</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> ed, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((tr[p].l == ed) &amp;&amp; (tr[p].r == ed))</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum = k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ed &lt;= mid)<span class="built_in">segchg</span>(p &lt;&lt; <span class="number">1</span>, ed, k);</span><br><span class="line">    <span class="keyword">if</span>(ed &gt; mid)<span class="built_in">segchg</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, ed, k);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">segsum</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((tr[p].l &gt;= l) &amp;&amp; (tr[p].r &lt;= r))<span class="keyword">return</span> tr[p].sum;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res += <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)res += <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sumtree</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">segsum</span>(<span class="number">1</span>, id[p], id[p] + sz[p] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sumpath</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[p] != top[q])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[p]] &lt; dep[top[q]])<span class="built_in">swap</span>(p, q);</span><br><span class="line">        res += <span class="built_in">segsum</span>(<span class="number">1</span>, id[top[p]], id[p]);</span><br><span class="line">        p = fa[top[p]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[p] &lt; dep[q])<span class="built_in">swap</span>(p, q);</span><br><span class="line">    res += <span class="built_in">segsum</span>(<span class="number">1</span>, id[q], id[p]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[p] != top[q])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[p]] &lt; dep[top[q]])<span class="built_in">swap</span>(p, q);</span><br><span class="line">        p = fa[top[p]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[p] &lt; dep[q])<span class="built_in">swap</span>(p, q);</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_v</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[p] != top[q])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[p]] &lt; dep[top[q]])<span class="built_in">swap</span>(p, q);</span><br><span class="line">        <span class="keyword">if</span>(fa[top[p]] == q)<span class="keyword">return</span> top[p];</span><br><span class="line">        p = fa[top[p]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[p] &lt; dep[q])<span class="built_in">swap</span>(p, q);</span><br><span class="line">    <span class="keyword">return</span> son[q];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">        <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="type">int</span> rt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rt = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ll z;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;z);</span><br><span class="line">            <span class="built_in">segchg</span>(<span class="number">1</span>, id[x], z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x == rt)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, tr[<span class="number">1</span>].sum);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">lca</span>(x, rt) != x)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">sumtree</span>(x));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, tr[<span class="number">1</span>].sum - <span class="built_in">sumtree</span>(<span class="built_in">get_v</span>(rt, x)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">sumpath</span>(x, y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>re的Java8代码（求调）：</p>
<details class="note warning"><summary><p>Java8</p>
</summary>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] w=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] h=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] e=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">200020</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] ne=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">200020</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> idx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] id=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] nw=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] dep=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] sz=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] top=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] fa=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] son=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">static</span> SegTree[] tr=<span class="keyword">new</span> <span class="title class_">SegTree</span>[<span class="number">800080</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Arrays.fill(h,-<span class="number">1</span>);</span><br><span class="line">        Scanner scan=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> n=scan.nextInt();</span><br><span class="line">        <span class="type">int</span> m=scan.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> a=scan.nextInt();</span><br><span class="line">            <span class="type">int</span> b=scan.nextInt();</span><br><span class="line">            add(a,b);</span><br><span class="line">            add(b,a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            w[i]=scan.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        dfs1(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="type">int</span> rt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="type">int</span> op=scan.nextInt();</span><br><span class="line">            <span class="type">int</span> x=scan.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">                rt=x;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="type">int</span> y=scan.nextInt();</span><br><span class="line">                segchg(<span class="number">1</span>,id[x],y);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x==rt)&#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%d\n&quot;</span>,tr[<span class="number">1</span>].sum);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(lca(x,rt)!=x)&#123;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;%d\n&quot;</span>,sumtree(x));</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;%d\n&quot;</span>,tr[<span class="number">1</span>].sum-sumtree(get_v(rt,x)));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">4</span>)&#123;</span><br><span class="line">                <span class="type">int</span> y=scan.nextInt();</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\n&quot;</span>,sumpath(x,y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        e[idx]=b;</span><br><span class="line">        ne[idx]=h[a];</span><br><span class="line">        h[a]=idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs1</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> father,<span class="type">int</span> depth)</span>&#123;</span><br><span class="line">        dep[p]=depth;</span><br><span class="line">        fa[p]=father;</span><br><span class="line">        sz[p]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[p];i!=-<span class="number">1</span>;i=ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(j==father)<span class="keyword">continue</span>;</span><br><span class="line">            dfs1(j,p,depth+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(sz[son[p]]&lt;sz[j])son[p]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs2</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> t)</span>&#123;</span><br><span class="line">        id[p]=++cnt;</span><br><span class="line">        nw[cnt]=w[p];</span><br><span class="line">        top[p]=t;</span><br><span class="line">        <span class="keyword">if</span>(son[p]==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        dfs2(son[p],t);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[p];i!=-<span class="number">1</span>;i=ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>((j==fa[p])||(j==son[p]))<span class="keyword">continue</span>;</span><br><span class="line">            dfs2(j,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">pushup</span><span class="params">(<span class="type">int</span> p)</span>&#123;</span><br><span class="line">        tr[p].sum=tr[p&lt;&lt;<span class="number">1</span>].sum+tr[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        tr[p].l=l;</span><br><span class="line">        tr[p].r=r;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            tr[p].sum=nw[r];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        build(p&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">        build(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        pushup(p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">segchg</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> ed,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((tr[p].l==ed)&amp;&amp;(tr[p].r==ed))&#123;</span><br><span class="line">            tr[p].sum=k;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=(tr[p].l+tr[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(ed&lt;=mid)segchg(p&lt;&lt;<span class="number">1</span>,ed,k);</span><br><span class="line">        <span class="keyword">if</span>(ed&gt;mid)segchg(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,ed,k);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">segsum</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((tr[p].l&gt;=l)&amp;&amp;(tr[p].r&lt;=r))<span class="keyword">return</span> tr[p].sum;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mid=(tr[p].l+tr[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)res+=segsum(p&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)res+=segsum(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sumtree</span><span class="params">(<span class="type">int</span> p)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> segsum(<span class="number">1</span>,id[p],id[p]+sz[p]-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sumpath</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(top[p]!=top[q])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dep[top[p]]&lt;dep[top[q]])&#123;</span><br><span class="line">                <span class="type">int</span> temp=p;</span><br><span class="line">                p=q;</span><br><span class="line">                q=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            res+=segsum(<span class="number">1</span>,id[top[p]],id[p]);</span><br><span class="line">            p=fa[top[p]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dep[p]&lt;dep[q])&#123;</span><br><span class="line">            <span class="type">int</span> temp=p;</span><br><span class="line">            p=q;</span><br><span class="line">            q=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        res+=segsum(<span class="number">1</span>,id[q],id[p]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lca</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(top[p]!=top[q])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dep[top[p]]&lt;dep[top[q]])&#123;</span><br><span class="line">                <span class="type">int</span> temp=p;</span><br><span class="line">                p=q;</span><br><span class="line">                q=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            p=fa[top[p]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dep[p]&lt;dep[q])&#123;</span><br><span class="line">            <span class="type">int</span> temp=p;</span><br><span class="line">            p=q;</span><br><span class="line">            q=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">get_v</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(top[p]!=top[q])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dep[top[p]]&lt;dep[top[q]])&#123;</span><br><span class="line">                <span class="type">int</span> temp=p;</span><br><span class="line">                p=q;</span><br><span class="line">                q=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fa[top[p]]==q)<span class="keyword">return</span> top[p];</span><br><span class="line">            p=fa[top[p]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dep[p]&lt;dep[q])&#123;</span><br><span class="line">            <span class="type">int</span> temp=p;</span><br><span class="line">            p=q;</span><br><span class="line">            q=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> son[q];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegTree</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> l;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h1 id="T3-【20180819省队班】-取数字"><a href="#T3-【20180819省队班】-取数字" class="headerlink" title="T3 【20180819省队班】 取数字"></a>T3 【20180819省队班】 取数字</h1><h2 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h2><details class="note info"><summary><p>题面</p>
</summary>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>给定 $n$ 个整数 $a_i$，你需要从中选取若干个数，使得它们的和是 $m$ 的倍数。问有多少种方案。有多个询问，每次询问一个的 $m$ 对应的答案。</p>
</blockquote>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><blockquote>
<p>第一行两个正整数 $n$，$q$，分别表示整数的数量和询问的数量。<br>第二行 $n$ 个整数 $a_i$ 。<br>接下来 $q$ 行，每行表示一个 $m$。</p>
</blockquote>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><blockquote>
<p>对于每个询问，输出一行答案 $\bmod{1e9+7}$。</p>
</blockquote>

</details>

<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>这道题是个背包计数的问题，背包的容量是模m循环的。<br>记<code>f[i][j]</code>表示考虑了前 $i$个整数，当前余数是 $j$，有选和不选两种情况。那么对于一次询问 $q$，我们直接做的复杂度是 $O(nm)$，总复杂度 $O(nmq)$。这档暴力分应该拿到。</p>
<p>我们注意到m很小，而n很大，也就是说有很多重复的值，那么我们考虑设计一个下标为<code>dp[m][m]</code>的DP方法，每次考虑一类数。<br>假设第 $i$ 种数有 <code>k[i]</code> 个，我们的转移是：<br>$$<br>dp[i][j]&#x3D;\sum_{h&#x3D;0}^{k[i]} C_{k[i]}^h dp[i-1][j - h \times a[i] \bmod m]<br>$$<br>注意到 $\sum k[i]&#x3D;n$ ，以及dp数组的第二维最大只有m，因此我们可以每次 $O(k[i])$ 地预处理出组合数的系数，表示<code>dp[i-1][j]</code>的贡献。写成伪代码就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for h : [0, k[i]]</span><br><span class="line">    c[h % m] += C(k[i], h)</span><br></pre></td></tr></table></figure>

<p>然后我们再递推<code>dp[i][j]</code>，把 $dp[i-1][j]\times c[k]\to dp[i][j+k\times i\bmod m]$ 即可。</p>
<p>总复杂度$O(q(n+m^3))$。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>100分代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200020</span>, M = <span class="number">110</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll T, n, m, k;</span><br><span class="line">ll a[N], fac[N], inv[N];</span><br><span class="line">ll t[M], f[M][M], pre[M];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>)ans = (ans * x) % mod;</span><br><span class="line">        x = (x * x) % mod;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll b, ll a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (((fac[b] * inv[a]) % mod) * (inv[b - a])) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++)fac[i] = (fac[i - <span class="number">1</span>] * i) % mod;</span><br><span class="line">    inv[N - <span class="number">1</span>] = <span class="built_in">qpow</span>(fac[N - <span class="number">1</span>], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = N - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)inv[i] = ((i + <span class="number">1</span>) * inv[i + <span class="number">1</span>]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(t, <span class="number">0</span>, <span class="built_in">sizeof</span>(t));</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)t[(a[i] % m + m) % m]++;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">qpow</span>(<span class="number">2</span>, t[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="built_in">sizeof</span>(pre));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= t[i]; k++)pre[k % m] = (pre[k % m] + <span class="built_in">C</span>(t[i], k)) % mod;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="built_in">min</span>(m - <span class="number">1</span>, t[i]); k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    f[i][(j + i * k) % m] = (f[i][(j + i * k) % m] + f[i - <span class="number">1</span>][j] * pre[k] % mod) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[m - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>re的Java8代码（求调）：</p>
<details class="note warning"><summary><p>Java8</p>
</summary>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> N=<span class="number">200020</span>,M=<span class="number">110</span>,mod=(<span class="type">int</span>)(<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span>[] a=<span class="keyword">new</span> <span class="title class_">long</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span>[] fac=<span class="keyword">new</span> <span class="title class_">long</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span>[] inv=<span class="keyword">new</span> <span class="title class_">long</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span>[] t=<span class="keyword">new</span> <span class="title class_">long</span>[M];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span>[][] f=<span class="keyword">new</span> <span class="title class_">long</span>[M][M];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span>[] pre=<span class="keyword">new</span> <span class="title class_">long</span>[M];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner scan=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        init();</span><br><span class="line">        <span class="type">int</span> n=scan.nextInt();</span><br><span class="line">        <span class="type">int</span> T=scan.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i]=scan.nextInt();</span><br><span class="line">        <span class="keyword">while</span>((T--)!=<span class="number">0</span>)&#123;</span><br><span class="line">            Arrays.fill(t,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;M;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;M;j++)f[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> m=scan.nextInt();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)t[(<span class="type">int</span>)((a[i]%m+m)%m)]++;</span><br><span class="line">            f[<span class="number">0</span>][<span class="number">0</span>]=qpow(<span class="number">2</span>,t[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">                Arrays.fill(pre,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=t[i];k++)pre[k%m]=(pre[k%m]+C((<span class="type">int</span>)t[i],k))%mod;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=min(m-<span class="number">1</span>,(<span class="type">int</span>)t[i]);k++)&#123;</span><br><span class="line">                        f[i][(j+i*k)%m]=(f[i][(j+i*k)%m]+f[i-<span class="number">1</span>][j]*pre[k]%mod)%mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(f[m-<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">qpow</span><span class="params">(<span class="type">long</span> x,<span class="type">long</span> k)</span>&#123;</span><br><span class="line">        <span class="type">long</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((k&amp;<span class="number">1</span>)==<span class="number">1</span>)ans=(ans*x)%mod;</span><br><span class="line">            x=(x*x)%mod;</span><br><span class="line">            k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">C</span><span class="params">(<span class="type">int</span> b,<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (((fac[b]*inv[a])%mod)*(inv[b-a]))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        fac[<span class="number">0</span>]=<span class="number">1l</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)fac[i]=(fac[i-<span class="number">1</span>]*i)%mod;</span><br><span class="line">        inv[N-<span class="number">1</span>]=qpow(fac[N-<span class="number">1</span>],mod-<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=N-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)inv[i]=((i+<span class="number">1</span>)*inv[i+<span class="number">1</span>])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

]]></content>
      <categories>
        <category>比赛解析</category>
      </categories>
      <tags>
        <tag>比赛解析</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流</title>
    <url>/OI/flow/</url>
    <content><![CDATA[<p>网络流。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<p>（3-13至3-14重修）<br>（6-23至6-24增添上下界网络流相关内容）</p>
<h1 id="什么是网络流"><a href="#什么是网络流" class="headerlink" title="什么是网络流"></a>什么是网络流</h1><p>网络流是指在<strong>网络</strong>（或者流网络， Flow Network ）中的<strong>流</strong>。</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>网络是指一个有向图 $G&#x3D;(V,E)$。</p>
<p>每条边 $(u,v)\in E$ 都有一个权值 $c(u,v)$，称之为容量（Capacity），当 $(u,v)\notin E$ 时有 $c(u,v)&#x3D;0$。</p>
<p>其中有两个特殊的点：源点（Source）$s\in V$ 和汇点（Sink）$t\in V,(s\neq t)$。</p>
<h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>设 $f(u,v)$ 定义在二元组 $(u\in V,v\in V)$ 上的实数函数且满足</p>
<ol>
<li>容量限制：对于每条边，流经该边的流量不得超过该边的容量，即，$f(u,v)\leq c(u,v)$</li>
<li>斜对称性：每条边的流量与其相反边的流量之和为 0，即 $f(u,v)&#x3D;-f(v,u)$</li>
<li>流守恒性：从源点流出的流量等于汇点流入的流量，即 $\forall x\in V - \lbrace s,t \rbrace , \sum_{(u,x) \in E} f(u,x) &#x3D; \sum_{(x,v) \in E} f(x,v)$</li>
</ol>
<p>那么 $f$ 称为网络 $G$ 的流函数。对于 $(u,v)\in E$，$f(u,v)$ 称为边的<strong>流量</strong>，$c(u,v)-f(u,v)$ 称为边的<strong>剩余容量</strong>。整个网络的流量为 $\sum_{(s,v)\in E}f(s,v)$，即<strong>从源点发出的所有流量之和</strong>。</p>
<p>一般而言也可以把网络流理解为整个图的流量。而这个流量必满足上述三个性质。</p>
<p>流函数的完整定义为</p>
<p>$$<br>f(u,v)&#x3D;<br>\begin{cases}<br>f(u,v), &amp; (u,v) \in E, \\<br>-f(v,u), &amp; (v,u) \in E, \\<br>0, &amp; (u,v) \not\in E , (v,u) \not\in E.<br>\end{cases}<br>$$</p>
<h3 id="反向边"><a href="#反向边" class="headerlink" title="反向边"></a>反向边</h3><p>反向边是网络流中很重要的一类边。</p>
<p>一般的时候，在题目给定的流网络中是不包含有关反向边的信息的，我们画图的时候也一般不将反向边画出来。</p>
<p>但是，反向边可以利用流网络的一些性质，通过对其流量进行操作，使得我们的子程序可以经由其进行反悔的操作。</p>
<p>建立反向边的时候可以使用一些小trick。</p>
<p>我们如果使用邻接表（或称链式前向星）来建图的话，可以选择同时建正向边和反向边，并使边的编号从0开始，从而可以通过使用异或操作来访问当前边的反向边。</p>
<h2 id="网络流的常见问题"><a href="#网络流的常见问题" class="headerlink" title="网络流的常见问题"></a>网络流的常见问题</h2><p>网络流问题中常见的有以下三种：最大流，最小割，费用流。</p>
<p>解决网络流问题的难点不是算法或者代码，而是建图。对于大多数的网络流题目，我们需要仔细分辨琢磨才可以知道如何将问题转换为网络流这几种问题的其中一种或几种，并将题目中的限制用边&#x2F;点的限制体现出来。</p>
<h1 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>对于一个给定的网络，其合法的流函数其实有很多。其中使得整个网络的流量最大的流函数被称为网络的最大流。</p>
<p>求解一个网络的最大流其实有很多用处，例如可以将二分图的最大匹配问题转化为求解最大流。</p>
<p>求解最大流的算法有很多种，比如Ford-Fulkerson增广路算法、Push-Relable预流推进算法等等。<br>实际上，最常用的还是Ford-Fulkerson增广路算法中的EK和Dinic两种。</p>
<h2 id="Ford-Fulkerson-增广路算法"><a href="#Ford-Fulkerson-增广路算法" class="headerlink" title="Ford-Fulkerson 增广路算法"></a>Ford-Fulkerson 增广路算法</h2><p>该方法通过寻找增广路来更新最大流，有EK,dinic,SAP,ISAP等主流算法。</p>
<p>求解最大流之前，我们先认识一些概念。</p>
<h3 id="残量网络"><a href="#残量网络" class="headerlink" title="残量网络"></a>残量网络</h3><p>首先我们介绍一下一条边的剩余容量 $c_f(u,v)$（Residual Capacity），它表示的是这条边的容量与流量之差，即 $c_f(u,v) &#x3D; c(u,v) - f(u,v)$。</p>
<p>对于流函数 $f$，残存网络 $G_f$（Residual Network）是网络 $G$ 中所有结点和<strong>剩余容量大于 0</strong> 的边构成的子图。形式化的定义，即 $G_f &#x3D; (V_f &#x3D; V,E_f &#x3D; \lbrace(u,v) \in E,c_f(u,v) &gt; 0 \rbrace)$。</p>
<p>注意，剩余容量大于 0 的边可能不在原图 $G$ 中（根据容量、剩余容量的定义以及流函数的斜对称性得到）。可以理解为，残量网络中包括了那些还剩了流量空间的边构成的图，也包括虚边（即反向边）。</p>
<h3 id="增广路"><a href="#增广路" class="headerlink" title="增广路"></a>增广路</h3><p>在原图 $G$ 中若一条从源点到汇点的路径上所有边的<strong>剩余容量都大于 0</strong>，这条路被称为增广路（Augmenting Path）。</p>
<p>或者说，在残存网络 $G_f$ 中，一条从源点到汇点的路径被称为增广路。如图：</p>
<p><img src="https://s2.loli.net/2022/02/28/T4tHBFq3yCSarhu.png" alt="maxflow1.png"></p>
<p>我们从 $4$ 到 $3$，肯定可以先从流量为 $20$ 的这条边先走。那么这条边就被走掉了，不能再选，总的流量为 $20$（现在）。然后我们可以这样选择：</p>
<ol>
<li><p>$4 \to 2 \to 3$ 这条 <strong>增广路</strong> 的总流量为 $20$。到 $2$ 的时候还是 $30$，到 $3$ 了就只有 $20$ 了。</p>
</li>
<li><p>$4 \to 2 \to 1 \to 3$ 这样子我们就很好的保留了 $30$ 的流量。</p>
</li>
</ol>
<p>所以我们这张图的最大流就应该是 $20 + 30 &#x3D; 50$。</p>
<h3 id="Edmonds-Karp-动能算法"><a href="#Edmonds-Karp-动能算法" class="headerlink" title="Edmonds-Karp 动能算法"></a>Edmonds-Karp 动能算法</h3><p>这个算法很简单，就是BFS<strong>找增广路</strong>，然后对其进行<strong>增广</strong>，直到图上再也没有增广路了为止。</p>
<p>我们不用管我们找到的增广路的正确性，毕竟如果我们找到了一条更优的路径的话可以通过之前经过的反向边进行反悔。这也就意味着，我们每次需要BFS的边鸡是包括反向边的。</p>
<p>在具体实现的时候，我们每一次找到增广路的时候，记录下这条路径上所有的最小流量 $minf$ ，那么整个图的流量就增加了 $minf$。同时我们给这条路径上的所有边的反向边都加上 $minf$ 的容量，以便将来反悔。</p>
<p>EK 算法的时间复杂度为 $O(nm^2)$（其中 $n$ 为点数，$m$ 为边数）。<br>其效率还有很大提升空间，但实际情况下不一定能跑满，应付 $10^3 \sim 10^4$ 大小的图应该足够了。</p>
<details class="note success"><summary><p>参考代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">20010</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], f[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> q[N], d[N], pre[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">    e[idx] = a, f[idx] = <span class="number">0</span>, ne[idx] = h[b], h[b] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="built_in">sizeof</span>(st));</span><br><span class="line">    q[<span class="number">0</span>] = S, st[S] = <span class="literal">true</span>, d[S] = INF;</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i];</span><br><span class="line">            <span class="keyword">if</span>(!st[v] &amp;&amp; f[i])</span><br><span class="line">            &#123;</span><br><span class="line">                st[v] = <span class="literal">true</span>;</span><br><span class="line">                d[v] = <span class="built_in">min</span>(d[t], f[i]);</span><br><span class="line">                pre[v] = i;</span><br><span class="line">                <span class="keyword">if</span>(v == T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q[++tt] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">EK</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        r += d[T];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = T; i != S; i = e[pre[i] ^ <span class="number">1</span>])</span><br><span class="line">            f[pre[i]] -= d[T], f[pre[i] ^ <span class="number">1</span>] += d[T];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">EK</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h3 id="Dinic-算法"><a href="#Dinic-算法" class="headerlink" title="Dinic 算法"></a>Dinic 算法</h3><p>EK 算法每一次遍历残量网络的时候只能最多找到一条增广路，但很可能我们的子程序为此而遍历了整个残量网络。这里还有很大的优化空间。</p>
<p><strong>Dinic 算法</strong>的过程是这样的：每次增广前，我们先用 BFS 来将图分层。设源点的层数为 $0$，那么一个点的层数便是它离源点的最近距离。</p>
<p>通过分层，我们可以干两件事情：</p>
<ol>
<li>如果不存在到汇点的增广路（即汇点的层数不存在），我们即可停止增广。</li>
<li>确保我们找到的增广路是最短的。（原因见下文）</li>
</ol>
<p>接下来是 DFS 找增广路的过程。</p>
<p>我们每次找增广路的时候，都只找比当前点层数多 $1$ 的点进行增广（这样就可以确保我们找到的增广路是最短的）。</p>
<p>Dinic 算法会不断重复这两个过程，直到没有增广路了为止。</p>
<p>Dinic 算法有两个优化：</p>
<ol>
<li><strong>多路增广</strong>：每次找到一条增广路的时候，如果残余流量没有用完怎么办呢？我们可以利用残余部分流量，再找出一条增广路。这样就可以在一次 DFS 中找出多条增广路，大大提高了算法的效率。</li>
<li><strong>当前弧优化</strong>：如果一条边已经被增广过，那么它就没有可能被增广第二次。那么，我们下一次进行增广的时候，就可以不必再走那些已经被增广过的边。</li>
</ol>
<p>Dinic 算法的时间复杂度是 $O(n^2m)$ 级别的，但实际上其实跑不满这个上限。<br>Dinic算法可以说是算法实现难易程度与时间复杂度较为平衡的一个算法，可以应对 $10^4 \sim 10^5$级别的图。<br>特别的，Dinic算法在求解二分图最大匹配问题的时候的时间复杂度是 $O(m\sqrt{n})$ 级别的，实际情况下则比这更优。</p>
<details class="note success"><summary><p>参考代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = <span class="number">200010</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], f[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> q[N], d[N], cur[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">    e[idx] = a, f[idx] = <span class="number">0</span>, ne[idx] = h[b], h[b] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, cur[S] = h[S];</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[v] == <span class="number">-1</span> &amp;&amp; f[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">                cur[v] = h[v];</span><br><span class="line">                <span class="keyword">if</span>(v == T)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q[++tt] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == T)<span class="keyword">return</span> limit;</span><br><span class="line">    <span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        cur[u] = i;<span class="comment">//当前弧优化</span></span><br><span class="line">        <span class="type">int</span> v = e[i];</span><br><span class="line">        <span class="keyword">if</span>(d[v] == d[u] + <span class="number">1</span> &amp;&amp; f[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="built_in">find</span>(v, <span class="built_in">min</span>(f[i], limit - flow));</span><br><span class="line">            <span class="keyword">if</span>(!t)d[v] = <span class="number">-1</span>;</span><br><span class="line">            f[i] -= t, f[i ^ <span class="number">1</span>] += t;</span><br><span class="line">            flow += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>, flow;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>()) <span class="keyword">while</span>(flow = <span class="built_in">find</span>(S, INF)) r += flow;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dinic</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h1 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>对于一个给定的网络，我们删去网络中的一个边集，使得源点与汇点不连通，这个被删去的边集就是这张图的一个<strong>割</strong>。在所有的割中，边集的容量和最小的被称为最小割。</p>
<h2 id="最大流最小割定理"><a href="#最大流最小割定理" class="headerlink" title="最大流最小割定理"></a>最大流最小割定理</h2><p>任何一个网络的最大流量等于最小割中边的容量值和。</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>我们如果回想一下最大流算法走完之后的结果。</p>
<p>对于每一条从源点到汇点的流量为正的路径，我们都能找到至少一条容量跑满的边。</p>
<p>这些边的容量之和就是我们最终得到的最大流。</p>
<p>我们考虑将这些边删去。</p>
<p>那么我们如果对剩下的边跑最大流算法的话，我们得到的最大流将会是0，也就意味着源点将不再与汇点直接连通。</p>
<p>这些跑满的边构成的边集就满足了我们对割的定义。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>所以说，我们完全可以用求解最大流的算法来求解最小割问题。</p>
<h2 id="最大权闭合子图问题"><a href="#最大权闭合子图问题" class="headerlink" title="最大权闭合子图问题"></a>最大权闭合子图问题</h2><p>最大权闭合子图是一种网络流问题，可以用最小割解决。</p>
<p>其定义就是，如果一个点选了，其后继节点必须得选。我们需要在这样的约束下最大化选择的点权和。</p>
<p>通常图中有一些点权为正的点和点权为负的点。（如果点权全为正的话不如全都选）<br>建图方法为，将源点连向所有正权点，边权为点权；将所有负权点连向汇点，边权为负点权；原图中的边也保留，边权为 $+\infty$。</p>
<p>考虑我们找到的最小割。我们割掉的正权边就代表我们不选这个点。其所依赖的点也就不再需要选了，从源点流出来的流经过那个点之后，沿着图上的边，经过负权点到达汇点。这些负权点等到被流灌满之后就代表着被割掉了，意味着我们使用不选的正权点覆盖了负权点的花费，我们也就选上了这个点。<br>此时，我们不选上的正权点与源点不连通，我们选上了的负权点与汇点也不连通，整个图就都不连通了。</p>
<p>最终的答案就是正权点的权值和减去最大流。</p>
<h1 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>给定一个网络 $G&#x3D;(V,E)$，每条边除了有容量限制 $c(u,v)$，还有一个单位流量的费用 $w(u,v)$。</p>
<p>当 $(u,v)$ 的流量为 $f(u,v)$ 时，需要花费 $f(u,v)\times w(u,v)$ 的费用。</p>
<p>$w$ 也满足斜对称性，即 $w(u,v)&#x3D;-w(v,u)$。</p>
<p>则该网络中总花费最小的最大流称为<strong>最小费用最大流</strong>，即在最大化 $\sum_{(s,v)\in E}f(s,v)$ 的前提下最小化 $\sum_{(u,v)\in E}f(u,v)\times w(u,v)$。</p>
<p>最小费用最大流问题与带权二分图最大匹配问题的关系就和最大流问题和二分图最大匹配问题的关系类似，这就意味着我们可以使用求解费用流问题的算法来求解带权二分图最大匹配问题。</p>
<h2 id="SSP-算法"><a href="#SSP-算法" class="headerlink" title="SSP 算法"></a>SSP 算法</h2><p>SSP（Successive Shortest Path）算法是一个贪心的算法。它的思路是每次寻找单位费用最小的增广路进行增广，直到图上不存在增广路为止。</p>
<p>如果图上存在单位费用为负的圈，SSP 算法正确无法求出该网络的最小费用最大流。此时需要先使用消圈算法消去图上的负圈。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>如果使用 Bellman-Ford 算法求解最短路，每次找增广路的时间复杂度为 $O(nm)$。设该网络的最大流为 $f$，则最坏时间复杂度为 $O(nmf)$。事实上，这个时间复杂度是<strong>伪多项式的</strong>。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>只需将 EK 算法或 Dinic 算法中找增广路的过程，替换为用最短路算法寻找单位费用最小的增广路即可。</p>
<p>这里写的是SPFA，因为怕有负边权导致的奇怪的结果。</p>
<p>当然，如果没有负权的话可以使用dijkstra。</p>
<details class="note info"><summary><p>基于EK算法的实现</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5010</span>, M = <span class="number">100010</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], f[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> q[N], d[N], pre[N], incf[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">    e[idx] = a, f[idx] = <span class="number">0</span>, w[idx] = -d, ne[idx] = h[b], h[b] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">memset</span>(incf, <span class="number">0</span>, <span class="built_in">sizeof</span>(incf));</span><br><span class="line">    q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, incf[S] = INF;</span><br><span class="line">    <span class="keyword">while</span>(hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh == N) hh = <span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i];</span><br><span class="line">            <span class="keyword">if</span>(f[i] &amp;&amp; d[v] &gt; d[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[v] = d[t] + w[i];</span><br><span class="line">                pre[v] = i;</span><br><span class="line">                incf[v] = <span class="built_in">min</span>(f[i], incf[t]);</span><br><span class="line">                <span class="keyword">if</span>(!st[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt++] = v;</span><br><span class="line">                    <span class="keyword">if</span>(tt == N) tt = <span class="number">0</span>;</span><br><span class="line">                    st[v] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> incf[T] &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EK</span><span class="params">(<span class="type">int</span> &amp;flow, <span class="type">int</span> &amp;cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    flow = cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = incf[T];</span><br><span class="line">        flow += t, cost += t * d[T];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = T; i != S; i = e[pre[i] ^ <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            f[pre[i]] -= t;</span><br><span class="line">            f[pre[i] ^ <span class="number">1</span>] += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c, d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c, d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> flow, cost;</span><br><span class="line">    <span class="built_in">EK</span>(flow, cost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, flow, cost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<details class="note info"><summary><p>基于 Dinic 算法的实现</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5010</span>, M = <span class="number">200010</span>, INF = <span class="number">1e16</span>;</span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">int</span> S, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], f[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> cur[N], d[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">    e[idx] = a, f[idx] = <span class="number">0</span>, w[idx] = -d, ne[idx] = h[b], h[b] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    d[S] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(S);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i];</span><br><span class="line">            <span class="keyword">if</span>(f[i] &amp;&amp; d[v] &gt; d[u] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[v] = d[u] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])</span><br><span class="line">                    vis[v] = <span class="number">1</span>, q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[T] != <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == T)<span class="keyword">return</span> limit;</span><br><span class="line">    <span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        cur[u] = i;</span><br><span class="line">        <span class="type">int</span> v = e[i];</span><br><span class="line">        <span class="keyword">if</span>(d[v] == d[u] + w[i] &amp;&amp; f[i] &amp;&amp; !vis[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="built_in">find</span>(v, <span class="built_in">min</span>(f[i], limit - flow));</span><br><span class="line">            <span class="keyword">if</span>(!t)d[v] = <span class="number">-1</span>;</span><br><span class="line">            f[i] -= t, f[i ^ <span class="number">1</span>] += t;</span><br><span class="line">            flow += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dinic</span><span class="params">(<span class="type">int</span> &amp;flow, <span class="type">int</span> &amp;cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    flow = <span class="number">0</span>, cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(cur, h, <span class="built_in">sizeof</span>(h));</span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">find</span>(S, INF);</span><br><span class="line">        flow += k;</span><br><span class="line">        cost += k * d[T];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c, d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c, d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> flow, cost;</span><br><span class="line">    <span class="built_in">dinic</span>(flow, cost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, flow, cost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（貌似寄了，求调）</p>

</details>

<h1 id="上下界网络流"><a href="#上下界网络流" class="headerlink" title="上下界网络流"></a>上下界网络流</h1><p>现在我们每一条边不仅有流量的上界了，还有了流量的下界。</p>
<h2 id="无源汇有上下界可行流"><a href="#无源汇有上下界可行流" class="headerlink" title="无源汇有上下界可行流"></a>无源汇有上下界可行流</h2><p>现在我们手里拿到了一张图，上面没有给定源点和汇点，同时每一条边都有流量的上界和下界。<br>现在我们需要求出来一个方案，使得我们这张图的所有点满足流量平衡（即每一个点流出的流量和流入的流量是相等的），同时满足流量限制。</p>
<p>例题就是LibreOJ的<span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8xMTU=">#115. 无源汇有上下界可行流</span>。</p>
<p>我们的思路如下：</p>
<p>我们可以将我们的一个可行方案拆成两部分，为每一条边的下限加上超出每一条边下限的部分。<br>我们称超出每一条边下限的这部分流叫做附加流。</p>
<p>首先我们跑满所有边的下限，记录下每一个点流入流量与流出流量之差，设其为 $A_i$。</p>
<p>根据上面我们得到的信息，我们在建立一个新图，是正常的不带下界的网络流，并新建两个源汇点 $S$ 与 $T$。这张图里面的边与原先起始点一样，而流量变为了原边的上界减去下界。</p>
<p>因为部分点的流量不是平衡的，我们需要让其在加上附加流之后平衡，同时在求附加流的这个图中也需要保证流量平衡，所以我们需要将每一个点中不平衡的流量给到源点或汇点。</p>
<p>对于 $A_i &gt; 0$ 的，说明这个点流入较多，需要往出流，其附加流的流出流量是大于其流入流量的，所以需要从 $S$ 向其连一条流量为 $A_i$ 的边；<br>对于 $A_i &lt; 0$ 的，说明这个点流出较多，需要再流入，其附加流的流入流量是大于其流出流量的，所以需要从其向 $T$ 连一条流量为 $-A_i$ 的边。</p>
<p>我们对这个新图跑一个最大流，然后看起最大流量是否等于 $S$ 的所有出边流量之和。如果相等，那么原图也就流量平衡了，这时候我们就得到了一个可行的方案。</p>
<details class="note success"><summary><p>参考代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> m, n;</span><br><span class="line"><span class="type">int</span> S, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], f[M], l[M], idx;</span><br><span class="line"><span class="type">int</span> A[N];</span><br><span class="line"><span class="type">int</span> q[N], d[N], cur[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], f[idx] = d - c, l[idx] = c, h[a] = idx++;</span><br><span class="line">    e[idx] = a, ne[idx] = h[b], f[idx] = <span class="number">0</span>, h[b] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, cur[S] = h[S];</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[v] == <span class="number">-1</span> &amp;&amp; f[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">                cur[v] = h[v];</span><br><span class="line">                <span class="keyword">if</span>(v == T)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q[++tt] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == T)<span class="keyword">return</span> limit;</span><br><span class="line">    <span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        cur[u] = i;</span><br><span class="line">        <span class="type">int</span> v = e[i];</span><br><span class="line">        <span class="keyword">if</span>(d[v] == d[u] + <span class="number">1</span> &amp;&amp; f[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="built_in">find</span>(v, <span class="built_in">min</span>(f[i], limit - flow));</span><br><span class="line">            <span class="keyword">if</span>(!t)d[v] = <span class="number">-1</span>;</span><br><span class="line">            f[i] -= t, f[i ^ <span class="number">1</span>] += t;</span><br><span class="line">            flow += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>, flow;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())<span class="keyword">while</span>(flow = <span class="built_in">find</span>(S, INF))r += flow;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    S = <span class="number">0</span>, T = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c, d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c, d);</span><br><span class="line">        A[a] -= c, A[b] += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(S, i, <span class="number">0</span>, A[i]);</span><br><span class="line">            tot += A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A[i] &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(i, T, <span class="number">0</span>, -A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">dinic</span>();</span><br><span class="line">    <span class="keyword">if</span>(res != tot)<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m * <span class="number">2</span>; i += <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[i ^ <span class="number">1</span>] + l[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="有源汇有上下界最大-x2F-最小流"><a href="#有源汇有上下界最大-x2F-最小流" class="headerlink" title="有源汇有上下界最大&#x2F;最小流"></a>有源汇有上下界最大&#x2F;最小流</h2><p>我们知道，在一个图中要能够跑出一个可行流的前提是所有点都需要流量平衡，但是我们的源点和汇点都没有流量平衡，这就很难办。</p>
<p>一个可以想到的方法就是，从汇点向源点连接一条容量为无限的边，这样就可以跑出来一个可行流。</p>
<p>我们再从给定的源点到汇点再跑一个最大流，将其加到我们的可行流上面就是我们的最大流了；<br>如果想要求最小流的话，就可以从汇点到源点跑一个残量网络上的最大流，代表着我们可以将这些流回退掉，从可行流里面减去当前的最大流就是最小流了。</p>
<p>例题分别是LibreOJ的<span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8xMTY=">#116. 有源汇有上下界最大流</span>和<span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8xMTc=">#117. 有源汇有上下界最小流</span>。</p>
<details class="note success"><summary><p>最大流 参考代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> m, n;</span><br><span class="line"><span class="type">int</span> S, T, s, t;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], f[M], l[M], idx;</span><br><span class="line"><span class="type">int</span> A[N];</span><br><span class="line"><span class="type">int</span> q[N], d[N], cur[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], f[idx] = d - c, l[idx] = c, h[a] = idx++;</span><br><span class="line">    e[idx] = a, ne[idx] = h[b], f[idx] = <span class="number">0</span>, h[b] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, cur[S] = h[S];</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[v] == <span class="number">-1</span> &amp;&amp; f[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">                cur[v] = h[v];</span><br><span class="line">                <span class="keyword">if</span>(v == T)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q[++tt] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == T)<span class="keyword">return</span> limit;</span><br><span class="line">    <span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        cur[u] = i;</span><br><span class="line">        <span class="type">int</span> v = e[i];</span><br><span class="line">        <span class="keyword">if</span>(d[v] == d[u] + <span class="number">1</span> &amp;&amp; f[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="built_in">find</span>(v, <span class="built_in">min</span>(f[i], limit - flow));</span><br><span class="line">            <span class="keyword">if</span>(!t)d[v] = <span class="number">-1</span>;</span><br><span class="line">            f[i] -= t, f[i ^ <span class="number">1</span>] += t;</span><br><span class="line">            flow += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>, flow;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())<span class="keyword">while</span>(flow = <span class="built_in">find</span>(S, INF))r += flow;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;s, &amp;t);</span><br><span class="line">    S = <span class="number">0</span>, T = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c, d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c, d);</span><br><span class="line">        A[a] -= c, A[b] += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(S, i, <span class="number">0</span>, A[i]);</span><br><span class="line">            tot += A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A[i] &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(i, T, <span class="number">0</span>, -A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add</span>(t, s, <span class="number">0</span>, INF);</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">dinic</span>();</span><br><span class="line">    <span class="keyword">if</span>(res != tot)<span class="built_in">puts</span>(<span class="string">&quot;please go home to sleep&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        res = f[idx - <span class="number">1</span>];</span><br><span class="line">        f[idx - <span class="number">1</span>] = f[idx - <span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        S = s, T = t;</span><br><span class="line">        <span class="type">int</span> ans = res + <span class="built_in">dinic</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<details class="note success"><summary><p>最小流 参考代码</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">400010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> m, n;</span><br><span class="line"><span class="type">int</span> S, T, s, t;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], f[M], l[M], idx;</span><br><span class="line"><span class="type">int</span> A[N];</span><br><span class="line"><span class="type">int</span> q[N], d[N], cur[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], f[idx] = d - c, l[idx] = c, h[a] = idx++;</span><br><span class="line">    e[idx] = a, ne[idx] = h[b], f[idx] = <span class="number">0</span>, h[b] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, cur[S] = h[S];</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[v] == <span class="number">-1</span> &amp;&amp; f[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">                cur[v] = h[v];</span><br><span class="line">                <span class="keyword">if</span>(v == T)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q[++tt] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == T)<span class="keyword">return</span> limit;</span><br><span class="line">    <span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        cur[u] = i;</span><br><span class="line">        <span class="type">int</span> v = e[i];</span><br><span class="line">        <span class="keyword">if</span>(d[v] == d[u] + <span class="number">1</span> &amp;&amp; f[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="built_in">find</span>(v, <span class="built_in">min</span>(f[i], limit - flow));</span><br><span class="line">            <span class="keyword">if</span>(!t)d[v] = <span class="number">-1</span>;</span><br><span class="line">            f[i] -= t, f[i ^ <span class="number">1</span>] += t;</span><br><span class="line">            flow += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>, flow;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())<span class="keyword">while</span>(flow = <span class="built_in">find</span>(S, INF))r += flow;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;s, &amp;t);</span><br><span class="line">    S = <span class="number">0</span>, T = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c, d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c, d);</span><br><span class="line">        A[a] -= c, A[b] += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(S, i, <span class="number">0</span>, A[i]);</span><br><span class="line">            tot += A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A[i] &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(i, T, <span class="number">0</span>, -A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add</span>(t, s, <span class="number">0</span>, INF);</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">dinic</span>();</span><br><span class="line">    <span class="keyword">if</span>(res != tot)<span class="built_in">puts</span>(<span class="string">&quot;please go home to sleep&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        res = f[idx - <span class="number">1</span>];</span><br><span class="line">        f[idx - <span class="number">1</span>] = f[idx - <span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        S = t, T = s;</span><br><span class="line">        <span class="type">int</span> ans = res - <span class="built_in">dinic</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/OI/segment-tree/</url>
    <content><![CDATA[<p>线段树及其衍生，如动态开点线段树、可持久化权值线段树等等。</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="什么是线段树？"><a href="#什么是线段树？" class="headerlink" title="什么是线段树？"></a>什么是线段树？</h1><p>线段树是一种数据结构，其可以以 $O( \log n)$ 的时间复杂度处理维护区间信息的问题。<br>其维护的信息满足可以快速合并两个区间的信息（例如区间和、区间最大（小）值。</p>
<p>线段树同时可以支持区间修改，但是区间修改时必须能够快速求出每个区间维护的信息。</p>
<h1 id="线段树的结构"><a href="#线段树的结构" class="headerlink" title="线段树的结构"></a>线段树的结构</h1><p>线段树在建立的时候，会将每一个区间长度不为1的区间进行二分，并递归对这两个区间进行判定。</p>
<p>这是一棵区间长度为12的线段树：</p>
<p><img src="https://s2.loli.net/2022/04/13/wjkzCcr7e4pBQyS.png" alt="segtree1.png"></p>
<p>我们可以明显看到，线段树是一棵二叉树。<br>线段树的高度一般是 $\log n$ 的，这就需要我们建立 $2^{\lceil \log n \rceil + 1}$ 个节点，这将会耗费我们大量的空间。</p>
<p>一般情况下，我们为了访问方便，也为了节省空间，我们一般将一个节点（设其编号为 $p$）的左儿子和右儿子分别设为 $p &lt;&lt; 1$ 和 $p &lt;&lt; 1 | 1$，就相当于是在一棵满二叉树上面访问。</p>
<p>于是我们就给出编号：</p>
<p><img src="https://s2.loli.net/2022/04/13/BYmKAP7NDaSytMq.png" alt="segtree2.png"></p>
<p>下面给出示例代码：</p>
<p>假设我们维护的是区间和，并使用类似</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">&#125;tr;</span><br></pre></td></tr></table></figure>

<p>的结构体来存储数据，那么建立线段树的函数就是像下面这个样子的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[p].l = l, tr[p].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    tr[p].sum = tr[p &lt;&lt; <span class="number">1</span>].sum + tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线段树的区间询问"><a href="#线段树的区间询问" class="headerlink" title="线段树的区间询问"></a>线段树的区间询问</h1><p>我们这里以区间求和为例。</p>
<p>我们先手动模拟一下区间求和的过程：</p>
<p>假设我们对这样一个长度为12的序列 $\lbrace 1,1,4,5,1,4,1,9,1,9,8,1 \rbrace$ 建立线段树，那么我们每一个区间的数据是这个样子的：</p>
<p><img src="https://s2.loli.net/2022/04/13/kHphs28SOJVRoGT.png" alt="segtree3.png"></p>
<p>我们假设需要对 $[2,8]$ 这个区间内的数据进行求和，那么我们覆盖的区间就是这个样子的：</p>
<p><img src="https://s2.loli.net/2022/04/13/hRWnlYSrVU7d51f.png" alt="segtree4.png"></p>
<p>我们想象一下将区间向上推：</p>
<p><img src="https://s2.loli.net/2022/04/13/Zphkae3wVJO1Lrq.gif" alt="segtree4.gif"></p>
<p>最后我们将 $[2,8]$ 这个大区间分为 $[2,2] \cup [3,3] \cup [4,6] \cup [7,8]$ 这几个小区间。</p>
<p><img src="https://s2.loli.net/2022/04/13/O6IKkaHo5cg1i3V.png" alt="segtree5.png"></p>
<p>我们每一次二分递归的时候，如果当前区间被我们询问的区间完全包含就返回当前区间的值，如果没有完全包含就递归询问左右区间，并输出两个区间的返回值之和。</p>
<p>在递归询问左右两区间的时候需要注意一下子区间是否与询问的区间有重合部分，如果两者交集为空，那就不需要询问了。</p>
<p>下面给出示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">segadd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)<span class="keyword">return</span> tr[p].sum;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res += <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)res += <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线段树的区间修改"><a href="#线段树的区间修改" class="headerlink" title="线段树的区间修改"></a>线段树的区间修改</h1><p>区间修改和区间求和有着相同的思路。</p>
<p>我们这里以区间加为例。</p>
<p>还是之前的例子，如果我们想要给区间 $[2,8]$ 同时加上一个数会怎样？</p>
<p>让我们再来看一下这个图：</p>
<p><img src="https://s2.loli.net/2022/04/13/O6IKkaHo5cg1i3V.png" alt="segtree5.png"></p>
<p>其中白色的区间是完全和我们询问没有任何关系的区间，黄色的区间是与我们询问的区间有交集，但是没有被新闻区间所包含的区间。</p>
<p>红色的区间和橙色的区间都被询问区间所包含，其中红色的区间是我们在区间求和的时候返回了值的区间，橙色的区间虽然被询问区间包含，但是我们没有访问到他们。</p>
<p>区间修改也是一样的思路。我们只需要将需要的区间修改即可，剩下的被询问区间包含的区间只需要标记一下就可以了。</p>
<p>这里需要用到懒标记的思想。</p>
<h2 id="懒标记"><a href="#懒标记" class="headerlink" title="懒标记"></a>懒标记</h2><p>懒标记的意思就是很懒的标记。我们用到它的时候才会将它兑现，否则他就在那里静静地待着就可以了。</p>
<p>我们考虑给结构体里面加上一个懒标记，就像这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    <span class="type">int</span> tag;<span class="comment">//&lt;- 就是这个</span></span><br><span class="line">&#125;tr;</span><br></pre></td></tr></table></figure>

<p>当某个区间有懒标记的时候，就意味着它的子树里面的所有区间都应该被修改，但是目前没有应用上。</p>
<p>但是拥有懒标记的区间的值在修改的时候已经被修改好了。</p>
<p>每一次我们递归询问子区间的时候，我们就需要将这个懒标记下传（如果有的话）。<br>我们需要一个<code>pushdown</code>函数来完成这件事。</p>
<p>我们这里仍然以区间加为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[p], &amp;left = tr[p &lt;&lt; <span class="number">1</span>], &amp;rght = tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(root.tag)</span><br><span class="line">    &#123;</span><br><span class="line">        left.sum += root.tag * (left.r - left.l + <span class="number">1</span>);</span><br><span class="line">        rght.sum += root.tag * (rght.r - rght.l + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//更新子区间值</span></span><br><span class="line">        left.tag += root.tag;</span><br><span class="line">        rght.tag += root.tag;</span><br><span class="line">        <span class="comment">//更新子区间懒标记</span></span><br><span class="line">        root.tag = <span class="number">0</span>;<span class="comment">//懒标记清空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzNzI=">Luogu P3372 【模板】线段树 1</span></p>
<p>参考代码：<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20va2Fpc2Vyd2lsaGVpbS9PSWNvZGVzL2Jsb2IvbWFzdGVyL0x1b2d1L3AzMDAwLXAzOTk5L3AzMzcyL3AzMzcyLmNwcA==">Luogu P3372</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzNzM=">Luogu P3373 【模板】线段树 2</span></p>
<p>参考代码：<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20va2Fpc2Vyd2lsaGVpbS9PSWNvZGVzL2Jsb2IvbWFzdGVyL0x1b2d1L3AzMDAwLXAzOTk5L3AzMzczL3AzMzczLmNwcA==">Luogu P3373</span></p>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="标记永久化"><a href="#标记永久化" class="headerlink" title="标记永久化"></a>标记永久化</h2><p>我们可以尝试一个思路：不下传标记。</p>
<p>我们重新思考一下懒标记的意义。</p>
<p>懒标记代表的是，这个点的所有子区间都需要被这个标记更新他们的值。</p>
<p>于是我们就可以将标记放进函数里面，随着函数下传，到时候也可以起到更新值的作用。</p>
<p>这样的方法适用于不能<code>pushdown</code>的时候。</p>
<p>具体情况我也没有遇见过，据说是需要配合可持久化权值线段树（aka主席树）使用。</p>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">segsum</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)<span class="keyword">return</span> tr[p].sum + tag * (tr[p].r - tr[p].l + <span class="number">1</span>);</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res += <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span>, l, r, tag + tr[p].tag);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)res += <span class="built_in">segsum</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, tag + tr[p].tag);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线段树上二分"><a href="#线段树上二分" class="headerlink" title="线段树上二分"></a>线段树上二分</h2><p>想不到吧，线段树还能优化二分！</p>
<p>我们考虑这样一个问题：我们需要找到一个位置 $pos$，使得 $[1,pos]$ 这个区间内数字的和不小于 $val$。保证所有权值非负。</p>
<p>那么我们可以直接进行二分，这样每做一次的复杂度是 $O(\log^2 n)$ 的。</p>
<p>我们可以用线段树来优化这样的过程。</p>
<p>我们带着 $val$ 在线段树上搜索。<br>如果当前节点的左儿子的权值 $\geq val$，就带着 $val$ 继续跳到左儿子搜索；<br>如果当前节点的左儿子的权值 $&lt; val$，就带着 $val-tr[tr[p].ls].val$ 继续跳到右儿子搜索。</p>
<h2 id="动态开点线段树"><a href="#动态开点线段树" class="headerlink" title="动态开点线段树"></a>动态开点线段树</h2><p>有时候我们需要维护的下标区域非常广（比如说 $10^9$），但是真正有值的地方其实很少。</p>
<p>我们当然不可能为这个序列直接创建一棵完整的线段树，这样子会耗费我们大量的空间维护许多无用的数据。</p>
<p>比如说维护一个序列里面有多少个数字大于某个数，但是这个数列的值域是 $10^9$，但是数列长度最多只有 $10^5$。</p>
<p>我们当然不可能直接创建一个覆盖整个值域的线段树，这样子会需要我们创建 $2^31$ 个节点，即使我们不考虑区间修改，只维护一个区间和的话也需要高达24GiB的空间，十分的浪费。</p>
<p>于是我们可以动态开点，只建立用到的区间，其他的就不会被声明，大大减少了我们需要用的空间。<br>或者说，我们什么时候需要用到某个节点了，我们就建立它。</p>
<p>但是这样做的代价就是我们无法再使用简单的 <code>p&lt;&lt;1</code> 和 <code>p&lt;&lt;1|1</code> 来访问当前节点的左右子节点了。<br>我们需要记录下当前节点的左右节点的编号。</p>
<p>我们以维护一个序列里面有多少个数字大于某个数为例。</p>
<p>那么我们的结构体就会变成这个样子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> ls, rs;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">&#125;tr;</span><br></pre></td></tr></table></figure>

<p>其中 <code>ls</code> 和 <code>rs</code> 分别代表了当前节点的左儿子和右儿子的编号。</p>
<p>那么我们就不需要<code>build</code>了，只需要一开始将第一个节点初始化为根节点即可。</p>
<p>然后我们的区间修改函数就是这个样子的。<br>我们可以有两种风格：</p>
<div class="tabs" id="dongtaikaidianxiugai"><ul class="nav-tabs"><li class="tab active"><a href="#dongtaikaidianxiugai-1">提前开点</a></li><li class="tab"><a href="#dongtaikaidianxiugai-2">用到再开</a></li></ul><div class="tab-content"><div class="tab-pane active" id="dongtaikaidianxiugai-1"><p>我们在访问子节点之前，首先看一下我们将要访问的这个子节点到底是否存在，如果不存在的话就新开一个。</p>
<p>这样子的话支持把当前区间的左右端点放在结构体里面存着，也支持将区间左右端点当做参数放到函数里面传。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">segadd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum += k * (tr[p].r - tr[p].l + <span class="number">1</span>);</span><br><span class="line">        tr[p].add += k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[p].ls)</span><br><span class="line">        &#123;</span><br><span class="line">            tr[p].ls = ++idx;</span><br><span class="line">            tr[tr[p].ls].l = tr[p].l;</span><br><span class="line">            tr[tr[p].ls].r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">segadd</span>(tr[p].ls, l, r, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[p].rs)</span><br><span class="line">        &#123;</span><br><span class="line">            tr[p].rs = ++idx;</span><br><span class="line">            tr[tr[p].rs].l = mid + <span class="number">1</span>;</span><br><span class="line">            tr[tr[p].rs].r = tr[p].r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">segadd</span>(tr[p].rs, l, r, k);</span><br><span class="line">    &#125;</span><br><span class="line">    tr[p].sum = tr[tr[p].ls].sum + tr[tr[p].rs].sum;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="dongtaikaidianxiugai-2"><p>我们在访问子节点的时候才看一下，我们的这个子节点是否存在。如果不存在的话就创建一个。</p>
<p>这样的话我们就在函数里面传节点编号的引用，并且同时把当前区间的左右端点放进函数里面当参数传。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">segadd</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> al, <span class="type">int</span> ar, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)p = ++idx;</span><br><span class="line">    <span class="keyword">if</span>(al &gt;= l &amp;&amp; ar &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p].sum += k * (ar - al + <span class="number">1</span>);</span><br><span class="line">        tr[p].add += k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (al + ar) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)<span class="built_in">segadd</span>(tr[p].ls, l, r, al, mid, k);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)<span class="built_in">segadd</span>(tr[p].rs, l, r, mid + <span class="number">1</span>, ar, k);</span><br><span class="line">    tr[p].sum = tr[tr[p].ls].sum + tr[tr[p].rs].sum;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<p>而查询函数不需要做太大的变动，只需要看一下当前访问的节点是否存在就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">segsum</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)<span class="keyword">return</span> tr[p].sum;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)res += <span class="built_in">segsum</span>(tr[p].ls, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid)res += <span class="built_in">segsum</span>(tr[p].rs, l, r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可持久化权值线段树"><a href="#可持久化权值线段树" class="headerlink" title="可持久化权值线段树"></a>可持久化权值线段树</h2><p>面对眼前的区间第 $k$ 小问题，我们应该怎么办？</p>
<p>我们的一个思路就是使用主席树。</p>
<p>主席树，全称为可持久化权值线段树，通过保存每次插入操作时的历史版本，以便查询区间第 $k$ 小。</p>
<p>怎么保存呢？</p>
<p>一种暴力的方法就是可以每一次插入的时候都开一棵线段树。<br>但是这样对空间的使用不是很友好。</p>
<p>那么我们分析一下，每一次修改的时候涉及的都只有一条从根节点到我们想要修改的节点的路径。<br>那么我们每一次只需要新建从根节点一直到我们想要修改的节点的一整条路径就可以了。</p>
<p>我们每一次就只新建了 $O(\log n)$ 个节点，大大节省了我们需要用的空间。</p>
<p>这种情况下，我们就不能采用堆式存储法（就是那个把左儿子和右儿子分别设为 $p &lt;&lt; 1$ 和 $p &lt;&lt; 1 | 1$ 的）了，必须使用动态开点。</p>
<p>对于预计需要的节点个数，我们可以采用这种办法：</p>
<p>我们每一次操作最多需要新开 $2^{\lceil \log n \rceil +1}$ 个节点，我们只需要根据 $n$ 和 $m$ 的大小来声明就可以了。</p>
<p>怎么维护区间第 $k$ 小？</p>
<p>一般情况下，我们可以用对区间建立一棵权值线段树的方法来维护当前区间的区间第 $k$ 小。<br>原理就是，权值线段树维护的是区间内每一个数有多少个。<br>我们只需要用类似线段树上二分的思想在线段树上搜索即可。</p>
<p>但是我们不能每一次都根据当前区间建立一棵线段树，这样又麻烦又浪费空间。</p>
<p>所以我们就像利用前缀和减去另一个前缀和得到区间和一样，将给当前区间建立一棵线段树的问题转化成了给分别建立在 $[1,l-1]$ 和 $[1,r]$ 上的两棵线段树做差。<br>而这样的两棵线段树可以通过每一次向线段树维护的区间最后追加一个数字来得到。</p>
<p>而这也就是主席树维护区间第 $k$ 小的主要思想。</p>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM4MzQ=">Luogu P3834 【模板】可持久化线段树 2</span></p>
<p>参考代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3834/p3834.cpp"><code>Luogu P3834</code></a></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM5MTk=">Luogu P3919 【模板】可持久化线段树 1（可持久化数组）</span></p>
<p>参考代码：<a href="https://gitee.com/kaiserwilheim/OIcodes/blob/master/Luogu/p3000-p3999/p3919/p3919.cpp"><code>Luogu P3919</code></a></p>
<h2 id="区间最大子段和"><a href="#区间最大子段和" class="headerlink" title="区间最大子段和"></a>区间最大子段和</h2><p>区间最大子段和也可以使用线段树来维护。</p>
<p>我们考虑记录一下每一个区间内的最大前缀和、最大后缀和、最大子段和与区间和。</p>
<p>区间合并的时候这样合并：</p>
<ul>
<li>最大前缀和：左儿子的最大前缀和与（右儿子的最大前缀和与左儿子的区间和之和）取最大值；</li>
<li>最大后缀和：右儿子的最大后缀和与（左儿子的最大前缀和与右儿子的区间和之和）取最大值；</li>
<li>最大子段和：左儿子的最大子段和、右儿子的最大子段和与（左儿子的最大后缀和与右儿子的最大前缀和之和）取最大值；</li>
<li>区间和：直接加。</li>
</ul>
<p>写了个重载加号：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> lms, rms;</span><br><span class="line">    <span class="type">int</span> ms, sum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> SegTree <span class="keyword">operator</span> + (<span class="type">const</span> SegTree &amp;lhs, <span class="type">const</span> SegTree &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">        &#123;</span><br><span class="line">            lhs.l, </span><br><span class="line">            rhs.r,</span><br><span class="line">            <span class="built_in">max</span>(lhs.lms, rhs.lms + lhs.sum),</span><br><span class="line">            <span class="built_in">max</span>(rhs.rms, lhs.rms + rhs.sum),</span><br><span class="line">            <span class="built_in">max</span>(lhs.rms + rhs.lms, <span class="built_in">max</span>(lhs.ms, rhs.ms)),</span><br><span class="line">            lhs.sum + rhs.sum</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>然后查询函数就是这个样子的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">SegTree <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l &gt;= l &amp;&amp; tr[p].r &lt;= r)<span class="keyword">return</span> tr[p].ms;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= mid)<span class="keyword">return</span> <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid)<span class="keyword">return</span> <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span>, l, r) + <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用线段树维护区间最大子段和的话还可以支持单点修改。</p>
<p>思路跟正常的单点修改一样。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pos, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].l == tr[p].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[p] = &#123; tr[p].l,tr[p].r,<span class="built_in">max</span>(k,<span class="number">0</span>),<span class="built_in">max</span>(k,<span class="number">0</span>),<span class="built_in">max</span>(k,<span class="number">0</span>),k &#125;;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (tr[p].l + tr[p].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid)<span class="built_in">modify</span>(p &lt;&lt; <span class="number">1</span>, pos, k);</span><br><span class="line">    <span class="keyword">if</span>(pos &gt; mid)<span class="built_in">modify</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, pos, k);</span><br><span class="line">    tr[p] = tr[p &lt;&lt; <span class="number">1</span>] + tr[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details class="note info"><summary><p>[SNOI2020] 区间和</p>
</summary>
<p>暴力修改，不是正解。<br>能过官方数据，但是不能过Hack数据。</p>
<p>提交记录：</p>
<p>洛谷：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDY3OTI=">题面</span>；<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3JlY29yZC83NDA2MDYwOA==">记录</span>。<br>LibreOJ：<span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8zMzI1">题面</span>；<span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcy8xNDcwODU2">记录</span>。</p>

</details>

<h2 id="线段树优化建图"><a href="#线段树优化建图" class="headerlink" title="线段树优化建图"></a>线段树优化建图</h2><p>线段树优化建图，又称线段树优化连边，是一种处理区间连边的方法。</p>
<p>有时候题目会让我们从一个点 $w$ 向一段区间 $[l,r]$ 内的所有点连上一条边权相等的边。</p>
<p>连边数量少的时候我们尚且还可以通过枚举来暴力建边，而当连边数量多起来的时候时间复杂度就不符合我们的要求了。</p>
<p>我们可以利用线段树来辅助我们建图。</p>
<p>线段树上的每一个节点都是一个虚拟的节点，其分别向其左儿子和右儿子连接一条没有影响的边。<br>这里的“没有影响”不仅指边权为0，还可以指流量为 $+\infty$、费用为0等等。</p>
<p>网络流相关的题目中利用这种方式优化建图的很多。</p>
<p>建图的时候，我们首先建立线段树，建立 $2^{\lfloor \log{n} \rfloor +1}$ 个节点和 $2^{\lfloor \log{n} \rfloor +2}$ 条双向边。</p>
<p>然后就是处理区间连边问题。<br>我们就像正常的线段树区间加一样，函数递归时，如果遇到了被完全包含在询问区间内的第一个区间，就从我们指定的点向代表该区间的点连一条边并返回即可。</p>
<h3 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDgwMjE=">洛谷 P8021</span> [ONTAK2015] Bajtman i Okrągły Robin</p>
<p>如果我们使用暴力建图的话，可以想到的是把每一个 Robin 向他能抢劫的时间点连一条容量为1、费用为 $c_i$ 的边。同时，源点向每一个 Robin 连一条容量为1费用为0的边，每一个时间点向汇点连一条容量为1费用为0的边，然后跑最大费用最大流就可以了。</p>
<p>我们如果使用线段树建图的话，就仿照上面的方法，到线段树上连边就可以了。因为我们是在这一段区间内选一个时间点抢劫，所以我们连边的时候仍然保持上面的方式，容量为1、费用为 $c_i$。</p>
<p>题解：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2Jsb2cvS2Fpc2VyLVdpbGhlaW0vc29sdXRpb24tcDgwMjE=">洛谷题解</span></p>
<p>参考代码：<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20va2Fpc2Vyd2lsaGVpbS9PSWNvZGVzL2Jsb2IvbWFzdGVyL0x1b2d1L3A2MDAwKy9wODAyMS9wODAyMS5jcHA=">Luogu P8021</span></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论（广义）学习笔记</title>
    <url>/notes/game-strategy/</url>
    <content><![CDATA[<p>简介： 博弈论</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>我们先举一个栗子：</p>
<p>假如你和李zen一起玩一个游戏；<br>你们面前都有一个开关，你们都可以选择让这个开关处于断开或闭合两种状态的其中任意一种。<br>而我会根据开关的状态给你们评级：<br>当两个开关都闭合时，你们都得 $C$ ；<br>当两个开关都断开时，你们都得 $B$ ；<br>当两个开关一开一断时，断开的得 $D$ ，闭合的得 $A$ 。<br>十分简单。</p>
<p>你会怎么选呢？</p>
<p>首先我们列一个表格，表示出所有结果：</p>
<p><img src="https://i.loli.net/2021/09/22/PugFZ2BDdAqo5zw.png" alt="博弈1.png"></p>
<p>现在你会做出什么选择呢？</p>
<p>你犹豫了一下，然后闭合了开关。<br>毕竟这样你可以<del>迫害李zen</del>得到更高的评级。<br>但是你的内心深处还是有一个声音：<br>“断开开关吧，毕竟李zen之前被迫害太多次了，他会<del>开始反围剿</del>伤心的”<br>驱使着你断开开关。<br>是不是？</p>
<p>你仍然在犹豫。</p>
<p>那么，如果现在我们规定，本次游戏结果计入今年的期末考试，只有拿到 $C$ 级才能及格，而你又不想挂科，怎么样？</p>
<p>为了更直观一点，我们用 $[-1,2]$ 范围内的整数来代替评级，是不是会更好一些？</p>
<p><img src="https://i.loli.net/2021/09/22/OSmtUF89Hs5covl.png" alt="博弈2.png"></p>
<p>这时候，你就可以进行一下比较：</p>
<p>如果你闭合开关，那么无论李zen干什么，你都可以拿到更高的分数<del>（除非他直接来找你）</del> ：<br>$0&gt;-1,2&gt;1$</p>
<p>此时，如果有两个策略 $α$ 与 $β$ ，无论他人选择什么，我们选 $α$ 得到的结果都严格优于选 $β$ ，那我们就称 $α$ 相对于 $β$ 是一个 <strong>严格优势策略(Strictly dominant strategy)</strong> 。</p>
<p>比如这道题里的“闭合开关”就是个相对于“断开开关”的严格优势策略。</p>
<p>假如你选择了断开开关，而李zen选择闭合开关，你挂科了。<br>这时候你就会得到一条重要的结论：</p>
<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论 1"></a>结论 1</h3><p><strong>永远，永远不要选择劣势策略。</strong><br>这里的 <strong>“严格劣势策略(Strictly dominated strategy)”</strong> 是相对于 <strong>“严格优势策略”</strong> 而说的，指有一个策略，不管别人选择什么，你选它的结果都严格劣于选其他的策略。</p>
<p>懂的都懂。</p>
<hr>
<p>所以说，你们两个人都选择断开开关，都得B，不是很好的吗？</p>
<p>这时候需要引入另一条重要的结论：</p>
<h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论 2"></a>结论 2</h3><p><strong>理性的选择最终一定导致非最优结果。</strong></p>
<p>对于zen来说，不管你怎么选，选择闭合开关总是对他有利的。但你不知道他会选什么，也不可以与它交流，所以你不能与他一起约好了选择断开开关。</p>
<hr>
<p>现在，我们更改一下游戏的结果。</p>
<p>假如你考砸了，你就会受到家长的诘问，因而变得伤心，这一部分也要算在期望收益里；</p>
<p>假如你让李zen考砸了，你就会心生愧疚<del>同时被愤怒的zen反围剿</del>，也会变得伤心，这一部分也要算在期望收益里。</p>
<p>于是，我们的表格变成了：</p>
<p><img src="https://i.loli.net/2021/09/22/16dpGnyJa9uB3vM.png" alt="博弈3.png"></p>
<p>在这种情况下，你就不会有任何优势策略或劣势策略。</p>
<p>这个博弈叫做 <strong>“协和谬误(Coordination problem)”</strong> 。</p>
<p>这个时候你就不知道怎么办了。</p>
<p>你不知道李zen会怎么做，你们两个人也无法交流，因此你就无法做出决定。</p>
<p>这就引出了另外一条很好的结论：</p>
<h3 id="结论-3"><a href="#结论-3" class="headerlink" title="结论 3"></a>结论 3</h3><p><strong>汝欲求之，必先知之。</strong></p>
<p>你在做出决定之前，最好先了解一下你的对手的基本信息。</p>
<p>在这局游戏里，你的对手是李zen。</p>
<p>碰巧，你知道李zen富有爱心，他总会考虑你的感受。如果他闭合了开关但你没有而使得你输了，他会不开心的。</p>
<p>这就导致他之前和鳖玩的时候被邪恶的鳖打到自闭。（之前的不计入期末成绩awa）</p>
<p>你们两个会玩的十分愉快。（你输了他会安慰你awa）</p>
<p>但是如果你跟鳖玩呢？</p>
<p>鳖不会有情感损伤的减益よ。</p>
<p>那么，你的期望收益就变成了这样：</p>
<p><img src="https://i.loli.net/2021/09/22/ElJjYIQzXW8mtdO.png" alt="博弈4.png"></p>
<p>此时，你就需要对你的策略进行一些改变：</p>
<p>因为无论你选择什么，鳖总会闭合开关，因为这相对于他来说是一种优势策略。</p>
<p>所以，你应当闭合开关，使得鳖的收益最小。</p>
<p>这时候，你就学会了一条重要的结论：</p>
<h3 id="结论-4"><a href="#结论-4" class="headerlink" title="结论 4"></a>结论 4</h3><p><strong>站在他人的立场上去分析他们会做出的决策</strong> ，或者， <strong>学会换位思考</strong> 。</p>
<p>现在，你大概就可以与鳖这样的人友好地游玩了，甚至能跟tue、zhua过上几招了。</p>
<p>但是，如果这个游戏的结果与你的期末考试成绩挂钩呢？<br>那么，就连zen也会闭合开关，来防止挂科的。</p>
<p>所以记住：</p>
<h3 id="结论-5"><a href="#结论-5" class="headerlink" title="结论 5"></a>结论 5</h3><p><strong>人是自私的。人都想偷懒。</strong></p>
<p>至此，你就基本上开始接触了博弈论。</p>
<hr>
<p>大家应该都听说过囚徒困境罢。<br>不出意外的话，两个囚徒都会选择供出对方。<br>那么，如何改变这个博弈的结果呢？</p>
<h3 id="如何改变博弈结果"><a href="#如何改变博弈结果" class="headerlink" title="如何改变博弈结果"></a>如何改变博弈结果</h3><p>我们有三种方法：</p>
<p><strong>1. 签订条约，制定规章制度等；</strong><br><strong>2. 多次重复博弈；</strong><br><strong>3. 教育。（如集体主义教育）</strong></p>
<p>不管哪一条，本质上都是改变了参与者的收益或参与者的动机。</p>
<hr>
<h2 id="更深的层次"><a href="#更深的层次" class="headerlink" title="更深的层次"></a>更深的层次</h2><p>我们刚才通过举例子知道了什么是博弈，但我们真的知道什么是博弈吗？</p>
<h3 id="博弈的组成"><a href="#博弈的组成" class="headerlink" title="博弈的组成"></a>博弈的组成</h3><p>一个博弈由三部分组成：</p>
<h4 id="1-参与人-Players"><a href="#1-参与人-Players" class="headerlink" title="1. 参与人(Players)"></a>1. 参与人(Players)</h4><p>在这里，我们使用小写字母 $i$ , $j$ 等来代表参与人。</p>
<h4 id="2-策略-Strategy"><a href="#2-策略-Strategy" class="headerlink" title="2. 策略(Strategy)"></a>2. 策略(Strategy)</h4><p>在这里，我们使用带有下标的小写字母 $s_i$ 来代表参与人 $i$ 的某一个策略。</p>
<p>我们使用带有下标的大写字母 $S_i$ 来代表参与人 $i$ 的所有可能的策略集合。</p>
<p>我们使用小写字母 $s_{-i}$ 来表示除参与人 $i$ 之外的所有参与人的策略。</p>
<h4 id="3-收益-Payoff"><a href="#3-收益-Payoff" class="headerlink" title="3. 收益(Payoff)"></a>3. 收益(Payoff)</h4><p>在这里，我们使用带有下标的大写字母 $U_i (s)$ 来代表参与人 $i$ 在所有参与者使用的策略为 $s$ 时所能得到的收益。（这一段好长啊）</p>
<p>另外的，我们使用小写字母 $s$ 来表示一个博弈。</p>
<p>好了，现在让我们来使用我们刚刚学会的表示方法来表示我们之前学过的东西。</p>
<p>那么，如果策略 $s_i$ 相对于策略 $s_i’$ 是一个严格优势策略的话，那么我们就可以写下</p>
<p>$$<br>\begin{equation}<br>U_i (s_i , s_{-i}) &gt; U_i (s_i’ , s_{-i})<br>\end{equation}<br>$$</p>
<p>类似的，如果策略 $s_i$ 相对于策略 $s_i’$ 是一个严格劣势策略的话，那么我们就可以写下</p>
<p>$$<br>\begin{equation}<br>U_i (s_i , s_{-i}) &lt; U_i (s_i’ , s_{-i})<br>\end{equation}<br>$$</p>
<h3 id="弱优与弱劣"><a href="#弱优与弱劣" class="headerlink" title="弱优与弱劣"></a>弱优与弱劣</h3><p>如果策略 $s_i$ 相对于策略 $s_i’$ 是一个严格优势策略，那么无论他人选择何种策略，那么我们选 $s_i$ 得到的结果都严格优于选 $s_i’$。</p>
<p>但有时候我们并不能总见到这样的策略。</p>
<p>那我们定义一个策略 $s_i$ 为相对于另一个策略 $s_i’$ 为 <strong>弱优策略(Weakly dominant strategy)</strong> ，此时只需要将大于号填上等于即可。<br>就像下面这样：</p>
<p>$$<br>\begin{equation}<br>U_i (s_i , s_{-i}) \leq U_i (s_i’ , s_{-i})<br>\end{equation}<br>$$</p>
<p>类似的， <strong>弱劣策略(Weakly dominated strategy)</strong> 的定义如下：</p>
<p>$$<br>\begin{equation}<br>U_i (s_i , s_{-i}) \geq U_i (s_i’ , s_{-i})<br>\end{equation}<br>$$</p>
<p>所以说，对于刚才你和李zen做的游戏，我们可以用这些表示来替换之前的说法：</p>
<p>（先放图）</p>
<p><img src="https://i.loli.net/2021/09/22/OSmtUF89Hs5covl.png" alt="博弈2.png"></p>
<p>其中，<br>$S_{you} &#x3D; \lbrace 1,0 \rbrace $<br>$S_{zen} &#x3D; \lbrace 1,0 \rbrace $<br>$U_{you} (1,1) &#x3D; 0 $<br>$U_{zen} (1,1) &#x3D; 0 $<br>$U_{you} (1,0) &#x3D; 2 $<br>$U_{zen} (1,0) &#x3D; -1 $<br>$U_{you} (0,1) &#x3D; -1 $<br>$U_{zen} (0,1) &#x3D; 2 $<br>$U_{you} (0,0) &#x3D; 1 $<br>$U_{zen} (0,0) &#x3D; 1 $<br>$U_{zen} (1,s_{-zen}) &gt; U_{zen} (0,s_{-zen}) $<br>$U_{you} (1,s_{-you}) &gt; U_{you} (0,s_{-you}) $</p>
<p>现在你就可以理解刚才我们讲的符号是什么意思了。</p>
<h3 id="迭代剔除劣势策略"><a href="#迭代剔除劣势策略" class="headerlink" title="迭代剔除劣势策略"></a>迭代剔除劣势策略</h3><p>让我们来做一个新的游戏。</p>
<p>你，李zen，鳖，tue，zhua，还有广大四班人民群众一起做一个游戏。每一个人都需要从范围为 $[1,100]$ 的整数里面选一个数。<br>AJ将会统计大家的结果，并进行总结。<br>总结后取平均数的 $\dfrac{2}{3}$ 作为基准数（向上取整）。基准数减去（你的结果与基准数的差）再除以基准数，得到一个百分数。这个百分数再乘以120就是你本次期末的数学成绩。</p>
<p>同时，AJ指定你和李zen为挑战对象。这意味着你如果比不过他，你就得承包他明年的巧克力供应了。</p>
<p>所以，你会选择哪一个数呢？</p>
<ul>
<li>首先，你知道即使大家都选择100，基准数也是 $67\dfrac{1}{3}$ ，所以说选择67以上的数字是不明智的选择。</li>
</ul>
<p>现在你把目光聚集到了 $[1,67]$ 范围内的整数上。</p>
<ul>
<li>其次，即使大家都选择67，那么基准数也将会是 $44$ ，所以选择44以上的数字也是不太明智的选择。</li>
</ul>
<p> 现在你把目光聚集到了 $[1,44]$ 范围内的整数上。</p>
<ul>
<li>然后，即使大家都选择了44，那么基准数也将会是 $28$ ，所以选择28以上的数字也是不很明智的选择。</li>
</ul>
<p>……</p>
<p>最后，这个基准数字将会迭代到1。<br>不断剔除明显看起来劣势的策略，找出来此时新出现的劣势策略并予以剔除，这就叫 <strong>迭代剔除劣势策略(Iterative deletion of dominated strategies)</strong> 。</p>
<h3 id="公共知识与相互知识"><a href="#公共知识与相互知识" class="headerlink" title="公共知识与相互知识"></a>公共知识与相互知识</h3><p>所以1是个明智的选择吗？</p>
<p>其实不是的。</p>
<p>大家都选择1的前提是，同学们都认为自己会选择1，且他人会选择1，且他人知道自己会选择1，且自己知道他人知道自己会选择1，且他人知道自己知道他人知道自己会选择1……</p>
<p>是不是绕起来了？</p>
<p>有一个相似的东西叫做 <strong>猜疑链</strong> 。</p>
<p>长度为2n+1的猜疑链大概是这样的：</p>
<p>你不知道我不知道你不知道我不知道你不知道……我不知道你不知道我不知道你在想什么。</p>
<p>省略的部分就不写出来了。</p>
<p>刚才我们遇见的东西看起来很像猜疑链，只不过“不知道”换成了“知道”。这就叫做 <strong>公共知识(Common knowledge)</strong> 。</p>
<p>但是在这个情况下，同学们们无法和对方沟通，无法知道别人的结果，所以这个东西是不能成立的。</p>
<p>AJ在统计完结果后让挑战对象互相看了对方的答案，但是你不知道李zen看了你的答案，同时李zen也不知道你看了他的答案。</p>
<p>这时候，公共知识的构建就停止在了某一层。这时候，我们就称其为 <strong>相互知识(Mutual knowledge)</strong> 。</p>
<p>是不是很简单？</p>
<h3 id="中位选民定理"><a href="#中位选民定理" class="headerlink" title="中位选民定理"></a>中位选民定理</h3><p>班长轮换时间到！</p>
<p>现在我们有两位班长候选人：bobo与武嘉。</p>
<p>而班级内将会产生十个不同的小团体，每个团体投一票。他们只会投给自己理想中的班长——也就是与自己交集最多的人。</p>
<p>小团体之间互无交集。<br>bobo和武嘉需要将自己定位到某一个小团体内，以计算选票。</p>
<p>现在我们将这些小团体分别命名为 $α,β,γ,δ,ε,ζ,η,θ,ι,κ$ 。</p>
<p>假如bobo选了η，而武嘉选了γ，那么他们两个人分别得到 $5.5$ 票与 $4.5$ 票。bobo会赢。</p>
<p>现在我们来模拟一下所有可能的结果。</p>
<p><img src="https://i.loli.net/2021/09/24/7rGpuJPQ4eTLN6n.png" alt="博弈5.png"></p>
<p>很明显，策略 $α$ 劣势于策略 $β$ ；去除策略 $α$ 后，策略 $β$ 劣势于策略 $γ$ ；去除策略 $β$ 后，策略 $γ$ 劣势于策略 $δ$ ；去除策略 $γ$ 后，策略 $δ$ 劣势于策略 $ε$ 。</p>
<p>同样的，策略 $κ$ 劣势于策略 $ι$ ；去除策略 $κ$ 后，策略 $ι$ 劣势于策略 $θ$ ；去除策略 $ι$ 后，策略 $θ$ 劣势于策略 $η$ ；去除策略 $θ$ 后，策略 $η$ 劣势于策略 $ζ$ 。</p>
<p>而策略 $ε$ 与策略 $ζ$ 没有优劣关系。</p>
<p>所以说，最后bobo和武嘉在进行玩迭代剔除劣势策略后，只能选择融入 $ε$ 和 $ζ$ 两个小团体之一了。</p>
<p>这就是著名的 <strong>中位选民定理(Median Voter Theorem)</strong> 了。</p>
<h3 id="最佳对策与期望收益"><a href="#最佳对策与期望收益" class="headerlink" title="最佳对策与期望收益"></a>最佳对策与期望收益</h3><p>现在让我们玩一个随机的游戏。<br>题面如下：</p>
<p><img src="https://i.loli.net/2021/09/24/ftmEhcYzuSdZkyI.png" alt="博弈6.png"></p>
<p>现在我们可以看到，没有明显的优势策略或劣势策略。</p>
<p>那我们该怎么办呢？</p>
<p>首先，我们可以看到，当李zen选择←时，选↑是我们的最佳对策；当李zen选择→时，选↓是我们的最佳对策。</p>
<p>但是你并不知道zen会选择什么。</p>
<p>你开始用AJ教你的数学知识来对每一个选项的期望收益进行一个模拟。</p>
<p>假设李zen选择←和→的几率是相等的，那么我们的期望收益如下：</p>
<p>$$<br>\begin{align}<br>U_{top} \  vs \  (\frac{1}{2} , \frac{1}{2} ) &amp; &#x3D; 5 \times \frac{1}{2} + 0 \times \frac{1}{2} &#x3D; 2 \frac{1}{2} \\<br>U_{middle} \  vs \  (\frac{1}{2} , \frac{1}{2} ) &amp; &#x3D; 1 \times \frac{1}{2} + 4 \times \frac{1}{2} &#x3D; 2 \frac{1}{2} \\<br>U_{down} \  vs \  (\frac{1}{2} , \frac{1}{2} ) &amp; &#x3D; 4 \times \frac{1}{2} + 2 \times \frac{1}{2} &#x3D; 3<br> \end{align}<br>$$</p>
<p>此时我们可以看到，选择↓是我们的最佳对策（也是最安全的对策），因为 $2 \dfrac{1}{2} &lt; 3 $ 。</p>
<p>但是如果你知道了李zen选择←或→的概率呢？</p>
<p>上图。</p>
<p><img src="https://i.loli.net/2021/09/24/mroUEi69tjgV1Cu.png" alt="博弈7.png"></p>
<p>图中的横轴代表李zen选←的概率，同时选→的概率是（1-选←的概率）。纵轴代表不同选择的期望收益。</p>
<p>所以，我们可以看到，在李zen选择某一策略的概率不同时，我们的最佳对策是不一样的。</p>
<p>在这里，我们可以这样定义 <strong>最佳对策(Best Responce)</strong> :<br>当</p>
<p>$$<br>U_i ( \hat{s_i} ,s_{-i} ) \geq U_i ( s_i’ ,s_{-i} ) \quad (s_i’ \in S_i )<br>$$</p>
<p>或</p>
<p>$$<br>U_i ( \hat{s_i} ,s_{-i} ) &#x3D; max( U_i ( S_i , s_{-i}))<br>$$</p>
<p>或</p>
<p>$$<br>EU_i ( \hat{s_i} ,p ) \geq max( EU_i ( s_i’ , p)) \quad (s_i’ \in S_i )<br>$$</p>
<p>时，我们称 $ \hat{s_i} $ 是策略 $s_{-i} $ 的最佳对策。</p>
<p>其中， $EU_i ( s_i , p ) $ 指的是策略 $s_i$ 在参与人 $i$ 持信念 $p$ 时的期望收益。</p>
<p>同时，我们需要注意一下，对于不同的策略集合 $s_{-i}$ ，其最佳对策的数量可能是不同的，且可能不为一（就是最佳对策不会只有一个）。</p>
<h2 id="纳什均衡"><a href="#纳什均衡" class="headerlink" title="纳什均衡"></a>纳什均衡</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>假设你需要和李zen一起完成一个项目。你将会付出 $s_y$ 个小时的时间，而zen将会付出 $s_z$ 个小时，其中 $s_y , s_z \in [0,10] $ 。</p>
<p>你们的收益为：</p>
<p>$$<br>\begin{align}<br>U_y &amp; &#x3D; 2 ( s_y + s_z + b s_y s_z ) - s_y^2 \\<br>U_z &amp; &#x3D; 2 ( s_y + s_z + b s_y s_z ) - s_z^2<br>\end{align}<br>$$</p>
<p>此时让我们来算一下我们怎么最大化我们的收益。</p>
<p>首先求一下导，把 $s_z$ 当做常数：</p>
<p>$$<br>\begin{align}<br>U_y’ &amp; &#x3D; 2 ( 1 + b s_z ) - 2 s_y \\<br>U_y’’ &amp; &#x3D; -2 &lt; 0<br>\end{align}<br>$$</p>
<p>此时令 $U_y’ &#x3D; 0 $ ，可以求出最佳对策：</p>
<p>$$<br>\begin{align}<br>2 ( 1 + b s_z ) - 2 s_y &amp; &#x3D; 0 \\<br>1 + b s_z &amp; &#x3D; s_y \\<br>s_y &amp; &#x3D; \frac{1}{1-b}<br>\end{align}<br>$$</p>
<p>此时画一下图：</p>
<p><img src="https://i.loli.net/2021/09/25/mwYX56SC4WaQtcT.png" alt="博弈8.png"></p>
<p>此时我们可以看到，两个人的最佳对策函数交于了一点。</p>
<p>在实际情况中，因为你们两个都想偷懒，所以你们会不断剔除掉双方付出过多的策略，最终直到选择那个交点。</p>
<p>这个就叫做 <strong>纳什均衡(Nash Equilibrium)</strong> 。</p>
<p>其定义是：</p>
<p>对于一个已选对策的集合$ \lbrace s_1^* , s_2^* , s_3^* , \dots , s_m^* \rbrace $ ，其纳什均衡是满足下列条件的策略集合：</p>
<p>对于 $ \forall $ 参与人 $i$ 来说，其策略 $ s_i^* $ 是 $ s_{-i}^* $ 的最佳对策。</p>
<p>要实现纳什均衡，我们需要几个动机。</p>
<h4 id="动机-1"><a href="#动机-1" class="headerlink" title="动机 1"></a>动机 1</h4><p><strong>人们永不反悔。</strong></p>
<p>或者说，在所有人都已经选定好每个人的策略了之后，改变自己的策略并不会有额外收益。</p>
<h4 id="动机-2"><a href="#动机-2" class="headerlink" title="动机 2"></a>动机 2</h4><p><strong>纳什均衡可以被看做一种自我实施的信念。</strong></p>
<h4 id="动机-3"><a href="#动机-3" class="headerlink" title="动机 3"></a>动机 3</h4><p>tbc</p>
<h3 id="找出博弈中的纳什均衡"><a href="#找出博弈中的纳什均衡" class="headerlink" title="找出博弈中的纳什均衡"></a>找出博弈中的纳什均衡</h3><p>假设我们现在与李zen玩一个新的游戏，题面如下：</p>
<p><img src="https://i.loli.net/2021/09/26/Qlx73OLrFZEYH9K.png" alt="博弈9.png"></p>
<p>现在，我们用绿色的圆圈和红色的方框来分别表示你和李zen的最佳对策：</p>
<p><img src="https://i.loli.net/2021/09/26/wo6Lc3VPdbTRvsX.png" alt="博弈10.png"></p>
<p>那么，这个博弈里的纳什均衡是什么呢？</p>
<p>我们可以看到，当你选择↓时，zen的最佳对策是选择→； 当李zen选择→时，你的最佳对策是选择↓。</p>
<p>一旦你们两个人中的其中一个选定了之后，另一个人就不会轻易跳出这个循环。</p>
<p>所以说， $(↓,→)$ 就是这场博弈里的纳什均衡。</p>
<p>当然，一场博弈的纳什均衡也可能不只有一个。<br>比如下图：</p>
<p><img src="https://i.loli.net/2021/09/26/NLsOb3oUgT26yM7.png" alt="博弈11.png"></p>
<p>很简单是不是？</p>
<p>这时你们会发现，在这场博弈中，虽然看起来 $(←,↑)$ 明显是纳什均衡 <del>（其实也真的是）</del> ，但是如果你仔细看的话，右下角的那个零零也符合纳什均衡的定义，虽然两个人什么都得不到且傻子也会知道选择有收益的那个策略而不是一点收益都没有的，但是一旦两个人知道对方会选择这个零零，那就不会轻易更改自己的策略，不要忘了<a href="/game_strategy/#%E5%8A%A8%E6%9C%BA-1">动机1</a>、<a href="/game_strategy/#%E5%8A%A8%E6%9C%BA-2">动机2</a>和<a href="/game_strategy/#%E7%BB%93%E8%AE%BA-5">结论5</a>。</p>
<p>这就类似全局最优解和局部最优解。</p>
<h3 id="帕累托优势"><a href="#帕累托优势" class="headerlink" title="帕累托优势"></a>帕累托优势</h3><p>在刚才上面那个博弈中，我们可以清楚的看到，左上的那个纳什均衡的收益是严格大于右下的那个的。</p>
<p>如果我们重复这次博弈。那么最终选择左上的几率会是百分之百。</p>
<p>这就叫做 <strong>帕累托优势(Pareto Dominate)</strong> 。</p>
<hr>
<p>咕了。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>傅里叶变换</title>
    <url>/maths/fourier-transform/</url>
    <content><![CDATA[<p>简介： 傅里叶变换和FFT、复数、单位根<br>（20220321重修）</p>
<span id="more"></span>

<div id="problem-card-vis">false</div>

<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>今天AJ给大家留了一个作业：</p>
<p>多项式相乘。</p>
<p>$$<br>\begin{gather}<br>f(x) &#x3D; (x^2 + 3x - 1) \\<br>g(x) &#x3D; (2x^2 + x - 5) \\<br>f(x) \times g(x) &#x3D; ?<br>\end{gather}<br>$$</p>
<p>大家都很认真、很用心地做了出来。</p>
<p>$$<br>\begin{align}<br>f(x) \times g(x) &amp; &#x3D; (x^2 + 3x - 1) (2x^2 + x - 5) \\<br>&amp; &#x3D; x^2 \times g(x) + 3x \times g(x) - g(x) \\<br>&amp; &#x3D; (2x^4 + x^3 - 5x^2) + (6x^3 + 3x^2 - 15x) + (2x^2 + x - 5) \\<br>&amp; &#x3D; 2x^4 + x^3 - 5x^2 + 6x^3 + 3x^2 - 15x + 2x^2 + x - 5 \\<br>&amp; &#x3D; 2x^4 + 7x^3 - 4x^2 - 16x + 5<br>\end{align}<br>$$</p>
<p>看起来很复杂，对吗？</p>
<p>但是，精通数学的王哥在纸上写写画画几十秒钟之后，得出来的答案跟正确答案也是一样的。<br>惊呆了的tüe问王哥他用的是什么办法。<br>王哥回答：“ <strong>傅里叶变换</strong> 。”</p>
<h1 id="多项式乘法的本质"><a href="#多项式乘法的本质" class="headerlink" title="多项式乘法的本质"></a>多项式乘法的本质</h1><p>王哥说：“我们知道，所有多项式都拥有如下的形式：</p>
<p>$$<br>f(x) &#x3D; a_0 x^n + a_1 x^{n-1} + a_2 x^{n-2} + \cdots + a_{n-2} x^2 + a_{n-1} x +a_n<br>$$</p>
<p>我们也可以把一个多项式写成这样的形式：</p>
<p>$$<br>f(x) &#x3D; \sum_{i&#x3D;0}^n a_i x^{n-i}<br>$$</p>
<p>而两个多项式相乘 $f(x) \times g(x) &#x3D; h(x)$ 的时候，相乘的结果的第 $k$ 项系数 $h_{k-1}$ 等于所有 $f_{i}$ 与 $g_{k-i}$ 乘积之和。<br>所以，</p>
<p>$$<br>h_k &#x3D; \sum_{i&#x3D;0}^{k-1} f_i \times g_{k-1-i}<br>$$</p>
<p>这样的方法算出的结果是与两个多项式的次数相关的。”</p>
<p>或者（对于OIer）通俗一点来说，假设两个多项式的次数分别为 $n$ 和 $m$，那么这个算法的时间复杂度是 $O(nm)$ 的。</p>
<p>给个<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM4MDM=">模板题</span>的44分代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> X = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">char</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((ch &lt; <span class="number">48</span>) || (ch &gt; <span class="number">57</span>))ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>((ch &gt;= <span class="number">48</span>) &amp;&amp; (ch &lt;= <span class="number">57</span>))X = X * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">ll f[N], g[N], s[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(ll *s, ll *f, ll *g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n + m - <span class="number">1</span>; k++)</span><br><span class="line">        <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; i++)</span><br><span class="line">            s[k] += f[i] * g[k - i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m); n++; m++;</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)f[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)g[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">mul</span>(s, f, g);</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n + m - <span class="number">1</span>; i++)<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, s[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\color[rgb]{1,1,0.0625}{φ}$ （只保证44分）</p>
<h1 id="DFT"><a href="#DFT" class="headerlink" title="DFT"></a>DFT</h1><h2 id="多项式的点值表达"><a href="#多项式的点值表达" class="headerlink" title="多项式的点值表达"></a>多项式的点值表达</h2><p>为了简便表达，我们使用 $f_k$ 来代表 多项式 $f(x)$ 的第 $k+1$ 项系数。</p>
<p>今天AJ的作业是昨天的延伸：<br>给定一个 $n$ 次多项式的 $n+1$ 个点值，要求我们求出这个多项式。<br>（还让武嘉给了样例，而武嘉给的样例是1,3,5,7,9,114514）<br>全班只有王哥和某盒子做了出来。广告：<span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vNDcwOTUyMzc5">CoolHezi</span><br>他们用的是什么方法呢？</p>
<p><strong>拉格朗日插值</strong>。</p>
<p>想要了解拉格朗日插值，可以参考我的这个博客：<a href="/maths/lagrange-interpolation">拉格朗日插值</a></p>
<p>现在我们只需要知道，给定了 $n+1$ 个任意点值，可以求出来经过这几个点的一个 $n$ 次多项式。<br>如果两个多项式 $f(x)$ 和 $g(x)$ 在相同纵坐标上取点（设其分别为 $f(x)$  与 $g(x)$） 后相乘所得的结果（$f(x) \times g(x)$）等于两函数相乘后对应纵坐标处的点值（$h(x)$）。</p>
<p>举个栗子：</p>
<p>$$<br>\begin{align}<br>f(x) &amp;&#x3D; x^2 + 3x - 1 \\<br>g(x) &amp;&#x3D; 2x^2 + x -5<br>\end{align}<br>$$</p>
<p>我们分别取 $x \in [-1,1]$ 内的整数点所对应的点值：</p>
<img src="https://i.loli.net/2021/10/17/idm29GlQr7asBTc.png" alt="傅里叶1.png" width="60%" />

<p>我们可以清楚的看到：</p>
<p>$$<br>\begin{align}<br>f(-1) &amp; &#x3D; -3 &amp; f(0) &amp; &#x3D; -1 &amp; f(1) &amp; &#x3D; 3 \\<br>g(-1) &amp; &#x3D; -4 &amp; g(0) &amp; &#x3D; -5 &amp; g(1) &amp; &#x3D; -2<br>\end{align}<br>$$</p>
<p>相乘之后可得：</p>
<p>$$<br>\begin{align}<br>h(-1) &amp; &#x3D; 12 &amp; h(0) &amp; &#x3D; 5 &amp; h(1) &amp; &#x3D; -6<br>\end{align}<br>$$</p>
<p>检验一下：</p>
<img src="https://i.loli.net/2021/10/17/AvSKMrem6QlEtIU.png" alt="傅里叶2.png" width="60%" />

<p>但想要求出 $h(x)$ ，我们至少需要4+1&#x3D;5个点值。</p>
<p>怎么办？</p>
<p>多找几个啊。</p>
<p>于是我们就可以求出最终的多项式。</p>
<p>这就是FT的算法流程。<br>“把<strong>系数</strong>表达转换为<strong>点值</strong>表达”的算法叫做<strong>DFT</strong><br>“把<strong>点值</strong>表达转换为<strong>系数</strong>表达”的算法叫做<strong>IDFT</strong>(DFT的逆运算)</p>
<p>P.S:</p>
<ul>
<li>从一个多项式的系数表达确定其点值表达的过程称为<strong>求值</strong>(毕竟求点值表达的过程就是取了 n 个 x 然后扔进了多项式求了 n 个值出来)；</li>
<li>而求值运算的逆运算(也就是从一个多项式的点值表达确定其系数表达)被称为<strong>插值</strong>。</li>
</ul>
<p>F(Fourier)和T(Transform)有了，那F(Fast)呢？</p>
<h1 id="单位根与复数"><a href="#单位根与复数" class="headerlink" title="单位根与复数"></a>单位根与复数</h1><p>但是最终我们并没有觉得有什么可以加以利用的良好性质啊。<br>我们这些蒟蒻只会利用一些有理数和一些简单的无理数来进行一些简单的计算，再难一点的就不会了。</p>
<p><del>（而且这个多项式的次数和系数稍微一大就bz了）</del><br>准确来说，我们最终还是需要 $n+m$ 个点的求值与相乘，最终得到的时间复杂度与 $O(mn)$ 实际上差不太多，而且很可能在某些情况下更劣一些。</p>
<p>但是，法国数学家 <strong>傅里叶</strong> 横空出世，找了一些毒瘤数据代入，结果发现可以分治而使时间复杂度降低。<br>而他代入的正是单位根 $ω_{n+1}^{0 \to n}$ 。</p>
<h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>首先我们需要介绍复数。</p>
<p>已经会了的可以<a href="/maths/fourier-transform/#%E5%8D%95%E4%BD%8D%E6%A0%B9">跳过</a>。</p>
<p>（p.s.:下面我们使用的所有 $\sqrt{\quad}$ 标识都指的是平方根，算术平方根已使用+-来标记。）</p>
<h3 id="复数的概念"><a href="#复数的概念" class="headerlink" title="复数的概念"></a>复数的概念</h3><h4 id="虚数"><a href="#虚数" class="headerlink" title="虚数"></a>虚数</h4><p>我们所学的数轴是一条直线。</p>
<p><img src="https://i.loli.net/2021/10/18/ImBF56rhAYUQ2cL.png" alt="傅里叶3.png"></p>
<p>每一个有理数都能完美地与数轴上的某一个点一一对应。</p>
<p><img src="https://i.loli.net/2021/10/18/GBM34h7yDVjgzSm.png" alt="傅里叶4.png"></p>
<p>$+\sqrt2$ 、 $+\sqrt3$ 等无理数也能很好地对应在数轴上。</p>
<p><img src="https://i.loli.net/2021/10/18/pAs2ObDQ3Mf7Bv1.png" alt="傅里叶5.png"></p>
<p>但是人们说：“那 $+\sqrt{-1}$ 怎么办啊？”</p>
<p>我们找不到与 $+\sqrt{-1}$ 相对应的点。<br>而 $+\sqrt{-1}$ 又的的确确存在。</p>
<p>怎么办？</p>
<p>于是人们发明了一个概念：虚数。<br>而 $+\sqrt{-1}$ 在虚数里面叫做<strong>虚数单位</strong>，用 $i$ 表示。<br>所以，$i^2&#x3D;-1$ 。</p>
<p>但是又有人会问：“那 $-\sqrt{-1}$ 又怎么办？”</p>
<p>用 $-i$ 呗。</p>
<p>但是在数轴上，人们仍然找不到对应虚数的点。数轴上的每一个点都对应了一个实数，没有办法找到任何一个新的点来对应虚数了。<br>所以，人们就在数轴的 0 处添加了一条新的数轴，来代表虚数。这条新的数轴垂直于代表实数的数轴，单位是 $i$ 。</p>
<h3 id="复数及其运算"><a href="#复数及其运算" class="headerlink" title="复数及其运算"></a>复数及其运算</h3><p>复数形似 $a+bi$ 。<br>其中 $a$ 称为实部( $\Re$ )， $b$ 称为虚部( $\Im $ )。<br>复数也有加减乘除等运算。<br>复数加减时实部虚部分别加减：</p>
<p>$$<br>(a+bi) \pm (c+di) &#x3D; (a \pm c) + (b \pm d)i<br>$$</p>
<p>复数相乘时实部虚部分别相乘：</p>
<p>$$<br>\begin{align}<br>(a+bi) \times (c+di) &amp; &#x3D; a \times (c+di) + bi \times (c+di) \\<br>&amp; &#x3D; ac + adi + bci - bd \\<br>&amp; &#x3D; (ac - bd) + (ad + bc)i<br>\end{align}<br>$$</p>
<p>复数相除时就有点难办了。<br>直觉告诉我们 $\dfrac{a+bi}{c+di}$ 不会好化简。</p>
<p>这里需要引入一个概念：复数的共轭。<br>$a+bi$ 的共轭是 $a-bi$ 。<br>一个复数乘以其共轭最终得到的是一个实数。（ $(a+bi) \times (a-bi) &#x3D; a^2 + b^2$ ）</p>
<p>所以当我们化简 $\dfrac{a+bi}{c+di}$ 的时候，我们只需要上下同乘分母的共轭就可以了：<br>$$<br>\begin{align}<br>\frac{a+bi}{c+di} &amp; &#x3D; \frac{(a+bi)(c-di)}{(c+di)(c-di)} \\<br>&amp; &#x3D; \frac{(ac+bd) + (bc-ad)i}{c^2+d^2} \\<br>&amp; &#x3D; \frac{ac+bd}{c^2+d^2} + \frac{bc-ad}{c^2+d^2} i<br>\end{align}<br>$$</p>
<h3 id="复数在数轴上的表示"><a href="#复数在数轴上的表示" class="headerlink" title="复数在数轴上的表示"></a>复数在数轴上的表示</h3><p>那我们怎么在数轴上表示复数呢？</p>
<p>之前我们说过了，虚数单位 $i$ 找不到一个合适的与其对应的数轴上的点。</p>
<p>那我们到底怎么办呢？</p>
<p>于是有人加了一条垂直于原本数轴的轴，用来表示复数的虚部。</p>
<p>就像这样：</p>
<img src="https://i.loli.net/2021/10/18/L9kKUvWyAhiconp.png" alt="傅里叶6.png" width="60%" />

<p>于是我们举几个例子：</p>
<p><img src="https://i.loli.net/2021/10/19/cgUE58lZkOQJ17G.png" alt="傅里叶7.png"></p>
<p>此时我们关注一下两个虚数的积：</p>
<img src="https://i.loli.net/2021/10/19/RlLhAeVbzxXkHQf.png" alt="傅里叶8.png" width="60%" />

<p>如果我们连接表示复数的点和原点，我们可以看见这三条线的长度分别是 $\sqrt{3^2+4^2}&#x3D;\sqrt{25}&#x3D;5$ ，$\sqrt{5^2+2^2}&#x3D;\sqrt{29}$ 与 $\sqrt{14^2+23^2}&#x3D;\sqrt{725} &#x3D;5\sqrt{29}$ 。<br>凭借大家做几何题的直觉，我们可以看到， $5+2i$ 与 $x$ 轴的夹角与 $3+4i$ 与 $x$ 轴的夹角之和等于 $14+23i$ 与 $x$ 轴的夹角。<br>而且，通过刚才的例子，我们也可以看见 $5+2i$ 与原点的连线的长度与 $3+4i$ 与原点的连线的长度之积等于 $14+23i$ 与原点连线的长度。<br>数学家们为了简便地表示这些东西，发明了两个名词：<strong>幅角</strong>和<strong>模长</strong>。<br>所以，我们可以说，<strong>两个复数相乘时，幅角相加，模长相乘。</strong></p>
<p>证明：</p>
<p>我们设三个点分别为 $A$  ，$B$ 与 $C$ 。</p>
<img src="https://i.loli.net/2021/10/19/bVRTm4gy9dDhWnE.png" alt="傅里叶9.png" width="40%" />

<p>我们分别连接 $AO$ ， $BO$ 与 $CO$ 。</p>
<img src="https://i.loli.net/2021/10/19/TpDc6xyqOth5r8l.png" alt="傅里叶10.png" width="40%" />

<p>因为 $C$ 点代表的是 $(ac-bd)+(ad+bc)i$ ，所以 $AO$ ， $BO$ 与 $CO$ 的长度分别是：</p>
<p>$$<br>\begin{align}<br>AO &amp;&#x3D; \sqrt{a^2 + b^2} \\<br>BO &amp;&#x3D; \sqrt{c^2 + d^2} \\<br>CO &amp;&#x3D; \sqrt{(ac - bd)^2 + (ad+bc)^2}<br>\end{align}<br>$$</p>
<p>我们化简一下 $CO$ 的表达式，可得：</p>
<p>$$<br>\begin{align}<br>CO &amp; &#x3D; \sqrt{(ac-bd)^2+(ad+bc)^2} \\<br>&amp; &#x3D; \sqrt{a^2 c^2 - 2abcd + b^2 d^2 + a^2 d^2 + 2abcd + b^2 c^2} \\<br>&amp; &#x3D; \sqrt{a^2 (c^2 + d^2) + b^2 (c^2 + d^2)} \\<br>&amp; &#x3D; \sqrt{(a^2 + b^2) (c^2 + d^2)} \\<br>&amp; &#x3D; \sqrt{a^2 + b^2} \times \sqrt{c^2 + d^2} \\<br>&amp; &#x3D; AO \times BO<br>\end{align}<br>$$</p>
<p>我们可以得出， $CO&#x3D;AO \times BO$ 这一结论。</p>
<p>我们再连接 $BC$ 与 $AD$ ，$D$ 点代表 $1+0i$ 。</p>
<img src="https://i.loli.net/2021/10/19/81gGbRmnowh5IpK.png" alt="傅里叶11.png" width="40%" />

<p>凭借你做几何题的直觉，你应该知道 $\triangle AOD$ 与 $\triangle COB$ 看上去是相似的。</p>
<p>没错，他们就是相似的。</p>
<p>证明：</p>
<p>我们先算出来 $AD$ 和 $BC$ 的模长：</p>
<p>$$<br>\begin{align}<br>AD &amp; &#x3D; \sqrt{(a-1)^2 + b^2} \\<br>BC &amp; &#x3D; \sqrt{(ac-bd-c)^2 + (ad+bc-d)^2} \\<br>&amp; &#x3D; \sqrt{[(a-1)c-bd]^2 +[(a-1)d + bc]^2} \\<br>&amp; &#x3D; \sqrt{(a-1)^2 c^2 - 2(a-1)bcd + b^2 d^2 + (a-1)^2 d^2 + 2(a-1)bcd + b^2 c^2} \\<br>&amp; &#x3D; \sqrt{(a-1)^2 (c^2 + d^2) + b^2 (c^2 + d^2)} \\<br>&amp; &#x3D; \sqrt{[(a-1)^2 + b^2] (c^2 + d^2)} \\<br>&amp; &#x3D; \sqrt{(a-1)^2 + b^2} \times \sqrt{c^2 + d^2} \\<br>&amp; &#x3D; AD \times BO<br>\end{align}<br>$$</p>
<p>接下来我们证明两三角形相似：</p>
<p>$$<br>\begin{gather}<br>\because<br>CO &#x3D; AO \times BO , DO &#x3D; 1 \\<br>\therefore \frac{CO}{AO} &#x3D; \frac{BO}{DO} \\<br>\because BC &#x3D; AD \times BO\\<br>\therefore \frac{BC}{AD} &#x3D; BO \\<br>\therefore \frac{CO}{AO} &#x3D; \frac{BO}{DO} &#x3D; \frac{BC}{AD} \\<br>\therefore \triangle COB \sim \triangle AOD \\<br>\therefore \angle DOA &#x3D; \angle BOC \\<br>\because \angle DOC &#x3D; \angle DOB + \angle BOC \\<br>\therefore \angle DOC &#x3D; \angle DOB + \angle DOA<br>\end{gather}<br>$$</p>
<p>证毕。</p>
<h2 id="单位根"><a href="#单位根" class="headerlink" title="单位根"></a>单位根</h2><p>现在我们来介绍单位根。</p>
<p>单位根的意义是 $n$ 次方为 1 的复数，也就是 $x^n&#x3D;1$ 的复数解。</p>
<p>如果你学过三角函数的话你应该十分清楚什么是单位圆。<br>而单位圆可以帮我们更好地理解什么是单位根和单位根为什么能够代入之后能实现分治。</p>
<p>我们先画出一个单位圆：</p>
<img src="https://i.loli.net/2021/10/20/Eg1hOysmtHIK7YZ.png" alt="傅里叶12.png" width="60%" />

<p>我们知道， $1^n&#x3D;1$ ，所以单位根的其中一个一定是 $1$ 。</p>
<p>我们连接 $1$ 和 $0$ 。</p>
<img src="https://i.loli.net/2021/10/20/ewkq5Hsl2Xh8iDn.png" alt="傅里叶13.png" width="60%" />

<p>我们在这里举一个 $n&#x3D;4$ 的栗子来帮助我们理解单位根。</p>
<p>首先，我们知道， $(\pm i)^2 &#x3D; -1$ ，而 $-1^2&#x3D;1$ ，<br>所以 $i$ 和 $-i$ 也是 $n&#x3D;4$ 时的两个单位根。<br>当然，因为 $(-1)^2&#x3D;1$ ，所以我们不能丢下-1。</p>
<img src="https://i.loli.net/2021/10/20/ZgXGK4ioqftFAHa.png" alt="傅里叶14.png" width="60%" />

<p>至此，我们就找齐了 $n&#x3D;4$ 时的所有单位根。<br>我们记单位根分别为 $ω^0_4 , ω^1_4 , ω^2_4 , ω^3_4$ 。</p>
<p>但哪个对应哪个呢？</p>
<img src="https://i.loli.net/2021/10/20/pRgxdBbhqrAvweP.png" alt="傅里叶15.png" width="60%" />

<p>当我们观察图像的时候，我们可以发现这四个点与原点的连线可以平分这一个单位圆。<br>每相邻两条线之间的夹角都是 $90^{\circ}$ 。</p>
<p>当我们推广到 $n&#x3D;8$ 的时候。我们可以另外得到 $\frac{1}{\sqrt2}+\frac{1}{\sqrt2}i , \frac{1}{\sqrt2}-\frac{1}{\sqrt2}i , -\frac{1}{\sqrt2}+\frac{1}{\sqrt2}i , -\frac{1}{\sqrt2}-\frac{1}{\sqrt2}i$ 四个单位根。</p>
<p>我们把他们表示在复平面上之后会是这样一个情况：</p>
<img src="https://i.loli.net/2021/10/20/jXxYvVbk6ITR5Fc.png" alt="傅里叶16.png" width="60%" />

<p>我们会发现，新增的这四个单位根所对应的点也在圆上，且所有的这几个点与圆心\原点的连线平分这个单位圆为8份。</p>
<p>所以我们可以这样理解，所有的 $ω_n^{0 \to n-1}$ 与原点的连线可以平分单位圆为 $n$ 份，且每相邻两条线之间的夹角都是 $\frac{2π}{n}$ （即 $\frac{360}{n}^{\circ}$ ）</p>
<p>这样就好编号了：从 $1$ 开始，逆时针编号。</p>
<p>举个栗子：</p>
<p>$ω_8^{0 \to 7}$ 的值分别为 $1 , \frac{1}{\sqrt2} + \frac{1}{\sqrt2}i , i , -\frac{1}{\sqrt2} + \frac{1}{\sqrt2}i , -1 , -\frac{1}{\sqrt2} - \frac{1}{\sqrt2}i , -i , \frac{1}{\sqrt2} - \frac{1}{\sqrt2}$ 。</p>
<p>p.s.:虽然我们只承认 $ω_n^k$ 中的 $0\leq k &lt; n$ 的情况，但是 $k\geq n$ 和 $k&lt;0$ 的情况还是有的，这就跟 $\geq 2π$ （即 $360^{\circ}$ ）和 $&lt;0$ （即 $0^{\circ}$ ）的角一样。</p>
<h3 id="单位根的性质"><a href="#单位根的性质" class="headerlink" title="单位根的性质"></a>单位根的性质</h3><p>单位根有很多性质，这里会列举几个。其中，最后一个是最重要的，也是我们选择代入单位根的原因。</p>
<ol>
<li>$ω^a_n + ω^b_n &#x3D; ω_n^{a+b}$</li>
</ol>
<p>  可以从把单位根类比成切蛋糕的方法去理解。</p>
<ol start="2">
<li>$(ω^1_n)^k &#x3D; ω^k_n$</li>
</ol>
<p>  可以理解成把 $k$ 块蛋糕拼起来。</p>
<ol start="3">
<li>$ω_{λn}^{λk} &#x3D; ω_n^k$</li>
</ol>
<p>  同可以理解成把一块蛋糕平均切成 $\lambda$ 块。</p>
<ol start="4">
<li>$ω^k_{2n} &#x3D; - ω_{2n}^{(k+n)\bmod{n}}$</li>
</ol>
<p>  这是最重要的一条。<br>  这条的证明可以在复平面上清晰的看出。</p>
<img src="https://i.loli.net/2021/10/20/Huv9WglE7MbLTAj.png" alt="傅里叶17.png" width="60%" />

<p>这一条性质是我们选择代入单位根的原因。但为什么呢？</p>
<h1 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h1><h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p>傅里叶把多项式 $f(x)$ 按照次数分成奇偶两部分。（忘了的向前翻再看一遍）</p>
<p>即，<br>$$<br>\begin{align}<br>f(x) &amp;&#x3D; \sum^n_{i&#x3D;0} a_i x^{n-i} \\<br>&amp;&#x3D; \sum_{i&#x3D;0}^{\frac{n}{2}} a_i x^{n-2i} + \sum_{i&#x3D;0}^{\frac{n}{2}} a_{i+1} x^{n-2i-1}<br>\end{align}<br>$$<br>我们称 $\displaystyle \sum_{i&#x3D;0}^{\frac{n}{2}} a_{i+1} x^{n-2i-1}$ 为 $f_o(x)$ ， 称 $\displaystyle \sum_{i&#x3D;0}^{\frac{n}{2}} a_i x^{n-2i}$ 为 $f_e(x)$ 。</p>
<p>此时我们把式子化简一下，可得<br>$$<br>f(x) &#x3D; f_e(x^2) + x f_o(x^2)<br>$$</p>
<p>所以，我们想要计算 $f(x)$ 的话，只需要计算 $f_e(x)$ 与 $f_o(x)$ 即可。<br>当然，我们计算 $f_e(x)$ 与 $f_o(x)$ 的时候，也像刚才我们分解 $f(x)$ 一样，把它们分解掉。<br>最终我们可以达到分治的效果。</p>
<p>而我们不可能对于所有的点都进行实际的代入求值运算，那样会爆精度。</p>
<h2 id="代入求值"><a href="#代入求值" class="headerlink" title="代入求值"></a>代入求值</h2><p>我们刚刚介绍了单位根的性质，所以我们可以代入单位根来简化运算。</p>
<p>怎么简化？</p>
<p>我们尝试过代入几个整数来求值，但是那样子复杂度会爆掉。</p>
<p>然后我们就想到了代入相反数。<br>这样的话，我们只需要求出一半的值，就可以得到另外的所有值了。</p>
<p>我们还可以再快，即进行分治。</p>
<p>但是，分治要求我们每一次分治代入的值都为相反数，这要求了一对相反数的平方仍为相反数。<br>于是我们就找到了单位根。</p>
<p>我们代入 $ω^k_n$ （$0 \leq k &lt; \dfrac{n}{2}$），可得：<br>$$<br>\begin{align}<br>f(ω^k_n) &amp;&#x3D; f_e((ω^k_n)^2) + ω^k_n f_o((ω^k_n)^2) \\<br>&amp;&#x3D; f_e (ω^k_{\frac{n}{2}}) + ω^k_n f_o(ω^k_{\frac{n}{2}})<br>\end{align}<br>$$</p>
<p>此时我们对这个式子进行稍稍的变动，可得：<br>$$<br>\begin{align}<br>f(ω^k_n) &amp;&#x3D; f_e((ω^k_n)^2) + ω^k_n f_o((ω^k_n)^2) \\<br>f(ω_n^{k+\frac{n}{2}}) &amp;&#x3D; f_e((ω_n^{k+\frac{n}{2}})^2) + ω_n^{k+\frac{n}{2}} f_o((ω_n^{k+\frac{n}{2}})^2) \\<br>&amp;&#x3D; f_e (ω_n^{2k+n}) + ω_n^{k+\frac{n}{2}} f_o(ω_n^{2k+n}) \\<br>&amp;&#x3D; f_e (ω_n^{2k}) + ω_n^{k+\frac{n}{2}} f_o(ω_n^{2k}) \\<br>&amp;&#x3D; f_e (ω_{\frac{n}{2}}^k) + ω_n^{k+\frac{n}{2}} f_o(ω_{\frac{n}{2}}^k) \\<br>&amp;&#x3D; f_e (ω_{\frac{n}{2}}^k) - ω^k_n f_o(ω_{\frac{n}{2}}^k)<br>\end{align}<br>$$</p>
<p>通过 $\begin{cases} f(ω_n^k)&#x3D;f_e(ω_{\frac{n}{2}}^k)+ω^k_nf_o(ω_{\frac{n}{2}}^k) \\ f(ω_n^{k+\frac{n}{2}})&#x3D;f_e (ω_{\frac{n}{2}}^k) - ω_n^k f_o(ω_{\frac{n}{2}}^k)\end{cases}$ 这两个式子，我们理论上是可以求出所有点值的。因为 $f_e(x)$ 与 $f_o(x)$ 理论上只有 $f(x)$ 次数的一半，只能得到完整地求出 $f(x)$ 所需要的点值的一半。而两个式子分别能求出一半且互不重复，合起来就是我们所需要的所有点值了。</p>
<p>但是当我们遇到某一层的 $f(x)$ 是奇数次的时候，我们应该怎么办呢？</p>
<p>答案是：自己补。</p>
<p>我们可以手动为这个多项式补成2的整数次幂次。当然，是在不影响多项式整体的值得前提下，所以我们选择补0，即我们补上去的所有的 $a_k$ 都是0。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="DFT-1"><a href="#DFT-1" class="headerlink" title="DFT"></a>DFT</h2><h3 id="复数结构体"><a href="#复数结构体" class="headerlink" title="复数结构体"></a>复数结构体</h3><p>为了表示方便，我们使用结构体来表示复数。</p>
<p>我们同时重载一下运算符，以便做复数之间的四则运算。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> str;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Comp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Comp</span>(<span class="type">double</span> xx = <span class="number">0</span>, <span class="type">double</span> yy = <span class="number">0</span>) &#123; x = xx, y = yy; &#125;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    Comp <span class="keyword">operator</span> + (Comp <span class="type">const</span> &amp;B) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Comp</span>(x + B.x, y + B.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Comp <span class="keyword">operator</span> - (Comp <span class="type">const</span> &amp;B) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Comp</span>(x - B.x, y - B.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Comp <span class="keyword">operator</span> * (Comp <span class="type">const</span> &amp;B) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Comp</span>(x * B.x - y * B.y, x * B.y + y * B.x);</span><br><span class="line">    &#125;</span><br><span class="line">    Comp <span class="keyword">operator</span> / (Comp <span class="type">const</span> &amp;B) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> t = B.x * B.x + B.y * B.y;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Comp</span>((x * B.x + y * B.y) / t, (y * B.x - x * B.y) / t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a, b;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(Comp n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(n.x &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; n.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n.x &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        cout &lt;&lt; n.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n.y &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n.x != <span class="number">0</span>)<span class="built_in">putchar</span>(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">        cout &lt;&lt; n.y;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n.x == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; n.y;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)<span class="built_in">putchar</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; a.x &gt;&gt; a.y &gt;&gt; b.x &gt;&gt; b.y;</span><br><span class="line">    Comp c;</span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="built_in">write</span>(a), <span class="built_in">putchar</span>(<span class="string">&#x27;+&#x27;</span>), <span class="built_in">write</span>(b), <span class="built_in">putchar</span>(<span class="string">&#x27;=&#x27;</span>), <span class="built_in">write</span>(c), <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    c = a - b;</span><br><span class="line">    <span class="built_in">write</span>(a), <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), <span class="built_in">write</span>(b), <span class="built_in">putchar</span>(<span class="string">&#x27;=&#x27;</span>), <span class="built_in">write</span>(c), <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    c = a * b;</span><br><span class="line">    <span class="built_in">write</span>(a), <span class="built_in">putchar</span>(<span class="string">&#x27;*&#x27;</span>), <span class="built_in">write</span>(b), <span class="built_in">putchar</span>(<span class="string">&#x27;=&#x27;</span>), <span class="built_in">write</span>(c), <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    c = a / b;</span><br><span class="line">    <span class="built_in">write</span>(a), <span class="built_in">putchar</span>(<span class="string">&#x27;/&#x27;</span>), <span class="built_in">write</span>(b), <span class="built_in">putchar</span>(<span class="string">&#x27;=&#x27;</span>), <span class="built_in">write</span>(c), <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$\color[rgb]{1,1,0.0625}{φ}$</p>
<h3 id="预处理单位根"><a href="#预处理单位根" class="headerlink" title="预处理单位根"></a>预处理单位根</h3><p>我们之前应该提到过什么是单位根。但是怎么快速求出我们需要用的所有单位根呢？<br>开根号的方法太慢了，打表又太难。<br>所以我们使用三角函数。<br>没学过三角函数的可以自己先学一下<del>（话说为什么你会先学傅里叶变换？）</del><br>我们首先求出 $ω^1_n$ 。</p>
<p>[anime here]</p>
<p>C++的三角函数采用的是弧度制。而刚才我们已经介绍过什么是弧度了。</p>
<p>所以， $ω^1_n$ 就等于 $\cos(\dfrac{2π}{n})+\sin(\dfrac{2π}{n})i$ 。</p>
<p>把得到的结果依次乘起来就是所有的单位根。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxn 1000500</span></span><br><span class="line"><span class="comment">//用这句话能得到得到精确的π</span></span><br><span class="line"><span class="comment">//但是实际上并没有自己手动打更精确</span></span><br><span class="line"><span class="comment">//比如说下一个代码就是我自己手打的</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CP</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CP</span>(<span class="type">double</span> xx = <span class="number">0</span>, <span class="type">double</span> yy = <span class="number">0</span>) &#123; x = xx, y = yy; &#125;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    CP <span class="keyword">operator</span> + (CP <span class="type">const</span> &amp;B) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CP</span>(x + B.x, y + B.y);</span><br><span class="line">    &#125;</span><br><span class="line">    CP <span class="keyword">operator</span> - (CP <span class="type">const</span> &amp;B) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CP</span>(x - B.x, y - B.y);</span><br><span class="line">    &#125;</span><br><span class="line">    CP <span class="keyword">operator</span> * (CP <span class="type">const</span> &amp;B) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CP</span>(x * B.x - y * B.y, x * B.y + y * B.x);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//除法没用</span></span><br><span class="line">&#125;w[Maxn];</span><br><span class="line"><span class="comment">//w长得是不是很像ω?</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="function">CP <span class="title">sav</span><span class="params">(cos(<span class="number">2</span> * Pi / n), sin(<span class="number">2</span> * Pi / n))</span>, <span class="title">buf</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        w[i] = buf;</span><br><span class="line">        buf = buf * sav;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;w[%d][n]=(%.4lf,%.4lf)\n&quot;</span>, i, w[i].x, w[i].y);</span><br><span class="line">    <span class="comment">//由于精度问题会出现-0.0000的情况,将就看吧</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3Uub3JnL2Jsb2cvY29tbWFuZC1ibG9jay9mZnQteHVlLXhpLWJpLWpp">$\blacktriangleright$</span></p>
<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxn 1350000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Pi = <span class="number">3.1415926535897932394626433832795</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CP</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CP</span>(<span class="type">double</span> xx = <span class="number">0</span>, <span class="type">double</span> yy = <span class="number">0</span>) &#123; x = xx, y = yy; &#125;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    CP <span class="keyword">operator</span> + (CP <span class="type">const</span> &amp;B) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CP</span>(x + B.x, y + B.y);</span><br><span class="line">    &#125;</span><br><span class="line">    CP <span class="keyword">operator</span> - (CP <span class="type">const</span> &amp;B) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CP</span>(x - B.x, y - B.y);</span><br><span class="line">    &#125;</span><br><span class="line">    CP <span class="keyword">operator</span> * (CP <span class="type">const</span> &amp;B) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CP</span>(x * B.x - y * B.y, x * B.y + y * B.x);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//除法这里没用</span></span><br><span class="line">&#125;f[Maxn &lt;&lt; <span class="number">1</span>], sav[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dft</span><span class="params">(CP *f, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">1</span>)<span class="keyword">return</span>;<span class="comment">//边界</span></span><br><span class="line">    <span class="comment">//指针的使用比较巧妙 </span></span><br><span class="line">    CP *fl = f, *fr = f + len / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; len; k++)sav[k] = f[k];</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; len / <span class="number">2</span>; k++)<span class="comment">//分奇偶打乱</span></span><br><span class="line">    &#123;</span><br><span class="line">        fl[k] = sav[k &lt;&lt; <span class="number">1</span>]; fr[k] = sav[k &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dft</span>(fl, len / <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">dft</span>(fr, len / <span class="number">2</span>);<span class="comment">//处理子问题</span></span><br><span class="line">    <span class="comment">//由于每次使用的单位根次数不同(len次单位根),所以要重新求。</span></span><br><span class="line">    <span class="function">CP <span class="title">tG</span><span class="params">(cos(<span class="number">2</span> * Pi / len), sin(<span class="number">2</span> * Pi / len))</span>, <span class="title">buf</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; len / <span class="number">2</span>; k++)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//这里buf = (len次单位根的第k个) </span></span><br><span class="line">        sav[k] = fl[k] + buf * fr[k];<span class="comment">//(1)</span></span><br><span class="line">        sav[k + len / <span class="number">2</span>] = fl[k] - buf * fr[k];<span class="comment">//(2)</span></span><br><span class="line">        <span class="comment">//这两条语句具体见上面的式子</span></span><br><span class="line">        buf = buf * tG;<span class="comment">//得到下一个单位根。</span></span><br><span class="line">    &#125;<span class="built_in">f_or</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; len; k++)f[k] = sav[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;f[i].x);</span><br><span class="line">    <span class="comment">//一开始都是实数,虚部为0</span></span><br><span class="line">    <span class="built_in">f_or</span>(m = <span class="number">1</span>; m &lt; n; m &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//把长度补到2的幂,不必担心高次项的系数,因为默认为0</span></span><br><span class="line">    <span class="built_in">dft</span>(f, m);</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%.4f,%.4f)\n&quot;</span>, f[i].x, f[i].y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3Uub3JnL2Jsb2cvY29tbWFuZC1ibG9jay9mZnQteHVlLXhpLWJpLWpp">$\blacktriangleright$</span></p>
<p>好了，我相信你已经学会了利用DFT把多项式拆成一系列点值了。</p>
<p>但是我们怎么把这些点值还原为多项式呢？</p>
<h1 id="IDFT"><a href="#IDFT" class="headerlink" title="IDFT"></a>IDFT</h1><p>IDFT只需要改变DFT中的一点东西就可以得到。</p>
<p>因为我们代入的时候，得到了一个点值序列，我们在此称其为 $u$ ，而 $\displaystyle u[k]&#x3D;\sum_{i&#x3D;0}^{n-1} (ω^k_n)^i f(i)$ ，所以 $\displaystyle f(i) &#x3D; \frac{\sum\limits_{i&#x3D;0}^{n-1} (ω_n^{-k})^i u[i]}{n}$ 。</p>
<p>具体的证明过程目前请见<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2Jsb2cvY29tbWFuZC1ibG9jay9mZnQteHVlLXhpLWJpLWpp">这里</span> 。这个证明涉及到了单位根反演，可以再写一篇博客，所以我等写到的时候再补全证明。</p>
<p>上代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1350010</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Pi = <span class="number">3.1415926535897932384626433832795</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CP</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CP</span>(<span class="type">double</span> xx = <span class="number">0</span>, <span class="type">double</span> yy = <span class="number">0</span>) &#123; x = xx, y = yy; &#125;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    CP <span class="keyword">operator</span> + (CP <span class="type">const</span> &amp;B) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CP</span>(x + B.x, y + B.y);</span><br><span class="line">    &#125;</span><br><span class="line">    CP <span class="keyword">operator</span> - (CP <span class="type">const</span> &amp;B) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CP</span>(x - B.x, y - B.y);</span><br><span class="line">    &#125;</span><br><span class="line">    CP <span class="keyword">operator</span> * (CP <span class="type">const</span> &amp;B) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CP</span>(x * B.x - y * B.y, x * B.y + y * B.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;f[N &lt;&lt; <span class="number">1</span>], p[N &lt;&lt; <span class="number">1</span>], sav[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> tr[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fft</span><span class="params">(CP *f, <span class="type">bool</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; tr[i])<span class="built_in">swap</span>(f[i], f[tr[i]]);</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> p = <span class="number">2</span>; p &lt;= n; p &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> len = p &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="function">CP <span class="title">tG</span><span class="params">(cos(<span class="number">2</span> * Pi / p), sin(<span class="number">2</span> * Pi / p))</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(!flag)tG.y *= <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">f_or</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k += p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">CP <span class="title">buf</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="built_in">f_or</span>(<span class="type">int</span> l = k; l &lt; k + len; l++)</span><br><span class="line">            &#123;</span><br><span class="line">                CP tt = buf * f[len + l];</span><br><span class="line">                f[len + l] = f[l] - tt;</span><br><span class="line">                f[l] = f[l] + tt;</span><br><span class="line">                buf = buf * tG;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;f[i].x);</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;p[i].x);</span><br><span class="line">    <span class="built_in">f_or</span>(m += n, n = <span class="number">1</span>; n &lt;= m; n &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        tr[i] = (tr[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) ? n &gt;&gt; <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fft</span>(f, <span class="number">1</span>); <span class="built_in">fft</span>(p, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)f[i] = f[i] * p[i];</span><br><span class="line">    <span class="built_in">fft</span>(f, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">f_or</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ( <span class="type">int</span> )(f[i].x / n + <span class="number">0.49</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3Uub3JnL2Jsb2cvY29tbWFuZC1ibG9jay9mZnQteHVlLXhpLWJpLWpp">$\blacktriangleright$</span></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>P3047 [USACO12FEB] Nearby Cows 题解</title>
    <url>/solutions/solution-p3047/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">Nearby Cows</div>
<div id="problem-info-from">USACO 2012 February Gold</div>
<div id="problem-info-difficulty">提高+ /省选-</div>
<div id="problem-info-color">#3498db</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMwNDc=">Luogu P3047</span></li></ul></div>

<hr>
<p>简述一下题意，题目要求我们对于每一个点求出距离其不超过 $k$ 的点的点权和。</p>
<p>操作很简单，我们只需要开一个DP数组，记录下来每一个点与其距离为 $j \in \{ j|[0,k] \}$ 的点权和即可。</p>
<p>首先我们DFS一遍，记录下来每一个点子树中与其距离为 $j \in \{ j|[0,k] \}$ 的点权和：</p>
<figure class="highlight cpp"><figcaption><span>第一遍DFS</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[p][<span class="number">0</span>] = w[p];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i] == fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(e[i], p);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">            f[p][j + <span class="number">1</span>] += f[e[i]][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后考虑其祖先节点对其的影响。</p>
<p>我们通过再一次的DFS来统计影响，所以我们只需要计算该节点的父亲对其的影响即可。</p>
<p>举个例子：<br>我们现在节点 $x$ 统计答案，其父亲为 $y$。<br>对于每一个与 $y$ 相距 $j \in \{ j|[0,k-1] \}$ 的节点，其与 $x$ 的距离为 $j+1$。</p>
<p>根据这个我们可以统计出 $y$ 对 $x$ 的影响，然后就可以得到答案了。</p>
<figure class="highlight cpp"><figcaption><span>第二遍DFS</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i] == fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = k; j &gt;= <span class="number">2</span>; j--)</span><br><span class="line">            f[e[i]][j] -= f[e[i]][j - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">            f[e[i]][j + <span class="number">1</span>] += f[p][j];</span><br><span class="line">        <span class="built_in">dfs2</span>(e[i], p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[p][<span class="number">0</span>] = w[p];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i] == fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(e[i], p);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">            f[p][j + <span class="number">1</span>] += f[e[i]][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i] == fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = k; j &gt;= <span class="number">2</span>; j--)</span><br><span class="line">            f[e[i]][j] -= f[e[i]][j - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">            f[e[i]][j + <span class="number">1</span>] += f[p][j];</span><br><span class="line">        <span class="built_in">dfs2</span>(e[i], p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k; j++)sum += f[i][j];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>P3174 [HAOI2009] 毛毛虫 题解</title>
    <url>/solutions/solution-p3174/</url>
    <content><![CDATA[<br>
<span id="more"></span>
<div id="problem-card-vis">true</div>
<div id="problem-info-name">毛毛虫</div>
<div id="problem-info-from">HAOI 2009</div>
<div id="problem-info-difficulty">提高+ /省选-</div>
<div id="problem-info-color">#3498db</div>
<div id="problem-info-submit"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMxNzQ=">Luogu P3174</span></li></ul></div>

<hr>
<p>首先解读题目中的信息。<br>一条「毛毛虫」是由树上的一条链以及与该链直接相连但不在链上的节点组成的。<br>题目要求我们找出包含节点数最多的一条毛毛虫。</p>
<p>我们以此做一个DP。</p>
<p>为叙述方便，下面「最长链」的意义是包含节点数最多的「毛毛虫」，「次长链」代表包含节点次多的「毛毛虫」。<br>为区分正常意义与此处的意义，使用上面意义的词语会用直角括号包裹。</p>
<p>不管是什么树形DP我们都得DFS来遍历每一个点。<br>对于每一个点，我们记录下来其子树中以其为链顶的「最长链」，然后随着不断回溯不断更新每一个节点的「最长链」的值。</p>
<p>当然，答案链可能是两条竖直向上的链拼接在一起得到的，所以我们还需要记录以当前点为链顶的「次长链」，然后统计出来每一个点的答案，最后取较大的值。</p>
<p><big><strong>代码实现：</strong></big></p>
<p>对于每一个节点，我们记录一个<code>maxn</code>，一个<code>maxm</code>，和一个<code>sson</code>。<br>分别代表的是其所有以其子节点为链顶的「最长链」（但不含该节点）的最大值，<br>所有以其子节点为链顶的「次长链」（但不含该节点）的最大值，和该节点子节点的个数。<br>每一个节点的答案就是<code>maxn + maxm + sson + 1</code>。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>, M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxn[N], maxm[N];</span><br><span class="line"><span class="type">int</span> stre[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[p]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i] == fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(e[i], p);</span><br><span class="line">        stre[p]++;</span><br><span class="line">        <span class="type">int</span> v = maxn[e[i]] + stre[e[i]];</span><br><span class="line">        <span class="keyword">if</span>(v &gt; maxn[p])maxm[p] = maxn[p], maxn[p] = v;</span><br><span class="line">        <span class="keyword">else</span> maxm[p] = <span class="built_in">max</span>(maxm[p], v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, maxn[i] + maxm[i] + stre[i] + <span class="number">1</span> + (i != <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
















































































































]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
</search>
